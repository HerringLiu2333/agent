1. Plan Summary
Detect integer multiplications that are performed in 32-bit due to operand types and constant definitions, but whose results are intended to be 64-bit and can overflow on 32-bit builds (as in tmp = offset * TICKS_PER_HOUR where the constant lacks a 64-bit suffix).

2. Detection Steps
1) Step 1: Objective: Identify candidate integer multiplications that can be evaluated in 32-bit. Signals: Binary multiplication where both operands are integer-typed and neither is explicitly 64-bit (no long long type, no LL/ULL literal suffix, no 64-bit cast on operands). FP mitigation: Exclude operations where an operand is already 64-bit typed or explicitly cast to 64-bit.

2) Step 2: Objective: Recognize constant-expression operands that default to 32-bit. Signals: One operand is a literal or macro-expanded expression composed of integer literals without 64-bit suffix (e.g., a product like 32768 * 3600), as shown in [PATCH_DIFF] and [PATCH_DESCRIPTION]. FP mitigation: Exclude constants that already contain LL/ULL or are typed long long.

3) Step 3: Objective: Confirm the intermediate arithmetic type is 32-bit. Signals: Apply C usual arithmetic conversions to the two operands and mark expressions whose computed type is int or long (which is 32-bit on 32-bit targets), matching the root cause in [ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude if either operand’s type forces 64-bit arithmetic.

4) Step 4: Objective: Ensure the result is used in a widened (64-bit) context, signaling intention for a wide product. Signals: The product feeds an assignment to a 64-bit variable (e.g., s64/long long), a 64-bit function parameter, a return of 64-bit type, or is cast to 64-bit only after the multiplication, as described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Require at least one such widened use to avoid benign 32-bit math.

5) Step 5: Objective: Estimate overflow risk using constant magnitude and variable bounds. Signals: If the non-constant operand has an established bound from guards (comparisons to constants/macros like MAX_* in the same function), check whether abs(constant) × maxAbs(var) exceeds INT_MAX on 32-bit, reflecting [ROOTCAUSE_ANALYSIS] (MAX_OFFSET 277774 and TICKS_PER_HOUR ~1e8). FP mitigation: Require that the bound holds on all paths to the multiplication (path-sensitive check).

6) Step 6: Objective: Infer variable bounds from code structure. Signals: Prior checks such as -C ≤ var ≤ C, or var clamped to ±C via comparisons/conditionals, especially using macros like MAX_OFFSET as in [PATCH_DESCRIPTION]. FP mitigation: Only use bounds proven by dominating checks or consistent clamping just before the multiplication.

7) Step 7: Objective: Provide a heuristic when explicit bounds are unavailable. Signals: Flag when the constant operand is a large scaling factor composed of products of literals and of magnitude comparable to 10^8 (as in 32768 * 3600 from [PATCH_DESCRIPTION]) and the result is used in a 64-bit context. FP mitigation: Mark these as lower severity and suppress if the non-constant operand is a small literal or proven to be within a very small range locally.

8) Step 8: Objective: Detect macro-based pitfalls. Signals: Macro definitions that compute large constants from literal arithmetic without LL/ULL (e.g., #define TICKS_PER_HOUR (32768 * 3600) in [PATCH_DIFF]) and those macros used as operands in multiplications feeding 64-bit. FP mitigation: Do not report if the macro definition includes LL/ULL (as in the fixed (32768 * 3600LL) per [PATCH_DIFF]).

9) Step 9: Objective: Identify post-multiply widening as a smell. Signals: Patterns where a multiplication of 32-bit operands is performed and the entire product is then cast to 64-bit (i.e., widening occurs after the multiply), matching the described promotion pitfall in [ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude when a 64-bit cast applies to an operand before the multiply.

10) Step 10: Objective: Rank and reduce false positives by context. Signals: Elevate cases in driver/time-scaling conversions (unit multipliers like ticks per time), as in [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF], and de-prioritize general arithmetic without large constants or 64-bit sinks. FP mitigation: Require combined presence of large constant expression, 32-bit arithmetic, and 64-bit sink for high-confidence reports.

3. Target Elements
- Macro definitions of integer constants formed by arithmetic of literals.
- Binary arithmetic expressions (especially multiplication) with integer operands.
- Assignments where the RHS is a multiplication and the LHS is 64-bit (s64/long long).
- Function calls where multiplication results feed 64-bit parameters.
- Cast expressions applied to the entire product versus its operands.
- Conditional guards and comparisons that bound variable operands (e.g., var ≤ MAX_*).
- Variable declarations and typedefs indicating 64-bit usage (s64, u64, long long).

4. Dataflow / Taint Considerations
- Track dataflow from variable operands through guarding conditionals to the multiplication to derive max/min bounds (intra-procedural, path-sensitive).
- Track macro expansion of constant operands to determine whether they are composed of literal arithmetic without 64-bit suffix.
- Track the flow of the multiplication result to determine if/where it is widened to 64-bit (assignments, casts, parameters, returns).

5. Validation & Test Cases
- Positive: A function computes tmp (s64) = offset (long) * CONST where CONST is a macro defined as (literal * literal) without LL, and offset is range-checked against a large MAX_* (e.g., ~2.8e5); expect a high-confidence finding.
- Positive: Multiplication of two 32-bit operands assigned to a 64-bit variable where one operand is a large literal product (~1e8) without LL and no operand is cast to 64-bit; expect a finding (lower confidence if no bounds exist).
- Negative: Same scenarios but with the constant macro defined using 64-bit suffix (e.g., ...LL) or a 64-bit cast applied to an operand before multiplication; expect no finding.
- Negative: Multiplication where bounds prove the variable operand is tiny enough that abs(constant) × bound ≤ INT_MAX; expect no finding.
- Test harness notes: Run on both kernel-like codebases and small synthetic files mirroring [PATCH_DIFF]/[PATCH_DESCRIPTION] patterns to confirm confidence ranking and suppression behavior.

6. Estimated Effort & Priority
Medium: Requires type reasoning, macro expansion awareness, and simple range analysis; high value due to cross-architecture correctness issues highlighted in [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Platforms where long is 64-bit: Mitigate by requiring a 64-bit sink and noting potential 32-bit builds; document assumption.
- Missing or imprecise range information: Mitigate by downgrading to low confidence when bounds are unknown and by suppressing when small bounds are proven.
- Benign large constants used with tiny operands: Mitigate with path-sensitive bound checks and constant-times-bound comparison to INT_MAX.
- Over-reliance on macro names or comments: Avoid name-based heuristics; rely on type/context and magnitude analysis per [PATCH_DIFF]/[PATCH_DESCRIPTION].

8. Limitations & Assumptions
- The analysis cannot determine the target architecture; it assumes 32-bit builds are possible, as discussed in [ROOTCAUSE_ANALYSIS].
- Exact runtime ranges of variables may be unavailable; the checker relies on local guards (e.g., MAX_* comparisons) to infer bounds.
- It focuses on multiplication (the demonstrated root cause) and may miss similar issues in other operations (e.g., left shifts) not evidenced in the provided materials.
- Detection of “large” constants uses heuristic magnitude guided by [PATCH_DESCRIPTION] (~1e8) when bounds are unknown; this may not generalize to all domains.