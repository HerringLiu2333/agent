1. Plan Summary
Detect integer multiplications that are computed in 32-bit due to operand types and large int-typed constants, but whose result is used in a 64-bit context, risking overflow before widening (as in offset * TICKS_PER_HOUR).

2. Detection Steps
1) Step 1: Objective — find candidate multiplications.
- Signals — locate all binary multiplications where both operands are integral expressions and no operand is already 64-bit or wider (no long long/s64 type or explicit 64-bit cast).
- FP mitigation — exclude multiplications where any operand is explicitly cast to 64-bit or is a 64-bit literal (e.g., has LL semantics), since those already perform wide arithmetic ([ROOTCAUSE_ANALYSIS], [PATCH_DIFF]).

2) Step 2: Objective — identify “narrow compute, wide use” sites.
- Signals — among candidates, select those whose result feeds a 64-bit context: assigned to a 64-bit variable (e.g., s64), passed to a 64-bit parameter, or immediately cast to 64-bit after the multiplication.
- Why — matches the root cause where overflow happened before assigning to s64 ([ROOTCAUSE_ANALYSIS]).
- FP mitigation — exclude if the result remains in 32-bit throughout (no 64-bit use), as intention may be 32-bit math.

3) Step 3: Objective — detect large int-typed constant factors that enforce 32-bit arithmetic.
- Signals — one operand is a compile-time integer constant/expression of int type (no 64-bit suffix) with a large value on the order of tens of millions (e.g., like 32768*3600 ≈ 1.18e8) ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).
- Why — such constants make 32-bit overflow likely with modest multipliers; this mirrors TICKS_PER_HOUR.
- FP mitigation — ignore small constants (e.g., on the order of thousands or less), which are less likely to cause overflow in 32-bit multiplication.

4) Step 4: Objective — confirm operands will be multiplied in 32-bit due to usual arithmetic conversions.
- Signals — both operands’ effective types after promotions are ≤32-bit (e.g., int or long on ILP32), and the constant is int-typed; no operand has 64-bit qualifiers.
- Why — mirrors “offset (long on 32-bit) * int constant” computed in 32-bit before assignment ([ROOTCAUSE_ANALYSIS]).
- FP mitigation — if type information indicates 64-bit long (e.g., LP64), downgrade to warning or suppress unless additional evidence suggests cross-arch intent (document in Limitations).

5) Step 5: Objective — estimate overflow risk using known or inferred variable ranges.
- Signals — search for local bounds on the variable operand (e.g., comparisons to MAX_* macros or constants) and compute whether constant × a plausible bound exceeds 32-bit limits; e.g., with constant ≈ 1e8, any bound greater than ~20 implies risk ([ROOTCAUSE_ANALYSIS]: overflow for |offset| > ~18).
- Why — tightens the match to cases where overflow is demonstrably feasible.
- FP mitigation — if the variable is provably constrained to very small magnitude (e.g., |x| ≤ 1 or ≤ 10), suppress.

6) Step 6: Objective — connect macro-defined large constants to their uses.
- Signals — identify macros/constants defined as products of integer literals without 64-bit suffix (e.g., (32768 * 3600)) that are used as multiplicands in candidate sites.
- Why — matches the specific root cause where macro typing forced 32-bit arithmetic ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).
- FP mitigation — exclude macros already defined with 64-bit suffixes (e.g., 3600LL) or casts.

7) Step 7: Objective — catch deferred widening patterns.
- Signals — multiplication result is immediately cast to 64-bit or assigned to a 64-bit variable, but operands remain 32-bit.
- Why — the overflow occurs before the widening, exactly as described in the bug ([ROOTCAUSE_ANALYSIS]).
- FP mitigation — suppress if there is a pre-multiply widening cast on either operand.

8) Step 8: Objective — prioritize kernel/low-level time/tick-like patterns where constants are derived from frequencies.
- Signals — constants equal to products like 32768 * 3600 (tick rate × seconds/hour) or similar large frequency/time conversions used in RTC/timekeeping paths.
- Why — reflects the TPS6594 RTC scenario where tick-to-time conversion constants are large ([PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS]).
- FP mitigation — treat these as higher confidence; otherwise apply general heuristics from steps 3–5.

9) Step 9: Objective — generate actionable guidance.
- Signals — for flagged sites, point to the constant’s definition and the narrow operand types.
- Why — the fix is to widen the constant or cast an operand to 64-bit pre-multiply, as done by adding LL in the patch ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).
- FP mitigation — include a note to verify target architecture integer widths.

3. Target Elements
- Binary multiplication expressions and their operand types.
- Assignments/initializations where RHS is a multiplication and LHS is 64-bit.
- Function call sites where a multiplication expression is passed to a 64-bit parameter.
- Cast expressions applied to multiplication results vs. operands.
- Macro/constant definitions used as multiplicands, especially products of integer literals.
- Control-flow checks that bound the variable multiplicand (comparisons to constants/macros like MAX_*).

4. Dataflow / Taint Considerations
- Track the flow of the multiplication result into 64-bit sinks (assignments, returns, parameters) to detect “wide use.”
- Track simple range constraints on variable operands within the same function: constants/macros assigned to or compared with the variable before the multiplication.
- Recognize immediate casts: whether widening occurs before or after the multiplication.

5. Validation & Test Cases
- Positive: A variable of type long (on 32-bit) multiplied by an int-typed constant defined as (32768 * 3600), with the result assigned to s64 (tmp = offset * TICKS_PER_HOUR); should be flagged.
- Negative: Same code but with TICKS_PER_HOUR defined as (32768 * 3600LL), or with (s64)offset * TICKS_PER_HOUR; should not be flagged.
- Test harness notes: Run on samples simulating ILP32 and LP64 extractions; ensure the checker either flags only the ILP32-relevant case or emits an architecture-conditional advisory with clear rationale.

6. Estimated Effort & Priority
Medium: Requires type reasoning, constant evaluation, and lightweight range inference; high impact per [ROOTCAUSE_ANALYSIS] due to silent arithmetic corruption.

7. Likely False-Positive Sources & Mitigations
- Unknown architecture widths (long may be 64-bit): mitigate by checking presence of 64-bit operands or emitting lower-severity advisories when ambiguous.
- Variables tightly bounded to small magnitudes not inferred by the analyzer: mitigate by scanning local comparisons/guards and constants like MAX_*.
- Intentional 32-bit wrap semantics: mitigate by prioritizing cases with wide sinks and large constants typical of time/tick conversions.

8. Limitations & Assumptions
- The analyzer may not know the target data model (ILP32 vs LP64); results may be architecture-dependent.
- Precise value-range inference for variables is limited; the plan assumes simple intra-procedural bounds can be detected.
- Only multiplication is considered, as supported by the provided materials; other operations (e.g., addition) are out of scope.
- Constants “large enough to overflow” use heuristics informed by the example (≈1e8) from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].