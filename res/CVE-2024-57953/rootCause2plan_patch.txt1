1. Plan Summary
Detect 32-bit-only integer multiplications that overflow before being widened to 64-bit, especially when multiplying by large int-typed constants and then storing/using the result as 64-bit.

2. Detection Steps
1) Step 1: Find candidate integer multiplications. Signal: binary “*” between two non-floating integer expressions where neither operand is explicitly 64-bit (no long long/s64 types and no casts to 64-bit).

2) Step 2: Model evaluation width under ILP32 (32-bit long). Signal: apply usual arithmetic conversions and keep only multiplications whose computed type would be 32-bit on ILP32 (e.g., int × int, long(32) × int, etc.).

3) Step 3: Identify widening use that implies intent for 64-bit. Signal: the multiplication result flows into a 64-bit context (assignment to s64/long long, argument/return of 64-bit type, or combined with a 64-bit operand in a later expression).

4) Step 4: Detect large compile-time constants as scaling factors. Signal: one operand is a compile-time integer constant expression composed solely of integer literals/ops/macros without 64-bit suffix or cast; compute its value and signedness as an int-typed expression on ILP32.

5) Step 5: Assess overflow risk from constant magnitude. Signal: compute T = floor(INT_MAX / abs(constant)); if T is small (e.g., tens) then even moderate operand values overflow 32-bit—record T for reporting.

6) Step 6: Use simple value-range clues on the variable operand. Signal: collect nearby guards/assignments that bound the variable (comparisons, clamps, min/max, constants like MAX_*), and if the upper bound exceeds T (or the lower bound is less than -T), mark as definite overflow; otherwise as potential overflow.

7) Step 7: Confirm lack of explicit 64-bit promotion at the right place. Signal: ensure there is no cast or suffix that promotes an operand to 64-bit before the multiplication (e.g., LL suffix on the constant or a cast on the variable).

8) Step 8: Exclude cases where operand types already enforce ≥64-bit arithmetic. Signal: drop if, under ILP32 typing, at least one operand is 64-bit (long long/s64) or the constant/expression includes a 64-bit suffix/cast causing the product to be 64-bit.

9) Step 9: Exclude LP64-only computations. Signal: if the product’s computed type would be 64-bit solely because long is 64-bit (LP64), suppress; report only if it stays 32-bit on ILP32.

10) Step 10: Prioritize high-impact patterns. Signal: elevate findings where the constant is very large (e.g., time/tick scaling like thousands×thousands), the variable is user/configuration-driven, or the valid range is known to far exceed T.

11) Step 11: Produce actionable report context. Signal: include the multiply site, inferred operand types under ILP32, constant’s computed value and type, the widening sink (e.g., s64 target), and the threshold T explaining why overflow happens before widening.

3. Limitations & Assumptions
- Assumes an ILP32 model to decide when the multiplication computes in 32-bit; results may differ on LP64 builds.
- Requires the ability to evaluate constant expressions and resolve macros; incomplete macro expansion may reduce accuracy.
- Relies on simple, local range analysis; complex path-sensitive constraints or interprocedural bounds may be missed.
- The “small T” prioritization is heuristic; an organization-specific threshold should be configurable to balance false positives/negatives.
- Does not address other operators (addition/shifts) or non-constant scaling unless clearly risky; focus is on multiplication by large int-typed constants as in the root cause.