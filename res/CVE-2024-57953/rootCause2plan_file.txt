1. Plan Summary
Detect integer overflows caused by 32-bit intermediate multiplication where operands are not promoted to 64-bit, but the result is intended for 64-bit use (e.g., assigned to s64 or used with 64-bit division), as exemplified by offset * TICKS_PER_HOUR in the TPS6594 RTC driver.

2. Detection Steps
1) Step 1: Identify binary multiplication expressions whose two operands have types no wider than 32 bits (e.g., int, long on 32-bit) — focus on AST nodes for “a * b”, check static types — reduces FPs by excluding cases where at least one operand is already 64-bit.  
2) Step 2: Among these, select cases where the product directly or via a simple assignment/temporary feeds a 64-bit context (e.g., assigned to s64, passed to a function expecting 64-bit like div_s64) — signals: assignment to 64-bit lvalues, 64-bit parameter types, or use in div_s64 — maps to the root cause that programmer intended 64-bit math but got 32-bit intermediate.  
3) Step 3: Check whether neither operand is explicitly widened to 64-bit (no cast to long long/64-bit and no 64-bit literal suffix) — signals: absence of casts and LL/ULL suffix on literals/macros — reduces FPs where developers already ensured 64-bit promotion.  
4) Step 4: For constant/macro operands, resolve their definition and infer their literal type; flag when the macro’s arithmetic expression is composed of 32-bit literals and thus yields a 32-bit type (e.g., 32768 * 3600) — based on PATCH_DIFF changing to 3600LL — reduces FPs to the pattern fixed by the patch.  
5) Step 5: Heuristically assess “large-scale” multipliers: if a constant operand is a compile-time integer with magnitude likely to overflow 32-bit when multiplied by realistic inputs (e.g., approximately ≥1e7, as TICKS_PER_HOUR ≈ 1.179648e8 per ROOTCAUSE_ANALYSIS) — signals: absolute value threshold — mitigates FPs by focusing on high-risk constants.  
6) Step 6: If the variable operand has nearby range checks (e.g., comparisons against MIN/MAX before the multiply as in “if (offset < MIN_OFFSET || offset > MAX_OFFSET)”), extract those bounds — signals: same variable used in relational guards within the function — maps to the root cause by enabling worst-case overflow estimation.  
7) Step 7: Using the extracted bounds and the constant’s value, compute the worst-case 32-bit product and flag if it exceeds 32-bit signed range (e.g., MAX_OFFSET * TICKS_PER_HOUR > 2^31-1 per ROOTCAUSE_ANALYSIS) — signals: simple numeric evaluation — reduces FPs by requiring a demonstrable overflow on 32-bit.  
8) Step 8: Prioritize/report cases that also include subsequent 64-bit rounding/division steps (e.g., div_s64 on the product) — signals: call to div_s64 with the product variable — strengthens confidence that 64-bit arithmetic was intended (as in FILE_CONTENT tps6594_rtc_set_offset and read_offset).  
9) Step 9: Exclude cases that are guarded by explicit 64-bit promotion at the multiply site (e.g., cast of either operand to 64-bit or literal with LL suffix, as in the PATCH_DIFF fix to add 3600LL) — signals: presence of long long cast or LL suffix — removes fixed/benign sites.  
10) Step 10: Optionally flag constant macros used as “scale factors” both in multiplication and division without LL suffix (e.g., TICKS_PER_HOUR used in multiply and divide) — signals: same macro identifier in multiply and divide contexts — maps to cross-architecture fragility highlighted in ROOTCAUSE_ANALYSIS, while keeping severity lower unless Steps 1–8 hold.

3. Target Elements
- Binary multiplication expressions and their operand types.  
- Assignments and initializations where the RHS is a product and the LHS is 64-bit (e.g., s64).  
- Function calls taking 64-bit arguments (e.g., div_s64) or returning 64-bit results.  
- Macro definitions of integer constants used in arithmetic (resolve macro expansions).  
- Conditional range checks (comparisons) constraining the variable used in the multiply within the same function.  
- Cast expressions and integer literal suffixes indicating type promotion.

4. Dataflow / Taint Considerations
- Track intra-function flow from a variable through range checks to the multiply to ensure the bounded variable is the same used in the product.  
- Track the product value into 64-bit sinks (assignment to s64, argument to div_s64) to confirm intended 64-bit usage.  
- Simple constant propagation to evaluate macro/literal values and compute worst-case product with observed bounds.

5. Validation & Test Cases
- Positive: Pre-patch pattern: s64 tmp; long offset; #define TICKS_PER_HOUR (32768 * 3600); tmp = offset * TICKS_PER_HOUR; followed by div_s64(tmp, PPB_MULT); with prior check offset in [-277774, 277774] — expect a finding.  
- Positive: Similar case with const int SCALE = 100000000; long v; s64 y = v * SCALE; and y used in div_s64 — expect a finding.  
- Negative: Same as above but constant defined as (32768 * 3600LL) or explicit cast (s64)offset before multiply — expect no finding.  
- Negative: Both operands 64-bit already (e.g., s64 a, b; s64 y = a * b) — expect no finding.  
- Test harness notes: Run on functions with and without explicit range checks; ensure macro expansion resolution is enabled so constants like TICKS_PER_HOUR are analyzed.

6. Estimated Effort & Priority
Medium — requires type resolution, macro expansion awareness, and simple numeric reasoning; high value due to cross-architecture correctness per ROOTCAUSE_ANALYSIS and PATCH_DIFF.

7. Likely False-Positive Sources & Mitigations
- Code compiled only for 64-bit targets (ILP64/LP64): Mitigate by requiring 64-bit sink usage and large-scale multiplier heuristic or range-based overflow proof.  
- Products that are mathematically safe despite large constants due to tighter variable ranges not recognized: Mitigate by extracting range checks where present and otherwise lower severity without proof.  
- Unresolved macros/headers preventing constant evaluation: Mitigate by lowering confidence when the constant value cannot be determined.

8. Limitations & Assumptions
- Architecture widths (size of long) are not always known statically; the checker assumes LP32/ILP32 risk when both operands are ≤32-bit (per ROOTCAUSE_ANALYSIS).  
- Exact numeric evaluation of macros may fail if definitions are unavailable; detection may rely on heuristics.  
- The plan assumes availability of type info for kernel-specific typedefs like s64 and identification of functions like div_s64 (from FILE_CONTENT and ROOTCAUSE_ANALYSIS).  
- The checker focuses on multiplication; other operators with similar promotion pitfalls are out of scope based on the provided patch and analysis.