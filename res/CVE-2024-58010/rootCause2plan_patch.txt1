1. Plan Summary
Detect pre-patch code paths that reach operations identified in the patch without the protective checks/validations/handling that the patch introduces.

2. Detection Steps
1) Step 1: Identify scope — collect the files, functions, and code regions modified by the patch. Signals: locations changed in PATCH_DIFF, including added/modified conditions, calls, early returns, and error-handling constructs.

2) Step 2: Extract guard semantics — enumerate the specific checks/validations/assertions/error-handling introduced. Signals: new if-conditions, precondition validations, state/type checks, permission/authorization checks, null/length/state assertions, and added try/except/return-on-failure logic present in PATCH_DIFF.

3) Step 3: Map guarded operations — determine the operations that the new guards protect (the statements or calls immediately gated by the added checks). Signals: calls or state-changing operations moved under new conditions or preceded by new validation/error checks in PATCH_DIFF.

4) Step 4: Locate equivalent sites pre-patch — find all occurrences of the same operations in the corresponding code regions before the patch. Signals: same function names or call sites, same APIs or statements that are now guarded post-patch.

5) Step 5: Check absence of guards — flag sites where the guarded operation appears without any of the newly added checks. Signals: the specific condition/call/assertion/handler from PATCH_DIFF is missing in the same block or predecessor control paths.

6) Step 6: Check partial coverage — detect paths that bypass the guard even if a check exists on some branches. Signals: control-flow paths reaching the operation that do not pass through the guard, or guards placed under narrower conditions than the operation’s reach.

7) Step 7: Validate guard effectiveness — detect ineffective or ignored guards (e.g., guard result not used, condition always true/false, handler that doesn’t stop execution). Signals: unchecked return values of new validators, conditions that do not gate the operation, or error paths that still execute the operation.

8) Step 8: Propagate inputs/state — when indicated by the patch, trace the variables/parameters the guard inspects to the operation’s arguments/state. Signals: data-flow from the checked variable to the operation; if the patch checks a variable X, ensure the operation uses the same X or an alias.

9) Step 9: Compare preconditions — if the patch introduces a required precondition (e.g., initialization/state/permission), flag sites executing the operation without establishing that precondition. Signals: absence of the specific precondition sequence or API call added in PATCH_DIFF before the operation.

10) Step 10: Error handling parity — if the patch adds error handling or early return on failure, flag sites that call the operation while ignoring those failure conditions. Signals: missing early return, missing exception handling, or proceeding after a failure indicator where PATCH_DIFF shows a stop/return.

11) Step 11: Contextual match — ensure findings correspond to the same class by matching the exact constructs introduced by the patch. Signals: same function or API names, same variables, same structural pattern (e.g., identical guard condition or validator function name).

12) Step 12: Report deduplicated sites — group findings per operation site and summarize the missing/bypassed guard relative to PATCH_DIFF. Signals: one finding per unique operation with a list of uncovered paths and absent guard elements.

3. Limitations & Assumptions
- PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS are missing; the plan relies on PATCH_DIFF to derive the guard semantics and the protected operations.
- The exact vulnerability class (e.g., auth, bounds, null, state) cannot be determined without the patch details; steps are framed generically around “guards added by patch.”
- Assumes access to both pre-patch and post-patch code or at least the diff to identify what checks were added and where they apply.
- Determining “external/untrusted inputs” or environment influences is only possible if PATCH_DIFF reveals such context; otherwise this dimension is omitted.