1. Plan Summary
Detect cases where a local device_node pointer with automatic cleanup (__free(device_node)) escapes the function (e.g., stored into a longer-lived struct field), causing a premature of_node_put at function return and a potential use-after-free.

2. Detection Steps
1) Step 1: Objective — Identify local variables of type struct device_node* declared with automatic cleanup that triggers of_node_put. Signals — Function-local device_node* with an auto-cleanup attribute (conceptually “__free(device_node)”) as shown by the pre-patch pattern (based on [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation — Ensure the cleanup applies at function exit (not conditionally disabled).

2) Step 2: Objective — Find escapes where such an auto-cleanup variable is assigned to fields of objects that likely outlive the function. Signals — Assignments like target->field = node where node is the auto-cleanup variable and target is reachable from a function parameter, global/static, or returned to the caller (e.g., dlc->of_node = node as in [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation — Require that the base object is not stack-only and can escape (parameter-derived, global, heap-managed).

3) Step 3: Objective — Flag potential UAF when an auto-cleanup device_node* value escapes the function scope. Signals — Pair Step 1 and Step 2: the variable has auto of_node_put on return and its value flows into a field meant for later use (dlc->of_node). Why — Maps to the root cause where graph_util_parse_dai() stored dlc->of_node while auto cleanup dropped the ref at return (based on [ROOTCAUSE_ANALYSIS]). FP mitigation — Exclude cases where the receiving object is freed before function returns (intra-procedural lifetime analysis).

4) Step 4: Objective — Recognize error/success path asymmetry typical of this bug. Signals — Presence of explicit of_node_put(node) on error paths, and absence of an explicit put on success while using auto-cleanup (mirroring the pre-patch pattern versus the fix in [PATCH_DIFF]). Why — Confirms that the code expects the reference to persist on success but auto-cleanup contradicts it (based on [PATCH_DESCRIPTION], [PATCH_DIFF]). FP mitigation — Don’t require this to raise a warning, but use it to boost confidence.

5) Step 5: Objective — Confirm that the stored field is intended to retain a valid reference across driver lifetime. Signals — Later code puts the same field (e.g., of_node_put(dlc->of_node) in teardown routines like simple_util_clean_reference()) indicating ownership (based on [FILE_CONTENT], simple_util_clean_reference()). Why — If cleanup code puts the field, the field must hold a live ref; auto cleanup earlier would cause double put or UAF (based on [ROOTCAUSE_ANALYSIS]). FP mitigation — Treat such later puts as corroborating evidence; absence does not suppress the finding.

6) Step 6: Objective — Detect safe patterns that negate the issue to reduce false positives. Signals — The value assigned to the escaping field is a distinct reference that won’t be auto-put at function exit (e.g., stored from a variable without auto-cleanup, as in the patched code where node is a plain pointer and is explicitly put only on error, [PATCH_DIFF]). Why — Matches the fix strategy: remove auto-cleanup to keep ref while driver is in use (based on [PATCH_DESCRIPTION]). FP mitigation — Suppress when the escaping assignment uses a non-auto-cleanup variable or when ownership is clearly transferred without an auto release.

7) Step 7: Objective — Identify other escape mechanisms beyond direct field assignment. Signals — Returning the auto-cleanup variable, inserting into global/static containers, or passing it by pointer to functions that likely store it (e.g., setters taking a struct pointer and field name consistent with of_node). Why — Any escape while auto-cleanup runs at function exit risks UAF (based on [ROOTCAUSE_ANALYSIS]). FP mitigation — Restrict to known persistent sinks: fields of parameter-derived structs or global/static state; exclude purely local temporaries.

8) Step 8: Objective — Confirm the auto-cleanup’s release matches device_node semantics. Signals — Auto-cleanup attribute corresponds to of_node_put() release for device_node (conceptually “__free(device_node)” from [PATCH_DESCRIPTION], [PATCH_DIFF]). Why — Ensures the warning matches the refcount drop causing UAF (based on [ROOTCAUSE_ANALYSIS]). FP mitigation — Only trigger for device_node*; avoid generalizing to unrelated types.

9) Step 9: Objective — Prioritize findings in ASoC DT parsing contexts where of_node is stored for later use. Signals — Functions handling DAI link parsing and storing dlc->of_node, and later consumers like simple_util_parse_clk() that use dlc->of_node (based on [FILE_CONTENT], [ROOTCAUSE_ANALYSIS]). Why — Context strengthens likelihood of real UAF. FP mitigation — Prefer structures known to persist across probe/bind lifecycle (e.g., snd_soc_dai_link_component).

10) Step 10: Objective — Reduce noise from immediate-use scenarios. Signals — If the stored pointer is used only within the same function and not reachable by callers, don’t flag. Why — No lifetime crossing the auto cleanup boundary. FP mitigation — Intra-procedural escape analysis to ensure no outward reach.

3. Target Elements
- Local variable declarations of struct device_node* with auto-cleanup semantics (conceptually “__free(device_node)”).
- Assignments to fields of structs reachable from function parameters (e.g., dlc->of_node) or global/static memory.
- Function returns that return such pointers.
- Error/success path conditionals around of_node_put and auto-cleanup lifetime.
- Calls that infer later cleanup of stored fields (e.g., of_node_put(field) in cleanup functions).
- Relevant ASoC parsing functions that populate snd_soc_dai_link_component.

4. Dataflow / Taint Considerations
- Track dataflow from the auto-cleanup device_node* to:
  - Struct field assignments on parameter-derived objects.
  - Global/static stores.
  - Return values.
- Model lifetime boundary at function exit: if value escapes and the source variable is auto-cleaned at exit, flag.
- Optionally model corroborating “sink” where the field is later passed to of_node_put, indicating expected ownership.

5. Validation & Test Cases
- Positive: Pre-patch pattern in graph_util_parse_dai(): local node with auto-cleanup assigned to dlc->of_node; warn (based on [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).
- Negative: Patched version where node is not auto-cleanup, and explicit of_node_put(node) only on error; no warning (based on [PATCH_DIFF]).
- Positive: Any function that declares device_node* with auto-cleanup and stores it into a struct field reachable from a parameter or global for later use; warn.
- Negative: Local auto-cleanup device_node* used only transiently or stored into a purely local struct that doesn’t escape; no warning.
- Test harness notes: Build small kernel-like stubs for snd_soc_dai_link_component and simple_util_clean_reference()-style cleanup to verify cross-function corroboration.

6. Estimated Effort & Priority
Medium — Requires type/attribute recognition, escape analysis, and basic interprocedural sinks, but within common CodeQL capabilities.

7. Likely False-Positive Sources & Mitigations
- Cases where a new, independent reference is created before escape (not visible if the “retain/get” function is unknown): mitigate by only warning when the exact auto-cleanup variable flows into the field without an intermediate distinct ownership step.
- Structs that appear parameter-derived but are actually ephemeral: mitigate by requiring additional evidence of persistence (e.g., later cleanup puts, or known framework types like snd_soc_dai_link_component).
- Functions that do not truly use auto-cleanup (macro aliasing): mitigate by precise recognition of the attribute/macro corresponding to device_node auto release.

8. Limitations & Assumptions
- Exact identification of the auto-cleanup attribute is assumed from its conceptual presence (“__free(device_node)”) as per [PATCH_DESCRIPTION] and [PATCH_DIFF]; variations may need configuration.
- The plan assumes that storing into snd_soc_dai_link_component or similar ASoC structures implies persistence beyond the function (based on [FILE_CONTENT], [ROOTCAUSE_ANALYSIS]); without full-project knowledge, some lifetime inferences may be approximate.
- The presence of functions that duplicate references (retain/get) is not enumerated in the provided materials; the checker will conservatively warn unless it can see a distinct non-auto-cleaned value being stored.