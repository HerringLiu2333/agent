1. Plan Summary
Detect cases where a struct device_node* local variable with automatic cleanup (e.g., __free(device_node)) is stored into a long-lived field (such as dlc->of_node) and thus becomes a dangling pointer when the function returns.

2. Detection Steps
1) Step 1: Identify local variables of type struct device_node* declared with an automatic cleanup annotation that calls of_node_put at scope exit (e.g., "__free(device_node)"). Signals: variable declarations annotated with __free(device_node) or equivalent cleanup for device_node.

2) Step 2: Find initializations of such variables via DT “get” APIs that grant a reference. Signals: assignment from of_graph_get_port_parent(ep) to the annotated device_node* variable.

3) Step 3: Track dataflow from the annotated local device_node* variable to escaping assignments. Signals: an assignment storing the local variable into a field of a parameter or heap/global object that outlives the function; specifically dlc->of_node = node.

4) Step 4: Classify the destination as long-lived. Signals: the destination is a field of struct snd_soc_dai_link_component passed in (dlc), which is later referenced by other helpers (e.g., simple_util_parse_clk, simple_util_clean_reference in this file) and thus survives the function.

5) Step 5: Check for absence of a compensating ref acquisition before storing. Signals: no call to of_node_get(node) (or equivalent) on the annotated pointer prior to the assignment to dlc->of_node.

6) Step 6: Verify that the function has a normal success return path after the assignment. Signals: control-flow paths where return 0 or non-error ret occurs after the assignment, implying the automatic cleanup will execute at function exit.

7) Step 7: Confirm that the destination field is intended to be used post-return. Signals: later functions in the same file access dlc->of_node (e.g., simple_util_parse_clk uses dlc->of_node to get clocks; simple_util_clean_reference calls of_node_put on it), indicating a lifetime beyond the function.

8) Step 8: Emit a finding when an auto-cleaned device_node* escapes into dlc->of_node (or analogous long-lived field) without ref acquisition. Rationale: on function return, the cleanup will drop the reference (of_node_put), leaving the stored field as a dangling pointer and enabling use-after-free.

3. Limitations & Assumptions
- Assumes the tool can recognize __free(device_node) as a cleanup that calls of_node_put at scope exit; if __free is macro-expanded differently, detection may miss it.
- Only of_graph_get_port_parent(ep) is evidenced as a ref-granting source here; other DT “get” APIs are not enumerated in the supplied materials.
- The analysis infers long-lived semantics of dlc->of_node from its later uses shown; it cannot universally prove lifetimes across modules or all call chains.
- The checker does not require proving a concrete dereference-after-return; it flags the lifetime mismatch pattern that leads to use-after-free.