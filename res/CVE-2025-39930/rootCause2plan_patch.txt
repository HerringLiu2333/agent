1. Plan Summary
Detect cases where a local struct device_node pointer annotated with auto-cleanup (__free(device_node)) escapes the function (e.g., assigned into dlc->of_node or handed off via snd_soc_get_dlc), causing premature of_node_put at function exit and a dangling pointer (use-after-free).

2. Detection Steps
1) Step 1: Objective — find local variables of type struct device_node* declared with an auto-cleanup attribute. Signals — variable declaration with __free(device_node) as shown in [PATCH_DIFF]; this is the premature release mechanism per [ROOTCAUSE_ANALYSIS]. FP mitigation — restrict to device_node pointers to match the documented bug class.

2) Step 2: Objective — recognize acquisition of a refcounted node that should outlive the function. Signals — initialization of such a variable from of_graph_get_port_parent(ep), as in [PATCH_DIFF], which returns a node reference that normally requires of_node_put. FP mitigation — prioritize when the source is of_graph_get_port_parent to align with the concrete case.

3) Step 3: Objective — detect that the auto-cleaned pointer is handed off to a long-lived driver structure. Signals — dataflow from the local node to a write into a field named of_node reachable from a function parameter (e.g., dlc->of_node as indicated by function signature and [ROOTCAUSE_ANALYSIS]). FP mitigation — require the target object to be reachable from a function parameter or global (i.e., outlives the current stack frame).

4) Step 4: Objective — detect indirect handoff via helper calls known to populate dlc->of_node. Signals — the node value (directly or via an intermediate like args) flows into a call to snd_soc_get_dlc with the dlc pointer argument, per [ROOTCAUSE_ANALYSIS] (“stored in dlc->of_node”). FP mitigation — only treat snd_soc_get_dlc as an escaping sink when the node reaches the call site arguments.

5) Step 5: Objective — confirm the problematic lifetime boundary is crossed. Signals — presence of a control-flow path where the function returns success (e.g., after ret = snd_soc_get_dlc(&args, dlc) with ret >= 0), so scope exit triggers the auto-cleanup as stated in [ROOTCAUSE_ANALYSIS]. FP mitigation — require an observable non-error return path after the escape; if all paths return an error immediately, do not report.

6) Step 6: Objective — verify the auto-cleanup will actually run on the success path. Signals — the auto-cleanup-annotated variable remains in scope until function exit and is not unconditionally bypassed by earlier returns. FP mitigation — ignore paths that never reach a scope exit while the pointer is live.

7) Step 7: Objective — avoid flagging already-correct patterns. Signals — absence of __free(device_node) on the local variable and presence of an explicit put only on error paths as in [PATCH_DIFF] (explicit of_node_put(node) under ret < 0). FP mitigation — if no auto-cleanup attribute is present, do not report even if the pointer escapes.

8) Step 8: Step objective — reduce noisy reports from purely local usage. Signals — ensure the node is not only used locally or passed to callees without any parameter that is a caller-visible structure (no assignment to parameter-reachable fields and no known handoff calls like snd_soc_get_dlc). FP mitigation — require a proven escape to an outliving object (parameter field/global) or the modeled handoff call to raise an alert.

3. Target Elements
- Function-local variable declarations with attributes (auto-cleanup).
- Calls to of_graph_get_port_parent.
- Assignments to struct fields reachable from function parameters (e.g., dlc->of_node) and to globals/statics.
- Calls to snd_soc_get_dlc (known handoff sink from [ROOTCAUSE_ANALYSIS]).
- Return statements and control-flow determining success vs. error paths.

4. Dataflow / Taint Considerations
- Track dataflow from the auto-cleaned device_node local through direct assignments and through intermediate locals/structs (e.g., args) to:
  - Fields named of_node within structures reachable from parameters (dlc->of_node).
  - The arguments of snd_soc_get_dlc that, per [ROOTCAUSE_ANALYSIS], result in dlc->of_node retaining the node.
- Identify an “escape” if the value reaches a caller-visible object that outlives the current function or a modeled handoff call, and the function reaches a non-error return afterward.

5. Validation & Test Cases
- Positive: A function declares struct device_node *node __free(device_node) = of_graph_get_port_parent(ep); then the node flows (directly or via args) into snd_soc_get_dlc(&args, dlc) and the function returns success; expect a report.
- Positive: Same as above but with an explicit assignment dlc->of_node = node; expect a report.
- Negative: The function does not use __free(device_node); it assigns node to dlc->of_node and only calls of_node_put(node) on error (as in [PATCH_DIFF]); expect no report.
- Negative: The auto-cleaned node is only used locally and not stored to any parameter/global field or passed to snd_soc_get_dlc; expect no report.
- Negative: All paths after the potential handoff return an error immediately; expect no report.
- Test harness notes: Include a model indicating snd_soc_get_dlc stores the node into dlc->of_node when supplied via args, as implied by [ROOTCAUSE_ANALYSIS], to validate indirect handoff detection.

6. Estimated Effort & Priority
Medium — requires attribute detection, interprocedural dataflow to modeled sink(s), and basic path feasibility (success vs. error paths).

7. Likely False-Positive Sources & Mitigations
- Unknown callee semantics causing over-approximation of “handoff”: mitigate by only modeling snd_soc_get_dlc as a handoff sink (per [ROOTCAUSE_ANALYSIS]) and requiring evident dataflow from node to its arguments.
- Field-name collisions on of_node in unrelated contexts: mitigate by also checking the surrounding types/parameters consistent with snd_soc_dai_link_component usage seen in [PATCH_DIFF].
- Complex control flow obscuring success paths: mitigate by requiring a clear path to non-error return after the escape.

8. Limitations & Assumptions
- Only snd_soc_get_dlc is modeled as a handoff function based on the provided materials; other handoff APIs are not covered.
- The plan assumes that assigning into dlc->of_node or handing off via snd_soc_get_dlc causes the node to outlive the function, as stated in [ROOTCAUSE_ANALYSIS]; lifetime of other targets cannot be inferred here.
- The analysis does not model compensating refcount increments because no such APIs are described in the supplied materials.