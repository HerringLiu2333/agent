1. Plan Summary
Detect cases where a local struct device_node* is declared with an automatic cleanup (__free(device_node)) and then stored into a longer-lived object (e.g., a parameter struct field) while the function returns success, causing a premature of_node_put and a dangling pointer.

2. Detection Steps
1) Step 1: Identify locals with automatic cleanup on device_node — find local variables of type struct device_node* declared with the __free(device_node) cleanup attribute (based on PATCH_DIFF and FUNCTION_CONTENT). This maps to the root cause because __free(device_node) triggers of_node_put at scope exit; reduce false positives by restricting strictly to device_node pointers with this exact attribute.

2) Step 2: Confirm initialization from a refcounted-producing API — check if the variable is initialized from of_graph_get_port_parent(ep) (as shown in PATCH_DIFF/FUNCTION_CONTENT), which returns a node requiring of_node_put. This aligns with ROOTCAUSE_ANALYSIS that a refcounted node was obtained; reduce false positives by prioritizing cases sourced from this API.

3) Step 3: Detect pointer escape to longer-lived storage — find assignments where the cleaned-up local flows into a field of a structure reachable from a function parameter or a global (e.g., dlc->of_node = node as in FUNCTION_CONTENT). This maps to the root cause because the pointer escapes the local scope and is intended to be used after function return; reduce false positives by requiring the left-hand side base object is derived from a function parameter or global (not a local stack object).

4) Step 4: Ensure a success exit path after the escape — require a control-flow path from the field store to a non-error return (e.g., return 0 or fallthrough to a success return, as in FUNCTION_CONTENT parse_dai_end). This ties to ROOTCAUSE_ANALYSIS where the bug manifests only when the function returns success and the cleanup runs; reduce false positives by excluding cases where all paths after the store immediately return an error.

5) Step 5: Verify lack of compensating ref bump — ensure there is no of_node_get(node) (or equivalent ref increment) on the local pointer before the store into the longer-lived field (per ROOTCAUSE_ANALYSIS noting “No compensating of_node_get()”). This confirms the premature put will drop the last reference; reduce false positives by not flagging cases where of_node_get is found before the escape.

6) Step 6: Confirm cleanup remains active until function exit — check that the local variable remains in scope to the end and no code disables the cleanup or transfers ownership correctly (the attribute guarantees an of_node_put at exit per PATCH_DESCRIPTION). This ensures the automatic put will happen; reduce false positives by ignoring cases where the attribute is absent (post-patch) or the variable is never stored into longer-lived memory.

7) Step 7: Optional corroboration via post-store usage — allow but do not require subsequent in-function uses of node (e.g., of_graph_get_endpoint_count(node) in FUNCTION_CONTENT) to confirm the same variable is tracked. This does not cause the bug but strengthens confidence that the same object is being analyzed; reduce false positives by treating this as a supporting signal, not a requirement.

3. Target Elements
- Function definitions and return statements (to classify success vs error exits).
- Local variable declarations with cleanup attributes (specifically __free(device_node)).
- Call sites of of_graph_get_port_parent (source of device_node).
- Assignments to struct fields where the base is derived from a parameter or global (e.g., param->field = node).
- Calls to of_node_get and of_node_put (refcount adjustments).
- Control-flow structures (gotolabels, if/return) to detect paths from store to success return.

4. Dataflow / Taint Considerations
- Track dataflow from the local device_node* with __free(device_node) to:
  - Stores into fields of parameter-derived or global objects.
  - Function returns (success paths).
- Model refcount “taint” increments: if of_node_get(node) occurs before the escape, consider the field to hold a retained reference and suppress the warning.
- Model cleanup at scope exit: the presence of __free(device_node) implies an of_node_put at all exits where the variable’s scope ends.

5. Validation & Test Cases
- Positive: Local “struct device_node *node __free(device_node) = of_graph_get_port_parent(ep); dlc->of_node = node; … return 0;” as in pre-patch FUNCTION_CONTENT; expect a finding.
- Positive: Same as above but reaching success via a goto to an end label with return 0; expect a finding (matches PATCH_DIFF/FUNCTION_CONTENT flow).
- Negative: Same code with node declared without __free(device_node) (post-patch per PATCH_DIFF); expect no finding.
- Negative: With __free(device_node) but calling of_node_get(node) immediately before “dlc->of_node = node;” and then returning success; expect no finding (retained reference).
- Test harness notes: Ensure the CFG captures the success path after the store, and that attribute recognition for __free(device_node) and function name matching for of_graph_get/of_node_get are available.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where the stored field is a documented weak reference not requiring ownership; mitigate by restricting to device_node and requiring absence of of_node_get.
- Stores into objects that do not outlive the function (e.g., stack-allocated locals reachable via pointers); mitigate by requiring base object derived from parameters/globals.
- Alternate ref-retention patterns not named of_node_get; mitigate by focusing on the explicit of_node_get absence per ROOTCAUSE_ANALYSIS.

8. Limitations & Assumptions
- Assumes __free(device_node) invokes of_node_put at scope exit (from PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS); the checker does not model other cleanup attributes.
- Assumes of_graph_get_port_parent returns a refcounted device_node requiring of_node_put (supported by ROOTCAUSE_ANALYSIS and PATCH_DIFF context).
- Does not enumerate all possible ref-retention APIs beyond of_node_get due to lack of data in provided materials.
- Success vs error return classification is heuristic (e.g., return 0 treated as success per FUNCTION_CONTENT); other conventions are not modeled.