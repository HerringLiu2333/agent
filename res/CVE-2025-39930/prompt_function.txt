1. CVE Identifier
CVE-2025-39930

2. Vulnerability Type
Use-after-free due to premature refcount decrement (lifetime/refcount bug on device_node)

3. Root Cause Summary
graph_util_parse_dai() stored the parent device_node into dlc->of_node for use by the driver, but declared the local variable with "__free(device_node)", causing of_node_put() to be called automatically at function exit. This prematurely drops the reference while dlc->of_node still points to the node, leaving a dangling pointer. Subsequent use of dlc->of_node by the ASoC card/links can dereference a freed device_node, leading to use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA SoC (ASoC) simple-card-utils, device-tree graph DAI parsing

2) Pre-Patch Flaw:
In graph_util_parse_dai(), the line "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);" ensures node is put at scope end, even when assigned to dlc->of_node for longer-term use. No compensating of_node_get() or retention was performed to keep the node alive beyond the functionâ€™s scope.

3) Trigger Condition:
- ep is non-NULL and graph_util_parse_dai() returns success.
- dlc->of_node is set to node, and the function exits, triggering the auto of_node_put from __free(device_node).
- Later operations in the driver/card use dlc->of_node (e.g., link handling), while the node may already have been freed.

4) Impact Mechanism:
The auto of_node_put decreases the reference count of the device_node to zero, allowing it to be freed. dlc->of_node then becomes a dangling pointer; dereferencing it can cause use-after-free, leading to crashes or memory corruption in kernel space.

5. Patch Analysis
1) Fix Approach:
Remove the "__free(device_node)" cleanup attribute from the local node variable to prevent automatic of_node_put at function exit, thereby retaining the reference for dlc->of_node on success. Add an explicit of_node_put(node) on the error path to avoid leaks when snd_soc_get_dlc() fails.

2) Key Code Changes:
- Replaced "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);" with "node = of_graph_get_port_parent(ep);".
- Added explicit "of_node_put(node);" before returning when "ret < 0" after snd_soc_get_dlc(&args, dlc) fails.
- No changes to successful path; dlc->of_node continues to reference node, now without being prematurely put.

3) Locking/Concurrency Impact:
No locking changes. The fix corrects device_node refcount handling, eliminating a race where premature put could free the node while other users (via dlc->of_node) still access it. Ensures proper lifetime management without introducing new synchronization primitives.

6. Broader Kernel Security Implications
This issue highlights the risk of using automatic cleanup attributes with refcounted kernel objects when pointers escape the local scope. Premature refcount drops can lead to subtle use-after-free bugs that are hard to reproduce and diagnose, especially under concurrent device unbind/rebind or graph reconfiguration. Ensuring explicit, context-aware refcount management is critical in subsystems relying on device-tree nodes and shared structures to prevent kernel memory safety violations.