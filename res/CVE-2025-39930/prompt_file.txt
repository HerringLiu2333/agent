1. CVE Identifier
CVE-2025-39930

2. Vulnerability Type
Use-after-free due to premature reference release (lifetime/refcount bug)

3. Root Cause Summary
graph_util_parse_dai() stored a device_node pointer (dlc->of_node) for use beyond the functionâ€™s scope while the local variable holding that pointer was annotated with __free(device_node). This caused an automatic of_node_put() at function return, prematurely dropping the reference to the device node that dlc->of_node still pointed to. Subsequent uses of dlc->of_node by the driver could dereference a freed device_node, resulting in a use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA SoC (ASoC) simple-card-utils (sound/soc helpers parsing DT for DAI links)

2) Pre-Patch Flaw:
- In graph_util_parse_dai(), the parent device node was acquired and assigned to a local variable with automatic cleanup: "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);" and then stored for long-term use: "dlc->of_node = node".
- The __free(device_node) attribute caused of_node_put(node) when the function returned, leaving dlc->of_node as a dangling pointer.

3) Trigger Condition:
- Any call to graph_util_parse_dai() that succeeds in setting dlc->of_node (i.e., ep is non-NULL and parsing succeeds).
- Subsequent code paths that use dlc->of_node after graph_util_parse_dai() returns (for example, simple_util_parse_clk() later uses dlc->of_node to get clocks) will operate on a potentially freed device_node.

4) Impact Mechanism:
- Premature of_node_put() drops the reference, allowing the DT node to be freed while dlc->of_node still references it.
- Later accesses to dlc->of_node can lead to use-after-free, causing crashes or memory corruption. Additionally, cleanup code like simple_util_clean_reference() will attempt a second of_node_put() on an already-freed node, compounding the fault.

5. Patch Analysis
1) Fix Approach:
Remove the __free(device_node) auto-cleanup from the local 'node' pointer so the reference persists for the driver lifetime, and explicitly of_node_put(node) only on error paths to avoid leaks.

2) Key Code Changes:
- Replaced:
  "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);"
  with:
  "node = of_graph_get_port_parent(ep);"
- Added explicit release on error:
  After "ret = snd_soc_get_dlc(&args, dlc);" if (ret < 0) { of_node_put(node); return ret; }
- No of_node_put() on success, ensuring dlc->of_node retains a valid reference until later released by simple_util_clean_reference().

3) Locking/Concurrency Impact:
None. The patch strictly adjusts device_node reference management; no locks, ordering, or RCU semantics were changed.

6. Broader Kernel Security Implications
This highlights the risk of using automatic cleanup (__free) on objects whose references escape the function scope. In DT-heavy subsystems, incorrect device_node reference handling easily leads to lifetime bugs (UAF or leaks). Ensuring consistent get/put ownership when storing pointers in long-lived structures is essential to prevent kernel crashes or memory corruption; careful auditing is recommended wherever __free(device_node) is introduced or where pointers are propagated to persistent fields.