1. Plan Summary
Detect use-after-free caused by a local struct device_node* annotated with __free(device_node) that is handed off to longer-lived storage (e.g., dlc->of_node) and thus freed at function exit while still in use.

2. Detection Steps
1) Step 1: Identify functions that declare a local struct device_node* variable annotated with the auto-cleanup attribute __free(device_node). Signal: a local device_node pointer carrying the specific __free(device_node) attribute.

2) Step 2: Within those functions, find where that variable is initialized from an API that returns a referenced OF node, specifically of_graph_get_port_parent(ep). Signal: a call to of_graph_get_port_parent whose return value flows into the annotated local variable.

3) Step 3: Determine whether the annotated device_node pointer “escapes” the function by being stored into a field of a parameter or other outliving object. Signal: assignment or dataflow to a struct field reachable from function parameters (e.g., dlc->of_node) or other non-local storage.

4) Step 4: Treat writes to any field named of_node reachable from parameters as high-confidence escapes. Signal: an lvalue access chain ending in .of_node on a parameter or on an object derived from a parameter.

5) Step 5: Also treat as escapes returning the pointer, storing it in a global/static, or writing through an alias of a parameter. Signal: return statements carrying the pointer, assignments to globals/statics, or indirect stores via pointers obtained from parameters.

6) Step 6: For each escape, confirm that there exists a normal (non-error) return path after the escape point. Signal: control-flow path to a function exit without an intervening explicit of_node_put(node) that would prevent the auto-cleanup from being the final release.

7) Step 7: Recognize that __free(device_node) enforces an unconditional of_node_put() at function exit. Signal: the presence of the attribute on the local variable implies drop at scope end irrespective of outcome.

8) Step 8: If explicit of_node_put(node) calls are present only on error paths (e.g., when ret < 0) but not on success, treat this as reinforcing the risk that success returns still trigger auto-free. Signal: conditional cleanup limited to error branches alongside the __free attribute.

9) Step 9: Prioritize findings within ASoC simple-card-utils helpers like graph_util_parse_dai that populate dlc->of_node for driver use. Signal: function name graph_util_parse_dai and parameters matching (device, endpoint ep, snd_soc_dai_link_component *dlc).

10) Step 10: Suppress findings where the annotated pointer does not escape (no assignment to of_node or other outliving storage and not returned). Signal: absence of any escape sink as defined in Steps 3–5.

11) Step 11: Emit a result tying the escape site (e.g., write to dlc->of_node) to the annotated variable, explaining that auto-cleanup will free the node at function exit, leaving the recipient with a dangling pointer. Signal: a clear path from the annotated local to the outliving field and a post-escape normal return.

12) Step 12: Optionally raise severity when the pointer originates specifically from of_graph_get_port_parent(ep), as this is known to require matching of_node_put management. Signal: source API name matches of_graph_get_port_parent.

3. Limitations & Assumptions
- Assumes __free(device_node) implies an automatic of_node_put() at function exit; the checker must model this destructor-like behavior.
- Lacks visibility into snd_soc_get_dlc internals; assumes that dlc->of_node can be populated within the function or via helper calls and that it outlives the function.
- Assumes fields named of_node reachable from parameters represent long-lived storage used by the driver; cannot prove actual post-return usage.
- Focuses on of_graph_get_port_parent(ep) as the source of referenced nodes per the provided materials; other sources are not considered.
- Path sensitivity may be approximate; the checker infers success-path returns without comprehensive semantic understanding of ret values.