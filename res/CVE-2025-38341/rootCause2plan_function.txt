1. Plan Summary
Detect functions that free a caller-supplied buffer on a DMA mapping error path while also returning an error, leading to double free when callers also free the buffer on error (as in the pre-patch fbnic_mbx_map_msg case).

2. Detection Steps
1) Step 1: Objective — Identify candidate functions performing DMA map flows; Signals — Calls to dma_map_single(dev, P, ..., direction) where P originates from a function parameter; FP mitigation — Exclude cases where P is allocated within the same function prior to the dma_map_single call.
2) Step 2: Objective — Find mapping-error branches; Signals — A conditional using dma_mapping_error(dev, addr) that controls an error path after dma_map_single; FP mitigation — Require addr to be the value returned by the preceding dma_map_single.
3) Step 3: Objective — Spot callee-side freeing of caller buffer on the error path; Signals — In the dma_mapping_error branch, a call to free_page with the same pointer P (possibly cast) and an immediate return of a negative error code (e.g., -ENOSPC); FP mitigation — Ensure the free_page and return occur within the same guarded block and that no success-state side effects (e.g., tail advancement) occur before return.
4) Step 4: Objective — Confirm the buffer is caller-owned at function entry; Signals — P is a function parameter, not assigned from an allocator in the function, and not stored to any persistent structure prior to the error branch; FP mitigation — Require absence of any assignment of P into fields/arrays (e.g., mbx->buf_info[...].msg = P) before the error path executes.
5) Step 5: Objective — Establish conditional ownership transfer only on success; Signals — On the success path (i.e., not the dma_mapping_error branch), store P into a persistent structure/field after the map (e.g., mbx->buf_info[tail].msg = P and mbx->buf_info[tail].addr = addr), then advance state; FP mitigation — Require that these stores do not occur before the error check.
6) Step 6: Objective — Correlate call sites that free the same buffer on callee error; Signals — At call sites to the candidate function, the actual argument A passed as P is freed via free_page(A) in a control-flow path dominated by an error check on the callee’s return (e.g., if (ret < 0) { free_page(A); ... }); FP mitigation — Require the free_page to occur only in the error branch and use the same variable A without reassignment.
7) Step 7: Objective — Strengthen evidence of error return; Signals — The callee returns a negative errno on the error path (as seen with -ENOSPC in [PATCH_DIFF]/[FUNCTION_CONTENT]) and the caller checks the return for error (non-zero or negative); FP mitigation — Prefer explicit comparisons (ret < 0) or standard kernel error handling patterns, and deprioritize ambiguous checks.
8) Step 8: Objective — Exclude cases where the callee clearly owns the buffer; Signals — Presence of allocation of P inside the callee or documented ownership transfer before mapping; FP mitigation — Filter out functions where P is allocated locally and freed on error without ever being passed in as a parameter.
9) Step 9: Objective — Exclude error paths that sanitize the pointer to prevent double free; Signals — Callee sets the caller’s pointer to NULL via by-reference parameter before return; FP mitigation — If pointer is passed by value (as in the provided case), treat as risky; if passed by pointer-to-pointer and NULLed, deprioritize.
10) Step 10: Objective — Report high-confidence double-free patterns; Signals — Combine Steps 3–7: callee frees param P on dma_mapping_error and returns error; at least one caller frees the same argument on error; FP mitigation — Require both callee and caller evidence to reduce FPs.

3. Target Elements
- Functions that call dma_map_single and check dma_mapping_error.
- Function parameters used as the dma_map_single buffer argument.
- Error-handling branches with immediate returns and frees.
- Assignments storing the buffer into persistent structures on success.
- Call sites that check callee return values and free the same argument on error.

4. Dataflow / Taint Considerations
- Track dataflow from a function parameter P into the dma_map_single buffer argument.
- Track the returned dma address into the dma_mapping_error check.
- Track P into free_page calls in the error branch.
- Track P’s storage into struct/array fields only on the success path to model ownership transfer on success.
- Interprocedurally track the actual argument A at call sites to confirm free_page(A) occurs in error-handling paths predicated on the callee’s return.

5. Validation & Test Cases
- Positive: A function like pre-patch fbnic_mbx_map_msg that calls dma_map_single(msg), on dma_mapping_error frees msg via free_page and returns -ENOSPC; a caller that, upon negative return, also calls free_page(msg).
- Negative: The post-patch version where the dma_mapping_error branch returns an error without free_page; callers still free the page on error.
- Test harness notes: Use minimal kernel-like stubs for dma_map_single/dma_mapping_error/free_page and emulate a caller-callee pair; validate that only the pre-patch pair is flagged.

6. Estimated Effort & Priority
High: Requires interprocedural analysis (callee pattern plus caller error-handling correlation) and kernel-specific API understanding of dma_map_single/dma_mapping_error.

7. Likely False-Positive Sources & Mitigations
- Callee legitimately owns the buffer (mitigate by excluding locally allocated buffers and requiring parameter-origin).
- Caller does not free on error (mitigate by requiring at least one caller with an error-path free to report).
- Alternative free routines or complex aliasing obscure identity (mitigate by strict identity tracking of the same variable used as argument and in free_page).
- Error path where callee nullifies or otherwise makes double free impossible (mitigate by deprioritizing if pointer-to-pointer is NULLed; not applicable in provided case).

8. Limitations & Assumptions
- Assumes dma_map_single and dma_mapping_error semantics as shown; other DMA APIs are not covered by this plan.
- Assumes availability of caller bodies to confirm error-path frees; if unavailable, the checker may need to report lower confidence based solely on callee-side freeing.
- Does not infer project-wide ownership contracts beyond the observed pattern (based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]).
- Only considers free_page as the freeing primitive (based on [FUNCTION_CONTENT]/[PATCH_DIFF]); other freeing APIs are out of scope due to lack of evidence.