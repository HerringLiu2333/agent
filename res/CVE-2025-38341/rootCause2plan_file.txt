1. Plan Summary
Detect double-free risks where a helper frees a caller-owned buffer on an error path and callers also free the same buffer when the helper returns an error, as exemplified by fbnic_mbx_map_msg and its callers.

2. Detection Steps
1) Step 1: Objective — Identify helper functions that free a pointer parameter on an error path. Signals — A function with a pointer parameter P and a control-flow branch that returns a negative error code and calls a free routine on P (e.g., free_page((unsigned long)P)). FP mitigation — Require that the free occurs only in an error-returning branch and that P is a direct formal parameter (not a local).

2) Step 2: Objective — Specialize for the fbnic pattern involving DMA mapping failures. Signals — In the same function, a call to dma_map_single with P and a check of dma_mapping_error on its return controlling the branch where P is freed and a negative error is returned (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS). FP mitigation — Ensure the free is under the dma_mapping_error-controlled branch and the function returns a well-known error (e.g., -ENOSPC), strengthening the match with the described root cause.

3) Step 3: Objective — Confirm the helper does not claim ownership before the error branch. Signals — On the success path after dma_mapping_error is false, P is stored into an internal field (e.g., mbx->buf_info[tail].msg = P), but there is no such storage before the error return (from FILE_CONTENT). FP mitigation — Require that storage to internal state occurs only after the error check; if storage occurs before the error return, skip (ownership may already have transferred).

4) Step 4: Objective — Find call sites that also free the same object on helper error. Signals — A call to the helper with an argument A; control-flow using the helper’s return value to detect error (e.g., if (err)), followed by free_page(A) on that error path (from FILE_CONTENT: fbnic_mbx_alloc_rx_msgs and multiple xmit helpers). FP mitigation — Require that A is the same variable passed to the helper and that free is guarded by an error condition derived from the helper call.

5) Step 5: Objective — Connect callee-side free and caller-side free to flag double free. Signals — For a given helper function and a given parameter position, existence of at least one caller that frees the same argument A on error; the callee frees that parameter on its own error path. FP mitigation — Report only when both sides’ frees are on the same error condition family (e.g., helper returns negative error and caller checks for non-zero/negative) to reduce mismatches.

6) Step 6: Objective — Prefer Linux page-buffer patterns relevant to the case. Signals — Frees via free_page and allocations via __get_free_page or functions that are subsequently freed by free_page (e.g., fbnic_tlv_msg_alloc followed by free_page in FILE_CONTENT). FP mitigation — Prioritize warnings where both callee and caller use the same freeing primitive (free_page) on the same pointer.

7) Step 7: Objective — Exclude clear transfer-of-ownership cases. Signals — If the helper stores P into a long-lived structure before any potential error return, or if it nulls the caller’s pointer via an out-parameter, assume ownership transfer. FP mitigation — Suppress when the function writes P into a global/device struct prior to return on all paths, or when the caller’s variable is not subsequently freed on error (no double free in practice).

8) Step 8: Objective — Exclude idempotent or guarded frees. Signals — If the caller sets the variable to NULL before freeing or tests for NULL and the callee sets it to NULL on error, double free risk is mitigated. FP mitigation — Suppress if either side sets the pointer to NULL before the other free, or if frees are conditionally mutually exclusive.

9) Step 9: Objective — Aggregate evidence across multiple callers. Signals — Multiple callers free the argument on error (as in ROOTCAUSE_ANALYSIS listing several helpers); increase confidence if more than one caller exhibits this pattern. FP mitigation — Raise confidence score when multiple independent call sites match; optionally lower severity when only one marginal call site is found.

10) Step 10: Objective — Highlight the specific dma_map_single/dma_mapping_error idiom. Signals — Presence of dma_map_single and dma_mapping_error controlling the error path where the free occurs (PATCH_DIFF). FP mitigation — If this idiom is present, elevate priority because it maps precisely to the root cause summarized in ROOTCAUSE_ANALYSIS.

3. Target Elements
- Functions that take pointer parameters and return error codes.
- Error-handling branches within such functions, especially those predicated by dma_mapping_error after dma_map_single.
- Calls to memory-free routines (free_page specifically in this case).
- Call sites that process the function’s error return and free the argument.
- Assignments of the parameter to internal state post-success checks (to reason about ownership transfer).

4. Dataflow / Taint Considerations
- Track the actual argument expression A at call sites to the corresponding formal parameter P inside the callee.
- Track control dependencies: callee returns an error value along the path where P is freed, and caller branches on that return to free A.
- Track pointer identity between A and P through casts (e.g., (unsigned long)P) and simple assignments, ensuring both frees target the same object.
- Track success-path storage of P into internal fields to infer ownership transfer only after successful mapping, not on the error path.

5. Validation & Test Cases
- Positive: Pre-patch fbnic_mbx_map_msg freeing msg on dma_mapping_error, combined with fbnic_mbx_alloc_rx_msgs and fbnic_fw_xmit_simple_msg freeing msg on helper error (as described in ROOTCAUSE_ANALYSIS and visible in FILE_CONTENT).
- Negative: Patched fbnic_mbx_map_msg without free in the dma_mapping_error branch (PATCH_DIFF), while callers still free on error; checker should not flag.
- Test harness notes: Include variants where the callee frees on non-DMA errors to verify generality, and cases where the callee stores the pointer before freeing to ensure suppression when ownership transfer is ambiguous.

6. Estimated Effort & Priority
Medium: Requires interprocedural dataflow (argument-to-parameter mapping), control-flow analysis for error paths, and matching frees at two levels.

7. Likely False-Positive Sources & Mitigations
- Ownership conventions unknown: Mitigate by requiring both callee free-on-error and caller free-on-error evidence.
- Different free functions for the same resource: Mitigate by prioritizing identical free primitives (free_page) and flagging lower severity if frees differ.
- Complex aliasing: Mitigate by focusing on direct variable arguments and simple casts; de-prioritize when alias chains are long or uncertain.
- Condition mismatches: Mitigate by ensuring the caller’s error check is directly derived from the callee’s return and the callee’s free occurs only on an error-returning path.

8. Limitations & Assumptions
- Assumes that free_page is the correct deallocator for the passed object; custom allocators/deallocators beyond those shown are not modeled from provided data.
- Cannot conclusively infer documented ownership semantics; relies on behavioral evidence (free in callee on error plus free in caller on error).
- Does not reason about concurrency or double free due to races; focused on structural error-path double frees.
- Scope tailored to patterns evidenced by PATCH_DIFF and ROOTCAUSE_ANALYSIS; broader kernel-wide allocator patterns may need extension.