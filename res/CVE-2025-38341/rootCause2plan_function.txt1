1. Plan Summary
Detect functions that free a caller-provided buffer in the error path after a failed DMA mapping (dma_map_single + dma_mapping_error) while returning an error code, indicating a likely double free because ownership should remain with the caller until success.

2. Detection Steps
1) Step 1: Identify candidate functions that call dma_map_single(dev, buf, size, direction) and bind the buffer argument (buf) and the returned DMA address variable (addr).
2) Step 2: In the same function, locate a conditional that checks dma_mapping_error(dev, addr) and identify its “error” branch.
3) Step 3: Within that error branch, detect a deallocation of the same buffer (buf) via free_page (allowing casts/aliases) and a subsequent return of a negative error code (e.g., -ENOSPC).
4) Step 4: Verify that buf is not allocated in this function (no alloc_page/kmalloc/allocations producing buf) and that buf originates from a function parameter or caller-provided value.
5) Step 5: Confirm that before the error-branch return, buf has not been written into any longer-lived storage (e.g., field/array/global assignment) or otherwise marked as transferred; i.e., no ownership handoff has occurred on the error path.
6) Step 6: Check the success path (the branch where dma_mapping_error is false) for evidence of ownership transfer, such as assigning buf into a struct/array field (e.g., mbx->buf_info[...].msg = buf) before function return.
7) Step 7: If Step 6 is true, infer an ownership contract of “callee takes ownership only on success”; therefore, freeing buf in the error path is inconsistent and likely violates the contract.
8) Step 8: Optionally strengthen the finding by scanning call sites: find at least one caller that, upon receiving a negative return from the callee, frees the same argument (buf) on its error path.
9) Step 9: Prioritize/report when Steps 1–7 hold; elevate severity if Step 8 also holds. Include path context: dma_map_single -> dma_mapping_error -> free_page(buf) -> return error, and any success-path assignment demonstrating ownership transfer.
10) Step 10: Suppress cases where the function clearly always consumes ownership (e.g., also frees buf on the success path or never exposes buf to caller), or where the function returns the freed resource, to reduce false positives.

3. Limitations & Assumptions
- Assumes the presence of dma_map_single and dma_mapping_error API usage; other DMA APIs are not covered by this plan.
- Cannot perfectly infer ownership contracts without explicit documentation; Step 6’s “ownership on success” inference is heuristic.
- Cross-call-site confirmation (Step 8) may be limited by incomplete codebases or indirect frees; absence of such evidence should not block reporting but may lower confidence.
- Detection focuses on free_page; analogous frees (e.g., kfree/put_page) are not guaranteed detected unless explicitly added by the implementation.