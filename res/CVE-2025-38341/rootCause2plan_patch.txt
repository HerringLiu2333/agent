1. Plan Summary
Detect functions that call dma_map_single and, on dma_mapping_error, free the same buffer passed to dma_map_single before returning an error, indicating a potential double free due to caller-retained ownership on failure.

2. Detection Steps
1) Step 1: Objective: Find candidate functions performing DMA mapping of a message. Signals: Calls to dma_map_single(dev, buf, size, dir) with a pointer argument captured to a variable and used in a subsequent check. FP mitigation: Require a following conditional that invokes dma_mapping_error(dev, mapped_addr) on that returned address, as in [PATCH_DIFF].

2) Step 2: Objective: Identify error-handling branches for mapping failures. Signals: Control-flow branch whose condition is dma_mapping_error with the mapped address returned by the earlier dma_map_single. FP mitigation: Ensure the dma_mapping_error uses the same dev and mapped address returned by the immediately preceding dma_map_single in the same function.

3) Step 3: Objective: Detect deallocation of the buffer in the mapping-failure branch. Signals: A free operation such as free_page(...) where the argument is dataflow-equivalent to the buffer argument passed to dma_map_single (e.g., msg in [PATCH_DIFF]). FP mitigation: Use value/alias flow to confirm it is the same object (allowing casts like (unsigned long)msg) and that the free occurs within the dma_mapping_error branch.

4) Step 4: Objective: Confirm that the error branch returns an error code after the free. Signals: A return statement with a negative errno (e.g., -ENOSPC as in [PATCH_DIFF]) in the same error branch. FP mitigation: Ensure the return is control-dependent on the same dma_mapping_error branch to avoid misclassifying unrelated cleanup paths.

5) Step 5: Objective: Assess ownership by determining if the freed buffer is caller-provided. Signals: The buffer argument to dma_map_single originates from a function parameter or a value passed into the function, and there is no local allocation of that buffer in the same function. FP mitigation: Suppress when the buffer is allocated within the function (e.g., via a recognizable page allocator) before the dma_map_single call, indicating callee-owned memory.

6) Step 6: Objective: Increase confidence by checking post-call behavior in callers (optional but preferred). Signals: At call sites of the callee, along error-return paths (return value < 0), detect a subsequent free of the same buffer (e.g., free_page(msg)), aligning with [ROOTCAUSE_ANALYSIS] “All existing callers … free the page.” FP mitigation: Require path-sensitivity from the call result check to the free and argument identity to the original buffer.

7) Step 7: Objective: Avoid flagging legitimate, balanced cleanup on success paths. Signals: Ensure the flagged free occurs only under dma_mapping_error, not under a branch that follows a successful mapping or a later teardown where the callee clearly owns the buffer. FP mitigation: If the callee stores the buffer for later use on success and frees it only during its own teardown paths (not on mapping failure), suppress the alert.

8) Step 8: Objective: Prioritize likely harmful cases. Signals: Presence of both the free in the error branch and an immediate error return (as in [PATCH_DIFF]) suggests the callee is signaling failure while also freeing caller memory, matching [ROOTCAUSE_ANALYSIS]. FP mitigation: Lower severity or suppress if additional evidence shows the callee is documented/annotated as taking ownership even on failure (if such metadata exists).

3. Target Elements
- Functions that wrap DMA mapping of messages/buffers.
- Calls to dma_map_single and subsequent dma_mapping_error checks.
- Error-handling branches and return statements with error codes.
- Deallocation calls such as free_page and their arguments.
- Function parameters and local variables used as dma_map_single buffer arguments.
- Call sites of such functions and post-call error-handling code paths.

4. Dataflow / Taint Considerations
- Track dataflow from function parameters (or external inputs) to the buffer argument of dma_map_single.
- Track the equivalence of that buffer argument to the argument of free operations inside the dma_mapping_error branch, allowing simple casts.
- Track control dependence from dma_mapping_error to the free and to the error return.
- Interprocedurally, at callers, track the same buffer argument through the call and into post-call frees on error paths to corroborate double-free risk.

5. Validation & Test Cases
- Positive: A function calls dma_map_single(dev, msg, …); if dma_mapping_error(dev, addr) then free_page((unsigned long)msg); return -ENOSPC; and a caller frees msg on error. Expect a high-confidence alert.
- Positive: Same as above without an observed caller free; still flag as potential ownership violation per [ROOTCAUSE_ANALYSIS].
- Negative: A function allocates the page locally (callee-owned), calls dma_map_single, and on dma_mapping_error frees the locally allocated page and returns an error. Expect no alert.
- Negative: A function calls dma_map_single, on dma_mapping_error returns an error without freeing the msg (as in the patched version). Expect no alert.
- Test harness notes: Include paths with casts on msg, ensure detection across basic blocks, and include a caller-level test to validate interprocedural corroboration.

6. Estimated Effort & Priority
High: The issue can cause allocator corruption and crashes per [ROOTCAUSE_ANALYSIS], and detection requires control-flow and dataflow analyses with optional interprocedural correlation.

7. Likely False-Positive Sources & Mitigations
- Callee legitimately owns the buffer (allocated internally or by contract): mitigate by checking for local allocation and parameter-origin analysis.
- Unrecognized allocator/deallocator pairs: mitigate by focusing on free_page as evidenced in [PATCH_DIFF], and optionally allowing a configurable list.
- Complex ownership transfer protocols not encoded in code: mitigate by requiring the specific dma_mapping_error gating and immediate error return pattern.

8. Limitations & Assumptions
- Assumes the semantic contract that on dma_map_single failure the caller retains ownership, based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; this may not universally hold for other APIs.
- The plan focuses on free_page; other deallocators (e.g., kfree) are not covered unless configured.
- Verifying that “all existing callers free the page” is approximated via optional interprocedural checks; completeness is not guaranteed.
- The checker cannot infer documentation-only ownership contracts beyond code patterns and may miss or misclassify atypical ownership designs.