1. Plan Summary
Detect double-free scenarios where a callee frees a pointer argument on an error path and returns an error, while callers also free the same argument when they observe that error.

2. Detection Steps
1) Step 1: Identify deallocation sinks — look for calls to free_page(ptr) and treat ptr as the deallocated resource. Focus on pointers that are variables or parameters, not temporaries.

2) Step 2: Find “free-on-error” callees — for each function, detect control-flow paths where a parameter (or a value directly derived from a parameter) is passed to free_page() and the function subsequently returns an error (e.g., negative errno constant). Signals: a call to free_page(argFromParam) followed by a return with a negative integer, often gated by an error predicate (e.g., a mapping error check).

3) Step 3: Model the freed parameter position — record which formal parameter index(s) in the callee correspond to the freed pointer (e.g., the msg parameter in fbnic_mbx_map_msg).

4) Step 4: Identify callers that pass a concrete variable as the argument to that freed parameter position. Signals: the actual argument expression in the call is a local variable, SSA value, or an alias of the same variable (no intervening reassignments between the call and a potential free).

5) Step 5: Detect caller error-handling paths — find control-flow checks immediately dependent on the callee’s return value (e.g., “if (err) …”, “if (ret < 0) …”, or direct-condition calls) that represent the “callee returned error” branch.

6) Step 6: On the caller’s error branch, look for a second free of the same argument variable via free_page(theSameVar). Allow straightforward nesting (e.g., free occurs inside the guarded block), and match by identity or simple aliasing to the call argument.

7) Step 7: Report a potential double free when both conditions hold: (a) the callee frees the parameter on an error-return path, and (b) the caller frees the same argument upon detecting the error return from that call.

8) Step 8: Account for one-hop wrappers — detect “passthrough wrappers” that accept the pointer parameter, call a free-on-error callee with the same pointer argument, and return the callee’s result without freeing the pointer themselves. Signals: single call to the target callee, the wrapper returns the callee’s int result, and the same pointer flows from wrapper parameter to callee argument.

9) Step 9: Propagate the free-on-error behavior through such wrappers to their callers, treating the wrapper’s corresponding parameter as if it were freed-on-error by the wrapper itself.

10) Step 10: Prioritize high-confidence cases by recognizing typical error predicates inside the callee (e.g., checks like dma_mapping_error(dev, addr) guarding the free_page+error return). Use this as a boosting signal but do not make it mandatory.

11) Step 11: Increase precision by recognizing likely ownership sources for the argument variable in the caller (e.g., assigned from __get_free_page(...) or fbnic_tlv_msg_alloc(...)) prior to the call. Use this as an additional confidence boost.

12) Step 12: Suppress obvious false positives by ensuring the callee path that frees-and-returns-error does not also stash the same pointer into a persistent structure on that same path (i.e., require that after free_page and error return, the pointer is not stored for later lifetime extension).

3. Limitations & Assumptions
- Assumes negative integer return values indicate error; errno constants are treated as negative-return signals.
- Alias tracking is limited to simple cases (same variable or straightforward assignments); complex aliasing or pointer arithmetic may not be fully handled.
- Wrapper propagation is limited to simple passthroughs (single call, direct return of callee’s result); deeper or more complex wrapper chains may be missed.
- The checker cannot infer documented ownership semantics; it infers risk purely from code patterns (free in callee on error + free in caller on error).
- The plan focuses on free_page as the deallocator (per the provided code); other deallocators are not considered unless explicitly modeled.