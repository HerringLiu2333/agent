1. Plan Summary
Detect functions that free a caller-provided buffer in the dma_mapping_error path after dma_map_single and return an error, while callers also free that buffer on error, leading to a double free.

2. Detection Steps
1) Step 1: Identify candidate functions that call dma_map_single(dev, buf, size, direction) and immediately test dma_mapping_error(dev, addr) on the returned DMA address. Signals: a variable assigned from dma_map_single; a conditional whose predicate is dma_mapping_error on the same dev and addr.

2) Step 2: Within the dma_mapping_error branch, detect a call to free_page on the buffer argument passed to dma_map_single. Signals: free_page called with a value aliasing the second argument of dma_map_single (possibly via casts), in the same error branch.

3) Step 3: Confirm the error branch returns an error code rather than continuing normal execution. Signals: a return statement in the error branch returning a negative errno constant or non-zero error code (e.g., -ENOSPC).

4) Step 4: Ensure the freed buffer is caller-provided, not allocated by the callee. Signals: the freed value is derived from a function parameter (or external variable) and there is no allocation of that buffer in the callee (e.g., no alloc_page or equivalent producing that same value in the function).

5) Step 5: For each candidate callee, collect call sites where a pointer P is passed as the buffer argument to the callee. Signals: call expressions to the callee with an argument P that aliases the buffer used in dma_map_single.

6) Step 6: At each call site, capture the return value or error indicator from the callee. Signals: assignment of the call result to a variable (e.g., ret) or direct use in a conditional.

7) Step 7: In the call site’s error-handling path (where the callee’s result indicates failure), check for a free_page on the same pointer P. Signals: a control-flow branch conditioned on the call result (e.g., ret < 0 or non-zero) that invokes free_page(P) within that branch.

8) Step 8: Verify the call site’s free_page targets the same object passed to the callee, accounting for simple casts or aliases. Signals: equivalence/aliasing between P at the call site and the argument freed in the callee’s error path.

9) Step 9: Exclude cases where the callee clearly owns the buffer (e.g., the buffer is allocated inside the callee and not provided by the caller). Signals: presence of allocation in the callee producing the freed value; absence of buffer as a parameter.

10) Step 10: Optionally prioritize findings where the callee stores the buffer pointer on success but not on failure, reinforcing the ownership-by-caller-on-error pattern. Signals: assignments like mbx->... = buf on the non-error path and no such storage on the error path.

11) Step 11: Report a potential double free when both conditions hold: callee frees the caller-provided buffer in the dma_mapping_error branch and returns error; caller frees the same buffer in its error path after the call. Signals: matched callee-side and caller-side locations forming a feasible error path.

12) Step 12: De-duplicate reports per (callee, caller, buffer) triple and provide both code locations to aid remediation. Signals: grouping by function pair and buffer variable identity.

3. Limitations & Assumptions
- Assumes that returning an error from the callee implies the caller retains cleanup responsibility; actual ownership contracts are not inferable solely from code.
- Focuses on the dma_map_single/dma_mapping_error/free_page pattern; similar issues using other DMA APIs or different free primitives may be missed.
- Error detection relies on common kernel patterns (negative errno or non-zero returns); atypical signaling mechanisms may be under-reported.
- Alias tracking is limited to straightforward cases; complex indirections or frees through helper wrappers may be missed or produce false negatives.
- Concurrency, race conditions, and allocator-side effects are not modeled; the checker targets static double-free patterns only.