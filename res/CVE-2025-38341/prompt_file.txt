1. CVE Identifier
CVE-2025-38341

2. Vulnerability Type
Double free (memory ownership/management bug)

3. Root Cause Summary
fbnic_mbx_map_msg() freed the message page on DMA mapping failure even though the function’s contract is that the caller retains ownership on error. All its callers already free the page when fbnic_mbx_map_msg() returns an error, so the extra free in the callee caused a double free. The patch removes the premature free in fbnic_mbx_map_msg(), aligning the implementation with the ownership semantics.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking – Meta FBNIC Ethernet driver firmware mailbox (fbnic/fw mailbox message handling)

2) Pre-Patch Flaw:
In fbnic_mbx_map_msg(), the error path after dma_map_single() did:
“if (dma_mapping_error(...)) { free_page((unsigned long)msg); return -ENOSPC; }”.
This violated the stated semantics (caller retains ownership on error) and duplicated the caller’s cleanup.

3) Trigger Condition:
DMA mapping failure (dma_mapping_error() returns true) during mailbox message mapping for TX or RX:
- RX: fbnic_mbx_alloc_rx_msgs() calls fbnic_mbx_map_msg(); on error it executes free_page(), causing a second free.
- TX: multiple xmit helpers allocate a message, call fbnic_mbx_map_msg(), and free the page on error (e.g., fbnic_fw_xmit_simple_msg(), fbnic_fw_xmit_ownership_msg(), fbnic_fw_xmit_heartbeat_message(), fbnic_fw_xmit_fw_start_upgrade(), fbnic_fw_xmit_fw_write_chunk(), fbnic_fw_xmit_tsene_read_msg()).

4) Impact Mechanism:
Double free of a page (buddy allocator page) leading to allocator metadata corruption, potential use-after-free, and kernel crash or other undefined behavior. The second free occurs in the caller after the callee already freed the same page when DMA mapping failed.

5. Patch Analysis
1) Fix Approach:
Enforce single-owner cleanup by removing the free in fbnic_mbx_map_msg() so that only callers free the message on error, as intended.

2) Key Code Changes:
- In fbnic_mbx_map_msg(): removed free_page((unsigned long)msg) from the dma_mapping_error() path and returned -ENOSPC directly.
Diff hunk:
- if (dma_mapping_error(fbd->dev, addr)) {
-     free_page((unsigned long)msg);
-     return -ENOSPC;
- }
+ if (dma_mapping_error(fbd->dev, addr))
+     return -ENOSPC;

3) Locking/Concurrency Impact:
None. No locking changes; the bug and fix pertain solely to memory ownership in the error path. Calls that occur under fw_tx_lock are unaffected in terms of synchronization.

6. Broader Kernel Security Implications
Double free in kernel space can corrupt the page allocator and potentially enable denial-of-service or escalation via memory corruption. This fix reinforces strict ownership contracts between helper routines and their callers, highlighting the importance of consistent allocation/free semantics across driver paths to avoid double frees when handling error returns from DMA mapping or similar resource acquisitions.