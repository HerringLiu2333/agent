1. Plan Summary
Detect stack buffer overflows caused by using an externally reported size (e.g., from EFI GetVariable) to read into a fixed-size stack buffer without bounding the copy to the buffer’s capacity or verifying an exact-size match.

2. Detection Steps
1) Step 1: Objective: Find call sites of efi.get_variable that perform a read (non-NULL data buffer). Signals: A call where the “data” argument is a pointer to a local fixed-size object (struct or array) and the “data_size” argument is a pointer to a scalar length variable. FP mitigation: Restrict to buffers that are automatic (stack) storage with compile-time size and exclude heap/dynamically sized buffers.

2) Step 2: Objective: Confirm two-step “probe-then-read” pattern that trusts external length. Signals: In the same function, an earlier efi.get_variable call with a NULL data buffer and the same data_size variable (or an alias) used to learn size. FP mitigation: Require clear dataflow identity between the two calls’ size variables and the same EFI variable context (e.g., same name/guid operands), per [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF].

3) Step 3: Objective: Determine whether the read call’s length is not bounded to the destination size. Signals: At the read call, the value passed via data_size is not set to sizeof(buffer) or otherwise clamped to <= sizeof(buffer) on all paths. FP mitigation: Treat as safe if the length argument is a constant equal to sizeof(buffer), or if a dominating check ensures data_size <= sizeof(buffer) before the call.

4) Step 4: Objective: Detect absence of pre-call size bounding. Signals: No dominating condition like data_size <= sizeof(buffer) or explicit assignment/clamp data_size = sizeof(buffer) (or equivalent min) occurs before the read call. FP mitigation: Accept any clear bounding pattern that ensures the callee will not write more than the buffer capacity, even if implemented via a helper or min-like construct.

5) Step 5: Objective: Strengthen confidence using “probe + fixed-size stack target” combination. Signals: The buffer at the read call is a fixed-size local struct/array, and data_size was previously set by a probe call or otherwise influenced by external/firmware size. Why it maps: Matches the pre-patch flaw where firmware size controlled how many bytes were written into a smaller stack struct [ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude cases where the second call’s buffer is dynamically allocated based on the probed size.

6) Step 6: Objective: Flag missing post-call exact-size validation when relevant. Signals: After the read, absence of a check that the returned data_size equals sizeof(buffer). Why it maps: The patch adds “status == EFI_SUCCESS AND data_size == sizeof(buffer)” as a correctness check; its absence often accompanies misuse of unbounded length [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]. FP mitigation: Do not report solely for missing post-check if pre-call bounding is correct; use as a secondary signal to raise confidence.

7) Step 7: Objective: Ensure the status-based control flow doesn’t implicitly bound size. Signals: The only status checks are for EFI_BUFFER_TOO_SMALL or EFI_SUCCESS, without any branch that enforces or adjusts data_size relative to sizeof(buffer) pre-call. Why it maps: The unsafe pre-patch logic trusted the probed size and only checked status codes, not capacity [ROOTCAUSE_ANALYSIS]. FP mitigation: If any branch adjusts the size or redirects flow when size exceeds the buffer, suppress.

8) Step 8: Objective: Consolidate a report when all risky conditions hold. Signals: (a) Read call to efi.get_variable with a stack fixed-size buffer; (b) data_size tainted by a prior probe or external value; (c) no dominating bound to sizeof(buffer); (d) optional: missing post-call equality check. FP mitigation: Require (a)-(c); treat (d) as a confidence booster but not mandatory.

3. Target Elements
- Call sites to efi.get_variable.
- Local (stack) variable declarations for fixed-size structs/arrays used as buffers.
- Scalar length variables passed by pointer as size/length parameters to efi.get_variable.
- Control-flow guards and comparisons involving the length and sizeof(buffer).
- Prior efi.get_variable calls with NULL data buffer (probe calls).
- Assignments that set or clamp the length variable before the read call.
- Status checks and post-call validations comparing data_size to sizeof(buffer).

4. Dataflow / Taint Considerations
- Track dataflow into the size variable from:
  - A prior efi.get_variable “probe” call (NULL data buffer) that writes into size.
  - Any other external-influenced sources.
- Propagate through assignments and simple arithmetic; consider aliases/pointers to the same size variable.
- Determine dominance: whether a bounding assignment or guard controls all paths to the read call.
- Treat the read call as potentially writing “size” bytes into the buffer; require proof of size <= sizeof(buffer) to deem safe.

5. Validation & Test Cases
- Positive: Two-step pattern: first efi.get_variable(..., &size, NULL) gets EFI_BUFFER_TOO_SMALL; then efi.get_variable(..., &size, &stack_struct) without any size <= sizeof(stack_struct) guard (the pre-patch pattern per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).
- Positive: Single efi.get_variable call where &stack_struct is the buffer and &size is passed, with size coming from an external/probe source and no bounding to sizeof(stack_struct).
- Negative: Fixed version: data_size initialized to sizeof(stack_struct); single efi.get_variable read; post-call check enforces status == EFI_SUCCESS and data_size == sizeof(stack_struct) [PATCH_DIFF].
- Negative: Two-step probe followed by dynamic allocation using the probed size and reading into that heap buffer.
- Negative: Any pattern that clamps data_size to <= sizeof(buffer) or passes a constant sizeof(buffer) to the read call.

- Test harness notes: Run on the btintel_uefi_get_dsbr() pre- and post-patch snippets to ensure only the pre-patch variant is flagged; include synthetic variants for heap allocation and clamped size.

6. Estimated Effort & Priority
Medium effort; High priority due to kernel stack overflow risk and recurring “probe-then-read into fixed buffer” anti-pattern [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- APIs with different semantics where the callee never writes more than the provided buffer size: mitigate by scoping to efi.get_variable as evidenced in [PATCH_DIFF].
- Complex clamping via helpers/macros not recognized as bounds: mitigate by recognizing common min-like patterns and dominance-based guards.
- Flexible array members within structs: mitigate by requiring compile-time known buffer size and explicit sizeof(buffer) comparisons.

8. Limitations & Assumptions
- Assumes efi.get_variable writes up to the provided size into the data buffer, as implied by [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]; API semantics are not independently verified.
- Does not generalize to other firmware/syscall APIs unless explicitly enumerated; plan is scoped to efi.get_variable based on provided evidence.
- May miss cases where size is safely clamped via opaque helper functions that are not modeled.