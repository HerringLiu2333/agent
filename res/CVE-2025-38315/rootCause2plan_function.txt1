1. Plan Summary
Detect cases where efi.get_variable writes into a fixed-size stack buffer using an EFI-reported size without bounding or validating it against the buffer’s sizeof, leading to a potential stack overflow.

2. Detection Steps
1) Step 1: Find functions that invoke efi.get_variable twice, using the same size variable by address in both calls. Signal: first call’s data argument is NULL and a later call’s data argument is non-NULL.

2) Step 2: In the second call, confirm the destination argument is the address of a local, fixed-size stack variable (e.g., a struct or array declared in the function). Signal: address-of a non-pointer local variable with statically known size.

3) Step 3: Track data flow of the size variable from the first call to the second call to ensure it is reused unchanged. Signal: the value written via the size pointer in the probe call flows into the size pointer argument of the subsequent call without being set to sizeof(buffer) or clamped.

4) Step 4: Recognize the “probe for size” pattern on the first call. Signal: post-call condition compares status to EFI_BUFFER_TOO_SMALL and checks the size variable is non-zero; use this as a strong indicator but allow detection even if only the NULL data probe call is present.

5) Step 5: Check for absence of a bounds assignment before the second call. Signal: no assignment that sets the size variable to sizeof(the destination buffer) prior to the second call.

6) Step 6: Check for absence of a bounds comparison relative to the destination buffer. Signal: no condition ensuring the size variable is <= or == sizeof(the destination buffer) either immediately before the second call or immediately after it.

7) Step 7: Examine validation after the second call. Signal: a status-only check (e.g., comparing status to EFI_SUCCESS) without any accompanying check that the returned size equals sizeof(the destination buffer).

8) Step 8: Report a result when all signals align: two-step size probe, stack-local fixed-size buffer as destination, the EFI-reported size reused for the write, and no sizeof-based bounds enforcement.

3. Limitations & Assumptions
- Assumes the argument order of efi.get_variable from the provided code: fourth parameter is a size pointer and fifth is the data buffer.
- Assumes the EFI runtime writes data_size bytes into the provided buffer, per the root cause description; the checker cannot verify runtime behavior.
- The plan focuses on this specific API; similar issues via wrappers or different firmware APIs may not be detected.
- Static analysis cannot determine actual EFI variable sizes; it flags missing validation rather than guaranteed overflows.
- The checker relies on identifying local fixed-size stack variables; cases using heap buffers or dynamically sized allocations are out of scope.