1. CVE Identifier
CVE-2025-38315

2. Vulnerability Type
Stack buffer overflow (unsafe length handling of EFI variable into fixed-size stack struct)

3. Root Cause Summary
btintel_uefi_get_dsbr() queried the EFI variable size first, then reused that returned size as the copy length when reading into a fixed-size stack struct without verifying it was <= sizeof(struct btintel_dsbr). If the EFI variable was larger than the struct, efi.get_variable() wrote data_size bytes into the smaller stack buffer, overflowing it. The pre-patch logic trusted external (firmware) length and failed to bound the copy to the destination’s capacity or to ensure an exact-size match.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth Intel driver (btintel), function btintel_uefi_get_dsbr(), handling UEFI variable BTINTEL_EFI_DSBR.

2) Pre-Patch Flaw:
- data_size initialized to 0, followed by a probe call: efi.get_variable(..., &data_size, NULL) expecting EFI_BUFFER_TOO_SMALL to learn required size.
- The subsequent call passed &data_size and &data, with data_size set to the firmware-reported required size, but data was a fixed-size local struct.
- There was no check that data_size <= sizeof(data), and no bounding of the copy to sizeof(data), leading to unsafe copy into a stack buffer.

3) Trigger Condition:
The UEFI variable BTINTEL_EFI_DSBR is larger than sizeof(struct btintel_dsbr) (i.e., data_size returned by the first call exceeds the fixed local buffer size).

4) Impact Mechanism:
efi.get_variable() uses the caller-provided data_size as the buffer length and copies that many bytes into &data; when data_size > sizeof(data), this overwrites adjacent stack memory, causing a stack buffer overflow and kernel memory corruption (potential crash or exploitation).

5. Patch Analysis
1) Fix Approach:
- Enforce a strict, known bound by initializing data_size to sizeof(data) before the read.
- Remove the initial “size probe” call and perform a single bounded read.
- Validate that the returned status is EFI_SUCCESS and that data_size equals sizeof(data), rejecting any size mismatch.

2) Key Code Changes:
- data_size set to sizeof(data) instead of 0.
- Deleted the first get_variable() call with NULL buffer and the EFI_BUFFER_TOO_SMALL check.
- Single get_variable() call now uses &data with data_size = sizeof(data).
- Added check: if (status != EFI_SUCCESS || data_size != sizeof(data)) return -ENXIO; ensuring no overflow and exact-size data.

3) Locking/Concurrency Impact:
None. No locking or concurrency changes; the issue and fix concern buffer sizing and bounds validation only.

6. Broader Kernel Security Implications
- Reading firmware-provided data into fixed-size kernel buffers must always bound copy lengths to the destination size and validate expected structure sizes; trusting external size reports can lead to kernel memory corruption.
- The common two-step EFI GetVariable pattern (probe size then read) is safe only when copying into an appropriately sized dynamically allocated buffer; for fixed-size structures, callers must set the input buffer length to sizeof(struct) and require exact matches.
- Stack overflows in kernel space are high-risk, potentially enabling privilege escalation or denial-of-service; this fix strengthens defensive handling of UEFI input in the Bluetooth subsystem.