1. Plan Summary
Detect stack-based buffer overflows where a two-step EFI variable read (efi.get_variable) uses an untrusted size to fill a fixed-size stack buffer without constraining the size to the buffer’s sizeof.

2. Detection Steps
1) Step 1: Identify candidate API calls — find calls to efi.get_variable where the last argument is a non-null buffer pointer expression and the size argument is a pointer to a scalar size variable.
2) Step 2: Determine destination buffer properties — resolve the buffer argument; if it is the address-of a local (stack) variable with a statically known size (array or struct), record its sizeof and treat it as a fixed-size stack buffer.
3) Step 3: Capture the size variable — resolve the object whose address is passed as the size parameter; track assignments to this variable within the same function before the call.
4) Step 4: Match the two-step probe pattern — look for an earlier reachable call to efi.get_variable in the same function that passes the same size-variable pointer and a NULL buffer argument (the “probe” call that sets size based on the EFI variable).
5) Step 5: Check for missing pre-call bounds — for the “second” call (with non-null buffer), see if dominating code assigns sizeVar = sizeof(buffer) or otherwise constrains sizeVar to be ≤ sizeof(buffer) (e.g., an if-guard that returns or errors when sizeVar > sizeof(buffer)); if not found, mark as unsafe.
6) Step 6: Recognize safe usage patterns — if the size argument passed to the second call is syntactically sizeof(buffer) (e.g., via direct assignment immediately before the call) or a clearly bounded form (e.g., min with sizeof(buffer)), treat it as safe and suppress.
7) Step 7: Distinguish ineffective checks — do not consider post-call checks (e.g., comparing returned data_size after the call) as mitigating the overflow risk if the call itself could have used a larger, unchecked size; require the bound to hold at the moment of the call.
8) Step 8: Flag the vulnerable pair — raise an alert when: (a) the buffer is a fixed-size stack object, (b) sizeVar originates from a prior probe call (NULL buffer), and (c) no dominating bound ensures sizeVar ≤ sizeof(buffer) or resets sizeVar to sizeof(buffer) before the second call.
9) Step 9: Heuristic single-call safeguard — optionally, for single efi.get_variable calls (no prior probe) into a fixed-size stack buffer, flag if the sizeVar is not assigned to sizeof(buffer) (or a bounded expression) in dominating code; lower severity than the two-step pattern.
10) Step 10: Reduce false positives — do not report when the destination is heap-allocated, when the destination size is dynamic, or when the size argument is a compile-time expression exactly equal to sizeof(destination).

3. Limitations & Assumptions
- Assumes the EFI API is named efi.get_variable with signature semantics consistent with the provided code (size pointer then data pointer); other similar APIs are not covered unless explicitly listed.
- Value-range reasoning is approximated via syntactic dominance: the checker looks for explicit assignments/guards involving sizeof(buffer) before the call, not full numeric range analysis.
- Interprocedural flows of sizeVar are not considered; analysis is scoped to the same function.
- The checker infers “stack buffer” from local variables; it may miss cases where buffers are passed through local pointers or allocated in unusual ways.