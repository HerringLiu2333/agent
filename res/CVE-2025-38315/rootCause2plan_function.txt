1. Plan Summary
Detect functions that perform a two-step EFI variable read where an untrusted size from the first call is reused as the length for a second call to fill a fixed-size stack buffer without verifying that the size is bounded by the buffer’s size, leading to a potential stack buffer overflow.

2. Detection Steps
1) Step 1: Identify candidate functions that call efi.get_variable at least twice with the same variable name/guid within the same function scope. Signals: multiple efi.get_variable call sites sharing the same first arguments and a common size variable; FP mitigation: restrict to calls occurring in the same function and in close control-flow proximity.
2) Step 2: Detect a first “probe” call where the output buffer argument is NULL and a size pointer variable is supplied. Signals: efi.get_variable(..., size_ptr, NULL) and subsequent conditional on the returned status constant; FP mitigation: require that the size variable is later reused as an input to a second call.
3) Step 3: Link the second efi.get_variable call that uses the same size variable but with a non-NULL buffer. Signals: efi.get_variable(..., same size_ptr, &buffer_var) and buffer_var is the address of a local variable; FP mitigation: ensure buffer_var is a local stack object (address-of a local struct/array) rather than heap/global.
4) Step 4: Confirm the destination buffer is fixed-size and stack-allocated. Signals: local struct/array declaration whose address is passed to efi.get_variable and sizeof(buffer_var) is computable; FP mitigation: exclude cases where the buffer size is dynamically allocated or computed from the size variable.
5) Step 5: Check for absence of a bounds check between the size variable and sizeof(buffer_var) prior to the second call. Signals: no preceding conditional that requires size <= sizeof(buffer_var) or assigns size = sizeof(buffer_var); FP mitigation: treat explicit comparisons (<=, ==) or clamping to sizeof(buffer_var) as safe and do not flag.
6) Step 6: Check for absence of a post-call validation that the returned size equals the expected fixed-size. Signals: after the second call, only status is tested and no conditional guards that size == sizeof(buffer_var); FP mitigation: if there is a combined status-and-size check (e.g., status OK and size == sizeof(buffer)), do not flag.
7) Step 7: Identify initial size variable initialization patterns that indicate reliance on external size. Signals: size variable initialized to 0 and later populated by the first call; FP mitigation: use this as a supporting signal, not a strict requirement, to avoid missing variants that initialize size differently.
8) Step 8: Validate that the probe call’s status check indicates “buffer too small” logic. Signals: conditional comparing the status to a constant and continuing to the second call on the “buffer too small” path; FP mitigation: require the second call to be reachable from the branch where the first call indicates the presence of data.
9) Step 9: Model dataflow from the first call to the size variable and from the size variable to the second call’s length argument. Signals: def-use chain showing the size variable is set (or tainted) by the first call and used unmodified in the second; FP mitigation: if any intermediate clamp sets size to sizeof(buffer_var), consider safe.
10) Step 10: Ensure the path to the second call lacks a guard that rejects oversized values (e.g., returning error if size > sizeof(buffer_var)). Signals: no conditional rejecting size mismatches; FP mitigation: treat any rejection on mismatch as safe, mirroring the fix in [PATCH_DIFF].
11) Step 11: Confirm the vulnerability impact context is a stack-based buffer. Signals: destination buffer is a local variable (automatic storage) with known fixed size and address passed to the call; FP mitigation: de-prioritize if destination is heap-allocated with capacity >= size or if the length passed is the buffer’s sizeof.
12) Step 12: Optionally prioritize findings where both calls use identical variable/guid arguments. Signals: first two parameters of both calls are syntactically equivalent; FP mitigation: this strengthens the linkage to the exact pattern in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Functions containing multiple calls to efi.get_variable.
- Call sites to efi.get_variable with NULL buffer and non-NULL buffer.
- Local variable declarations for fixed-size buffers (structs/arrays) whose addresses are passed to efi.get_variable.
- Local “size” variables passed by address to efi.get_variable.
- Condition checks on call return status and on the size variable.
- Assignments to and comparisons involving the size variable and sizeof(buffer).

4. Dataflow / Taint Considerations
- Track taint from the first efi.get_variable call into the size variable (set-by-call semantics), then into the second call’s length parameter.
- Treat any operation that sets the size variable to sizeof(buffer) or constrains it via size <= sizeof(buffer) as a de-taint (sanitization).
- Recognize absence of sanitization on the path from the first call to the second call as a risk signal.

5. Validation & Test Cases
- Positive: The pre-patch btintel_uefi_get_dsbr() in [FUNCTION_CONTENT] (two calls, second writes into a fixed-size stack struct, no size-vs-buffer check).
- Negative: The patched variant in [PATCH_DIFF] (data_size initialized to sizeof(data), single call, and post-call check data_size == sizeof(data)).
- Negative: A hypothetical function where, before the second call, the code verifies size <= sizeof(buffer) or assigns size = sizeof(buffer).
- Test harness notes: Run the checker on code containing both pre-patch and patched versions to confirm one flagged finding and one non-finding.

6. Estimated Effort & Priority
High: Requires inter-call reasoning, local dataflow tracking, and buffer-size analysis to avoid false positives.

7. Likely False-Positive Sources & Mitigations
- APIs with different semantics where size is an upper bound rather than a write length; mitigate by focusing on efi.get_variable as evidenced in [ROOTCAUSE_ANALYSIS].
- Cases where buffer is not stack-allocated or its capacity matches the size; mitigate by requiring fixed-size stack buffers and computable sizeof.
- Implicit sanitization via helper macros/functions; mitigate by recognizing common equality/inequality checks to sizeof(buffer) and early returns on mismatch.

8. Limitations & Assumptions
- Assumes efi.get_variable uses the provided size to determine how many bytes to write into the supplied buffer, as stated in [ROOTCAUSE_ANALYSIS].
- Does not generalize to other firmware APIs without similar semantics; the inputs do not provide broader API catalogs.
- Precise modeling of EFI status constants and side effects on the size variable may be limited; the checker relies on structural patterns from [FUNCTION_CONTENT] and [PATCH_DIFF].