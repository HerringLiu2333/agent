1. CVE Identifier
CVE-2025-38315

2. Vulnerability Type
Stack-based buffer overflow (length/size misuse when reading EFI variable)

3. Root Cause Summary
The function btintel_uefi_get_dsbr() queried the EFI variable size first and then reused that untrusted size as the input length for a second efi.get_variable() call into a fixed-size stack buffer without bounding it. Specifically, after a first call to get the size, it called efi.get_variable(..., &data_size, &data) where data_size could exceed sizeof(data), and there was no check that data_size <= sizeof(data). This allowed the EFI runtime service to write data_size bytes into a buffer of only sizeof(data), causing a stack buffer overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth Intel driver (btintel), EFI variable handling in btintel_uefi_get_dsbr()

2) Pre-Patch Flaw:
- The code trusted the EFI-reported variable size and passed it as the input buffer length for a fixed-size stack struct btintel_dsbr.
- Missing bounds/equality check between the returned EFI size and sizeof(struct btintel_dsbr).
- Evidence: pre-patch sequence in btintel_uefi_get_dsbr():
  - First call: efi.get_variable(..., &data_size, NULL) to fetch size.
  - Second call: efi.get_variable(..., &data_size, &data) with data_size potentially larger than sizeof(data), and no validation “if (status != EFI_SUCCESS) return -ENXIO;”.

3) Trigger Condition:
- The UEFI variable BTINTEL_EFI_DSBR exists and its size is larger than sizeof(struct btintel_dsbr), so the first call returns EFI_BUFFER_TOO_SMALL and sets data_size to a larger value that is then used as the input size for the second call.

4) Impact Mechanism:
- The EFI runtime service uses the input data_size parameter to determine how many bytes to write; since data points to a smaller stack buffer, this results in a stack-based buffer overflow, corrupting adjacent stack memory and potentially leading to kernel crashes or code execution.

5. Patch Analysis
1) Fix Approach:
- Eliminate the two-step “query size then read” pattern for a fixed-size structure.
- Initialize data_size to sizeof(data) and perform a single get_variable call using the known buffer size.
- Validate that the returned data_size equals sizeof(data) and reject any mismatch.

2) Key Code Changes:
- Initialize data_size to sizeof(data) instead of 0:
  - unsigned long data_size = sizeof(data);
- Remove the initial probe call that requested NULL buffer to obtain size.
- Perform one get_variable call with &data and then verify both status and size:
  - if (status != EFI_SUCCESS || data_size != sizeof(data)) return -ENXIO;

3) Locking/Concurrency Impact:
- None. No locking or concurrency changes; the fix is purely a bounds/size validation change for memory safety.

6. Broader Kernel Security Implications
- Demonstrates the risk of trusting external/environment-provided sizes (EFI variables) and passing them as authoritative lengths to kernel copy routines.
- Reinforces the need for strict size validation or controlled fixed-size reads when dealing with firmware interfaces and runtime services.
- Reduces attack surface from malicious or malformed EFI variable stores that could otherwise induce kernel stack corruption via driver variable reads.