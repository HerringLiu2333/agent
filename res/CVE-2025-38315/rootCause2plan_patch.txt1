1. Plan Summary
Detect unsafe efi.get_variable usage that copies firmware-provided data into a fixed-size stack buffer using an unbounded size learned from a prior “probe” call, without constraining the copy length to the destination’s sizeof.

2. Detection Steps
1) Step 1: Identify calls to efi.get_variable where the data buffer argument is non-null and points to a local, fixed-size stack object (e.g., address-of a local struct or array) — target copy sites.
2) Step 2: For each target copy site, determine the size variable passed by address to efi.get_variable; record that variable and the destination object’s sizeof.
3) Step 3: Within the same function, find a preceding call to efi.get_variable that uses the same size variable address and passes a null data buffer (probe pattern to obtain required size).
4) Step 4: Establish data-flow from the probe call’s output (the size variable) to the later copy call, ensuring the same variable value is reused as the copy length.
5) Step 5: Check that, between probe and copy, there is no assignment of the size variable to the destination’s sizeof and no transformation that caps it to the destination capacity.
6) Step 6: Check there is no guard before the copy call that ensures size <= sizeof(destination) or size == sizeof(destination) (e.g., no if-condition that rejects oversized values).
7) Step 7: Confirm the destination is a fixed-size automatic (stack) object, not dynamically sized according to the probed length; flag only stack-backed buffers.
8) Step 8: Optionally note status checks (e.g., EFI_BUFFER_TOO_SMALL or EFI_SUCCESS) are present or absent, but do not treat them as mitigating unless they enforce size constraints.
9) Step 9: If all above hold, report the copy call as a potential stack buffer overflow: external firmware size is used as copy length into a smaller, fixed-size stack buffer without bounding to sizeof.
10) Step 10: Also flag single-call patterns where the size variable at the copy site is neither initialized to sizeof(destination) nor constrained relative to it, and its value originates from outside the function (e.g., earlier API calls), indicating an unbounded read into a stack struct.

3. Limitations & Assumptions
- Assumes efi.get_variable writes up to the caller-provided size; exact semantics are inferred from the supplied materials.
- Limits scope to efi.get_variable patterns; other firmware/driver APIs with similar semantics are not covered.
- Does not prove runtime feasibility (e.g., specific variable names or GUIDs); it flags static patterns lacking bounds relative to the destination.
- Cannot detect nuanced bounds enforcement via opaque helper functions unless they clearly set size to sizeof(destination) or compare against it.