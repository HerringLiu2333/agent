1. Plan Summary
Detect stack-based buffer overflows caused by reading a UEFI variable into a fixed-size local buffer using an externally provided size without bounding that size to sizeof(buffer), as exemplified by the pre-patch btintel_uefi_get_dsbr sequence.

2. Detection Steps
1) Step 1: Identify candidate functions that call the EFI get_variable routine accessed via efi.get_variable. Signal: call expressions whose callee is the get_variable member of the efi object (as seen in FILE_CONTENT and PATCH_DIFF); mitigate FP by restricting to this specific API name.
2) Step 2: Within a function, locate a “probe-then-read” pattern: a first call with the data pointer argument NULL and a second call with a non-NULL data pointer, both sharing the same size variable. Signal: two calls to efi.get_variable where the 5th argument is NULL in the first and an address-of in the second, and the 4th argument is the same size variable; mitigate by requiring both calls occur in the same function and along a feasible path.
3) Step 3: Resolve the data pointer of the second call to the underlying storage; confirm it is the address of a local, fixed-size stack object (struct or array). Signal: address-of a local variable declared in the function; mitigate FP by excluding heap (kmalloc/etc.) and non-local storage.
4) Step 4: Compute the buffer’s capacity as sizeof(stack object) and record the size variable passed to the EFI call. Signal: availability of sizeof on the declaration; mitigate FP by skipping incomplete types or VLAs.
5) Step 5: Check for absence of a pre-call bound: no conditional guarding the second call ensures the size value (dereferenced size pointer) is ≤ sizeof(stack object). Signal: lack of any comparison against sizeof(buffer) in the dominating conditions; mitigate by recognizing guards even if they appear in preceding branches.
6) Step 6: Check for absence of a pre-call override: the size variable is not set to sizeof(stack object) before the second call (as done in the patch, PATCH_DIFF). Signal: no assignment of data_size = sizeof(buffer) dominating the second call; mitigate FP by allowing trivial aliasing of the size variable.
7) Step 7: Check for absence of a post-call validation: there is no check that the returned data_size equals sizeof(buffer) after the second call (status != EFI_SUCCESS || data_size != sizeof(data) in PATCH_DIFF). Signal: no equality or ≤ comparison to sizeof(buffer) following the call; mitigate FP by accepting any size mismatch check that returns or errors.
8) Step 8: Confirm the probe semantics that increase risk: the first call explicitly expects EFI_BUFFER_TOO_SMALL and checks size > 0, then uses the probed size directly (as in FILE_CONTENT). Signal: branch testing status != EFI_BUFFER_TOO_SMALL or size being zero; mitigate FP by treating this as a heuristic that strengthens confidence but is not strictly required.
9) Step 9: Exclude safe dynamic sizing patterns: if the destination buffer is heap-allocated according to the probed size (e.g., kmalloc(data_size)) or a flexible buffer sized by the size value, do not report. Signal: second call’s data argument derived from a heap allocation sized by the same size variable; mitigate FP by requiring stack-based destination for this checker’s scope.
10) Step 10: Exclude safe fixed-size reads: if the second call passes a fixed size (size variable assigned to sizeof(buffer) prior to the call) and validates the returned data_size, do not report. Signal: explicit data_size = sizeof(buffer) and post-call check for equality (PATCH_DIFF); mitigate FP by recognizing exact-size enforcement.
11) Step 11: Report only when the full pattern holds: local fixed-size stack destination, external/probed size used for the read, and no bounds or validation present. Signal: presence of Steps 2–7 conditions; mitigate FP by requiring all these signals.
12) Step 12: Increase priority when the stack object is a small packed struct likely intended to be read exactly (e.g., __packed struct btintel_dsbr) and the code treats it as a fixed format (FILE_CONTENT and ROOTCAUSE_ANALYSIS). Signal: __packed annotation and small sizeof; mitigate FP by using this as a prioritization hint, not a strict filter.

3. Target Elements
- Function bodies containing calls to efi.get_variable.
- Call sites for efi.get_variable and their arguments (size pointer and data pointer).
- Local variable declarations of fixed-size buffers (structs/arrays) and address-of uses as data destinations.
- Control-flow checks around calls (status/error codes and size comparisons).
- Assignments to the size variable and comparisons against sizeof(buffer).

4. Dataflow / Taint Considerations
- Track the size variable passed by pointer to the first call and reused in the second call; ensure it is the same storage across calls.
- Model dominance: whether assignments or guards (size <= sizeof) precede the second call.
- Track the data pointer in the second call back to a local fixed-size buffer; exclude flows to heap-allocated buffers sized by the size variable.

5. Validation & Test Cases
- Positive: Pre-patch btintel_uefi_get_dsbr pattern (FILE_CONTENT) with first get_variable probing size, second call passing &data with unbounded data_size; expect a report.
- Negative: Patched version (PATCH_DIFF) initializing data_size to sizeof(data), removing the probe, and checking data_size == sizeof(data) after the call; expect no report.
- Negative: A function that probes size, allocates buffer via kmalloc(data_size), then reads into that heap buffer and validates status; expect no report.
- Test harness notes: Include unit snippets mimicking efi.get_variable signature with local structs and control-flow; verify the checker’s path sensitivity and dominance of guards.

6. Estimated Effort & Priority
High.

7. Likely False-Positive Sources & Mitigations
- Indirect/wrapper calls to EFI that the checker doesn’t recognize; mitigate by focusing on efi.get_variable naming as in provided code.
- Complex control flow where bounds checks exist but are non-local; mitigate by using dominance analysis and recognizing equivalent guards.
- Cases where the API semantics differ (size used for output length, not input bound); mitigate by restricting to the specific EFI pattern evidenced (ROOTCAUSE_ANALYSIS and FILE_CONTENT).

8. Limitations & Assumptions
- Assumes the last two parameters of efi.get_variable are the size pointer and the data pointer and that the size bounds the write, based on FILE_CONTENT and ROOTCAUSE_ANALYSIS.
- Assumes stack overflow is the targeted class; global/static overflows are not covered by this checker to reduce FPs.
- Does not generalize to non-EFI firmware APIs due to lack of evidence in the provided materials.