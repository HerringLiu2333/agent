1. CVE Identifier
CVE-2025-38315

2. Vulnerability Type
Stack-based buffer overflow (memory safety bug)

3. Root Cause Summary
The btintel_uefi_get_dsbr function queried the UEFI variable size and then read that many bytes into a fixed-size stack buffer (struct btintel_dsbr data) without verifying that the variable’s size was less than or equal to sizeof(data). If the UEFI variable BTINTEL_EFI_DSBR was larger than struct btintel_dsbr, efi.get_variable wrote beyond the buffer, causing a stack overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth subsystem, Intel btintel driver (function btintel_uefi_get_dsbr)

2) Pre-Patch Flaw:
- In btintel_uefi_get_dsbr, data_size was first obtained via efi.get_variable(..., &data_size, NULL).
- The subsequent call used efi.get_variable(..., &data_size, &data) with data_size potentially greater than sizeof(struct btintel_dsbr).
- No check ensured data_size <= sizeof(data) before writing into the stack-allocated data buffer.

3) Trigger Condition:
Presence of a UEFI variable BTINTEL_EFI_DSBR whose size exceeds sizeof(struct btintel_dsbr) (5 bytes), causing efi.get_variable to write more than the buffer can hold when the second call passes the larger data_size with &data.

4) Impact Mechanism:
Stack buffer overflow in kernel context within btintel_uefi_get_dsbr, leading to stack corruption, potential kernel crash, or other undefined behavior; exploitation potential depends on the ability to control the EFI variable’s size/content.

5. Patch Analysis
1) Fix Approach:
- Use the known size of struct btintel_dsbr as the read buffer size for efi.get_variable.
- Eliminate the initial size-query call and enforce exact-size matching by verifying that the returned data_size equals sizeof(struct btintel_dsbr).
- Fail safely if the EFI variable does not match the expected size.

2) Key Code Changes:
- Initialize data_size to sizeof(data) instead of 0.
- Remove the preliminary efi.get_variable(..., &data_size, NULL) probe for size.
- Call efi.get_variable once with &data and a fixed data_size (sizeof(data)).
- Add a check: if (status != EFI_SUCCESS || data_size != sizeof(data)) return -ENXIO.
Relevant diff hunks in btintel_uefi_get_dsbr:
- unsigned long data_size = 0; -> unsigned long data_size = sizeof(data);
- Removed first get_variable(size probe) and its status checks.
- After read: added data_size == sizeof(data) validation.

3) Locking/Concurrency Impact:
None. The change is confined to local buffer handling within a synchronous EFI variable read; no locks or ordering semantics were modified.

6. Broader Kernel Security Implications
This fix highlights the need for strict bounds checking when interfacing with firmware/EFI variables. Kernel code must pass explicit buffer sizes to firmware APIs and validate returned lengths to prevent memory corruption. Similar patterns in other EFI/ACPI interactions should be audited to avoid trusting external variable sizes and to enforce exact or bounded structure sizes before copying into fixed-size buffers.