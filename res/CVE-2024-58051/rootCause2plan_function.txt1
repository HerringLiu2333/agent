1. Plan Summary
Create a parameterized detector that flags code patterns matching the pre-patch behavior described in the patch (missing checks/validations/guards and unsafe operations), by generalizing the exact edits shown in the patch across the codebase.

2. Detection Steps
1) Step 1: Identify the functions, methods, and code regions modified by the patch (names, signatures, locations) from PATCH_DIFF; these define the scope of vulnerable patterns.
2) Step 2: Extract the specific protective constructs added in the patch (e.g., conditions, validations, bounds/permission checks, null checks) from PATCH_DIFF/PATCH_DESCRIPTION; these are the “required guards.”
3) Step 3: Derive the pre-patch unsafe operation(s) from PATCH_DIFF (e.g., direct calls, dereferences, copies, arithmetic, state changes) that the patch now guards or replaces; these are the “sinks.”
4) Step 4: Model the guard-sink relationship: record which variables/parameters the new guard references and which operation(s) it protects (based on control-flow and data-flow around the edits).
5) Step 5: Search the codebase for occurrences of the same sink operations (same API names or equivalent operations, same argument/receiver shapes) that occur without the guard constructs identified in Step 2.
6) Step 6: For each candidate occurrence, check that the missing guard is relevant: the guard would apply to the same variables/parameters reaching the sink (match variable identity or aliasing consistent with the patch site).
7) Step 7: If the patch introduces precondition checks (e.g., range, null, state, permission), detect paths where the sink is reachable without those preconditions being established (no equivalent check dominates the sink).
8) Step 8: If the patch adds data sanitization or transformation before the sink, flag uses where the sink consumes raw data without that transformation (compare argument preparation steps to patch’s added steps).
9) Step 9: If the patch changes call ordering or enforces a sequence (e.g., validate-then-use), flag sequences that perform the sink before the required step (identify control-flow ordering relative to the guard).
10) Step 10: If the patch tightens error handling (e.g., return on failure), flag paths that ignore failure/return values and proceed to the sink (missing early returns or error branches found in PATCH_DIFF).
11) Step 11: Suppress false positives where an equivalent guard exists via a different but semantically similar construct (e.g., alternative check covering the same predicate), by matching the condition semantics to the patch.
12) Step 12: Report findings with context: the sink location, the expected guard per patch, and evidence of absence (no dominating check/transform), referencing the corresponding patched change for justification.

3. Limitations & Assumptions
- PATCH_DESCRIPTION, PATCH_DIFF, FUNCTION_CONTENT, and ROOTCAUSE_ANALYSIS are not provided, so the exact guard types, API names, and operations cannot be specified here.
- The plan assumes the patch adds explicit, identifiable constructs (checks, validations, transformations, ordering) that can be generalized; without those details, the checker must be instantiated with project-specific signals from the missing materials.
- Source classification (e.g., “untrusted input”) and precise sink taxonomy depend on FUNCTION_CONTENT and PATCH_DIFF; these must be supplied to finalize data-flow and control-flow criteria.
- Semantic equivalence of alternative guards requires project/domain knowledge; the checker may under- or over-report without concrete predicates from the patch.