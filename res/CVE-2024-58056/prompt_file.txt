1. CVE Identifier
CVE-2024-58056

2. Vulnerability Type
Incorrect resource lifetime management / invalid release (ida_free called for an ID that was never allocated)

3. Root Cause Summary
The rproc_alloc() error path calls put_device(), which triggers rproc_type_release(). Pre-patch, rproc->index was zero-initialized (kzalloc) and ida_alloc() was performed later in rproc_alloc(). rproc_type_release() unconditionally freed the index when rproc->index >= 0, resulting in ida_free() being called for an ID that was never allocated. This ordering bug caused a WARN splat (“ida_free called for id=0 which is not allocated”) and can panic systems configured with panic_on_warn.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
remoteproc core (drivers/remoteproc/remoteproc_core.c)

2) Pre-Patch Flaw:
- In rproc_alloc(), the unique device index (rproc->index via ida_alloc(&rproc_dev_index)) was assigned only after several allocations (name, firmware, ops). If any of those failed, the function jumped to put_device and released the device.
- In rproc_type_release(), the code freed the ID when “if (rproc->index >= 0) ida_free(&rproc_dev_index, rproc->index);”. Because rproc->index was zero-initialized, this condition was true even when ida_alloc had not been called.

3) Trigger Condition:
Any error before the original ida_alloc call in rproc_alloc(), e.g.:
- kstrdup_const(name) fails (name allocation).
- rproc_alloc_firmware() fails (firmware name allocation).
- rproc_alloc_ops() fails (ops allocation).
These paths jump to put_device, invoking rproc_type_release with rproc->index still at 0.

4) Impact Mechanism:
- rproc_type_release calls ida_free on a non-allocated index, triggering WARN in lib/idr (“ida_free called for id=0 which is not allocated”).
- On systems with panic_on_warn or strict CI/testing environments, this can cause a kernel panic or abort, leading to denial of service; otherwise it degrades reliability and logs a warning.

5. Patch Analysis
1) Fix Approach:
Reorder initialization to allocate the unique device index early in rproc_alloc(), before any operation that can fail and trigger put_device(). This ensures rproc->index reflects a valid allocated ID before release paths run.

2) Key Code Changes:
- Inserted early allocation:
  - rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);
  - if (rproc->index < 0) { dev_err(...); goto put_device; }
  Added immediately after device init/idr_init in rproc_alloc().
- Removed the later, redundant ida_alloc block that previously occurred after name and ops allocation.
- No changes to rproc_type_release; its “if (rproc->index >= 0) ida_free(...)” now only executes for an actually allocated index due to the earlier assignment.

3) Locking/Concurrency Impact:
No locking or concurrency changes; fix is strictly an ordering change. It removes the race-like window where release could execute with an uninitialized (zero) index by ensuring the index is allocated before any potential error-triggered release.

6. Broader Kernel Security Implications
- Invalid resource release paths that rely on sentinel values must ensure fields are initialized to clearly invalid states (e.g., -1) or be assigned before any failure paths; otherwise WARNs can escalate to panics (DoS) under certain configs.
- The change improves robustness of remoteproc device lifecycle management and reduces the chance of kernel WARN/panic due to misuse of IDA/IDR APIs.
- Similar patterns elsewhere should audit release conditions that check numeric fields against >= 0 when those fields may be zero-initialized before successful allocation.