1. CVE Identifier
CVE-2024-58056

2. Vulnerability Type
Improper resource cleanup due to incorrect initialization/order (invalid ida_free on unallocated ID)

3. Root Cause Summary
rproc_alloc() could error out before assigning a valid IDA index to rproc->index, yet the release path rproc_type_release() unconditionally freed the ID when (rproc->index >= 0). Because rproc objects are zero-initialized, rproc->index was 0 (not -1) before ida_alloc(), so the release path treated it as allocated and called ida_free() on an ID that was never allocated. The bug stems from incorrect ordering and reliance on a sentinel without ensuring rproc->index is set before any path that can trigger put_device() and the release callback.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- drivers/remoteproc (remoteproc core)

2) Pre-Patch Flaw:
- In rproc_alloc(), ida_alloc(&rproc_dev_index, GFP_KERNEL) was performed too late (after name allocation and ops setup), leaving a window where errors could trigger put_device(&rproc->dev) before rproc->index was assigned.
- rproc_type_release() used the condition (rproc->index >= 0) to decide to call ida_free(), but rproc->index was implicitly 0 (zeroed struct) even when no ID was allocated, causing ida_free to be invoked with an unallocated ID.

3) Trigger Condition:
- Any error in rproc_alloc() occurring before the original ida_alloc() call (e.g., kstrdup_const(name) failure or rproc_alloc_ops() failure) that leads to the put_device: error path and executes rproc_type_release().

4) Impact Mechanism:
- rproc_type_release() calls ida_free() with id=0 that was never allocated, producing a kernel WARN splat: “ida_free called for id=0 which is not allocated.” This indicates improper cleanup and can disrupt probe/teardown flows.

5. Patch Analysis
1) Fix Approach:
- Reorder operations in rproc_alloc() to allocate the ID earlier so rproc->index is valid before any subsequent operation that might fail and trigger device release.

2) Key Code Changes:
- Inserted early allocation:
  - rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);
  - Error path “goto put_device” if allocation fails.
- Removed the later (original) ida_alloc block performed after name and ops setup.
- File: drivers/remoteproc/remoteproc_core.c, function: rproc_alloc(), moved ida_alloc to immediately after idr_init(&rproc->notifyids).

3) Locking/Concurrency Impact:
- No locking primitives were added or changed.
- The change is purely in call ordering; it ensures IDA state is consistent with release behavior without modifying concurrency semantics.

6. Broader Kernel Security Implications
- While the immediate symptom is a WARN from ida_free on an unallocated ID, such cleanup mismatches can cause noisy logs and fragility in device probe/teardown paths in remoteproc.
- Ensuring indices are allocated before potential failure paths reduces the risk of allocator-state inconsistencies and unintended side effects during error handling.