1. CVE Identifier
CVE-2024-58056

2. Vulnerability Type
Improper resource deallocation due to cleanup/initialization ordering bug (invalid ida_free on unallocated ID)

3. Root Cause Summary
In rproc_alloc(), error handling invokes put_device(&rproc->dev), which triggers rproc_type_release(). Before the patch, ida_alloc() was called late in rproc_alloc(), so early failures left rproc->index at its zero-initialized value from kzalloc. rproc_type_release() checks (rproc->index >= 0) and calls ida_free() based on that, incorrectly freeing ID 0 that was never allocated. This stems from relying on a default-initialized field to indicate allocation success, combined with an initialization/cleanup order that allowed the release path to run before ida_alloc() set a valid index or a negative sentinel.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Remoteproc core (drivers/remoteproc/remoteproc_core.c), device allocation and release paths.

2) Pre-Patch Flaw:
- rproc_alloc() performed several allocations (name, firmware, ops) before calling ida_alloc() to obtain rproc->index.
- On any earlier failure, put_device() invoked rproc_type_release(), which used rproc->index >= 0 to decide to ida_free(), while rproc->index was still zero from kzalloc.

3) Trigger Condition:
Any error occurring in rproc_alloc() before ida_alloc() (e.g., kstrdup_const(name) failure, rproc_alloc_firmware() failure, or rproc_alloc_ops() failure) causing the function to goto put_device and run the release path with rproc->index still at 0.

4) Impact Mechanism:
- rproc_type_release() calls ida_free() with id=0 that was never allocated, hitting the WARN in ida_free (“ida_free called for id=0 which is not allocated”) and potentially perturbing ID management or device cleanup consistency.
- Results in warning splat and could degrade system reliability if WARNs are treated as fatal or indicate broader cleanup inconsistencies.

5. Patch Analysis
1) Fix Approach:
Reorder initialization to perform ida_alloc() immediately after device setup (before any operation that can fail and lead to put_device()), ensuring rproc->index is properly set to a valid ID (>=0) on success or a negative error code on failure. This makes the release path’s (rproc->index >= 0) check correct.

2) Key Code Changes:
- Moved “/* Assign a unique device index and name */ rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);” from after rproc_alloc_ops() to right after idr_init(&rproc->notifyids).
- Added failure handling after early ida_alloc() with dev_err() and goto put_device.
- Removed the later ida_alloc() block to avoid delayed initialization.
Relevant hunk:
+ /* Assign a unique device index and name */
+ rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);
+ if (rproc->index < 0) {
+     dev_err(dev, "ida_alloc failed: %d\n", rproc->index);
+     goto put_device;
+ }
… and deletion of the same block later in the function.

3) Locking/Concurrency Impact:
No new locks or concurrency changes; the fix is purely an ordering correction. IDA’s internal locking remains unchanged. The earlier assignment ensures correct state for the release path without altering synchronization.

6. Broader Kernel Security Implications
Initialization/cleanup ordering must guarantee that release paths only act on resources that were actually acquired. Using zero-initialized fields as allocation status is unsafe; either allocate earliest, use negative sentinel values, or track allocation with explicit flags. Similar patterns elsewhere can cause invalid frees, WARNs, or subtle resource accounting inconsistencies, which can escalate into stability or security issues if cleanup corrupts shared allocators or indices.