1. Plan Summary
Detect unsafe, unconditional get_net() invocations on network namespaces in asynchronous paths (e.g., timer/workqueue) where teardown can race, and where a conditional maybe_get_net() and early abort are required to prevent refcount misuse and potential use-after-free.

2. Detection Steps
1) Step 1: Objective — enumerate candidate ref acquisitions; Signals — locate call sites invoking get_net(arg) where arg is a pointer expression denoting a network namespace object (e.g., a field named “net” within networking-related structs); FP mitigation — exclude sites already guarded by an immediately surrounding conditional that uses maybe_get_net on the same arg.
2) Step 2: Objective — identify risky execution contexts; Signals — determine if the enclosing function (or its transitive callees) is reachable from timer/workqueue/deferred-execution callbacks (e.g., registered timer callbacks) using call graph reachability; FP mitigation — require an explicit registration edge (function pointer assigned as a timer/work callback) or a short bounded chain from such callbacks to reduce spurious reachability.
3) Step 3: Objective — confirm absence of safe conditional reference acquisition; Signals — check that no dominating control-flow check uses maybe_get_net on the same net pointer prior to the get_net call; FP mitigation — allow recognition of equivalent patterns where maybe_get_net result controls an early return/goto on failure (as in the [PATCH_DIFF]).
4) Step 4: Objective — ensure the get_net is intended to pin for subsequent use (and thus dangerous if the refcount is 0); Signals — from the get_net program point, detect subsequent operations in the same function that rely on objects tied to the namespace (e.g., crypto or protocol operations following the ref acquisition, as in crypto_aead_encrypt after get_net in [PATCH_DIFF]); FP mitigation — require that at least one non-trivial operation follows the get_net (not immediately put_net or return).
5) Step 5: Objective — detect lack of an early-abort path when the namespace cannot be safely referenced; Signals — absence of a failure branch local to the call site that returns/aborts before proceeding when the ref cannot be acquired (i.e., no “if (!maybe_get_net(...)) { cleanup; return err; }” pattern); FP mitigation — if a surrounding higher-level guard already guarantees netns liveness (via maybe_get_net or equivalent inc-not-zero pattern), do not flag.
6) Step 6: Objective — reduce false positives from known-safe namespaces; Signals — check whether the net pointer argument is a known global/permanent namespace (e.g., patterns like a well-known singleton) or already holds a strong reference on entry; FP mitigation — if a dominating earlier get_net/maybe_get_net on the same variable exists on all paths to the use, suppress.
7) Step 7: Step Objective — rank/suppress low-risk sites; Signals — prioritize/report only sites both reachable from asynchronous teardown-prone paths (Step 2) and lacking conditional acquisition (Steps 3 and 5); FP mitigation — optionally annotate/report other get_net sites with low severity for manual review rather than flagging as defects.

3. Target Elements
- Function call sites to get_net and maybe_get_net.
- Functions registered as timer/workqueue/deferred-execution callbacks and their transitive callees.
- Control-flow dominance/guards around ref acquisition.
- Return/abort paths following conditional acquisition (early exits, gotos).
- Subsequent operations after ref acquisition indicating continued use of net-tied resources (e.g., crypto operations as in [PATCH_DIFF]).
- Resource cleanup calls near early abort (e.g., releasing related refs like tipc_bearer_put per [PATCH_DIFF], treated generically as cleanup).

4. Dataflow / Taint Considerations
- Track the net pointer argument into get_net/maybe_get_net back to its definition to determine identity equivalence between guarded and unguarded uses.
- Track call graph reachability from timer/work/deferred callbacks to the get_net site.
- Forward slice from get_net to detect subsequent meaningful operations on objects associated (syntactically) with the same namespace context.
- Control-flow analysis to determine dominance of maybe_get_net checks and presence of early-abort paths that prevent execution past the guard.

5. Validation & Test Cases
- Positive: A function reachable from a timer callback calls get_net(obj->net) and then performs protocol/crypto work; there is no preceding maybe_get_net guard or early abort on failure — expect a report (mirrors pre-patch tipc_aead_encrypt per [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]).
- Negative: The same function uses if (!maybe_get_net(obj->net)) { cleanup; return -ENODEV; } before proceeding to operations — expect no report (matches the fix in [PATCH_DIFF]).
- Test harness notes: Build small kernel-like stubs with timer callback registration leading to a function that either uses get_net unconditionally (should trigger) or maybe_get_net with early return and cleanup (should not trigger).

6. Estimated Effort & Priority
Medium — requires call graph reachability, basic dataflow, and control dominance analysis; high priority for kernel/network code due to UAF risk from teardown races (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- get_net used where the namespace is known immortal or already pinned on all paths: mitigate by checking for dominating prior pin or known singleton patterns.
- Over-approximate reachability from asynchronous contexts causing spurious flags: mitigate by requiring explicit callback registration edges or a small bounded call depth.
- Sites with external synchronization/lifetime guarantees not visible to static analysis: mitigate by allowing suppressions and by prioritizing only asynchronous-context-reachable cases.

8. Limitations & Assumptions
- The plan assumes maybe_get_net is the canonical safe API for conditional ref acquisition (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]); equivalent custom inc-not-zero patterns may be missed.
- Determining “known immortal” namespaces or external lifetime guarantees may be infeasible from static analysis alone; some safe uses of get_net may be flagged.
- Precise identification of timer/workqueue reachability depends on recognizing kernel registration patterns not shown in the provided snippets; detection may under/over-approximate such paths.