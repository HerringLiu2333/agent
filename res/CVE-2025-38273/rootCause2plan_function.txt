1. Plan Summary
Detect kernel functions that start asynchronous AEAD encryption and unconditionally call get_net on a struct net pointer without a prior maybe_get_net-style guard, risking refcount increments from zero during namespace teardown.

2. Detection Steps
1) Step 1: Identify functions that set up an AEAD request callback and launch encryption (look for calls to aead_request_set_callback followed by crypto_aead_encrypt). This matches the asynchronous crypto workflow implicated in the root cause (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: require presence of both the callback setup and a subsequent crypto_aead_encrypt call.

2) Step 2: Within these functions, locate calls to get_net(netptr) where netptr is a struct net pointer derived from another objectâ€™s field (e.g., aead->crypto->net). This reflects the unconditional ref acquisition criticized in ROOTCAUSE_ANALYSIS and shown in FUNCTION_CONTENT. FP mitigation: constrain netptr to flows originating from parameter/field dereferences rather than well-known globals.

3) Step 3: Check that the same function does not guard the get_net with a prior maybe_get_net(netptr) on the same netptr. This directly captures the missing validation fixed in PATCH_DIFF. FP mitigation: treat any maybe_get_net on the same variable/path within dominance of get_net as a guard and do not flag.

4) Step 4: Confirm the function treats -EINPROGRESS/-EBUSY specially after crypto_aead_encrypt (e.g., branching/return on those values). This further corroborates asynchronous execution where teardown races are relevant (FUNCTION_CONTENT). FP mitigation: only flag when such asynchronous return handling is present.

5) Step 5: Track that put_net is later invoked on the same netptr (either in the function or on success paths) to establish a refcounting pair. This indicates intentional lifecycle management around the netns and strengthens the case that a try-get is needed (FUNCTION_CONTENT). FP mitigation: require a matching put_net on the same netptr to reduce noise from incidental get_net uses.

6) Step 6: Check if the function also acquires another resource before get_net (e.g., tipc_bearer_hold(b)) and may need to release it if net acquisition fails. This mirrors the multi-resource lifetime pattern in FUNCTION_CONTENT and highlights the need for early rollback on failed net acquisition as per PATCH_DIFF. FP mitigation: prefer flagging when such pre-acquired resources exist, since early-exit cleanup is expected if maybe_get_net fails.

7) Step 7: Look for absence of an early-exit path tied to net acquisition failure (i.e., no branch that releases prior holds and returns when net acquisition would fail). This maps to the root cause where get_net cannot fail and thus offers no safe bail-out (ROOTCAUSE_ANALYSIS), whereas the patch introduces -ENODEV early return (PATCH_DIFF). FP mitigation: ensure the only net acquisition observed is get_net (void-return) and not a conditional acquisition with error handling.

8) Step 8: Exclude cases where the net pointer originates from objects with explicit lifetime guarantees in the same function (e.g., freshly allocated net or clearly checked against teardown state). This reduces false alarms where a teardown race cannot occur. FP mitigation: check for immediate construction/ownership transfer patterns of netptr within the function and do not flag those.

9) Step 9: Optionally prioritize matches within net/tipc or functions using tipc_* symbols to reflect the evidenced subsystem (FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS). This tightens the search to the demonstrated domain. FP mitigation: use subsystem scoping as a severity boost rather than a hard filter.

3. Target Elements
- Function bodies that call: aead_request_set_callback, crypto_aead_encrypt, get_net, put_net.
- Variables representing struct net pointers flowing from object fields (e.g., aead->crypto->net).
- Control-flow branches handling -EINPROGRESS/-EBUSY returns.
- Resource-hold patterns (e.g., tipc_bearer_hold and tipc_bearer_put).
- Early-exit/error paths around resource acquisition.

4. Dataflow / Taint Considerations
- Track dataflow from a field dereference to a struct net pointer used in get_net and later in put_net to ensure it is the same object.
- Establish control dominance: ensure aead_request_set_callback and crypto_aead_encrypt occur in the same function and that get_net is executed before starting encryption.
- Track absence/presence of maybe_get_net on the same netptr before get_net.

5. Validation & Test Cases
- Positive: Pre-patch tipc_aead_encrypt where get_net(aead->crypto->net) is unconditionally called before crypto_aead_encrypt with a callback and -EINPROGRESS/-EBUSY handling; expect a finding.
- Negative: Post-patch tipc_aead_encrypt where maybe_get_net is used with early -ENODEV return and bearer release; expect no finding.
- Negative: A function that calls get_net on a netptr but performs only synchronous work (no aead_request_set_callback, no -EINPROGRESS/-EBUSY handling); expect no finding.
- Test harness notes: Validate dataflow equivalence of netptr across get_net and put_net; verify control ordering of callback setup -> get_net -> crypto_aead_encrypt.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Safe contexts where get_net cannot encounter a zero refcount due to external lifetime guarantees; mitigate by requiring asynchronous crypto workflow signals.
- Functions using get_net on well-known global net namespaces; mitigate by requiring netptr to flow from object field dereferences.
- Cases with alternative teardown guards not captured (e.g., locks or state checks); mitigate by documenting limitations and prioritizing subsystem-specific matches.

8. Limitations & Assumptions
- Cannot statically determine if a network namespace is in teardown or its refcount is zero; we infer risk from missing maybe_get_net and async workflow (ROOTCAUSE_ANALYSIS).
- Completion-path details are not provided, so we assume put_net pairing in the caller suffices for lifecycle intent (FUNCTION_CONTENT).
- The plan focuses on AEAD encryption paths; similar patterns in other async subsystems may exist but are out of scope given the provided evidence (PATCH_DIFF, ROOTCAUSE_ANALYSIS).