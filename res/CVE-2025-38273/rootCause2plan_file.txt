1. Plan Summary
Detect unsafe lifetime pinning of struct net across asynchronous operations: flag call paths that unconditionally use get_net() before scheduling async work whose completion dereferences and put_net()s the same net, instead of using maybe_get_net() with early failure handling.

2. Detection Steps
1) Step 1: Locate async completion patterns — find functions that set a crypto callback (e.g., calls to an API like aead_request_set_callback) and subsequently start an operation that may complete asynchronously (e.g., calls that can return -EINPROGRESS/-EBUSY as in crypto_aead_encrypt per [FILE_CONTENT]). FP mitigation: restrict to call sites where CRYPTO_TFM_REQ_MAY_BACKLOG or equivalent async flags are provided in the callback registration.

2) Step 2: In those functions, identify net namespace pinning — find calls to get_net(arg) on a struct net* prior to starting the async operation (as seen pre-patch in tipc_aead_encrypt in [FILE_CONTENT] and corrected in [PATCH_DIFF]). FP mitigation: require that the get_net call is in the same function that sets the callback and precedes the async call.

3) Step 3: Identify the corresponding completion callback — resolve the function pointer passed to the callback registration and analyze its body (e.g., tipc_aead_encrypt_done in [FILE_CONTENT]). FP mitigation: only proceed if the callback dereferences or otherwise uses a struct net associated with the async operation.

4) Step 4: Confirm put_net in the callback — check that the callback calls put_net(netVar) before returning on non-inprogress paths (as observed in tipc_aead_encrypt_done in [FILE_CONTENT]). FP mitigation: ensure put_net is reachable along at least one success/failure path (excluding explicit -EINPROGRESS early return).

5) Step 5: Establish dataflow correspondence — verify that the struct net* used in put_net in the callback flows from the same object/field path as the one passed to get_net in the producer (e.g., aead->crypto->net used in both places per [FILE_CONTENT]). FP mitigation: require a consistent field-path match (same base type and member chain), or a value carried via the operation context (e.g., stored in tx_ctx and retrieved in the callback).

6) Step 6: Detect unsafe acquisition — if Steps 2–5 hold and the acquisition uses get_net (void, unconditional) instead of maybe_get_net (boolean check), flag it as a potential teardown-race/UAF risk (per root cause in [ROOTCAUSE_ANALYSIS] and fix in [PATCH_DESCRIPTION]/[PATCH_DIFF]). FP mitigation: exclude cases where the same function immediately calls and balances put_net synchronously without scheduling async work.

7) Step 7: Prefer safe pattern — recognize and suppress findings where maybe_get_net is used with a conditional guard that prevents starting the async operation on failure and performs necessary cleanup (e.g., releases previously acquired resources and returns -ENODEV early, as in [PATCH_DIFF]). FP mitigation: require a control-flow branch on maybe_get_net’s false result that avoids the async call site.

8) Step 8: Check cleanup symmetry on failure (optional robustness) — when maybe_get_net is used, verify that the failure branch releases earlier holds (e.g., tipc_bearer_put) and returns an error before reaching the async call (per [PATCH_DIFF]). FP mitigation: only warn if failure branch falls through to the async call or omits cleanup.

9) Step 9: Cross-check for implicit net usage in callback — if the callback obtains net via an intermediate object (e.g., aead->crypto->net loaded from skb context as in [FILE_CONTENT]), treat it as equivalent to the get_net target if the base object used in both contexts is the same instance passed through the operation’s context. FP mitigation: require that the producer stored a pointer to that base object in the context passed to the callback.

10) Step 10: Prioritize risky contexts — raise severity if the producer function can be invoked from timers/workqueues or during teardown-sensitive paths (as noted in [ROOTCAUSE_ANALYSIS] about discovery timer firing); heuristically identify timer/workqueue handlers or functions transitively called from them. FP mitigation: if no async or teardown-prone context indicators are present, lower severity rather than suppress.

3. Target Elements
- Function bodies that:
  - Register async crypto callbacks (e.g., aead_request_set_callback).
  - Start async operations (e.g., crypto_aead_encrypt).
  - Pin/unpin net namespaces (get_net, maybe_get_net, put_net).
- Callback function bodies that:
  - Use or dereference a struct net obtained from the producer context.
  - Call put_net on that net.
- Expressions and field paths referencing struct net (e.g., aead->crypto->net).
- Control-flow around acquisition (conditional checks on maybe_get_net) and early exits.
- Resource management around failure branches (e.g., tipc_bearer_put as in [PATCH_DIFF]).

4. Dataflow / Taint Considerations
- Track dataflow from the net pointer passed to get_net/maybe_get_net to the net pointer passed to put_net in the callback via:
  - Context structs stored in the request or skb control block (e.g., tx_ctx in [FILE_CONTENT]).
  - Field-path equivalence (e.g., aead->crypto->net used both before and in the callback).
- Track whether the async operation is started only if the net reference was successfully obtained (i.e., control-flow dependence on maybe_get_net result).
- Track that the same request/sk_buff is used to bind producer context to callback via the callback’s “data” argument (as in tipc_aead_encrypt_done using skb->cb).

5. Validation & Test Cases
- Positive: A function calls aead_request_set_callback, calls get_net(obj->net), then calls crypto_aead_encrypt; the callback retrieves net from obj->net or the context and calls put_net(net) (mirrors pre-patch tipc_aead_encrypt/tipc_aead_encrypt_done in [FILE_CONTENT]). Expected: flagged.
- Negative: Same as above but uses maybe_get_net(obj->net) with a guarded early return that releases other resources and never reaches crypto_aead_encrypt on failure (as in [PATCH_DIFF]). Expected: no finding.
- Negative: Synchronous use where get_net is followed by immediate work and balanced put_net in the same function without async callback. Expected: no finding.
- Negative: maybe_get_net used, but callback does not put_net (no cross-boundary lifetime use). Expected: no finding.
- Test harness notes: Include interprocedural flow from producer to callback via context pointer; simulate both success and failure branches to ensure control-flow analysis distinguishes guarded paths.

6. Estimated Effort & Priority
Medium: Requires interprocedural dataflow between producer and callback and recognition of async crypto patterns, but the API and patterns are well-scoped per [FILE_CONTENT].

7. Likely False-Positive Sources & Mitigations
- Cases where get_net is safe due to external lifetime guarantees not visible to static analysis; mitigate by requiring presence of async scheduling and callback put_net on the same net.
- Callbacks that use a different net than the one pinned; mitigate by enforcing field-path or context equivalence checks.
- Frameworks that wrap crypto callbacks or net refs in macros; mitigate with API-name pattern lists derived from [FILE_CONTENT] and conservative matching.

8. Limitations & Assumptions
- We assume that aead_request_set_callback and crypto_aead_encrypt are representative of async operations; other async APIs may need to be enumerated separately (not provided).
- We cannot statically determine real teardown timing; we approximate risk by the presence of async completion and cross-boundary net usage as per [ROOTCAUSE_ANALYSIS].
- We assume put_net in the callback corresponds to the prior get_net/maybe_get_net in the producer when dataflow/field-paths match; complex aliasing beyond this may evade the checker.