1. Plan Summary
Detect array/table indexing where an index variable can equal a sentinel/upper-bound constant (e.g., NPHY_IQCAL_NUMGAINS) and is used without a preceding bounds check, leading to potential out-of-bounds reads as in wlc_phy_iqcal_gainparams_nphy().

2. Detection Steps
1) Step 1: Identify candidate array accesses — find array or table subscripting expressions (including multi-dimensional) where at least one index is a variable, not a compile-time constant — this narrows analysis to dynamic indexing sites where OOB can arise per the pre-patch flaw in [ROOTCAUSE_ANALYSIS].
2) Step 2: Infer likely bound constants — locate named integer constants/macros in scope whose names or usage suggest “count/size/num” semantics and are used in comparisons or loops with the same index variable (e.g., NPHY_IQCAL_NUMGAINS seen in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]) — reduce FPs by prioritizing constants also used as loop bounds like “for (i < CONST)”.
3) Step 3: Track index value to sentinel — perform path-sensitive value reasoning to see if the index variable may equal the identified bound constant on any path, e.g., initialized to the constant or left unchanged through a switch/break selection as described in [ROOTCAUSE_ANALYSIS] — mitigate FPs by requiring a feasible path from function entry to the array access with no dominating assignment that constrains the index to be < bound.
4) Step 4: Check for guarding conditions — before the array access, search dominating conditionals that ensure index < bound or index != bound (e.g., “if (idx < NUM)” or early return on “idx == NUM” as added in [PATCH_DIFF]) — suppress findings when such a guard dominates the use.
5) Step 5: Confirm bound-targeted dimension — when arrays are multi-dimensional, associate the bound constant with the specific dimension being indexed by the variable (e.g., k is the middle dimension in tbl_iqcal_gainparams_nphy[band_idx][k][…] per [PATCH_DIFF]) — avoid FPs by not applying a bound intended for a different dimension.
6) Step 6: Strengthen sentinel semantics — increase confidence when the same index variable is compared for equality to the bound constant anywhere in the function (e.g., “idx == NUM” as in the fix), indicating the constant is a sentinel upper bound per [ROOTCAUSE_ANALYSIS] — deprioritize reports lacking any such equality comparisons.
7) Step 7: Aggregate repeated risky uses — boost severity if multiple consecutive dereferences use the same unguarded index into the same table (as three field assignments in [PATCH_DIFF]) — this aligns with the impact mechanism in [ROOTCAUSE_ANALYSIS] and reduces one-off incidental FPs.
8) Step 8: Report only when no safe recovery — if the analysis finds that on some path the index equals the bound constant and reaches the array access without a dominating guard or corrective reassignment, flag as potential OOB read — avoid reporting when later code conditionally returns or otherwise prevents the access on the problematic path.

3. Target Elements
- Array and multi-dimensional array subscripting expressions.
- Integer constants/macros used as counts/sizes (e.g., NPHY_IQCAL_NUMGAINS).
- Assignments and initializations of index variables.
- Control-flow constructs computing indices (switch/case as noted in [ROOTCAUSE_ANALYSIS]).
- Conditional checks involving the index and the bound (e.g., <, <=, ==).
- Early returns or WARN/WARN_ON-like calls that gate access (per [PATCH_DIFF]).

4. Dataflow / Taint Considerations
- Track constant propagation of sentinel/upper-bound values into index variables.
- Path-sensitive control-flow to determine whether assignments guarantee index < bound along all paths dominating the access.
- Dominance analysis to ensure guards (idx < bound or idx == bound with early return) precede and protect the access.
- Dimension association between index variables and specific array dimensions to match the correct bound.

5. Validation & Test Cases
- Positive: A function computes k via switch, may leave k == NUM_GAINS, then immediately uses table[band][k][1..3] with no prior check; expect a report (mirrors [ROOTCAUSE_ANALYSIS]/[PATCH_DIFF] pre-fix).
- Negative: Same function with “if (k == NUM_GAINS) return;” or “if (k < NUM_GAINS) { use table[band][k][…]; }” immediately guarding the access; expect no report (mirrors [PATCH_DIFF]).
- Test harness notes: Include multi-dimensional arrays and ensure at least one case where the bound constant is associated with a different dimension to verify dimension mapping and FP suppression.

6. Estimated Effort & Priority
Medium: Requires constant/value range reasoning and simple path dominance checks; high priority due to kernel OOB read risk highlighted in [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Constants not truly representing bounds (mitigate by requiring usage as loop bounds or equality checks).
- Arrays with custom bounds differing from the identified constant (mitigate via dimension association and declaration-size heuristics where available).
- Incomplete path reasoning leading to infeasible paths (mitigate with dominance and must-assign analysis before use).
- Defensive “idx == bound” checks placed after, not before, the access (treat as unguarded and report).

8. Limitations & Assumptions
- Exact initialization/control-flow conditions producing the sentinel value are not provided ([ROOTCAUSE_ANALYSIS] states unknown), so the checker assumes path-feasible equality to the bound is indicative of risk.
- The checker infers which constant is the correct bound from naming/usage; no explicit type-level size metadata is guaranteed.
- It assumes early-return or a dominating conditional is the primary protection strategy, as per the fix in [PATCH_DIFF].