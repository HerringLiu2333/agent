1. Plan Summary
Detect loops that search a fixed-size table for a key and then use the loop index to access the table without validating that a match was found (risking out-of-bounds access when the index equals the iteration bound), as exemplified in wlc_phy_iqcal_gainparams_nphy().

2. Detection Steps
1) Step 1: Identify candidate search loops — find for-loops that initialize an index (e.g., k) to a lower bound (often 0), iterate with a strict upper bound comparison (var < UPPER), and increment by 1 — this matches the pattern “for (k = 0; k < NPHY_IQCAL_NUMGAINS; k++)” in [FUNCTION_CONTENT]. Reduce FPs by focusing on loops where the loop variable is used to subscript an array within the loop body.

2) Step 2: Confirm “search-and-break” semantics — within such loops, look for a conditional comparing an array element at the current index to a key (equality/inequality) followed by a break (e.g., arr[…][k][0] == key then break) as shown in [FUNCTION_CONTENT]. This maps to the root cause in [ROOTCAUSE_ANALYSIS] where the presence of a conditional break implies a possible “no match” path; reduce FPs by requiring that the compared array is a consistent base array reference (same symbol) across loop and post-loop uses.

3) Step 3: Locate post-loop array uses with the loop index — after the loop, find reads from or writes to the same table using the loop variable as an array subscript (any dimension position), e.g., tbl_iqcal_gainparams_nphy[band_idx][k][…] as in [FUNCTION_CONTENT]. This maps to the OOB read in [ROOTCAUSE_ANALYSIS]; reduce FPs by requiring at least one such use dominates subsequent control flow (i.e., is reachable immediately after the loop without intervening reassignments of the index).

4) Step 4: Check for absence of a bounds guard — verify that, along paths from the loop exit to each post-loop array use, there is no guard ensuring the index is within [0, UPPER-1], specifically a check against the sentinel k == UPPER (e.g., if (k == NPHY_IQCAL_NUMGAINS) return;) as added in [PATCH_DIFF]. This directly targets the fix described in [PATCH_DESCRIPTION] and [PATCH_DIFF]; reduce FPs by accepting any dominating guard that ensures k < UPPER or otherwise prevents the array access on the k == UPPER path (e.g., early return/goto).

5) Step 5: Ensure a feasible “no match” path exists — confirm that the loop body does not contain an unconditional break/return that would make the “no break” termination impossible and that the loop upper bound is a constant or macro (e.g., NPHY_IQCAL_NUMGAINS) used as the array’s index range as in [FUNCTION_CONTENT]. This ties to [ROOTCAUSE_ANALYSIS] item 3; reduce FPs by requiring that the only way to exit early from the loop is the conditional break, making k == UPPER a viable outcome.

6) Step 6: Track reassignment of the loop index — if the loop index is reassigned between loop exit and the array access to a value provably in-range, suppress the finding. This avoids flagging cases where developers clamp or reset the index before use, which would not match the root cause.

7) Step 7: Correlate the searched array and the used array — prefer cases where the same base array object (e.g., tbl_iqcal_gainparams_nphy) is used inside the loop for matching and after the loop for dereferencing, as in [FUNCTION_CONTENT]. This tightens the signal to true table lookup patterns and reduces false matches on different arrays.

8) Step 8: Consider multi-dimensional indexing — treat uses where the loop index appears in any subscript dimension (e.g., [band_idx][k][…]) as risky, reflecting the 3D table in [FUNCTION_CONTENT]. Reduce FPs by requiring that the index dimension is consistently the same within the loop and post-loop uses.

9) Step 9: Check for alternative guards — accept equivalent guards such as assertions, WARN/BUG macros, or error handling that precludes execution of the post-loop access when k == UPPER (e.g., WARN_ON plus return as in [PATCH_DIFF]). This maps to the patch approach in [PATCH_DESCRIPTION]; reduce FPs by recognizing common kernel guard idioms that dominate the dereference.

10) Step 10: Aggregate multiple accesses — if multiple post-loop accesses exist (e.g., multiple fields read from tbl_iqcal_gainparams_nphy with [k] as in [FUNCTION_CONTENT]), report once per loop region to avoid duplicate warnings. This maintains signal clarity while emphasizing the core issue.

3. Target Elements
- For-loops with index variables and explicit upper bounds.
- Array subscripts (including multi-dimensional) that use the loop index.
- Conditional statements with equality checks against array elements and break statements.
- Post-loop control-flow regions containing array accesses.
- Guards/assertions/macros (e.g., WARN_ON) and early exits (return/goto) dominating array uses.
- Assignments to the loop index after the loop.

4. Dataflow / Taint Considerations
- Track the loop index variable’s value range from loop init through loop exit to post-loop uses (range can be either found index < UPPER or UPPER on no-match).
- Track dataflow of the base array symbol used in the loop comparison and post-loop dereference to ensure they refer to the same table.
- Model control-flow dominance to ensure that guards (k < UPPER or k != UPPER) dominate the array dereference; if not, the path is potentially vulnerable.

5. Validation & Test Cases
- Positive: Pre-patch pattern from [FUNCTION_CONTENT] else-branch where k scans 0..NPHY_IQCAL_NUMGAINS-1, may remain equal to NPHY_IQCAL_NUMGAINS, and is used to index tbl_iqcal_gainparams_nphy without guard.
- Negative: Patched pattern from [PATCH_DIFF] where a dominating if (WARN_ON(k == NPHY_IQCAL_NUMGAINS)) return; exists before any tbl_iqcal_gainparams_nphy[...][k][...] access.
- Negative: Variant where after the loop, code clamps k (e.g., if (k == UPPER) k = UPPER-1;) before dereferencing, or where the loop returns on no-match.
- Test harness notes: Ensure tests include multi-dimensional arrays, matching inside the loop with break, and multiple post-loop dereferences; include control-flow variations (if/else branches) to verify dominance analysis.

6. Estimated Effort & Priority
Medium: requires control-flow dominance, range reasoning for loop indices, and correlation of loop-bound constants with array indices.

7. Likely False-Positive Sources & Mitigations
- Domain invariants guaranteeing a match (not statically provable): mitigate by requiring absence of any explicit guard and strong search-and-break pattern correlation on the same array.
- Complex control flow where guards are indirect: mitigate with dominance checks and path-feasibility heuristics.
- Different arrays used in loop vs. post-loop: mitigate by requiring the same base array symbol across both.

8. Limitations & Assumptions
- Assumes the loop upper bound corresponds to the valid index range of the table; actual array sizes are not always derivable from macros or declarations.
- Cannot prove semantic invariants that a match must exist; the checker flags potential issues in the absence of explicit guards, as per [ROOTCAUSE_ANALYSIS].
- Recognition of guards relies on common kernel idioms (e.g., WARN_ON, return); unconventional guarding patterns may be missed.