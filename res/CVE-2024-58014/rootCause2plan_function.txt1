1. Plan Summary
Detect loops that search a table for a match up to a fixed bound and then use the loop index to read from the same table without validating that a match was found, which can lead to out-of-bounds reads.

2. Detection Steps
1) Step 1: Identify a for-loop that initializes an index variable (e.g., k) and has a loop condition of the form “k < LIMIT” where LIMIT is a constant or macro (e.g., NPHY_IQCAL_NUMGAINS). Signals: loop variable starts at zero and is incremented; the upper bound is a fixed expression used directly in the loop condition.

2) Step 2: Within that loop, find a conditional that compares an element of a table indexed by the loop variable to a computed key, and breaks on match. Signals: an array access like tbl[...][k][...] compared for equality to a value (e.g., gain_index), followed by a break statement.

3) Step 3: Record the table symbol used in the search (e.g., tbl_iqcal_gainparams_nphy) and the exact dimension indexed by the loop variable. Signals: the loop variable k appears as one of the array indices inside the loop (e.g., second dimension in tbl[band_idx][k][0]).

4) Step 4: After the loop, locate subsequent reads from the same table using the same index variable in the same dimension. Signals: expressions on the right-hand side of assignments that read tbl[...][k][field] to populate other variables (e.g., params->txgm, params->pga, params->pad, params->ncorr[...]).

5) Step 5: Check for the absence of a guard that ensures the loop index is within bounds before those table reads. Signals: no intervening conditional like “if (k == LIMIT) { return/abort }” or “if (k < LIMIT) { … }” controlling execution before the first array read.

6) Step 6: Verify the loop’s “match found” condition is the only means for exiting early, meaning if no match occurs, the loop ends with k == LIMIT. Signals: the loop exits normally when k reaches LIMIT and the only early exit path is a break triggered by the equality check.

7) Step 7: Confirm the post-loop reads are not dominated by any path that restricts k to a valid range (e.g., reassignment of k, bounds clamp). Signals: dataflow shows k is unchanged between loop exit and the first table read, and there is no reassignment or clamp like “k = LIMIT - 1”.

8) Step 8: Ensure the reported access is a read to prevent false positives for writes where bounds might differ; prioritize RHS table accesses that feed into parameters or computed values. Signals: assignments of the form “dst = tbl[...][k][...]” and combined bitfield computations like cal_gain using values read from tbl.

9) Step 9: Aggregate multiple consecutive reads using the same out-of-bounds-prone index into a single finding for the site. Signals: a sequence of tbl[...][k][1..7] reads without intervening guards; group them as one violation.

10) Step 10: Treat presence of an explicit bounds check with early return or equivalent (e.g., WARN_ON(k == LIMIT) followed by return) as a suppression. Signals: detection of a conditional comparing k to LIMIT immediately before table accesses and branching that prevents the read when k == LIMIT.

3. Limitations & Assumptions
- Assumes the loop bound (e.g., NPHY_IQCAL_NUMGAINS) reflects the valid maximum index for the table dimension being accessed; actual array size is not verified here.
- Does not infer dynamic guarantees that a match always exists; flags potential issues based on control-flow structure rather than runtime behavior.
- Multi-dimensional array layout and which dimension corresponds to LIMIT are inferred from usage patterns; mismatches could reduce accuracy.
- The checker focuses on read-side OOB risks; write-side patterns are not covered.