1. CVE Identifier
CVE-2024-58009

2. Vulnerability Type
NULL pointer dereference due to missing NULL check in error path

3. Root Cause Summary
The error-handling path in l2cap_sock_alloc unconditionally dereferenced the socket pointer and executed “sock->sk = NULL” after l2cap_chan_create failed. In call paths where l2cap_sock_alloc is invoked with sock == NULL (e.g., from l2cap_sock_new_connection_cb), this led to a NULL pointer dereference. The flawed logic was introduced when ensuring no dangling sk pointer on error, but it failed to account for a NULL sock argument in some contexts.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth L2CAP socket handling (net/bluetooth/l2cap_sock.c)

2) Pre-Patch Flaw:
In l2cap_sock_alloc, after “chan = l2cap_chan_create();” if channel creation failed, the code executed:
- “sk_free(sk);”
- “sock->sk = NULL;”
without verifying that sock was non-NULL, assuming a valid struct socket was always provided.

3) Trigger Condition:
When l2cap_sock_alloc is called with sock == NULL (as happens in l2cap_sock_new_connection_cb) and l2cap_chan_create() returns NULL, the error path writes to sock->sk, dereferencing a NULL pointer.

4) Impact Mechanism:
Dereferencing a NULL socket pointer causes a kernel NULL pointer dereference/Oops, leading to a system crash or denial-of-service.

5. Patch Analysis
1) Fix Approach:
Defensive programming: add a NULL check before touching sock->sk in the error path to safely handle invocations with a NULL sock pointer.

2) Key Code Changes:
In l2cap_sock_alloc:
- Replaced “sock->sk = NULL;” with “if (sock) sock->sk = NULL;” under the “if (!chan)” branch.
- No reordering of bt_sock_alloc() and l2cap_chan_create(), explicitly avoiding side effects of adding a dummy channel to global lists.

3) Locking/Concurrency Impact:
None. The patch only adds a conditional check and does not alter locking, ordering, or list manipulation. The description notes why reordering calls (which could affect global list visibility) was avoided.

6. Broader Kernel Security Implications
This change eliminates a straightforward kernel crash in Bluetooth error handling, improving robustness against malformed states or resource failures during connection setup. It underscores the need to validate pointers across shared helper paths that may be used with different calling conventions. By preventing NULL dereferences, the fix reduces potential denial-of-service vectors arising from Bluetooth stack operations.