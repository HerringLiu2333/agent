1. Plan Summary
Detect functions that dereference a pointer parameter without guarding for NULL, where at least one call site passes a literal NULL to that parameter, focusing on error/cleanup paths after failed allocations.

2. Detection Steps
1) Step 1: Identify candidate functions — look for function definitions with a pointer parameter and at least one dereference or field access of that parameter inside the function body (e.g., param->field). This matches the root cause of unguarded dereference in l2cap_sock_alloc (sock->sk) from [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS] — mitigate FPs by requiring evidence of a dereference write (assignment) to a field of the parameter.
2) Step 2: Locate NULL-passing call sites — find calls where the corresponding actual argument is the literal NULL for the candidate parameter. This is grounded in l2cap_sock_new_connection_cb calling l2cap_sock_alloc(..., NULL, ...) from [FILE_CONTENT], which ensures the callee must handle NULL — mitigate FPs by requiring at least one such call site in the same compilation unit or reachable project scope.
3) Step 3: Pair call sites with callees — for each such call, associate the callee parameter index with the function’s parameter. This establishes that the parameter can be NULL (as per [ROOTCAUSE_ANALYSIS] trigger condition), reducing speculation.
4) Step 4: Find unguarded dereferences — within the callee, identify dereference sites of the parameter that are not dominated by an explicit non-NULL guard (e.g., if (param) or equivalent check) on all paths from function entry to the dereference. This directly targets “missing NULL check on the sock parameter” described in [ROOTCAUSE_ANALYSIS] and fix in [PATCH_DIFF].
5) Step 5: Focus on error/cleanup blocks — prefer dereferences occurring inside branches guarded by failed-allocation checks (e.g., if (!X) { ... }) where X is a local pointer returned by an allocation/creation function and cleaned up right before the dereference. This mirrors the pattern “if (!chan) { sk_free(sk); sock->sk = NULL; }” from [PATCH_DIFF], reducing FPs by focusing on typical error paths.
6) Step 6: Require cleanup cues — inside the error branch, look for cleanup/free calls on other locals (e.g., sk_free(sk) or similar resource-release calls) preceding the dereference of the parameter. This aligns with the failure path in [FILE_CONTENT] and [PATCH_DIFF], tightening the heuristic to error handling code.
7) Step 7: Exclude guarded paths — suppress results if an explicit check of the parameter (if (param) …) encloses the dereference, or if the code returns/escapes early when the parameter is NULL before reaching the dereference. This reflects the correct post-patch pattern “if (sock) sock->sk = NULL” in [PATCH_DIFF].
8) Step 8: Verify reachability from NULL call site — ensure that control flow from the NULL-passing call site can reach the dereference (i.e., no intervening checks in the callee that would return or ensure non-NULL). This ties the report to the actionable, externally-triggerable path described in [ROOTCAUSE_ANALYSIS].
9) Step 9: Prioritize field-write dereferences — rank/report higher when the dereference is an assignment to a field of the parameter (param->field = …), as in “sock->sk = NULL” from [PATCH_DIFF], which is a common cleanup pattern where NULL-guard is expected. This reduces noise from read-only dereferences that may behave differently.
10) Step 10: Provide diagnostic context — for each finding, include the callee function name, parameter index/name, dereference location, the preceding failure-check (if any), and at least one call site passing NULL. This allows mapping back to the precise root cause scenario identified in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Function definitions and their formal parameters of pointer type.
- Call sites where an actual argument is the literal NULL.
- Field access/indirect accesses on parameters (e.g., param->field).
- Conditional branches indicating allocation failure (e.g., if (!ptr)) and cleanup sequences (free/put/unlink calls).
- Control-flow dominance/guard checks (conditions verifying parameter non-NULL).
- Return statements and early exits that could guard dereferences.
- Assignment statements writing into parameter fields.

4. Dataflow / Taint Considerations
- Track literal NULL at call sites flowing into specific callee parameters.
- In the callee, track control-flow paths from entry to the dereference to ensure no dominating non-NULL guard exists.
- Prefer paths that include a failed-allocation predicate (if (!X)) prior to the dereference to match error/cleanup contexts.
- Exclude flows where an if (param) or equivalent dominates the dereference.

5. Validation & Test Cases
- Positive: l2cap_sock_alloc pre-patch with l2cap_sock_new_connection_cb calling l2cap_sock_alloc(..., NULL, ...); inside l2cap_sock_alloc, in the if (!chan) error branch, the statement “sock->sk = NULL” without guarding “if (sock)” should be flagged (from [FILE_CONTENT] and [PATCH_DIFF] pre-change).
- Negative: l2cap_sock_alloc post-patch where “if (sock) sock->sk = NULL” guards the dereference; the checker should not flag this (from [PATCH_DIFF]).
- Negative: Functions where the parameter is dereferenced but all call sites pass non-NULL (no literal NULL found), or where an if (param) dominates the dereference; should not be flagged.
- Test harness notes: Run intra-project to ensure call-callee pairing; ensure control-flow analysis can compute dominance and reachability across simple conditionals.

6. Estimated Effort & Priority
Medium: Requires interprocedural call-argument mapping and intraprocedural dominance analysis, but with simple heuristics (literal NULL calls and unguarded deref in error branches).

7. Likely False-Positive Sources & Mitigations
- Indirect guards via helper functions not recognized as null checks; mitigate by recognizing common idioms (if (param), early return on !param).
- Conditional compilation/code paths not active in the analyzed configuration; mitigate by requiring at least one observed NULL call site.
- Complex path conditions where dereference is unreachable when param is NULL; mitigate by ensuring path reachability from NULL call site without an early guard.

8. Limitations & Assumptions
- Assumes availability of at least one literal NULL call site to the callee (as in l2cap_sock_new_connection_cb in [FILE_CONTENT]); may miss cases where NULL flows through variables.
- Does not model kernel-specific helper semantics for null-guarding beyond simple dominance of “if (param)”.
- Does not reason about concurrency or lifetime beyond single-function control flow; focuses on the NULL deref condition identified in [ROOTCAUSE_ANALYSIS].