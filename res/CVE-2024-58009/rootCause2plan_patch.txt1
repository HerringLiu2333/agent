1. Plan Summary
Detect functions that dereference a pointer parameter in an error-handling path without guarding it against NULL while at least one caller passes NULL for that parameter.

2. Detection Steps
1) Step 1: Identify candidate functions with at least one pointer-typed parameter. Signals: C/C++ functions where a parameter’s type is a pointer (e.g., struct T*).

2) Step 2: Locate dereferences of each such parameter inside the callee. Signals: member access through “param->field”, pointer deref “*param”, or indexing “param[i]”; prioritize writes like “param->field = …”.

3) Step 3: Determine whether the dereference is dominated by a non-NULL guard on that parameter. Signals: dominating checks such as “if (param) …”, “if (param != NULL) …”, early returns on “if (!param) return …”, or equivalent assertions; if present, mark deref as guarded and skip.

4) Step 4: Focus on dereferences that occur inside an error-handling branch triggered by a failed resource creation. Signals: immediate control-flow context is a branch where a variable assigned from a function call (e.g., “x = f();”) is tested for NULL/false (e.g., “if (!x)” or “if (x == NULL)”), and the dereference appears within that branch.

5) Step 5: Further prioritize dereferences that write to a member of the parameter (e.g., “param->field = NULL”). Signals: assignment where the LHS base is the parameter; this matches the “sock->sk = NULL” pattern.

6) Step 6: Collect call sites for the callee and check whether at least one passes a literal NULL for the parameter in question. Signals: argument expression is the NULL literal (or 0 in C) at any call site (e.g., from l2cap_sock_new_connection_cb).

7) Step 7: Validate reachability from the call site to the unguarded dereference without an intervening guarantee that the parameter becomes non-NULL. Signals: absence of intra-callee reassignments to the parameter and absence of dominating non-NULL guards before the dereference.

8) Step 8: Exclude cases where the callee unconditionally enforces a non-NULL precondition before the dereference. Signals: explicit BUG_ON/ASSERT-style checks, early returns on NULL at all entries, or wrapper validation that dominates the deref.

9) Step 9: Report a finding when all conditions hold: (a) unguarded dereference of a pointer parameter, (b) deref is inside an error/failure branch after a failed call, and (c) at least one caller passes NULL to that parameter. Include evidence: callee function, parameter, deref location and enclosing failure-check, and a representative call site passing NULL.

3. Limitations & Assumptions
- Assumes at least one visible call site passes a literal NULL; may miss issues when NULL flows indirectly (e.g., conditional expressions or aliasing) without a literal.
- Treats “error-handling branch” as branches directly testing a call result for NULL; does not recognize custom error macros or non-NULL failure conventions.
- Relies on dominance analysis for guards; complex control flow or macro-heavy code may obscure guards and yield false positives/negatives.
- Does not model external specifications that a parameter must be non-NULL; if such contracts exist but are not enforced in code, findings may include intended precondition violations.