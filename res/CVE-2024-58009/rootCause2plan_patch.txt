1. Plan Summary
Detect functions that dereference an optional pointer parameter in an error-handling path triggered by an unrelated allocation/creation failure without first checking the parameter for NULL, while there exists at least one call site that passes NULL for that parameter.

2. Detection Steps
1) Step 1: Objective — Identify candidate functions with a pointer parameter that can be optional. Signals — Functions taking a pointer parameter (e.g., a struct socket* like “sock” per [ROOTCAUSE_ANALYSIS]) that is dereferenced inside the function. FP mitigation — Prefer parameters of pointer-to-struct types and names seen in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] (e.g., sock) but do not hardcode names; keep general.

2) Step 2: Objective — Find error-handling blocks controlled by failure of an independent resource. Signals — Conditionals whose guard checks a callee’s return value for NULL (pattern: x = foo(); if (!x) { ... }), as in l2cap_chan_create() failure in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation — Require the guarded block to include typical error-path indicators (e.g., return of NULL/error, calls to free-like functions), aligning with “sk_free(sk); return NULL;” in [PATCH_DIFF].

3) Step 3: Objective — Within such error blocks, locate dereferences of the candidate parameter. Signals — Field accesses or stores via the parameter (e.g., param->field = ...), specifically mirroring “sock->sk = NULL;” in [PATCH_DIFF]. FP mitigation — Exclude cases where the dereference is syntactically guarded by a local null-check (if (param) ...) or dominated by an earlier check asserting non-NULL.

4) Step 4: Objective — Establish absence of a dominating non-NULL guarantee for the parameter at the dereference. Signals — No enclosing condition that ensures param != NULL, no prior early-return on param == NULL, no assertion macros that imply non-NULL on that path. FP mitigation — Use control-flow dominance reasoning to ensure that any checks found actually protect the dereference.

5) Step 5: Objective — Confirm a feasible call path that can pass NULL to the parameter. Signals — At least one call site to the function where the corresponding actual argument is syntactically NULL (e.g., NULL literal) or a value proven to be NULL on some path, consistent with “called from l2cap_sock_new_connection_cb()” with sock == NULL in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]. FP mitigation — Require at least one explicit NULL actual argument; if unavailable, lower severity or suppress.

6) Step 6: Objective — Correlate the independent failure condition with the dereference. Signals — The dereference occurs solely within the error block for the unrelated resource’s failure (e.g., chan == NULL), as in [PATCH_DIFF]. FP mitigation — Exclude dereferences outside error blocks or ones directly tied to checks about the parameter itself.

7) Step 7: Objective — Prioritize cleanup-style dereferences that are typical in error paths. Signals — The error block contains releases/frees (e.g., sk_free(sk)) and cleanup assignments (param->field = NULL), per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation — Require at least one cleanup signal to reduce benign matches.

8) Step 8: Objective — Exclude safe patterns introduced by the patch. Signals — Presence of an explicit NULL guard around the dereference (if (param) param->field = ...), per [PATCH_DIFF] fix. FP mitigation — Do not flag when such a guard is present.

9) Step 9: Objective — Ensure path feasibility. Signals — Interprocedural path exists: caller can pass NULL, callee reaches the error block, and there is no intervening reassignment that makes the parameter non-NULL. FP mitigation — If path requires unresolved interprocedural facts, downgrade severity instead of reporting.

10) Step 10: Objective — Rank findings for kernel-like contexts. Signals — File paths or namespaces matching kernel subsystems (e.g., net/bluetooth) and pointer-to-kernel-structs (e.g., struct socket) as in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation — Use this only for ranking, not as a hard filter, to remain general.

3. Target Elements
- Functions and their pointer parameters (e.g., struct socket*).
- Call sites to these functions and actual arguments.
- Conditional blocks guarding on callee return values being NULL.
- Pointer dereferences of parameters (field accesses/assignments).
- Error-handling constructs: return of NULL/error, free/release calls.
- Dominance/guard checks ensuring parameter non-NULL.

4. Dataflow / Taint Considerations
- Track potential NULL values from call sites to the callee’s parameter (interprocedural).
- Track control-flow into blocks gated by unrelated resource failures (e.g., result of another allocation/creation being NULL).
- Verify absence of a guarding non-NULL condition dominating the dereference.
- Ensure the parameter is not reassigned to a proven non-NULL value before the dereference along the flagged path.

5. Validation & Test Cases
- Positive: A function f(struct socket *sock) does x = create(); if (!x) { free(y); sock->sk = NULL; return NULL; } and a caller invokes f(..., NULL, ...). Expect a report.
- Positive: Same as above but error block lacks free; still guarded by if (!x) and assigns sock->sk = NULL; caller passes NULL. Expect a report due to error block and NULL call site.
- Negative: Same function with if (sock) sock->sk = NULL; inside the error block. Expect no report.
- Negative: Same function without any call sites passing NULL (all callers pass a variable proven non-NULL). Expect no report.
- Test harness notes: Include interprocedural paths and ensure the analysis models NULL literals and simple conditional passing; confirm dominance checks suppress guarded dereferences.

6. Estimated Effort & Priority
Medium — Requires interprocedural call-site analysis, path feasibility, and dominance checks, but patterns are well-structured and common in kernel error paths.

7. Likely False-Positive Sources & Mitigations
- Missing or incomplete call graph leading to unknown call sites: require at least one explicit NULL caller to report.
- Macros/inlines obscuring null checks: apply dominance analysis after macro expansion where possible.
- Functions where parameter is never intended to be NULL: rely on call-site evidence rather than naming/type alone.
- Complex aliasing of the parameter: limit to direct dereferences of the parameter identifier, or require conservative proof that aliases refer to the parameter.

8. Limitations & Assumptions
- Assumes availability of at least one visible call site passing NULL; private or out-of-scope callers may be missed.
- Does not attempt to reorder functions as discussed in [PATCH_DESCRIPTION]; focuses solely on missing NULL checks.
- Cannot infer subsystem-specific invariants beyond what’s evident; relies on general error-path heuristics derived from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].