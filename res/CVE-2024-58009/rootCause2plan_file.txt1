1. Plan Summary
Detect functions that may be called with a NULL pointer argument and that dereference that parameter without a guarding NULL check, especially in error/cleanup paths after another allocation fails.

2. Detection Steps
1) Step 1: Identify candidate callee functions with pointer parameters to struct-like types. Signals: function parameters whose types are pointers to records (e.g., struct socket*, struct foo*), and those parameters are dereferenced via field access in the body.

2) Step 2: For each such function, collect all direct call sites and determine if any pass a NULL literal (0 or NULL) for the relevant parameter. Signals: call expressions where the ith argument is syntactically the NULL literal.

3) Step 3: Mark the parameter as “possibly NULL” in the callee if at least one call site passes NULL. Signals: existence of at least one call site with NULL for that parameter.

4) Step 4: Inside the callee, find dereferences of the parameter (reads or writes) such as “param->field = …”, “x = param->field”, or passing “param” into APIs that dereference it. Signals: member access through “->”, array indexing via the parameter, or calls where the parameter flows into a function argument that is dereferenced.

5) Step 5: For each dereference, check if it is syntactically and semantically guarded by a prior explicit non-NULL test on the parameter (e.g., if (param) …). Signals: dominance or path conditions that ensure the deref occurs only when the parameter is known non-NULL; absence of such a guard marks it as potentially unsafe.

6) Step 6: Prioritize dereferences within cleanup/error paths that are triggered by another allocation or factory function returning NULL. Signals: control flow under a condition like “if (!X) { … param->field … }” where X was assigned from a function with allocation semantics (e.g., “X = foo_create();”), followed by frees/finalizers of other objects (e.g., sk_free(sk)).

7) Step 7: Further prioritize write-access dereferences that clear fields (e.g., “param->field = NULL”) as in the provided flaw. Signals: assignments where the LHS base is the parameter and RHS is a literal NULL.

8) Step 8: Ensure reachability from the function entry to the dereference along a path that does not test the parameter for non-NULL and does not return early before the dereference. Signals: path feasibility analysis respecting conditionals and returns.

9) Step 9: Correlate with call sites to ensure at least one NULL-passing call can reach the callee entry without an intervening wrapper that replaces the NULL argument. Signals: interprocedural dataflow from the call node to the callee parameter mapping.

10) Step 10: Report a finding when all are true: (a) a callee has a parameter possibly NULL due to a caller passing NULL, (b) the callee dereferences the parameter, (c) no guarding NULL check for the parameter dominates the dereference, and (d) (optional confidence boost) dereference occurs in an error/cleanup region controlled by a failed allocation of another object.

3. Limitations & Assumptions
- Assumes CodeQL can resolve direct call sites; indirect calls via function pointers or cross-module boundaries may be missed.
- Assumes type information is available to recognize struct-like pointer parameters and member accesses; heavy macro indirection may obscure patterns.
- The plan focuses on explicit NULL literals at call sites; arguments that are conditionally NULL but not literal may be under-reported.
- Path feasibility is approximated; some paths flagged may be infeasible at runtime due to external invariants not captured by static analysis.
- Kernel-specific allocation/finalizer recognition (e.g., “_create”, “_alloc”, “free” patterns) is heuristic and may need tuning for other subsystems.