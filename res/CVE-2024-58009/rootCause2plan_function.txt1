1. Plan Summary
Detect unguarded dereferences of a pointer parameter in error/cleanup paths where the function can be called with a NULL argument (evidenced by call sites), exemplified by assigning to fields of a possibly NULL socket after a failed “create” call.

2. Detection Steps
1) Step 1: Identify candidate functions with pointer parameters (e.g., struct socket* sock) that are dereferenced via field access (param->field) anywhere in the function body.
2) Step 2: For each such pointer parameter, collect call sites and mark the parameter “nullable” if any call passes a literal NULL (or a value proven to be NULL) at that argument position.
3) Step 3: Within the callee, locate error/cleanup branches characterized by a variable assigned from a function call followed by a null-check (“X = call(); if (!X) { … }”) that gates the branch.
4) Step 4: In these failure branches, search for dereferences or field writes to the nullable parameter (e.g., sock->sk = NULL) and record them as potential issues.
5) Step 5: Strengthen confidence by requiring the failure branch to also perform resource cleanup (e.g., a call resembling object free such as sk_free(some_var)), indicating an error path rather than normal operation.
6) Step 6: Ensure the identified dereference is not dominated by a guard proving non-nullness of the parameter (e.g., there is no preceding condition “if (param) { … }” that must hold on all paths to the dereference).
7) Step 7: Confirm there exists at least one feasible path from the function entry to the failure branch where the parameter remains possibly NULL (based on call-site nullability and intra-procedural control flow).
8) Step 8: Optionally prioritize matches where the parameter type is struct socket* and the dereference targets known socket fields (e.g., “->sk”), as this matches the known flaw pattern in the Bluetooth L2CAP layer.
9) Step 9: De-prioritize or suppress cases where the failure branch explicitly re-checks the parameter for NULL before dereferencing (e.g., “if (param) param->field = …”), as these are patched-safe patterns.
10) Step 10: Report each instance where a nullable pointer parameter is dereferenced in a failure/cleanup branch without a preceding null guard, highlighting the specific call site passing NULL and the dereference location.

3. Limitations & Assumptions
- Assumes the codebase provides at least one call site passing NULL to identify the parameter as nullable; indirect or function-pointer-based calls may be missed.
- Does not infer API-specific semantics (e.g., whether sock_init_data internally guards NULL); the checker relies solely on explicit guards in the caller/callee code and control-flow dominance.
- Kernel macros, inlining, and conditional compilation may obscure calls or dereferences; accuracy depends on the extractor’s ability to resolve them.
- The plan targets a general pattern; subsystem-specific nuances (e.g., L2CAP global list behavior) are not modeled and are out of scope.