1. Plan Summary
Detect functions that dereference a pointer parameter in an error/cleanup branch even though the function can be called with a NULL argument, leading to a NULL pointer dereference on allocation/creation failure.

2. Detection Steps
1) Step 1: Objective: Identify candidate functions whose pointer parameter(s) may be NULL. Signals: Find function parameters of pointer type that have at least one call site passing a NULL literal (based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS noting l2cap_sock_alloc can be called with NULL). FP mitigation: Require at least one explicit NULL actual argument in the codebase to flag the parameter as “maybe NULL.”

2) Step 2: Objective: Locate error branches triggered by failed allocation/creation within those candidate functions. Signals: In-function conditional checks immediately testing the result of a call or assignment against NULL (e.g., “if (!var)” after a call like l2cap_chan_create) (supported by FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Restrict to checks directly guarding a block that performs cleanup and returns an error/NULL.

3) Step 3: Objective: Within such failure branches, find dereferences of the maybe-NULL parameter. Signals: Field/member access or pointer dereference expressions of the form param->field or equivalent inside the “failure” branch (matches sock->sk = NULL in PATCH_DIFF/FUNCTION_CONTENT). FP mitigation: Exclude cases where the dereference is syntactically guarded by a local null-check of the same parameter (e.g., “if (param)”).

4) Step 4: Objective: Confirm reachability to the dereference without a dominating non-NULL check on the parameter. Signals: Control-flow dominance where no prior “if (!param) return/goto” or assert-like construct guarantees non-NULL on all paths to the dereference (ROOTCAUSE_ANALYSIS notes lack of check before sock->sk = NULL). FP mitigation: Require absence of such dominating guards; treat early returns on NULL as disqualifying for the path.

5) Step 5: Objective: Prioritize “cleanup-context” dereferences typical of error paths. Signals: In the same failure block, presence of resource cleanup (e.g., freeing a local allocation like sk_free(sk)) followed or preceded by a return statement (seen in FUNCTION_CONTENT: sk_free(sk); sock->sk = NULL; return NULL). FP mitigation: Preferentially report dereferences inside blocks that both clean up and return, reducing incidental matches.

6) Step 6: Objective: Exclude dereferences that already implement the fix pattern. Signals: Presence of a local guard “if (param) param->field = …” (as introduced in PATCH_DIFF: if (sock) sock->sk = NULL). FP mitigation: Do not report dereferences syntactically guarded by a non-NULL check of the parameter in the same block.

7) Step 7: Objective: Handle simple aliases to the parameter. Signals: Local variables assigned directly from the parameter (e.g., p = param) and then dereferenced in the failure branch. FP mitigation: Only consider direct, unmodified aliases (single assignment without intervening reassignments) to avoid over-approximating.

8) Step 8: Objective: Avoid false positives when the parameter is proven non-NULL by interface contract observable in code. Signals: All call sites pass non-NULL, or an immediate assertion/BUG_ON-like macro that unconditionally enforces non-NULL before the failure branch. FP mitigation: If all observed call sites pass non-NULL or a dominating hard assertion exists, suppress the finding.

9) Step 9: Objective: Boost confidence when an earlier use suggests the parameter may legally be NULL. Signals: The parameter is passed to helpers whose semantics allow NULL (e.g., init-like helpers; ROOTCAUSE_ANALYSIS notes sock_init_data correctly guards NULL), without implying non-NULL thereafter. FP mitigation: Treat such uses as neutral (do not count as guarantees), but use them as a weak supporting signal rather than a trigger.

10) Step 10: Objective: Report only when all three signals co-occur: maybe-NULL parameter, failed-allocation branch, and unguarded dereference within that branch. Signals: Conjunction of Steps 1–3 with reachability per Step 4 (matches the exact pre-patch flaw described in ROOTCAUSE_ANALYSIS and PATCH_DIFF). FP mitigation: Require the return/cleanup context from Step 5 for higher precision by default; allow a “strict” mode without it.

3. Target Elements
- Function definitions with pointer parameters.
- Call sites that pass NULL literals to those parameters.
- Conditional checks comparing a local variable to NULL immediately after a function call (allocation/creation failure checks).
- Statements inside those failure branches: cleanup calls, field/member accesses on the parameter, and return statements.
- Simple aliases of the parameter within the function.
- Dominating guards or early returns that constrain parameter nullness.

4. Dataflow / Taint Considerations
- Treat a pointer parameter as “maybe NULL” if any call site passes NULL; propagate to direct aliases.
- Model control-flow from allocation/creation call to its failure-branch via the NULL check (e.g., if (!chan)).
- Verify no dominating non-NULL checks for the parameter on paths to the dereference.
- Consider the dereference a sink if it accesses fields/members of the maybe-NULL parameter inside the failure branch.

5. Validation & Test Cases
- Positive: Pre-patch l2cap_sock_alloc with sock passed as NULL from some caller; inside the if (!chan) branch, “sk_free(sk); sock->sk = NULL; return NULL;” should be reported (supported by FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS).
- Negative: Patched version where the dereference is guarded: “if (sock) sock->sk = NULL;” (PATCH_DIFF) — should not be reported.
- Negative: A function where no call site passes NULL to the pointer parameter — should not be reported even if there’s an unguarded dereference in an error branch.
- Negative: A function with an early “if (!param) return …;” and the dereference lies only on the else-path — should not be reported.
- Test harness notes: Build a small corpus including the exact snippet from FUNCTION_CONTENT (pre- and post-patch) and synthetic functions mimicking allocation-failure branches with/without NULL call sites.

6. Estimated Effort & Priority
Medium effort; high priority due to direct kernel NULL dereference risk (ROOTCAUSE_ANALYSIS describes DoS via kernel crash).

7. Likely False-Positive Sources & Mitigations
- Missing or out-of-scope call sites causing the analysis to miss or misclassify NULL arguments; mitigate by requiring at least one visible NULL call site.
- Complex aliasing obscuring the parameter; mitigate by focusing on direct aliases only.
- Assertions/macros that enforce non-NULL not recognized by the analysis; mitigate by modeling common assert/BUG_ON patterns where available.
- Heuristics around “allocation/creation failure branches” misidentifying generic NULL checks; mitigate by requiring adjacent cleanup and return as in FUNCTION_CONTENT.

8. Limitations & Assumptions
- Assumes at least one call site passing NULL is visible to the analysis; cross-compilation units without full call graph may limit detection.
- Does not prove the allocation/creation call can actually fail at runtime; treats the NULL check branch as feasible.
- Does not model concurrency or side effects discussed in PATCH_DESCRIPTION (global list implications) since they are orthogonal to the NULL dereference pattern.
- Cannot rely on undocumented helper semantics (e.g., sock_init_data) beyond what ROOTCAUSE_ANALYSIS states about safe NULL handling.