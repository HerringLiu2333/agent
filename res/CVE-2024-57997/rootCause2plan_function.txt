1. Plan Summary
Detect kernel allocations that under-allocate arrays by using only an element count as the byte size and then treating the result as an array of non-byte elements, as exemplified by the pre-patch wcn36xx_probe bug.

2. Detection Steps
1) Step 1: Objective — Find kmalloc-like allocation sites where size equals a “count” only. Signals — Calls to devm_kmalloc/kmalloc (and similar) where the size argument is a single variable/expression not multiplied by sizeof(...) or an element size. FP mitigation — Exclude devm_kcalloc/kmalloc_array/kcalloc calls since they express count × size already (based on [PATCH_DIFF], [PATCH_DESCRIPTION]).

2) Step 2: Objective — Ensure the allocated pointer is used as an array of non-byte elements. Signals — The allocation result is assigned/stored to a variable/field of type T* where T is a struct or non-byte type (not void/char/u8). FP mitigation — Skip if the target type is void*/char*/u8*; under-allocation is unlikely when allocating raw byte buffers (based on the struct intent in [ROOTCAUSE_ANALYSIS]).

3) Step 3: Objective — Confirm array-like usage of the allocated pointer. Signals — Post-allocation uses such as p[i], p[i].field, *(p + i), or address-of p[i] indicating element-wise access to T rather than bytes. FP mitigation — Require at least one array-style access on the same value stemming from the allocation to reduce flagging opaque buffers (root-cause pattern from [ROOTCAUSE_ANALYSIS]).

4) Step 4: Objective — Tie the “count” variable to the array bounds to strengthen evidence. Signals — A loop or conditional with bound i < count (or equivalent) where p[i] or p[i].field is accessed. FP mitigation — Require a clear dataflow from the allocation’s size argument to the bound used for indexing, matching the n_channels pattern in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS].

5) Step 5: Objective — Detect missing element-size multiplication. Signals — The size argument equals the count variable (or an alias) and lacks syntactic multiplication by sizeof(T) or sizeof(*p). FP mitigation — Exclude cases where a prior computation already multiplied by sizeof(T) and stored in the count variable (no evidence of this in the provided bug; conservative assumption).

6) Step 6: Objective — Preferentially flag struct element types where sizeof(T) > 1. Signals — T is a struct type (as in struct wcn36xx_chan_survey) or an integer type wider than 1 byte. FP mitigation — Give higher confidence to struct pointers; de-prioritize scalar non-byte types if array access evidence is weak (based on [ROOTCAUSE_ANALYSIS]).

7) Step 7: Objective — Highlight absence of zero-initialization when reads occur. Signals — Paths reading p[i].field (RHS) with no dominating write to that field since allocation. FP mitigation — Restrict to same-function simple paths (post-allocation reads) to minimize interprocedural ambiguity; this mirrors the uninitialized read concern in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].

8) Step 8: Objective — Account for device-managed allocators. Signals — devm_kmalloc specifically, followed by storing into a persistent struct field (e.g., wcn->chan_survey). FP mitigation — Treat field stores similarly to locals; still require array-style use evidence to avoid false positives (based on [FUNCTION_CONTENT], [PATCH_DIFF]).

9) Step 9: Objective — Prioritize reports that match the exact anti-pattern in the CVE. Signals — devm_kmalloc(..., count, GFP_*) assigned to a struct T* and later used as p[i].field with i bounded by count. FP mitigation — Rank these highest; they mirror the pre-patch pattern in [PATCH_DIFF] and [FUNCTION_CONTENT].

10) Step 10: Objective — Suppress if a corrective pattern is present. Signals — Immediate follow-up memset(p, 0, count × sizeof(T)) or realloc with correct size on the same pointer before use. FP mitigation — Require correct product count × sizeof(T); a bare memset(count) without sizeof(T) does not suppress.

3. Target Elements
- Allocation call sites: devm_kmalloc, kmalloc, kzalloc variants (focus on kmalloc-like with a single size).
- Assignment targets of allocations: variables/fields typed as pointers to struct or non-byte types.
- Array-like dereferences of allocated pointers: p[i], p[i].field, *(p + i).
- Loop/condition bounds that use the same “count” as the allocation size.
- Simple intra-function reads/writes to detect uninitialized field reads post-allocation.

4. Dataflow / Taint Considerations
- Track the allocation result to its uses (array indexing and field access).
- Track the size argument expression to identify the “count” variable and its aliases.
- Track control-flow bounds (i < count) to correlate with indexing of the allocated pointer.
- For uninitialized read heuristic, track writes to p[i].field along paths from allocation to reads within the same function.

5. Validation & Test Cases
- Positive: devm_kmalloc(dev, n_channels, GFP_KERNEL) assigned to struct foo *arr; later for (i = 0; i < n_channels; i++) arr[i].metric = 0; Expect a finding for under-allocation by sizeof(struct foo).
- Positive: kmalloc(count, GFP_KERNEL) to struct bar *p; later x = p[idx].field; Expect a finding (under-allocation and potential uninitialized read if no prior write).
- Negative: devm_kcalloc(dev, n_channels, sizeof(*arr), GFP_KERNEL) with arr[i] use. Expect no finding (matches fix in [PATCH_DIFF], [PATCH_DESCRIPTION]).
- Negative: devm_kmalloc(dev, len, GFP_KERNEL) assigned to u8 *buf and used via memcpy/byte indexing. Expect no finding (byte buffer).
- Test harness notes: Exercise both local variables and struct fields, and both with and without explicit loops that bind i < count.

6. Estimated Effort & Priority
High — Requires type-aware reasoning, call-graph/AST patterning for kmalloc-like APIs, and basic intra-procedural dataflow for bounds/index correlation.

7. Likely False-Positive Sources & Mitigations
- Count variable already encodes bytes (pre-multiplied): Mitigate by requiring array-style element access and pointer type T* where T is non-byte.
- Opaque buffers later cast to struct arrays: Mitigate by requiring array-style use on the original allocated pointer or its straightforward aliases.
- Custom allocators or wrappers: Limit initial scope to known kmalloc-like functions to reduce noise.
- Complex interprocedural initialization before reads: Limit uninitialized-read heuristic to same-function simple paths.

8. Limitations & Assumptions
- The precise type of wcn->chan_survey and sizeof(struct) are not provided; we assume it is a struct pointer based on [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF].
- Cross-function array bounds and initialization may not be captured; the checker focuses on intra-procedural evidences.
- The checker assumes that a non-byte pointer used with p[i] implies element-wise semantics that require count × sizeof(T) allocation.