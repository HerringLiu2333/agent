1. CVE Identifier
CVE-2024-57997

2. Vulnerability Type
- Heap out-of-bounds access due to incorrect allocation size
- Uninitialized memory use (secondary effect)

3. Root Cause Summary
In wcn36xx_probe(), the driver allocated the channel survey array with devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL) instead of allocating n_channels elements of struct wcn36xx_chan_survey. This under-sized allocation led to out-of-bounds access when indexing wcn->chan_survey[idx] as an array of structs in wcn36xx_get_survey(), and also left the memory uninitialized when no frames had been processed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Qualcomm Atheros WCN36xx wireless driver (drivers/net/wireless/ath/wcn36xx/main.c), channel survey handling.

2) Pre-Patch Flaw:
- In wcn36xx_probe(), the code used devm_kmalloc with a size equal to the number of channels (bytes), not the total bytes needed for an array of struct wcn36xx_chan_survey:
  “wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);”
- The buffer was too small for n_channels elements and not zero-initialized, enabling both heap OOB and uninitialized reads.

3) Trigger Condition:
- Any call to wcn36xx_get_survey() that accesses wcn->chan_survey[idx] (for 2.4 GHz and 5 GHz channels) triggers out-of-bounds access because idx is treated as a struct index while the buffer was sized in bytes.
- Additionally, when there are no frames on a channel, reading chan_survey->rssi/snr uses uninitialized memory.

4) Impact Mechanism:
- Out-of-bounds read/write on the heap (KASAN-reported) when accessing chan_survey[idx].rssi and chan_survey[idx].snr.
- Potential memory corruption, system crash, or information disclosure; uninitialized values could propagate into survey->noise and flags.

5. Patch Analysis
1) Fix Approach:
- Allocate the channel survey array with the correct element count and size, and ensure zero-initialization to avoid uninitialized reads, by switching to devm_kcalloc().

2) Key Code Changes:
- Replaced:
  devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);
  with:
  devm_kcalloc(wcn->dev, n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL);
- This change both fixes the size calculation and initializes the memory to zero.

3) Locking/Concurrency Impact:
- None. The change is confined to probe-time allocation; no locks or ordering were added/modified.

6. Broader Kernel Security Implications
- This is a common class of kernel bugs where kmalloc is used with element count rather than total size, leading to heap OOB; using kcalloc/kmalloc_array prevents both size miscalculation and uninitialized use.
- Strengthens the case for systematic use of array allocators and static analysis checks in drivers, especially where arrays of structs are indexed by external inputs (e.g., channel index).
- KASAN proved effective in detecting the issue; maintaining such sanitizers and enforcing allocation patterns can prevent similar vulnerabilities across wireless subsystems.