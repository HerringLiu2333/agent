1. Plan Summary
Detect under-sized heap allocations of arrays of structs that are later indexed and have their fields read, and flag possible uninitialized reads when zero-initialization is missing.

2. Detection Steps
1) Step 1: Objective: Find allocations intended for arrays of structs. Signals: Calls to devm_kmalloc/kmalloc-like functions where the result is stored in a pointer to a struct type (e.g., struct wcn36xx_chan_survey*). FP mitigation: Exclude cases where the pointer type is to a byte-sized element (char/uint8_t) or void* used for raw buffers.

2) Step 2: Objective: Identify mis-sized allocations using only an element count. Signals: Size argument equals a count variable (e.g., n_channels) without multiplication by sizeof(element), per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: Require the count variable is derived from array sizes (e.g., sum of .n_channels) as shown in [FILE_CONTENT] to indicate intended array-of-struct allocation.

3) Step 3: Objective: Confirm array semantics at use sites. Signals: Subsequent indexed or pointer arithmetic on the allocated pointer followed by field access (e.g., ptr[idx], (ptr + idx)->field, ptr[idx].rssi/snr), as seen in wcn36xx_get_survey() in [FILE_CONTENT]. FP mitigation: Require at least one field access through the indexed element (selection of a member on the indexed value).

4) Step 4: Objective: Quantify under-allocation risk. Signals: Element type has sizeof > 1 (struct type with members), but allocated bytes equal only the count; conceptually expected bytes should be count * sizeof(element). FP mitigation: Skip when sizeof(element) is 1 or unknown, or when there is evidence of packing into 1-byte elements.

5) Step 5: Objective: Detect safer allocation patterns and suppress. Signals: Calls to devm_kcalloc/kcalloc/kmalloc_array with (count, sizeof(element), flags) as in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS], or kzalloc. FP mitigation: Do not flag if the allocation uses any zero-initializing or array-aware allocator.

6) Step 6: Objective: Bind allocation site to the field/method that uses it. Signals: The allocated pointer is stored in a struct field (e.g., wcn->chan_survey) and later referenced in another function (e.g., wcn36xx_get_survey()), per [FILE_CONTENT]. FP mitigation: Require at least one cross-function use to indicate lifetime beyond local scope.

7) Step 7: Objective: Flag potential uninitialized reads. Signals: Reads of fields (e.g., rssi, snr) from elements occur without any prior write/initialization on the path from allocation, as described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Suppress if there’s a proven write (memset, assignment to those fields, or zero-initializing allocator) dominating before the read.

8) Step 8: Objective: Correlate index source to channel enumeration. Signals: Index variable (e.g., idx/band_idx) derived from input to get_survey-like functions and compared against band->n_channels, then used to access the allocated array (per [FILE_CONTENT]). FP mitigation: Require index bounds checks are based on channel counts to strengthen confidence that the pointer is intended as a per-channel array of structs.

9) Step 9: Objective: Increase confidence by matching domain-specific field names. Signals: Access to fields named rssi and snr used to compute survey values (survey->noise, SURVEY_INFO_NOISE_DBM) in [FILE_CONTENT], indicating per-channel survey struct semantics. FP mitigation: Treat this as a heuristic signal; do not solely rely on names, but use it to prioritize matches.

10) Step 10: Objective: Rank severity. Signals: Difference between conceptual required size (count * sizeof(struct)) and actual size (count) is positive; plus presence of read-before-write suggests both OOB and uninitialized read risk per [ROOTCAUSE_ANALYSIS]. FP mitigation: Lower severity if index is always zero or the array is never read (no observable field access).

3. Target Elements
- Allocation sites calling devm_kmalloc/kmalloc-like functions.
- Variables representing element counts (e.g., n_channels built from .n_channels fields).
- Pointer fields in driver state structs (e.g., wcn->chan_survey).
- Indexing expressions and field accesses on allocated pointers.
- Functions that consume the array (e.g., wcn36xx_get_survey()).
- Control-flow and dataflow between allocation and first read/write.

4. Dataflow / Taint Considerations
- Track the allocated pointer from the allocation site to all uses across functions.
- Track the index variable’s origin and bounds checks relative to count variables.
- Track writes to the allocated memory (explicit field assignments, memset/memcpy) and identify paths where reads occur without prior writes.
- Distinguish zero-initializing allocators (kcalloc/kzalloc) from non-initializing ones (kmalloc/devm_kmalloc) to model initialization state.

5. Validation & Test Cases
- Positive: Pre-patch pattern where devm_kmalloc stores to wcn->chan_survey with size equal to n_channels, followed by wcn->chan_survey[idx].rssi/snr access (from [PATCH_DIFF] and [FILE_CONTENT]); expect a finding for under-allocation and possible uninitialized read.
- Negative: Post-patch pattern using devm_kcalloc with (n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL); expect no finding (from [PATCH_DIFF]).
- Negative: Allocation with kmalloc using n_channels * sizeof(struct wcn36xx_chan_survey) or kmalloc_array; expect no finding (aligned with [ROOTCAUSE_ANALYSIS] guidance).
- Positive: kmalloc (non-zero-initializing) of struct array followed by immediate reads of struct fields without any writes; expect uninitialized-read finding (per [ROOTCAUSE_ANALYSIS]).

- Test harness notes: Run within a kernel driver codebase including the provided file; verify cross-function tracking (allocation in probe, use in get_survey).

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Intentional raw byte buffers later cast and managed with custom size logic; mitigate by requiring indexed field access consistent with struct type.
- Pointer types to 1-byte elements; mitigate by checking sizeof(element) > 1.
- Cases where allocation size equals count but later a separate buffer maps to actual struct storage; mitigate by requiring dataflow from the allocation to the field access.
- Reads that appear uninitialized but are preceded by writes in other unmodeled paths; mitigate by conservative path analysis and suppress when any dominating initialization is detected.

8. Limitations & Assumptions
- The exact definition and size of struct wcn36xx_chan_survey is not present in [FILE_CONTENT]; the checker assumes CodeQL can resolve sizeof for struct types in the full codebase.
- Precise determination of uninitialized reads may be limited by path explosion and concurrency; the plan assumes a best-effort intra/inter-procedural dataflow.
- The checker relies on recognition of kernel allocation APIs; availability of such models is assumed based on [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF].
- Index range safety beyond local checks (e.g., external inputs) is not determinable solely from provided materials.