1. Plan Summary
Detect kernel allocations that allocate an array of structs with kmalloc-like APIs using only the element count (not count * sizeof(element)), which are later accessed via array indexing, leading to heap out-of-bounds and potential uninitialized reads (as seen in wcn36xx chan_survey).

2. Detection Steps
1) Step 1: Identify allocation calls whose objective is to allocate memory that will hold multiple elements. Signals: call expressions to devm_kmalloc or kmalloc-like APIs where the returned pointer is assigned to a variable or struct field of non-byte pointer type T* (e.g., struct foo*).

2) Step 2: Filter out correctly sized array allocations. Signals: exclude calls to kcalloc/devm_kcalloc/kmalloc_array/devm_kmalloc_array, and exclude kmalloc calls where the size argument syntactically includes sizeof(T), sizeof(*ptr), or an equivalent scale (e.g., product with sizeof or shift by element size).

3) Step 3: Flag suspected under-sized allocations. Signals: allocations from Step 1 where the size argument is a bare “count” expression (e.g., an integer variable like n_channels or sum of counts) with no multiplication by sizeof(element), and where sizeof(T) > 1 (non-byte types).

4) Step 4: Trace the allocated pointer value to its storage target to understand subsequent uses. Signals: assignments to locals, globals, or struct fields (e.g., wcn->chan_survey) and straightforward aliases; keep a set of targets that receive the allocation result.

5) Step 5: Find array-like uses of the allocated pointer indicating multi-element access. Signals: uses of the target pointer in array indexing or pointer arithmetic followed by dereference, e.g., ptr[idx], (ptr + idx)->field, or &ptr[idx]; index must be a non-zero-capable expression (variable or non-constant).

6) Step 6: Correlate the under-sized allocation with array indexing to confirm the risk. Signals: any use from Step 5 on the same pointer/field collected in Step 4 establishes that the pointer is treated as an array of T, making the bare “count” size from Step 3 suspect for heap OOB.

7) Step 7: Prioritize cases where the index can range over a count-like domain. Signals: indices derived from parameters or local variables used as positions (e.g., idx) and especially when the size expression (Step 3) is itself a “count” variable (e.g., sum of two counts), even if control-flow bounds aren’t provably enforced.

8) Step 8: Detect potential uninitialized reads when non-zeroing allocators are used. Signals: for targets allocated via kmalloc/devm_kmalloc, find first field reads of ptr[idx].field where no dominating write to that field on that element is observed along the path from allocation (in the same function or straightforward interprocedural call/return).

9) Step 9: Suppress obvious non-issues to reduce noise. Signals: exclude T being char/unsigned char/byte-sized; exclude cases where only ptr[0] is accessed; exclude cases where a memset/memset-like zeroing or explicit write to the relevant fields dominates every read site.

10) Step 10: Report with contextual evidence to aid triage. Signals: include the allocation site (API and size expression), the inferred element type T, and at least one array-indexing use that demonstrates multi-element access.

3. Limitations & Assumptions
- Assumes the element type T is available to the analyzer (headers included) to check sizeof(T) > 1; otherwise, the checker may conservatively skip uncertain types.
- Interprocedural dataflow is limited to straightforward assignments and uses; complex aliasing or indirect stores may cause misses or false negatives.
- Determining definite uninitialized-use paths is best-effort; the checker focuses on clear cases without intervening writes and may not capture all control-flow nuances.
- The plan generalizes beyond devm_kmalloc to kmalloc-like APIs; environment-specific wrappers not present in the provided materials are not covered.
- The checker cannot prove at compile time that index ranges exceed the under-sized allocation; it flags patterns strongly indicative of the bug class (count-only allocation + array use).