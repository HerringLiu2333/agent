1. Plan Summary
Detect kernel allocations that under-size arrays of structs by using an element count as the byte size (instead of count × sizeof(element)), and optionally highlight subsequent reads from uninitialized elements when non-zero-initializing allocators are used.

2. Detection Steps
1) Step 1: Identify allocations via devm_kmalloc/kmalloc-like APIs whose size argument is a single count variable (e.g., n_channels) rather than an expression involving sizeof(T) or multiplication. Signal: call expressions to devm_kmalloc/kmalloc where the size parameter is a variable and not a product or sizeof-based computation.

2) Step 2: Filter to allocations where the result is stored in a typed pointer to a non-trivial struct type (e.g., struct wcn36xx_chan_survey*), not a byte buffer (char*/void*). Signal: assignment or initialization of a pointer with pointee type being a struct.

3) Step 3: Confirm the pointer is used as an array of elements (not a single element). Signal: subsequent indexed access like ptr[i] or ptr[i].field, or pointer arithmetic with an index to access multiple elements.

4) Step 4: Strengthen array intent by linking the index range to the same count variable used in the allocation size. Signal: for-loops or bounds checks using the count variable (e.g., i < n_channels) when accessing ptr[i].

5) Step 5: Flag under-allocation when a struct pointer allocated via devm_kmalloc/kmalloc uses only the count as size and is then indexed as if it contained count elements. Signal: absence of sizeof(struct) in the size computation combined with array-style usage across multiple indices.

6) Step 6: Optionally detect safer allocation intent: if the same site later computes sizes using sizeof(struct) or uses kcalloc elsewhere for similar arrays, highlight inconsistency to reduce false negatives. Signal: similar variables or allocation sites allocating arrays of the same type with sizeof(T) × count or kcalloc.

7) Step 7: Identify potential uninitialized-use risks when non-zero-initializing allocators are used (kmalloc/devm_kmalloc) for arrays of structs. Signal: allocation via kmalloc/devm_kmalloc for a struct* array without immediate bulk initialization (memset/for-loop writes to all elements) before reads.

8) Step 8: Trace reads from fields of array elements to ensure they can occur without a dominating write on all paths. Signal: a read of ptr[i].field in any function after allocation where there is no preceding write to ptr[i].field on all control-flow paths (e.g., reporting or aggregation reads when no frames were processed).

9) Step 9: Prioritize findings where both issues co-occur (under-sized allocation and potential uninitialized read), as these match the CVE’s root cause and impact. Signal: combined presence of Steps 5 and 8 at or near the same allocation site.

3. Limitations & Assumptions
- Assumes kmalloc/devm_kmalloc are non-zero-initializing; the plan does not enumerate all kernel allocator variants beyond those mentioned.
- The checker infers “count variable” heuristically (e.g., loop bounds or naming); it may misclassify size expressions that are computed elsewhere or through macros.
- Static analysis may not reliably prove all-paths initialization of struct fields; uninitialized-read detection is best-effort and may yield false positives/negatives.
- Precise struct size may not be available for cross-translation-unit analysis; the plan treats any struct type as larger than 1 byte, which may not hold for atypical cases.
- Concurrency, device-managed lifetimes, and conditional initialization dependent on runtime events (e.g., “no frames on the channel”) are not fully modeled.