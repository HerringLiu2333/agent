1. CVE Identifier
CVE-2024-57997

2. Vulnerability Type
- Heap buffer overflow (undersized allocation for array of structs)
- Use of uninitialized heap memory (secondary effect)

3. Root Cause Summary
The driver allocated memory for an array of struct wcn36xx_chan_survey using devm_kmalloc with the element count (n_channels) as the size instead of n_channels * sizeof(struct wcn36xx_chan_survey). This under-allocates the buffer, causing out-of-bounds writes/reads when indexing per-channel survey data. Additionally, using kmalloc left the buffer uninitialized, leading to potential use of uninitialized values when channels had no frames.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking, Qualcomm Atheros wcn36xx driver (drivers/net/wireless/ath/wcn36xx)

2) Pre-Patch Flaw:
- In wcn36xx_probe(), the code allocated the survey array with: devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL); instead of allocating n_channels elements of struct wcn36xx_chan_survey.
- The buffer was not zero-initialized, so fields could be read before being set when no frames were received on a channel.

3) Trigger Condition:
- Any path that indexes wcn->chan_survey by channel (e.g., tracking SNR/RSSI per RX frame added by “wcn36xx: Track SNR and RSSI for each RX frame”) or reporting survey data, after probe initializes the array with the undersized allocation.

4) Impact Mechanism:
- Out-of-bounds heap accesses when accessing chan_survey[i] beyond the mistakenly allocated n_channels bytes, leading to memory corruption and potential kernel crashes.
- Reading uninitialized fields from the survey array could propagate undefined/bogus values (and potentially expose stale data) when no frames have been seen on a channel.

5. Patch Analysis
1) Fix Approach:
- Correct the allocation to account for element size and ensure zero-initialization by switching to devm_kcalloc with n_channels and sizeof(struct wcn36xx_chan_survey).

2) Key Code Changes:
- Replaced:
  - wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);
- With:
  - wcn->chan_survey = devm_kcalloc(wcn->dev, n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL);
- This fixes the size miscalculation and initializes memory to zero to avoid uninitialized use.

3) Locking/Concurrency Impact:
- None. The change is limited to allocation during probe; no locking semantics or ordering were modified.

6. Broader Kernel Security Implications
- Highlights a common and severe class of bugs: array allocations using element count instead of count * sizeof(element), leading to heap overflows.
- Reinforces best practices to use kcalloc for array allocations to both compute sizes safely and obtain zeroed memory, reducing risks of both OOB and uninitialized-use bugs.
- Validates the usefulness of KASAN for detecting such memory errors early in development/testing.