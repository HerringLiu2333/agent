1. CVE Identifier
CVE-2024-57997

2. Vulnerability Type
Heap buffer overflow (under-allocation) with potential uninitialized memory use

3. Root Cause Summary
The driver allocated wcn->chan_survey with devm_kmalloc using only the number of channels (n_channels) as the size, instead of n_channels multiplied by sizeof(struct wcn36xx_chan_survey). This miscalculation under-allocates the array and leaves its contents uninitialized. Subsequent per-channel survey updates (tracking SNR/RSSI per RX frame) write into struct fields, causing out-of-bounds writes beyond the allocated buffer and/or reading uninitialized values when no frames have been observed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm wcn36xx WiFi driver (drivers/net/wireless/ath/wcn36xx), function wcn36xx_probe

2) Pre-Patch Flaw:
In wcn36xx_probe, the array allocation was: “wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);” which allocates only n_channels bytes. The code intended an array of struct wcn36xx_chan_survey of length n_channels, but failed to multiply by the element size and did not zero-initialize the array.

3) Trigger Condition:
When the driver initializes or updates channel survey data per channel (as introduced by “wcn36xx: Track SNR and RSSI for each RX frame”), any access to wcn->chan_survey[i] writes/reads struct fields, immediately exceeding the allocated size if sizeof(struct wcn36xx_chan_survey) > 1. Additionally, reading survey contents without prior frames leads to use of uninitialized memory.

4) Impact Mechanism:
- Out-of-bounds writes on the heap (slab) corrupt adjacent kernel memory, detected by KASAN. 
- Uninitialized reads can propagate bogus measurements and potentially leak stack/slab contents through telemetry or cause undefined behavior. 
- Memory corruption risks include crashes, data corruption, or further exploitable conditions in the kernel.

5. Patch Analysis
1) Fix Approach:
Replace the incorrect kmalloc with kcalloc to correctly allocate n_channels elements of struct wcn36xx_chan_survey and zero-initialize them, eliminating both under-allocation and uninitialized use.

2) Key Code Changes:
- Pre-patch: “wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);”
- Post-patch: “wcn->chan_survey = devm_kcalloc(wcn->dev, n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL);”
This change fixes size computation (count × element size) and ensures initial zero state.

3) Locking/Concurrency Impact:
None. The change is confined to allocation semantics in probe; it does not alter locking, ordering, or concurrency behavior.

6. Broader Kernel Security Implications
Size miscalculations in array allocations are a common and severe class of bugs in kernel drivers, leading to heap overflows and memory corruption. Using kcalloc for arrays enforces correct size computation and mitigates uninitialized memory issues, improving robustness. This fix highlights the need for systematic audits of allocation patterns in drivers, especially where per-object arrays are indexed by runtime counts (e.g., channels, queues, stations).