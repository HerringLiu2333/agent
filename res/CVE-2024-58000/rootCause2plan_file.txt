1. Plan Summary
Detect user-controlled indices used to access kernel arrays without speculation-safe clamping (array_index_nospec), focusing on io_uring-style “offset into pre-mapped region” patterns.

2. Detection Steps
1) Step 1: Objective: Identify functions that accept user-provided pointers or indices. Signals: Parameters typed as __user pointers or variables set from casts like (uintptr_t)uarg; evidence from io_get_ext_arg_reg using const struct io_uring_getevents_arg __user *uarg and offset = (uintptr_t)uarg [FILE_CONTENT, ROOTCAUSE_ANALYSIS]. FP mitigation: Require the source to be an explicit __user parameter or derived from a user API call context (e.g., io_uring_enter flags).

2) Step 2: Objective: Taint-mark index-like variables derived from these user inputs. Signals: Assignments, arithmetic, or copies propagating from user inputs to variables named offset/head/index; the ext-arg case computes offset and end and then uses offset further [FILE_CONTENT]. FP mitigation: Stop taint if value is sanitized through array_index_nospec.

3) Step 3: Objective: Find kernel array/pointer bases being indexed via these tainted values. Signals: Pointer arithmetic base + index or base[index] where base is a field of a kernel struct (e.g., ctx->cq_wait_arg) or a kernel-managed mapping; io_get_ext_arg_reg returns ctx->cq_wait_arg + offset [FILE_CONTENT]. FP mitigation: Exclude bases known to be user memory or unrelated temporary buffers.

4) Step 4: Objective: Detect presence of architectural bounds checks without speculation-safe clamping. Signals: Preceding checks like alignment (offset % sizeof(long)), sum overflow checks (check_add_overflow(offset, size, &end)), and comparisons against region size (end > ctx->cq_wait_size), but no array_index_nospec before the indexing/return [FILE_CONTENT, ROOTCAUSE_ANALYSIS]. FP mitigation: Only flag when one of these bounds checks exists, to avoid generic indexing that may already be safe via other mechanisms.

5) Step 5: Objective: Determine absence of array_index_nospec-style mitigation right before the sink. Signals: No call that clamps the tainted index using array_index_nospec(index, bound) between the bounds check and the use/return; patch adds offset = array_index_nospec(offset, ctx->cq_wait_size - size) [PATCH_DIFF, PATCH_DESCRIPTION]. FP mitigation: If array_index_nospec is applied to the same variable prior to use, do not report.

6) Step 6: Objective: Ensure the mitigation bound accounts for structure size when applicable. Signals: When code checks offset + sizeof(T) <= capacity, verify the corresponding mitigation (if present) uses capacity - sizeof(T) as the bound, per “truncate by maximum offset allowed considering the structure size” [PATCH_DESCRIPTION]. FP mitigation: Only warn on mitigation misconfiguration when both a size variable and capacity are explicitly present (as in io_get_ext_arg_reg with size and ctx->cq_wait_size).

7) Step 7: Objective: Flag pointer-return patterns as vulnerable even if dereference is outside the function. Signals: Sinks where the function returns base + tainted index (like ctx->cq_wait_arg + offset) without nospec clamping [FILE_CONTENT, ROOTCAUSE_ANALYSIS]. FP mitigation: Require that the base belongs to a kernel-managed region (e.g., ctx->cq_wait_arg and ctx->cq_wait_size) to avoid benign pointer math.

8) Step 8: Objective: Highlight contrasting safe patterns to reduce noise. Signals: Recognize safe use of array_index_nospec in similar contexts (e.g., io_get_sqe uses head = array_index_nospec(head, ctx->sq_entries)) to avoid flagging compliant code [FILE_CONTENT]. FP mitigation: Treat any analogous code with nospec as non-issues.

9) Step 9: Objective: Prioritize cases tied to io_uring ENTER_EXT_ARG_REG flow. Signals: Code paths guarded by flags like IORING_ENTER_EXT_ARG_REG and structures like io_uring_reg_wait; tainted index computed from these flows [FILE_CONTENT, ROOTCAUSE_ANALYSIS]. FP mitigation: Restrict alerts to code inside or immediately downstream of these APIs for higher precision.

3. Target Elements
- Functions handling __user pointers/arguments (e.g., io_get_ext_arg_reg).
- Variables derived from user pointers cast to integers (offset, index).
- Bounds check constructs (alignment modulo checks, check_add_overflow, comparisons against region sizes).
- Pointer arithmetic/index operations into kernel arrays or regions (base + index, base[index]).
- Presence/absence of array_index_nospec calls near these sinks.
- Flags and code paths for ENTER_EXT_ARG_REG/extended argument handling.

4. Dataflow / Taint Considerations
- Taint sources: __user parameters, integers derived from user pointers (uintptr_t casts), or values pulled from user-provided structs in io_uring_enter flows.
- Propagation: Simple assignments and arithmetic (add, sub, modulo) to index variables.
- Sinks: Pointer arithmetic or indexing into kernel-managed buffers/arrays; returning such pointers.
- Sanitizers: array_index_nospec applied to the same tainted index variable.

5. Validation & Test Cases
- Positive: Pre-patch io_get_ext_arg_reg where offset is from (uintptr_t)uarg, bounds checked, then used as ctx->cq_wait_arg + offset without array_index_nospec; expect a finding [FILE_CONTENT, ROOTCAUSE_ANALYSIS].
- Negative: Post-patch io_get_ext_arg_reg with offset = array_index_nospec(offset, ctx->cq_wait_size - size) immediately before use; expect no finding [PATCH_DIFF].
- Negative: io_get_sqe uses head = array_index_nospec(head, ctx->sq_entries) before accessing sq_sqes; expect no finding [FILE_CONTENT].
- Test harness notes: Run on the provided file contents; inject a minimal mock of __user and array_index_nospec symbol resolution for context.

6. Estimated Effort & Priority
High.

7. Likely False-Positive Sources & Mitigations
- Index derived from kernel-only values mistakenly marked tainted; mitigate by requiring __user origin or io_uring_enter extended-arg flow context.
- Bases that are user-space mappings rather than kernel arrays; mitigate by checking base ownership (struct fields like ctx->cq_wait_arg and associated size).
- Sanitization via other nospec-safe primitives; mitigate by treating array_index_nospec-equivalent clamps as safe.

8. Limitations & Assumptions
- Assumes availability of __user annotations and recognition of array_index_nospec; if missing, classification may be weaker.
- Cannot prove speculative execution risk beyond absence of nospec; relies on kernel hardening conventions stated in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].
- Does not fully verify subsequent dereferences of returned pointers; flags the pattern at pointer computation/return as per [ROOTCAUSE_ANALYSIS].