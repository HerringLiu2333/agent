1. Plan Summary
Detect cases where a user-controlled offset/index is architecturally bounds-checked and then used to index into a kernel array/pointer without speculative-execution sanitization (e.g., missing array_index_nospec), as in the pre-patch io_get_ext_arg_reg pattern.

2. Detection Steps
1) Step 1: Objective: Identify user-controlled index sources. Signals: function parameters annotated as __user or pointers cast to integer (e.g., uintptr_t) used as an offset, as in uarg in io_get_ext_arg_reg (from FUNCTION_CONTENT); FP mitigation: restrict to kernel code paths and to values explicitly originating from __user inputs.
2) Step 2: Objective: Track taint from the user-controlled value to an index variable. Signals: dataflow through casts, assignments, and arithmetic into a variable later named/used as offset or similar (offset/end in FUNCTION_CONTENT); FP mitigation: limit to intra-procedural flows to reduce noise, and require direct derivation within the function.
3) Step 3: Objective: Recognize the architectural bounds-check idiom. Signals: checks such as alignment (offset % sizeof(long)), overflow check (check_add_overflow), and comparison of end against a region-size field (end > ctx->cq_wait_size) as shown in FUNCTION_CONTENT; FP mitigation: require at least one explicit comparison to a known size field of the same object used as the base pointer.
4) Step 4: Objective: Identify the “kernel array base + size” pair. Signals: a pointer field (e.g., ctx->cq_wait_arg) paired with a size field (e.g., ctx->cq_wait_size) referenced in the same function (from FUNCTION_CONTENT/ROOTCAUSE_ANALYSIS); FP mitigation: confirm both fields belong to the same struct instance (ctx->...) and are used together in checks.
5) Step 5: Objective: Detect the indexing/pointer arithmetic sink. Signals: pointer addition of the tainted offset to the kernel base pointer (ctx->cq_wait_arg + offset) and use as a pointer value (e.g., returned pointer) as in FUNCTION_CONTENT; FP mitigation: ensure the tainted offset directly contributes to address calculation of a kernel-owned region pointer.
6) Step 6: Objective: Ensure control-flow ordering “checks then use.” Signals: the sink (pointer arithmetic) is reachable after the bounds checks (dominance/postdomination in the current function); FP mitigation: require that at least one path to the sink passes through the size comparison guarding the region.
7) Step 7: Objective: Verify lack of speculative-execution sanitization. Signals: absence of any call that sanitizes the index (e.g., array_index_nospec) on the tainted value between the bounds check and the sink (contrast with PATCH_DIFF adding offset = array_index_nospec(...)); FP mitigation: treat any assignment to the index from the return of array_index_nospec with a matching limit as mitigation and do not flag.
8) Step 8: Objective: Check for correct limit derivation context. Signals: presence of an element-size variable (sizeof(struct ...)) used in the bounds computation (end = offset + size, compare with ctx->cq_wait_size), as in FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS; FP mitigation: boost confidence when such size is present, but do not require it strictly to avoid missing variants.
9) Step 9: Objective: Confirm the pointer is kernel-internal, not user memory. Signals: the base pointer is a field of a kernel context struct (ctx->...), not derived from __user or copy_from_user; FP mitigation: exclude cases where the base itself is user memory or an alias of a __user pointer.
10) Step 10: Objective: Elevate confidence when the computed pointer is used meaningfully. Signals: the computed address is returned (as in FUNCTION_CONTENT) or dereferenced/passed to functions expecting kernel struct pointers; FP mitigation: deprioritize or suppress when the computed pointer is never used or only used in debug/logging.

3. Target Elements
- Functions taking __user parameters or user-controlled pointers/integers.
- Variable assignments/casts deriving an offset/index from user input.
- Conditional checks comparing offset+size against a region size field.
- Calls to check_add_overflow and similar overflow checks.
- Pointer arithmetic expressions base + offset forming a kernel address.
- Calls (or absence) to array_index_nospec applied to the index.
- Return statements and dereferences using the computed pointer.

4. Dataflow / Taint Considerations
- Treat __user parameters and values cast from them (e.g., uintptr_t from a __user pointer) as taint sources.
- Propagate taint through arithmetic (+, -, casts) and assignments to offset/end.
- Model guards: bounds checks (overflow check and end <= size) do not sanitize taint for speculation purposes.
- Sinks are address computations where a tainted index is added to a kernel base pointer used/returned.
- Sanitizers: array_index_nospec applied to the tainted index with a limit derived from the region size (as per PATCH_DIFF/ROOTCAUSE_ANALYSIS).

5. Validation & Test Cases
- Positive: Pre-patch io_get_ext_arg_reg that casts __user uarg to offset, performs overflow/size checks, and returns ctx->cq_wait_arg + offset with no array_index_nospec (from FUNCTION_CONTENT); expect a finding.
- Negative: Post-patch variant with offset = array_index_nospec(offset, ctx->cq_wait_size - size) before returning (from PATCH_DIFF); expect no finding.
- Negative: A function where the index is kernel-internal (not from __user) but otherwise similar checks exist; expect no finding.
- Test harness notes: Validate control-flow sensitivity (checks before use), taint propagation from __user, recognition of array_index_nospec as a sanitizer, and pairing of base pointer with its size field.

6. Estimated Effort & Priority
High priority; medium effort. Requires taint tracking, control-flow ordering, and recognition of kernel idioms (per ROOTCAUSE_ANALYSIS and PATCH_DIFF).

7. Likely False-Positive Sources & Mitigations
- Bounds-checked indices not derived from user input; mitigate by requiring __user origin.
- Cases where a different speculation barrier is used; mitigate by optionally whitelisting known barrier helpers if identifiable.
- Address computations that are never used/dereferenced; mitigate by requiring return/use as a kernel pointer.
- Bases that alias user memory; mitigate by excluding bases derived from __user or copy_from_user.

8. Limitations & Assumptions
- Assumes availability of __user annotations and ability to distinguish kernel-owned pointers from user memory.
- Cannot determine all equivalent speculation barriers beyond array_index_nospec from the provided materials.
- Does not verify the exact limit correctness (e.g., size subtraction) beyond presence/absence of nospec, as only the need for nospec is evidenced (PATCH_DIFF, ROOTCAUSE_ANALYSIS).
- Interprocedural uses of the computed pointer (later dereferences) may be missed if analysis is intra-procedural.