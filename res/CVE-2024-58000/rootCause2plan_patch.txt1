1. Plan Summary
Detect Spectre v1 gadgets where a user-controlled offset indexes a kernel array/region after a bounds check without array_index_nospec, or with an incorrect nospec upper bound that ignores the accessed structure size.

2. Detection Steps
1) Step 1: Identify candidate address computations. Look for pointer arithmetic or indexing that forms an address into a kernel array/region, e.g., base + offset or base[offset], then used or returned.
2) Step 2: Determine if the offset is user-controlled. Track dataflow to the offset from user-provided inputs in this path (the vulnerability description states the user can specify an offset for the wait argument region).
3) Step 3: Find preceding range checks constraining the offset span. Look for code computing end = offset + size (size equals the structure size used for the argument) and comparing end against a region size (e.g., end > region_size triggers an error), or equivalent checks on [offset, offset + size).
4) Step 4: Confirm control flow that uses the offset after the check. Ensure the address computation (base + offset) is reachable only after the explicit bounds check succeeds.
5) Step 5: Check for missing array_index_nospec before the address use. Flag if there is no application of array_index_nospec (or equivalent nospec masking) to the offset between the bounds check and the address computation.
6) Step 6: If array_index_nospec exists, verify the sanitized value is actually used. Ensure the pointer arithmetic uses the result of array_index_nospec rather than the original offset; flag if the original offset still flows into the address.
7) Step 7: Validate correctness of the nospec upper bound when a structure size is enforced. If the code validated offset + size <= region_size, then require array_index_nospec’s upper bound to dataflow from (region_size - size); flag if it uses the full region_size or a value not accounting for subtracting size.
8) Step 8: Correlate region_size and base consistency. Verify that the region_size used in checks and in the nospec bound refers to the same region as the base pointer being indexed; flag if the nospec bound is derived from an unrelated size.
9) Step 9: Exclude trivially safe cases. Do not report when the offset is a constant, provably non-user-controlled, or when an equivalent speculation barrier on the index is present prior to the address use.

3. Limitations & Assumptions
- Assumes the analysis can model “user-controlled” offsets; the materials state the offset is user-specified but do not enumerate all kernel taint sources.
- Assumes the checker can identify the structure size used by the bounds check (e.g., a sizeof or “size” variable) and relate it to the nospec bound; mismatches may be hard to confirm when expressions are opaque.
- Distinguishing kernel arrays/regions from user-mapped pointers may be imprecise without broader context; the plan relies on dataflow and consistency between base, region_size, and checks.
- Does not verify microarchitectural behavior; it flags code patterns susceptible to speculative OOB access per the described root cause.
- Equivalent mitigations (if any) other than array_index_nospec are not detailed in the materials; the checker may miss or misclassify such cases.