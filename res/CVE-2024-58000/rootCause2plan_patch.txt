1. Plan Summary
Detect Spectre v1-style gadgets where a user-controlled offset indexes into a kernel array/region after a bounds check but without array_index_nospec, or with an incorrect nospec limit that fails to account for the accessed structure size.

2. Detection Steps
1) Step 1: Objective: find pointer arithmetic or array indexing into kernel-resident arrays/regions using a variable offset. Signals: expressions like base + offset or base[offset], where base is a pointer/array field and offset is a non-constant variable used to compute an address that is then returned or dereferenced (as in ctx->cq_wait_arg + offset from [PATCH_DIFF]). FP mitigation: require that base has an associated “size/capacity” variable in scope (e.g., ctx->cq_wait_size as in [PATCH_DIFF]).

2) Step 2: Objective: identify whether the offset is user-controlled. Signals: dataflow/taint from external inputs consistent with “user can specify an offset” and “user given index” (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]), e.g., function parameters or values derived from user-facing APIs used to compute offset. FP mitigation: require a taint path from a user-influenced source to offset, and exclude offsets proven to be constant or bounded by compile-time constants.

3) Step 3: Objective: detect explicit pre-use bounds checks of the form end = offset + size; if (end > capacity) error. Signals: computation of an intermediate end (or equivalent expression) as offset plus a structure size, and comparison against a capacity/region size with an error path (per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: ensure the guard dominates the pointer arithmetic in control flow (i.e., the addressing happens only in the guarded “ok” branch).

4) Step 4: Objective: check for absence of array_index_nospec on the offset before it is used for addressing. Signals: lack of any assignment offset = array_index_nospec(offset, …) (or equivalent) along the path between the guard and the pointer arithmetic, specifically mirroring the addition in [PATCH_DIFF]. FP mitigation: suppress if array_index_nospec has been applied to the exact offset used in the address computation in the same basic block or dominating block.

5) Step 5: Objective: report missing-nospec cases as Spectre v1 gadgets. Signals: combination of Steps 1–4: user-controlled offset, guarded by a bounds check using offset + size <= capacity, then used for base + offset or base[offset] without prior array_index_nospec (as described in [ROOTCAUSE_ANALYSIS]). FP mitigation: additionally require a subsequent memory action (returning the computed pointer, dereferencing it, or copying from/to it) to avoid benign patterns.

6) Step 6: Objective: validate correctness of nospec limit if array_index_nospec is present. Signals: presence of array_index_nospec(offset, limit) and earlier end = offset + size; check whether limit equals capacity - size rather than capacity, matching “truncate by the maximum offset allowed considering the structure size” (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation: require that size in the end computation is the same symbol used to constrain the range; if size cannot be identified, do not flag this subcase.

7) Step 7: Objective: ensure the sanitized offset is the one used in the address computation. Signals: dataflow from the result of array_index_nospec to the offset used in base + offset or base[offset] (as in the patched assignment in [PATCH_DIFF]). FP mitigation: if the sanitized result is dead or a different unsanitized alias is used in the address computation, report; if the sanitized value dominates and is used, suppress.

8) Step 8: Objective: prioritize likely kernel fixed-region patterns to improve precision. Signals: fields/variables co-occurring with “size/capacity” siblings (e.g., foo and foo_size) and naming patterns reflecting fixed regions (e.g., “wait”, “reg”, “arg”) similar to ctx->cq_wait_arg and ctx->cq_wait_size (per [PATCH_DIFF]). FP mitigation: use naming/coupling only as a ranking heuristic; do not hard-filter on names to avoid missing variants.

9) Step 9: Objective: detect pointer-return gadgets similar to io_get_ext_arg_reg. Signals: function returns a computed pointer base + offset after the guard (as in [PATCH_DIFF] return ctx->cq_wait_arg + offset). FP mitigation: ensure the returned pointer is based on a user-controlled offset into a kernel region with a capacity variable.

10) Step 10: Objective: consolidate findings and reduce duplicates. Signals: multiple address computations in the same function with the same base/offset pattern; group under a single report with the primary site being the address computation. FP mitigation: collapse duplicate reports within a function and prefer the first unsafe use site.

3. Target Elements
- Functions computing or returning pointers via base + offset or base[offset].
- Condition checks comparing offset + size against a capacity/size variable and error paths.
- Calls (or absence) of array_index_nospec and their arguments.
- Pointer dereferences, memcopy/memset operations, and return statements using computed addresses.
- Struct fields representing buffers/regions and corresponding size/capacity fields.

4. Dataflow / Taint Considerations
- Track taint from user-controlled inputs to the offset variable (as per “user can specify an offset” from [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
- Track computation of end = offset + size (or equivalent) and the comparison to a capacity variable.
- Track whether array_index_nospec is applied to the offset and whether its result flows to the address computation.
- Track the variables representing size (structure size of the accessed element) and capacity (region size) to validate correct nospec limit (capacity - size).

5. Validation & Test Cases
- Positive: Code that computes end = offset + size; checks end <= capacity; returns base + offset or dereferences base + offset; offset is user-controlled; no array_index_nospec applied.
- Positive: Code that applies array_index_nospec(offset, capacity) while the guard uses end = offset + size <= capacity (incorrect limit), then uses base + offset.
- Negative: Patched pattern where offset = array_index_nospec(offset, capacity - size) is used before base + offset (as in [PATCH_DIFF]).
- Negative: Code where offset is fully derived from constants or provably in-range independent of user input.
- Test harness notes: Ensure control-flow sensitivity to match guards dominating uses; ensure dataflow ties array_index_nospec’s result to the actual addressing expression.

6. Estimated Effort & Priority
High priority; medium effort (requires taint tracking, control-flow dominance, and relational reasoning between guard expressions and nospec limits).

7. Likely False-Positive Sources & Mitigations
- Offsets not actually user-controlled: mitigate by requiring taint from user input as per [ROOTCAUSE_ANALYSIS].
- Alternative speculation mitigations not modeled: mitigate by only recognizing array_index_nospec per [PATCH_DESCRIPTION]/[PATCH_DIFF].
- Complex macros/inlines obscuring end/limit relationships: mitigate by requiring clear identification of size and capacity symbols; otherwise do not flag the “incorrect limit” subcase.
- Cases where base is not kernel-resident or no real memory access happens: mitigate by requiring dereference, memcpy/memset, or pointer return used by callers.

8. Limitations & Assumptions
- The plan assumes availability of a user-taint model to identify user-controlled offsets; the provided materials confirm user control but not precise sources.
- Inferring the “structure size” (size) used in end = offset + size may be non-trivial when hidden behind macros; detection of incorrect nospec limit relies on matching this symbol.
- The plan focuses on the specific mitigation array_index_nospec as per [PATCH_DIFF]; other valid mitigations (if any) are not considered due to lack of evidence.
- Determining that base points to kernel memory/“fixed region” is approximated via structural/contextual cues; exact classification may be imperfect.