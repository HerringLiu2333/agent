1. Plan Summary
Detect uses of user-controlled indices to compute kernel array addresses without speculative execution mitigation (array_index_nospec), even when a normal bounds check is present.

2. Detection Steps
1) Step 1: Identify user-controlled index candidates — track integer variables derived from __user pointers (e.g., casting a __user pointer to an integer) or values copied from userspace; model dataflow from such sources to local variables (e.g., “offset” from (uintptr_t)uarg).
2) Step 2: Find kernel array/pointer addressing sites — locate expressions that compute an address via array indexing or pointer arithmetic using the candidate index (e.g., base + offset, &base[offset], base[offset]).
3) Step 3: Ensure base is kernel memory, not userspace — require the base pointer/array is not annotated __user and is a field or variable originating from a kernel struct/context (e.g., a member like ctx->cq_wait_arg).
4) Step 4: Correlate with region-size bounds — within the same function, detect a bounds check that constrains the candidate index against a region size (e.g., computing end = offset + size and checking end <= region_size or similar), indicating architectural bounds checking was attempted.
5) Step 5: Link base and bounds — prefer cases where both the base pointer and the region size come from the same kernel object (e.g., ctx->cq_wait_arg with ctx->cq_wait_size) to increase confidence that the offset is intended as an index into that region.
6) Step 6: Require index is used post-check — ensure the candidate index flows through the checked path and is subsequently used in the address computation (avoid paths where the check leads to early error return and no use).
7) Step 7: Check for speculative-mitigation absence — on the path from the index source to the address computation, confirm there is no array_index_nospec applied to the index (e.g., no assignment like idx = array_index_nospec(idx, bound) or equivalent use).
8) Step 8: Validate appropriate bound is available — ensure that the code has a natural upper bound usable for nospec (e.g., region_size or region_size - size of accessed structure) in scope; this mirrors the fixed pattern (ctx->cq_wait_size - size).
9) Step 9: Exclude already-mitigated cases — do not flag when array_index_nospec is present using the candidate index, or when the index passed to the address computation demonstrably derives from an array_index_nospec result.
10) Step 10: Prioritize high-confidence matches — raise severity when all of: index from __user pointer cast, explicit overflow/limit check (e.g., check_add_overflow + end > region_size), base and size from same object, and direct base + offset usage are observed.
11) Step 11: Report precise sink and dataflow — for findings, highlight the address computation site (e.g., return base + offset) and summarize the dataflow from the user-controlled source to the sink without nospec sanitization, plus the nearby bounds check context.
12) Step 12: Provide remediation hint — suggest inserting array_index_nospec(index, max_allowed_offset) before the address computation, with max_allowed_offset reflecting the region size minus the accessed structure size where applicable.

3. Limitations & Assumptions
- Assumes CodeQL can recognize __user annotations and track dataflow from userspace inputs; alternative untrusted sources not annotated as __user may be missed.
- Assumes availability of a region size variable and that it is lexically/semantically associated with the base pointer; cases without an explicit region size check may be skipped to reduce false positives.
- Only array_index_nospec is treated as a valid mitigation; other equivalent mitigations (if any exist) are not modeled due to lack of evidence.
- The checker infers “structure size” usage from patterns like end = offset + sizeof(struct…) but cannot verify correctness of the exact bound (e.g., ctx->cq_wait_size - size) without full semantic modeling.