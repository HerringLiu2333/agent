1. CVE Identifier
CVE-2024-58086

2. Vulnerability Type
Use-after-free due to stale pointer (lifetime management bug)

3. Root Cause Summary
In v3d_perfmon_destroy_ioctl(), the driver destroyed a perfmon without checking whether it was currently active (v3d->active_perfmon). The function removed the perfmon from the IDR and immediately called v3d_perfmon_put(perfmon), potentially freeing it while v3d->active_perfmon still pointed to the same object. This left v3d->active_perfmon as a dangling pointer, enabling subsequent dereferences of freed memory and undefined behavior. The patch adds a check and stops the active perfmon before releasing it, preventing a stale pointer and ensuring proper teardown.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM V3D (Broadcom V3D GPU) performance monitor handling (drivers/gpu/drm/v3d/v3d_perfmon.c)

2) Pre-Patch Flaw:
v3d_perfmon_destroy_ioctl() unconditionally called v3d_perfmon_put(perfmon) after IDR removal, with no guard to stop and clear v3d->active_perfmon if the perfmon being destroyed was active. This mismatch in lifetime management between per-file perfmon objects and the device-level active pointer caused a dangling pointer.

3) Trigger Condition:
Userspace issues the destroy ioctl for a perfmon that is currently active (perfmon == v3d->active_perfmon). The function removes the perfmon from the IDR, unlocks, and frees it via v3d_perfmon_put() while the device’s active pointer remains set.

4) Impact Mechanism:
The device’s v3d->active_perfmon becomes stale and may be dereferenced by subsequent operations expecting a valid active perfmon, leading to use-after-free, undefined behavior, or system instability. Additionally, hardware performance monitoring may continue without a valid backing object until explicitly stopped elsewhere.

5. Patch Analysis
1) Fix Approach:
Introduce a check to detect when the perfmon being destroyed is the active perfmon and proactively stop it before releasing its reference. This ensures the active pointer is cleared and hardware monitoring is halted prior to freeing.

2) Key Code Changes:
- Added retrieval of the device pointer: struct v3d_dev *v3d = v3d_priv->v3d;
- Inserted conditional stop before put:
  if (perfmon == v3d->active_perfmon)
      v3d_perfmon_stop(v3d, perfmon, false);
- v3d_perfmon_put(perfmon) remains, but now executes after the active perfmon has been stopped.

3) Locking/Concurrency Impact:
No new locks were introduced; the existing mutex around IDR removal (v3d_priv->perfmon.lock) remains unchanged. The ordering is corrected: stop the active perfmon first (which is expected to clear v3d->active_perfmon) and then drop the reference, reducing the race window for dereferencing a freed active perfmon. Specific internal synchronization within v3d_perfmon_stop() is not shown; its locking behavior is unknown/not determinable from the provided context.

6. Broader Kernel Security Implications
This issue underscores the need for coordinated lifetime management between per-file objects and device-global pointers in GPU drivers. Destroy operations must handle active states to prevent dangling references and UAF. Ensuring resources are stopped/disabled before release is critical for preventing kernel memory safety violations and hardware interactions with freed structures.