1. Plan Summary
Detect IOCTL/object-destruction paths that free or decrement the last reference to an object still referenced by a device-global pointer, without first invoking the lifecycle “stop/clear” routine that nulls the global pointer, leading to a dangling pointer/use-after-free (as in v3d->active_perfmon).

2. Detection Steps
1) Step 1: Objective: Identify the device-global pointer field that tracks the “active/current” object. Conceptual signals: assignments of the form device->field = obj in a “start/enable” function and device->field = NULL in a “stop/disable” function; here v3d_perfmon_start sets v3d->active_perfmon = perfmon and v3d_perfmon_stop sets v3d->active_perfmon = NULL (based on FILE_CONTENT). FP mitigation: Require both a set-to-object and a set-to-NULL for the same field and consistent types (struct v3d_dev* to struct v3d_perfmon*), confirming a lifecycle-tracked global pointer.

2) Step 2: Objective: Identify the object’s freeing/destruction primitive. Conceptual signals: a “put” function that decrements a refcount and conditionally frees (v3d_perfmon_put calls refcount_dec_and_test then kfree) (based on FILE_CONTENT). FP mitigation: Ensure the freed type matches the global pointer’s type and the freeing path is reachable from public destroy paths.

3) Step 3: Objective: Find public destroy/remove paths that extract objects from handle maps and free them. Conceptual signals: functions that call idr_remove (or similar) to obtain an object pointer, then call the “put/free” function on that object (e.g., v3d_perfmon_destroy_ioctl removes from idr then v3d_perfmon_put) (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Require the removed object flows directly to the put/free call along some path.

4) Step 4: Objective: Check whether such destroy paths invoke the lifecycle “stop/clear” function before freeing. Conceptual signals: presence of a call to the function that sets the device-global pointer to NULL (v3d_perfmon_stop) on the same object, optionally gated by a comparison perfmon == device->active_perfmon (based on PATCH_DIFF and FILE_CONTENT). FP mitigation: Treat any call to the identified stop/clear function with the target object and the device as satisfying the condition.

5) Step 5: Objective: Flag destroy paths that free without first stopping/clearing the device-global pointer. Conceptual signals: in the same function, along a path from obtaining the object to calling the put/free, there is no prior call to the stop/clear function and no assignment that clears device->field = NULL for that object (based on ROOTCAUSE_ANALYSIS). FP mitigation: Confirm that a “start” function exists for this object/global pointer pair to reduce flagging unrelated frees.

6) Step 6: Objective: Confirm the destroy path could be operating on the “active” object. Conceptual signals: availability of the device pointer in scope (e.g., via v3d_priv->v3d or to_v3d_dev(dev)) or the ability to access device->field in the function; if the function never inspects device->field and still frees, that strengthens suspicion (based on PATCH_DIFF where obtaining v3d was added to perform the check). FP mitigation: Prefer flagging when the device pointer is available or could be easily obtained (present in parameters or derivable from file_priv), indicating the missing check is feasible.

7) Step 7: Objective: Use cross-path consistency to strengthen evidence. Conceptual signals: presence of another deletion/cleanup path for the same object that does call the stop/clear before free (e.g., v3d_perfmon_idr_del does stop then put) while the destroy ioctl path does not (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Only elevate/report when such an inconsistency exists for the same object/global pointer pair.

8) Step 8: Objective: Verify that the stop/clear function truly nulls the device-global pointer. Conceptual signals: within the stop function, an equality check perfmon == device->active_perfmon followed by device->active_perfmon = NULL (as in v3d_perfmon_stop) (based on FILE_CONTENT). FP mitigation: Require the exact field cleared is the one set in the start function.

9) Step 9: Objective: Confirm that freeing is not guarded by an equivalent nulling elsewhere in the destroy path. Conceptual signals: absence of any assignment device->field = NULL for this object within the destroy function or its directly inlined helpers prior to the put/free (based on FILE_CONTENT). FP mitigation: Traverse simple intra-procedural and obvious helper calls to detect explicit clears.

10) Step 10: Objective: Avoid false positives when the object cannot be active. Conceptual signals: presence of a provably mutually exclusive condition demonstrating that perfmon != device->active_perfmon or that the device->active_perfmon is already NULL along all paths before freeing. FP mitigation: Basic path-sensitivity to ignore reports when all paths guarantee the global pointer is not the target.

3. Target Elements
- Functions:
  - Start/stop lifecycle functions that set/clear device-global pointer fields.
  - Destroy/remove/IOCTL functions that remove objects from IDR and free/put them.
  - Cleanup callbacks (e.g., idr_for_each callbacks) used on close paths.
- Call sites:
  - idr_remove(), idr_for_each() callback body, v3d_perfmon_put(), kfree(), refcount_dec_and_test().
  - Calls to lifecycle “stop” functions that clear device->field.
- Allocation/freeing sites:
  - The freeing path inside the “put” function and its call sites.
- Condition checks:
  - Equality checks perfmon == device->active_perfmon and assignments device->active_perfmon = NULL.
- Lock boundaries:
  - Not strictly required for detection, but recognize that stop acquires perfmon->lock (context for understanding, based on FILE_CONTENT).

4. Dataflow / Taint Considerations
- Track the object pointer obtained from idr_remove (or similar map removal) through local variables to the put/free call.
- Track whether, along any path before the put/free, the object is passed to the stop/clear function with the corresponding device pointer.
- Track assignments to device->global_field along those paths; specifically, verify absence of clearing (device->field = NULL) before freeing the same object.
- Associate the device pointer used in start/stop with the same device pointer in the destroy path (e.g., via v3d_priv->v3d or to_v3d_dev(dev)) to ensure the correct global field is considered.

5. Validation & Test Cases
- Positive: Pre-patch v3d_perfmon_destroy_ioctl that removes from IDR and calls v3d_perfmon_put without a preceding v3d_perfmon_stop or clearing device->active_perfmon (based on ROOTCAUSE_ANALYSIS and implied by PATCH_DIFF change).
- Negative: v3d_perfmon_idr_del which checks if perfmon == v3d->active_perfmon and calls v3d_perfmon_stop before v3d_perfmon_put (based on FILE_CONTENT).
- Negative: Post-patch v3d_perfmon_destroy_ioctl including obtaining v3d and calling v3d_perfmon_stop on the active object before v3d_perfmon_put (based on PATCH_DIFF).
- Test harness notes: Run the checker on the file drivers/gpu/drm/v3d/v3d_perfmon.c for both pre- and post-patch snapshots; expect exactly one issue in the pre-patch destroy ioctl and none in the post-patch or in the idr_del helper.

6. Estimated Effort & Priority
Medium: Requires intra-procedural dataflow, basic call graph awareness, and pattern recognition of lifecycle set/clear and free paths, but limited scope and clear signals based on provided code.

7. Likely False-Positive Sources & Mitigations
- Destroy paths where external invariants guarantee the object is not active: mitigate by preferring cases where the device pointer is available and the check is feasible but missing.
- Alternative clearing not recognized as part of the stop function: mitigate by also recognizing explicit device->field = NULL assignments as acceptable clearing.
- Non-global fields or unrelated globals: mitigate by enforcing type consistency between device->field and freed object type and by requiring both start-set and stop-clear patterns on the same field.

8. Limitations & Assumptions
- Assumes availability of both lifecycle set (start) and clear (stop) functions in the analyzed compilation unit to identify the correct device-global field (based on FILE_CONTENT).
- Does not prove runtime activations; it infers risk from missing stop/clear before free in a path that could target the active object (based on ROOTCAUSE_ANALYSIS).
- Concurrency/locking correctness is not fully modeled; the checker focuses on missing logical stop/clear before free, as highlighted by the patch and analysis (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS).