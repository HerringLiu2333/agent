1. Plan Summary
Detect functions that destroy a v3d_perfmon object without first stopping it when it is the deviceâ€™s active perfmon, leaving v3d->active_perfmon as a dangling pointer.

2. Detection Steps
1) Step 1: Identify candidate destruction functions for struct v3d_perfmon. Look for a local variable of type v3d_perfmon assigned from idr_remove(&v3d_priv->perfmon.idr, ...) followed by a call to v3d_perfmon_put(perfmon).
2) Step 2: Establish the presence of the device-global active pointer. Within the same function, locate derivation of struct v3d_dev via v3d_priv->v3d and the field v3d->active_perfmon (or note its absence in the function).
3) Step 3: Check for an active-perfmon guard before freeing. Search for a control-flow condition comparing the object being destroyed (perfmon) to v3d->active_perfmon (e.g., perfmon == v3d->active_perfmon) on all paths that reach v3d_perfmon_put(perfmon).
4) Step 4: Verify proper deactivation occurs prior to release. On any path where perfmon may equal v3d->active_perfmon, ensure a call to v3d_perfmon_stop(v3d, perfmon, ...) occurs before v3d_perfmon_put(perfmon).
5) Step 5: Detect missing guard or stop. If there is no equality check against v3d->active_perfmon and no call to v3d_perfmon_stop with the same perfmon before v3d_perfmon_put, flag as a potential stale-pointer/use-after-free risk.
6) Step 6: Detect improper ordering. If v3d_perfmon_stop is present but occurs after v3d_perfmon_put(perfmon) or is invoked on an object other than the same perfmon being freed, flag the path.
7) Step 7: Increase confidence with context signals. Confirm the typical destroy pattern: mutex_lock around IDR removal, a null check returning -EINVAL on !perfmon, and then v3d_perfmon_put(perfmon); absence of active-perfmon handling in this pattern strengthens the finding.

3. Limitations & Assumptions
- Assumes v3d_perfmon_put(perfmon) may release/finalize and potentially free the object; exact semantics are not provided.
- Assumes v3d_perfmon_stop(v3d, perfmon, ...) is the correct way to halt monitoring and clear v3d->active_perfmon; the internal effects of v3d_perfmon_stop are not shown.
- Does not reason about concurrent updates or other sites that might clear v3d->active_perfmon; the checker focuses on the local destroy path.
- Scope is specific to v3d perfmon handling (v3d_priv->perfmon.idr, v3d_dev->active_perfmon); generalization to other subsystems is not supported by the provided materials.