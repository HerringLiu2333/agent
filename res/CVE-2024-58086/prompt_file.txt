1. CVE Identifier
CVE-2024-58086

2. Vulnerability Type
Use-after-free due to improper lifetime management (dangling pointer in device-global state)

3. Root Cause Summary
The destroy ioctl path did not stop and clear the device-global active perfmon (v3d->active_perfmon) before freeing the perfmon object. Specifically, v3d_perfmon_destroy_ioctl removed the perfmon from the IDR and immediately decremented its refcount to free it without checking whether it was the active perfmon. This left v3d->active_perfmon pointing at freed memory and the hardware counters still enabled, enabling subsequent dereferences (e.g., in v3d_perfmon_stop) to access freed memory and cause instability.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM V3D performance monitor (drivers/gpu/drm/v3d/v3d_perfmon.c)

2) Pre-Patch Flaw:
In v3d_perfmon_destroy_ioctl, after removing the perfmon from the IDR, the code immediately frees it without stopping it first or clearing v3d->active_perfmon. Evidence: pre-patch code contained “v3d_perfmon_put(perfmon);” with no prior stop or active pointer handling in v3d_perfmon_destroy_ioctl.

3) Trigger Condition:
Userspace issues DRM_IOCTL_V3D_PERFMON_DESTROY for a perfmon that is currently active (perfmon == v3d->active_perfmon).

4) Impact Mechanism:
- v3d->active_perfmon becomes a stale pointer to freed memory.
- Subsequent paths that access or stop the active perfmon (e.g., v3d_perfmon_stop which locks perfmon->lock and reads perfmon->values) can dereference freed memory (use-after-free), causing undefined behavior or a kernel crash.
- The stale non-NULL v3d->active_perfmon also prevents starting a new perfmon (v3d_perfmon_start checks v3d->active_perfmon), leading to device malfunction.

5. Patch Analysis
1) Fix Approach:
Ensure the active perfmon is stopped before destroying it. v3d_perfmon_stop disables the hardware counters, captures values if requested, and sets v3d->active_perfmon = NULL, eliminating the dangling pointer.

2) Key Code Changes:
- In v3d_perfmon_destroy_ioctl, add struct v3d_dev *v3d = v3d_priv->v3d.
- Before v3d_perfmon_put(perfmon), add:
  if (perfmon == v3d->active_perfmon)
      v3d_perfmon_stop(v3d, perfmon, false);
This mirrors the existing cleanup in v3d_perfmon_idr_del used during file close, which already stopped the active perfmon before put.

3) Locking/Concurrency Impact:
- v3d_perfmon_destroy_ioctl holds v3d_priv->perfmon.lock during IDR removal; v3d_perfmon_stop acquires perfmon->lock internally and validates perfmon == v3d->active_perfmon before clearing v3d->active_perfmon.
- The change closes a race window where active_perfmon could point to freed memory, by clearing the global pointer under perfmon->lock as part of stop.
- Aligns the destroy ioctl path’s synchronization with the file-close path (v3d_perfmon_idr_del), ensuring consistent lifetime and state cleanup.

6. Broader Kernel Security Implications
Dangling device-global pointers across IOCTL destruction paths are a common source of UAF in kernel drivers. Ensuring that all destruction paths stop hardware activity and clear global references before freeing objects is critical to prevent UAF, denial of service, and instability under adversarial or buggy userspace. This patch improves robustness by standardizing lifetime management and state cleanup for V3D perfmon objects.