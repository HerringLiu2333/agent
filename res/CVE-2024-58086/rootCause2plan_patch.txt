1. Plan Summary
Detect IOCTL destroy paths that release a currently active, globally referenced object without first stopping/quiescing it, leaving a stale pointer and enabling use-after-free (as in v3d perfmon destroy).

2. Detection Steps
1) Step 1: Objective: Identify candidate destroy paths for v3d perfmons. Signals: functions in drivers/gpu/drm/v3d/v3d_perfmon.c with names containing "destroy" (e.g., v3d_perfmon_destroy_ioctl) or handling a destroy request struct; this is based on the pre/post-change location and naming in [PATCH_DIFF]. FP mitigation: Restrict to the v3d driver file(s) and functions that call a final-release routine (v3d_perfmon_put) to ensure we’re on a destruction path per [ROOTCAUSE_ANALYSIS].

2) Step 2: Objective: Find the perfmon object being destroyed. Signals: a local variable of type struct v3d_perfmon* that is looked up/validated and later passed to v3d_perfmon_put, as shown in [PATCH_DIFF]. FP mitigation: Require that the object was retrieved under the perfmon mutex (v3d_priv->perfmon.lock), matching the context in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

3) Step 3: Objective: Determine whether the function acknowledges the “active” global reference. Signals: presence of a read of v3d->active_perfmon (global/device-level field) or of the device pointer v3d derived from v3d_priv->v3d, as added by [PATCH_DIFF]. FP mitigation: If no reference to v3d->active_perfmon exists anywhere in the function, mark as higher suspicion because the active-state is ignored in a destroy path (per [ROOTCAUSE_ANALYSIS]).

4) Step 4: Objective: Check for the required stop-before-put ordering. Signals: a call to v3d_perfmon_stop with arguments (v3d, perfmon, …) that occurs on all paths reaching v3d_perfmon_put for the same perfmon, as introduced in [PATCH_DIFF]. FP mitigation: Treat as safe if such a stop call post-dominates a check that perfmon == v3d->active_perfmon and dominates the subsequent put (per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).

5) Step 5: Objective: Verify the conditional guard linking “active” status to stop. Signals: a conditional comparison perfmon == v3d->active_perfmon guarding the v3d_perfmon_stop invocation, reflecting [PATCH_DIFF]. FP mitigation: If the stop is unguarded but uses the same perfmon, still accept as safe; if there is a guard but no stop call, flag.

6) Step 6: Objective: Confirm proper locking around stop and put to avoid races creating stale pointers. Signals: both the conditional check and v3d_perfmon_stop occur under v3d_priv->perfmon.lock, matching the context of the put as per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: If stop occurs outside the same lock region as the put, warn as risky but lower severity; if both occur under the lock, suppress race-related concerns.

7) Step 7: Objective: Allow equivalent cleanup patterns that clear the active pointer before put. Signals: an explicit write that clears v3d->active_perfmon (e.g., set to NULL) dominating the put when perfmon == v3d->active_perfmon, which achieves the same goal described in [ROOTCAUSE_ANALYSIS] (“cleared in a controlled manner”). FP mitigation: Only accept if the clear is within the same lock scope as the put to ensure atomicity, per [ROOTCAUSE_ANALYSIS].

8) Step 8: Objective: Report the core flaw. Signals: along any path where v3d_perfmon_put(perfmon) is called, there is no preceding stop of that perfmon (or active pointer clear), and the function does not otherwise handle v3d->active_perfmon, matching the pre-patch omission described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Require the function name/context to imply destruction and that the perfmon was validated/fetched prior to put to avoid incidental ref-drop sites.

9) Step 9: Objective: Prioritize findings most likely to be exploitable. Signals: presence of a global/device field v3d->active_perfmon of the same type as the object being put, indicating a potential dangling reference per [ROOTCAUSE_ANALYSIS]. FP mitigation: De-prioritize if analysis shows additional strong references are retained after put (if inferable), though primary evidence points to put leading to free as per [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Functions: destroy IOCTL handlers and destroy-like routines in drivers/gpu/drm/v3d/v3d_perfmon.c (e.g., v3d_perfmon_destroy_ioctl per [PATCH_DIFF]).
- Call sites: v3d_perfmon_put(perfmon) and v3d_perfmon_stop(v3d, perfmon, ...).
- Condition checks: comparisons between the object and v3d->active_perfmon.
- Lock boundaries: regions under v3d_priv->perfmon.lock.
- Field accesses: v3d_priv->v3d and v3d->active_perfmon.
- Variable flows: the perfmon local variable from lookup to put/stop.

4. Dataflow / Taint Considerations
- Track the specific struct v3d_perfmon* variable bound to the destroy request through the function to sinks: v3d_perfmon_put and v3d_perfmon_stop.
- Track control/data dependence showing that a stop call dominates the put for the same perfmon, and that it is conditionally gated by equality to v3d->active_perfmon.
- Track lock scopes to ensure stop and put occur within the same critical section, reducing race-induced stale pointer issues per [ROOTCAUSE_ANALYSIS].

5. Validation & Test Cases
- Positive: Pre-patch v3d_perfmon_destroy_ioctl that looks up perfmon under perfmon.lock and calls v3d_perfmon_put(perfmon) without referencing v3d->active_perfmon or calling v3d_perfmon_stop; expect a finding (per [ROOTCAUSE_ANALYSIS]).
- Positive: A destroy function that checks perfmon == v3d->active_perfmon but still proceeds to v3d_perfmon_put without calling stop; expect a finding.
- Negative: The patched v3d_perfmon_destroy_ioctl that retrieves v3d, checks perfmon == v3d->active_perfmon, and calls v3d_perfmon_stop before v3d_perfmon_put under the same lock; expect no finding (per [PATCH_DIFF]).
- Negative: A destroy path that, under perfmon.lock, explicitly clears v3d->active_perfmon before v3d_perfmon_put when equal; expect no finding.
- Test harness notes: Run analysis limited to drivers/gpu/drm/v3d to avoid cross-driver noise; verify path-sensitive dominance of stop/clear over put within the same lock scope.

6. Estimated Effort & Priority
Medium effort, high priority (use-after-free risk on destroy path with global active pointer per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Stop performed in a helper function not visible in the same function: mitigate by allowing interprocedural recognition of v3d_perfmon_stop calls on the same perfmon before put.
- Non-destroy ref-drops invoking v3d_perfmon_put: mitigate by requiring destroy-like naming/context and lock usage pattern as in [PATCH_DIFF].
- Cases where put does not free due to extra refs: mitigate by prioritizing findings in explicit destroy handlers and where active pointer is known to exist (per [ROOTCAUSE_ANALYSIS]).
- Alternate safe patterns (e.g., active pointer cleared elsewhere under lock): mitigate by recognizing explicit clears dominating put.

8. Limitations & Assumptions
- Assumes the relevant global field is v3d->active_perfmon and that v3d_perfmon_stop is the canonical quiesce operation, per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; other drivers/functions are out of scope.
- Cannot reliably prove whether v3d_perfmon_put frees the object in all cases; analysis assumes destroy paths imply final release as per [ROOTCAUSE_ANALYSIS].
- Assumes correct identification of lock scopes for perfmon.lock; mismatches or unconventional locking patterns may elude precise race assessment.