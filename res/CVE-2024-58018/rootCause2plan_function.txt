1. Plan Summary
Design a CodeQL checker that learns the security precondition(s) introduced by the patch for CVE-2024-58018 and flags pre-patch code paths that invoke the same operation(s) without those preconditions.

2. Detection Steps
1) Step 1: Objective: Identify the scope (functions/files) touched by the fix — Signals: functions, methods, or modules referenced in [PATCH_DIFF]/[PATCH_DESCRIPTION] and their call sites — FP mitigation: None possible without [PATCH_DIFF]; treat as a placeholder step pending patch details.
2) Step 2: Objective: Infer the new required precondition(s) added by the patch — Signals: newly added guards such as null checks, bounds/length checks, type/state/permission checks, error handling, locking, or sanitization calls shown in [PATCH_DIFF]/[FUNCTION_CONTENT] — FP mitigation: Treat only additions (not refactors) as likely preconditions; ignore cosmetic changes (renames, formatting).
3) Step 3: Objective: Model the guarded “vulnerable operation” — Signals: the statement(s)/call(s) whose execution is newly conditioned by the added check(s), or that moved under a lock/try/catch in [PATCH_DIFF] — FP mitigation: Require a clear dominance relationship (guard must control the operation in control flow).
4) Step 4: Objective: Find equivalent flows without the precondition — Signals: paths where the same operation/callee is reachable without a dominating equivalent guard or sanitizer — FP mitigation: Consider semantic equivalence of guards (e.g., alternative null/bounds forms); exclude paths with an obviously stronger guard.
5) Step 5: Objective: Generalize to call sites — Signals: calls to the patched function(s) (or to functions performing the same operation) lacking the added argument validation or surrounding checks visible in [PATCH_DIFF] — FP mitigation: Exempt call sites wrapped by helper functions that enforce the check before delegating.
6) Step 6: Objective: Capture added return-value/error handling requirements — Signals: [PATCH_DIFF] showing added return-value checks, error propagation, or early returns; pre-patch sites where returns are ignored or used without checking — FP mitigation: Only flag when the function’s contract appears changed (e.g., new error codes, null returns) and unchecked use could reach the vulnerable operation.
7) Step 7: Objective: Capture added synchronization/locking discipline — Signals: [PATCH_DIFF] adding lock acquisition, atomic check-then-use, or critical sections around shared state; pre-patch paths that access the same state without lock — FP mitigation: Verify consistent lock pairing and resource identity; ignore read-only accesses if patch indicates write-safety only.
8) Step 8: Objective: Capture added sanitization/normalization — Signals: [PATCH_DIFF] adding sanitizer/validator calls on inputs before use; pre-patch flows using the same inputs without sanitizer — FP mitigation: Treat functionally equivalent sanitizers as satisfying the requirement (match by dataflow effects, not names only).
9) Step 9: Objective: Account for interprocedural preconditions — Signals: upstream callers establishing the guard before calling downstream operations; ensure guard dominance across call boundaries — FP mitigation: Require that the guard value flows to the callee’s use site (e.g., validated variable is the same one used).
10) Step 10: Objective: Suppress cases guarded by contract annotations or asserts — Signals: presence of assertions, compile-time checks, or contract annotations that enforce the same predicate — FP mitigation: Recognize common assert/contract macros and treat them as guards if they abort/fail closed.
11) Step 11: Objective: Reduce noise from dead code and infeasible paths — Signals: constant conditions or proven invariants making the missing guard irrelevant — FP mitigation: Apply simple constant propagation and nullability facts to avoid flagging infeasible violations.
12) Step 12: Objective: Report findings with evidence of missing precondition — Signals: include the specific operation, the expected guard/sanitizer inferred from [PATCH_DIFF], and the path lacking it — FP mitigation: Only report when both the operation matches and no equivalent precondition dominates the path.

3. Target Elements
- Functions and methods modified by the patch and their transitive call sites.
- Condition checks (null, bounds/length, state/permission, type).
- Resource synchronization constructs (locks, atomics, critical sections).
- Input sanitization/validation calls added by the patch.
- Return-value use sites and error-handling paths.
- The specific “vulnerable operation” statements/calls guarded post-patch.

4. Dataflow / Taint Considerations
- Track dataflow from validated variables/parameters through to the vulnerable operation to ensure the guard protects the same value.
- Track whether sanitization calls occur on data before it reaches the sink.
- Model control-flow dominance: guard conditions that must be true prior to the operation.
- Interprocedural preconditions: guards in callers that protect uses in callees.
- Return-value propagation: from callee error/nullable results to usage sites that must check them.
- Locking discipline: model resource identity and whether a lock is held along paths to shared-state access.

5. Validation & Test Cases
- Positive: A pre-patch example where a call performs the vulnerable operation without a preceding null/bounds/permission check (or without lock/sanitizer), matching the guard added in the patch; expect a finding.
- Negative: A post-patch example where the same operation is dominated by the newly added guard/sanitizer/lock or where an equivalent guard exists; expect no finding.
- Test harness notes: Create minimal functions mirroring the patch pattern (one with missing guard, one with present equivalent guard; one with guard in the caller) to verify dominance, interprocedural, and sanitizer equivalence handling.

6. Estimated Effort & Priority
Medium, contingent on access to [PATCH_DIFF]/[FUNCTION_CONTENT] to instantiate the specific guard and sink patterns.

7. Likely False-Positive Sources & Mitigations
- Equivalent but syntactically different guards: mitigate via semantic equivalence checks and dataflow correlation.
- Guards enforced in wrappers/macros: mitigate by expanding common wrappers and recognizing assert/contract macros.
- Infeasible paths due to invariants: mitigate with simple constant/nullability reasoning.
- Read-only accesses flagged in locking rules: mitigate by distinguishing read vs write and the patch’s intended protection.

8. Limitations & Assumptions
- No [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], or [ROOTCAUSE_ANALYSIS] were provided, so the exact vulnerability class, guards, sinks, and functions are unknown.
- The plan assumes the patch introduced explicit preconditions (guards, sanitizers, locks, or error checks) that can be inferred and generalized; if the fix is an internal algorithmic change without explicit guards, this approach may not apply.
- Mapping of “equivalent guards” and sanitizer semantics depends on project-specific APIs not available here.