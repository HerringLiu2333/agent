1. Plan Summary
Detect unchecked devm_kzalloc() allocations whose returned pointers are dereferenced without prior NULL checks, as exemplified by mt7925_change_vif_links pre-patch behavior.

2. Detection Steps
1) Step 1: Identify call sites of devm_kzalloc where the return value is assigned to a pointer variable. Signals: function call named devm_kzalloc, result stored in a local pointer (e.g., mconf, mlink). FP mitigation: restrict to devm_kzalloc only, per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].

2) Step 2: Locate subsequent dereferences of the allocated pointer (member access “->” or pointer use in a context implying deref). Signals: statements such as mconf->link_id = ..., mlink->wcid.link_id = ..., as in [FUNCTION_CONTENT]. FP mitigation: require the dereference to occur along a path reachable from the allocation without intervening guards.

3) Step 3: Check for a dominating NULL check on the allocated pointer(s) before the first dereference. Signals: conditions like if (!mconf) or if (!mlink) with an aborting action (return/goto) that prevents deref on the NULL path; compare to the added check in [PATCH_DIFF]. FP mitigation: accept combined checks (if (!mconf || !mlink) return -ENOMEM) as sufficient.

4) Step 4: Handle conditional allocation within branches (e.g., the “add” loop’s else branch when old_links != 0). Signals: allocation occurs inside a conditional block; dereferences occur after the conditional join, as shown in [FUNCTION_CONTENT]. FP mitigation: use path-sensitive reasoning to only flag the path where allocation happened and no NULL guard exists.

5) Step 5: Require “nearby use” to reduce noise: the first dereference occurs within a bounded number of statements or within the same loop iteration after the allocation. Signals: the assignments to mconf->link_id and mlink->wcid.link_id immediately follow allocation in the same block (see [FUNCTION_CONTENT]). FP mitigation: limit to uses within the same basic block/iteration.

6) Step 6: Track pairs of allocations used together and ensure both are checked when both are dereferenced. Signals: two devm_kzalloc calls assigning to mconf and mlink, followed by dereferences of both variables in the same region. FP mitigation: only report if either allocated pointer lacks a guard but is dereferenced; avoid duplicates by reporting one issue for the pair.

7) Step 7: Treat uses in function calls that expect initialized structures as risky if a direct dereference occurs prior (e.g., mt7925_mac_link_bss_add with mlink after mlink->wcid.* writes). Signals: function calls with the allocated pointer as argument following member writes, per [FUNCTION_CONTENT]. FP mitigation: require at least one explicit member write before the call to confirm dereference risk.

8) Step 8: Exclude non-alloc branches that assign known non-NULL addresses (e.g., &mvif->bss_conf, &mvif->sta.deflink). Signals: pointer initialized from address-of operator in the “if (!old_links)” branch (see [FUNCTION_CONTENT]). FP mitigation: ensure the flagged path originates from devm_kzalloc, not from address-of.

9) Step 9: Recognize acceptable error handling patterns equivalent to the patch (return -ENOMEM or goto cleanup before deref). Signals: control flow that prevents execution of the dereference statements when the pointer is NULL, matching [PATCH_DIFF]. FP mitigation: do not flag when such guards exist.

10) Step 10: Report the allocation site and the first unguarded dereference site, explaining the risk of NULL pointer deref leading to DoS per [ROOTCAUSE_ANALYSIS]. Signals: path from devm_kzalloc to first mconf->… or mlink->… write without guard. FP mitigation: ensure the dereference is reachable under a feasible path (e.g., when new_links adds bits and old_links != 0) inferred from local control flow, per [FUNCTION_CONTENT].

3. Target Elements
- Function bodies containing devm_kzalloc calls.
- Allocation sites: devm_kzalloc return values assigned to pointer variables.
- Conditional blocks and loops (e.g., for_each_set_bit contexts).
- Pointer dereference expressions (member access via “->”; array element deref if applicable).
- Guard conditions checking pointers for NULL and associated aborting actions (return/goto).
- Control-flow joins where pointers from different origins (alloc vs address-of) are used.

4. Dataflow / Taint Considerations
- Track a “may-be-NULL” taint from devm_kzalloc return values to pointer variables.
- Propagate taint through simple assignments and array slots (e.g., mconfs[link_id] = mconf) but focus on original variable’s first dereference.
- Consider path conditions: taint applies only along branches where allocation occurred (e.g., old_links != 0 path).
- Stop taint at verified guards that dominate dereferences (if (!ptr) return/goto), as in [PATCH_DIFF].

5. Validation & Test Cases
- Positive: A function that allocates mconf = devm_kzalloc(...); mlink = devm_kzalloc(...); then immediately executes mconf->link_id = ...; mlink->wcid.link_id = ... without any prior NULL check (matches pre-patch in [FUNCTION_CONTENT]); expect a detection.
- Negative: Same function but with if (!mconf || !mlink) return -ENOMEM; inserted before any dereference (matches [PATCH_DIFF]); expect no detection.
- Negative: Branch where pointers are set to &mvif->bss_conf and &mvif->sta.deflink without allocation (matches “if (!old_links)” in [FUNCTION_CONTENT]); expect no detection.
- Test harness notes: Include loop/branch constructs to ensure path-sensitive handling of allocation vs address-of origins and verify dominance of guards.

6. Estimated Effort & Priority
High: kernel safety-critical, requires path-sensitive control-/data-flow modeling and dereference detection.

7. Likely False-Positive Sources & Mitigations
- Cases where a higher-level invariant guarantees non-NULL but is not syntactically visible; mitigation: require explicit local guards or accept only “nearby use” patterns.
- Pointers re-initialized from safe sources before dereference; mitigation: track reassignments and origin, and only flag paths where the origin is the allocation.
- Functions with complex error-handling using gotos; mitigation: ensure guard branches prevent deref on NULL paths (dominance check).

8. Limitations & Assumptions
- Only devm_kzalloc is considered; other allocators are out of scope based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].
- Contracts of called functions (e.g., mt7925_mac_link_bss_add) are not used to infer safety; detection focuses on direct dereferences observed in [FUNCTION_CONTENT].
- Precise modeling of for_each_set_bit and kernel macros may be limited; assumption is that deref analysis within loop bodies is feasible.
- Memory allocator behavior beyond “may return NULL” is not modeled; the checker assumes NULL is possible per [PATCH_DESCRIPTION].