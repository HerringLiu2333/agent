1. Plan Summary
Detect missing NULL checks after devm_kzalloc allocations that are subsequently dereferenced (directly or via storing into arrays/structures) within the same function, leading to potential NULL pointer dereferences as in mt7925_change_vif_links.

2. Detection Steps
1) Step 1: Objective: Find allocation sites that may return NULL. Signals: Calls to devm_kzalloc with results stored in pointer variables (based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Restrict to devm_kzalloc only, as explicitly implicated.

2) Step 2: Objective: Group related allocations made in the same logical block. Signals: Multiple devm_kzalloc results assigned to distinct pointers before any intervening dereference (e.g., mconf and mlink in the same sequence per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Limit grouping to allocations within the same basic block or contiguous sequence to avoid over-aggregation.

3) Step 3: Objective: Determine whether allocated pointers are validated for NULL before any use. Signals: Presence of conditions checking pointer(s) for NULL (e.g., logical negation or NULL equality) with control flow that prevents subsequent use (e.g., return -ENOMEM as in [PATCH_DIFF]). FP mitigation: Treat only control-flow paths that exit the function or jump to an error path before any use as valid “checks.”

4) Step 4: Objective: Identify unsafe uses of allocated pointers prior to NULL check. Signals: Direct dereference/field access (->), unary dereference (*), or pointer-based array indexing on the allocated pointer (as implied by “subsequent access to fields” in [ROOTCAUSE_ANALYSIS]). FP mitigation: Require an explicit dereference expression in the same function along some path without an intervening NULL guard.

5) Step 5: Objective: Capture indirect uses via storing the pointer into arrays/structures that are later dereferenced. Signals: Assignments like container[index] = pointer followed, along some path, by dereference of that same pointer value via the same variable or via reading container[index] and dereferencing (e.g., mconfs[link_id] = mconf then later deref, per [ROOTCAUSE_ANALYSIS]). FP mitigation: Only flag if a subsequent dereference of the stored pointer (or the retrieved container element) occurs in the same function on a path with no prior NULL check.

6) Step 6: Objective: Enforce path-sensitivity to ensure a true missing-check path exists. Signals: Control-flow and dataflow path from the allocation to the dereference with no dominating NULL check for the specific pointer value. FP mitigation: Do not report if all paths to dereference are dominated by a proper NULL check and an early error exit (per [PATCH_DIFF]).

7) Step 7: Objective: Handle multiple allocations that must be jointly validated. Signals: If multiple allocated pointers are used together or dereferenced in the same region, require that each has been NULL-checked, or a combined check (e.g., if (!mconf || !mlink)) dominates the first use (as added in [PATCH_DIFF]). FP mitigation: Only report the unvalidated pointer(s), not those covered by a dominating combined check.

8) Step 8: Objective: Recognize acceptable error-handling patterns. Signals: On detecting a NULL check, verify the guarded branch leads to an immediate error action (return negative errno like -ENOMEM, or equivalent early exit) before any use (aligned with [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Count as safe if the guarded branch prevents all further uses in the function.

9) Step 9: Objective: Exclude benign stores without subsequent use. Signals: If an allocated pointer is only stored and never dereferenced or propagated to a known dereference in the same function, do not flag. FP mitigation: Require a concrete dereference use site to minimize FPs.

10) Step 10: Objective: Report findings with context. Signals: Include the allocation site(s), first unguarded dereference/use site, and whether multiple allocations were present without a combined check (per the dual mconf/mlink case in [ROOTCAUSE_ANALYSIS]). FP mitigation: Aggregate related violations within the function to avoid duplicate reports.

3. Target Elements
- Function bodies containing devm_kzalloc call sites.
- Pointer variable assignments receiving devm_kzalloc results.
- Conditional checks testing these pointers for NULL.
- Control-flow exits (return, goto error) associated with allocation failure.
- Pointer dereferences: member access via ->, unary *, and pointer-based indexing.
- Assignments of allocated pointers into arrays/structures and later retrievals/dereferences within the same function.

4. Dataflow / Taint Considerations
- Forward dataflow from each devm_kzalloc-returned pointer to its uses.
- Treat a dominating NULL check that leads to an early exit as a sanitizer for that pointer.
- Track value propagation through simple assignments and container stores/loads within the same function.
- Path-sensitive reachability from allocation to dereference without intervening sanitization.

5. Validation & Test Cases
- Positive: Two devm_kzalloc allocations (like mconf and mlink) with no NULL checks, followed by either direct dereference of one or assignment mconfs[i] = mconf and later mconfs[i]->field access; expect a report for the unguarded pointer(s).
- Negative: Allocations followed immediately by if (!mconf || !mlink) return -ENOMEM; then dereferences; expect no report (matches [PATCH_DIFF]).
- Negative: Each allocation checked separately before any dereference; expect no report.
- Positive: One of two allocations checked, the other not, with dereference of the unchecked one; expect a report.
- Test harness notes: Use simplified kernel-like functions emulating mt7925_change_vif_links patterns, ensuring control-flow paths with and without early returns.

6. Estimated Effort & Priority
High: Requires path-sensitive dataflow within functions and recognition of combined checks; high impact given kernel DoS risk (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Deferred checks in callees or across function boundaries not visible intra-procedurally; mitigate by limiting to same-function dereferences.
- Macros/wrappers guaranteeing non-NULL semantics unknown to the analysis; mitigate by restricting to devm_kzalloc explicitly.
- Stores into containers that are only dereferenced in other functions; mitigate by requiring same-function dereference evidence.

8. Limitations & Assumptions
- Assumes devm_kzalloc can return NULL and must be checked (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
- Does not cover interprocedural flows where dereference occurs in a different function.
- Concurrency, locking, and lifetime nuances are not analyzed (unknown per [ROOTCAUSE_ANALYSIS]).
- Only devm_kzalloc is considered; other allocation APIs are not included due to lack of evidence in the provided materials.