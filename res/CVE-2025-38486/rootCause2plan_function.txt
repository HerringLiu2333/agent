1. Plan Summary
Detect functions that copy variable-length channel maps into fixed-size driver arrays without bounds checks or correct indexing, and that overwrite TX mappings with RX mappings in the same buffer.

2. Detection Steps
1) Step 1: Identify candidate API implementations — Look for functions assigned to driver ops fields analogous to set_channel_map or taking paired count/pointer parameters for TX/RX (based on PATCH_DIFF removing .set_channel_map and ROOTCAUSE_ANALYSIS describing this API). Mitigate FPs by prioritizing functions referenced from ops tables or called in init paths, as shown in PATCH_DIFF and PATCH_DESCRIPTION call trace.

2) Step 2: Locate array-element assignments from external slot arrays — Within candidates, find loops assigning array[i] or array[i].field from tx_slot[i] and/or rx_slot[i] (FUNCTION_CONTENT shows ctrl->pconfig[i].ch_mask = tx_slot[i]/rx_slot[i]). Mitigate FPs by requiring the destination array be a struct field (e.g., ctrl->pconfig) rather than a local with dynamic size.

3) Step 3: Flag missing bounds capping for TX — If a loop iterates i from 0 to i < tx_num and writes to a fixed-size destination array, check for absence of a guard ensuring tx_num ≤ destination_length (ROOTCAUSE_ANALYSIS: no bounds checks, PATCH_DIFF loop). Reduce FPs by accepting min/cap patterns or explicit if checks that limit tx_num to array length before the loop.

4) Step 4: Flag missing bounds capping for RX — Apply the same check for the RX loop i < rx_num writing to the same destination array (ROOTCAUSE_ANALYSIS and FUNCTION_CONTENT second loop). Reduce FPs using the same acceptance criteria as Step 3.

5) Step 5: Detect 1-based indexing violations — If the destination array has a known “+1” sized declaration or is documented/reserved to be 1-based (ROOTCAUSE_ANALYSIS: element 0 is unused), flag loops that start at index 0 assigning to array[0]. Mitigate FPs by only reporting when either array length expression suggests +1 sizing or other uses in the file consistently index from 1 (if visible); otherwise downgrade to a heuristic warning.

6) Step 6: Detect overlapping TX/RX writes into the same buffer — Find functions where both a TX loop and an RX loop write to the same destination array indices (same base array, same index variable range starting at 0) without offsetting or separation (ROOTCAUSE_ANALYSIS: RX overwrites TX). Reduce FPs by requiring both loops can execute on the same path (independent if checks without else/return and both source pointers are parameters).

7) Step 7: Require distinct sources for overlap finding — Ensure the two loops copy from different input arrays/pointers (e.g., tx_slot vs rx_slot per FUNCTION_CONTENT) to avoid flagging intentional duplicated passes over a single source. Reduce FPs by excluding cases where the second loop reads from the same source or performs a merge rather than a blind overwrite.

8) Step 8: Check for direction-aware indexing or buffers — Suppress the overlap warning if the RX loop writes to a different buffer or to disjoint indices (e.g., starts from a nonzero base offset) indicating separation of TX/RX storage (ROOTCAUSE_ANALYSIS demands separate mapping or correct indexing). Reduce FPs by recognizing consistent non-overlapping ranges or separate arrays.

9) Step 9: Evaluate presence of early validation gates — Before loops, look for checks that reject excessive counts (return error) or clamp counts to array length (ROOTCAUSE_ANALYSIS: missing), and suppress OOB warnings if present. Mitigate FPs by treating preconditions in wrappers as valid only if they dominate the loop along all paths.

10) Step 10: Confirm destination array is fixed-size or capacity-known — Prefer cases where the destination array’s compile-time bound is available (e.g., struct field sized by macro, per ROOTCAUSE_ANALYSIS mentioning QCOM_SDW_MAX_PORTS + 1) to assert potential OOB. If unknown, still warn but mark as lower confidence unless there is evidence that count can exceed a likely size (e.g., known API max like SLIM_MAX_TX_PORTS cited in ROOTCAUSE_ANALYSIS).

3. Target Elements
- Functions registered in ops structures as channel mapping handlers or with signatures that include TX/RX counts and slot arrays.
- For-loops or equivalent iteration constructs writing to array elements.
- Assignments to struct-field arrays (e.g., ctrl->pconfig[i].ch_mask) from parameter-provided arrays.
- Preceding condition checks that compare counts to array lengths or clamp them.
- Multiple loops within the same function writing to the same array with different sources.
- Ops table initializations referencing the function (based on PATCH_DIFF removal of .set_channel_map).

4. Dataflow / Taint Considerations
- Track taint from function parameters tx_num/rx_num and tx_slot/rx_slot into loop bounds and RHS expressions, respectively.
- Track the destination array expression (e.g., ctrl->pconfig) across both loops to confirm identical base and index domain.
- Identify presence/absence of dominating guards that constrain tx_num/rx_num to destination array length, including min/clamp patterns.
- Optionally infer 1-based indexing intent from array size “+1” declarations or consistent downstream uses starting at index 1.

5. Validation & Test Cases
- Positive: The pre-patch qcom_swrm_set_channel_map in FUNCTION_CONTENT: two loops starting at i=0, no bounds checks against ctrl->pconfig length, both writing ctrl->pconfig[i].ch_mask from tx_slot[i]/rx_slot[i], with independent if (tx_slot)/(rx_slot) conditions (expect: three findings—TX OOB risk, RX OOB risk, TX/RX overlap; and optionally index-0 misuse if +1 sizing is known).
- Negative: A corrected version that starts loops at i=1, clamps counts to min(count, ARRAY_LEN(pconfig)-1), and uses distinct buffers or disjoint index ranges for TX and RX; or returns error when counts exceed capacity (expect: no findings).
- Test harness notes: Include a variant where array size is unknown to the checker to ensure it downgrades OOB to lower confidence but still flags overlap; and a variant where RX loop uses else-if to TX loop (should not flag overlap).

6. Estimated Effort & Priority
High: Combines loop-bound analysis, array-size reasoning, path-sensitivity for guard detection, and multi-loop overlap detection.

7. Likely False-Positive Sources & Mitigations
- Intentional two-pass initialization that overwrites by design; mitigate by checking distinct sources and absence of merge logic.
- Unknown array sizes due to missing headers; mitigate by lowering confidence unless a guard is clearly missing and inputs are unbounded parameters.
- 1-based indexing detection without visible “+1” declarations; mitigate by treating it as heuristic and optional.
- Cases where upstream wrappers validate counts; mitigate by requiring domination of the loop along all paths.

8. Limitations & Assumptions
- The checker relies on availability of array size information or visible guards; if not present, OOB findings are heuristic.
- Detecting “index 0 reserved” is domain-specific; without an explicit +1-sized declaration or consistent 1-based uses, the checker cannot assert this reliably.
- Macro values like SLIM_MAX_TX_PORTS and QCOM_SDW_MAX_PORTS + 1 may be unavailable across translation units; bounds comparisons may be conservative.
- Concurrency/synchronization aspects are intentionally ignored per ROOTCAUSE_ANALYSIS indicating the issue is not concurrency-related.