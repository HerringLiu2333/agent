1. Plan Summary
Detect unsafe channel-map setters that copy TX/RX slot arrays into a driver configuration array without respecting array bounds, reserved index-0, or separation between TX and RX, leading to out-of-bounds writes and state overwrite.

2. Detection Steps
1) Step 1: Identify candidate functions implementing channel-map setting. Signals: functions assigned to the .set_channel_map field of a snd_soc_dai_ops initializer, or functions with parameters resembling (tx_num, const unsigned int* tx_slot, rx_num, const unsigned int* rx_slot).

2) Step 2: Locate loops that write from tx_slot or rx_slot into a configuration array. Signals: for/while loops whose body assigns to an indexed field like ctrl->pconfig[i].ch_mask (or similar array-of-struct element) using the loop index derived from tx_num or rx_num.

3) Step 3: Check for reserved-index misuse (index 0 written). Signals: the loop initializes the index to 0 or directly writes element [0]; additionally, the destination array’s declared size is a macro/expression of the form CONSTANT + 1 (heuristic suggesting 1-based indexing), yet the code writes index 0.

4) Step 4: Check for missing bounds enforcement against destination capacity. Signals: absence of a guard that compares tx_num/rx_num (or the computed index upper bound) to the destination array capacity, no min/clamp with the array size, and the loop bound is directly tx_num or rx_num.

5) Step 5: Attempt to resolve destination capacity for fixed-size arrays. Signals: the declaration of ctrl->pconfig (or the written array) has a compile-time length (including macro expressions), enabling comparison of loop bound to capacity; if resolvable and loop bound can exceed capacity or is unconstrained, flag.

6) Step 6: Flag potential overflow when source count is parameter-driven and unconstrained. Signals: the loop condition uses tx_num/rx_num directly without any preceding range checks (e.g., no if (tx_num <= CAP) nor equivalent), regardless of whether exact capacity is known.

7) Step 7: Detect TX/RX overwrite logic errors. Signals: presence of two separate loops guarded by tx_slot and rx_slot non-null checks that both write to the same destination array element expression (same base and same index expression i), with no offset, no separate TX/RX storage, and no merge logic.

8) Step 8: Exempt safe indexing patterns. Signals: indexing uses a base offset of 1 (e.g., pconfig[i + 1]) and there is an explicit check that tx_num/rx_num do not exceed capacity minus the offset, or the code uses validated clamped counts.

9) Step 9: Prioritize findings in the Qualcomm SoundWire ASoC context to reduce noise. Signals: function name or file/module context includes soundwire: qcom or is referenced by a qcom_swrm_* symbol or registered via qcom snd_soc_dai_ops, when such metadata is available.

3. Limitations & Assumptions
- The exact declaration and capacity of ctrl->pconfig[] are not provided; the checker assumes it can resolve fixed-size array lengths (including macro expressions like CONST + 1) where available, else it relies on absence of bounds checks as a heuristic.
- The invariant “element 0 is unused” is inferred heuristically from +1-sized arrays; if capacity cannot be resolved or arrays are dynamically sized, reserved-index misuse may be undetectable.
- Maximum possible values of tx_num/rx_num (e.g., SLIM_MAX_TX_PORTS) are not guaranteed known at analysis time; the checker flags missing validation rather than proving concrete overflow.
- The plan assumes access to AST/IR for function pointer initializations (snd_soc_dai_ops) to link .set_channel_map to its implementation; if such linkage is unavailable, signature-based matching is used and may increase false positives.
- The checker focuses on kernel-driver-like patterns; similar bugs in other subsystems may be missed if they don’t follow the same TX/RX dual-loop signature.