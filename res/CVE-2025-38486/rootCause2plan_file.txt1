1. Plan Summary
Detect unsafe implementations of set_channel_map that write into a fixed-size, 1-based port configuration array using 0-based, unchecked indices and overwrite TX mapping with RX mapping.

2. Detection Steps
1) Step 1: Identify candidate functions — find functions assigned to the .set_channel_map member of a snd_soc_dai_ops initializer, or functions with parameters (dai, tx_num, tx_slot, rx_num, rx_slot) that are used as SND/ASoC channel map callbacks.
2) Step 2: Locate array writes in the candidate — within the callback, find loops over tx_num and rx_num where the loop index starts at 0 and is used directly to index a struct field array (e.g., ctrl->pconfig[i].ch_mask) without an offset.
3) Step 3: Resolve target array and capacity — resolve the type of ctrl (e.g., qcom_swrm_ctrl) and the declaration of the target array (e.g., pconfig[QCOM_SDW_MAX_PORTS + 1]); record that its capacity is a fixed compile-time bound.
4) Step 4: Check for absence of bounds enforcement — confirm there is no guard that clamps tx_num/rx_num to the array capacity (no min with QCOM_SDW_MAX_PORTS(+1), no i < capacity check, and no parameter validation limiting tx_num/rx_num).
5) Step 5: Detect 1-based indexing contracts around the array — in the same file, search for other writes to the same array that use an index offset of +1 (e.g., ctrl->pconfig[i + 1] = ...) or code that explicitly masks out index 0 (e.g., set_bit(0, &ctrl->port_mask)), indicating index 0 is reserved and valid indices are 1..N.
6) Step 6: Flag index-0 usage inconsistencies — if Step 5 finds a 1-based contract but the set_channel_map callback writes ctrl->pconfig[i] with i starting at 0, flag as violating the 1-based indexing invariant (risk of writing to the reserved element 0).
7) Step 7: Identify potential out-of-bounds writes — if Step 4 shows no bounds check and Step 3 gives a fixed capacity, flag the loops that iterate up to tx_num/rx_num as potentially OOB when these counts can exceed capacity (e.g., array sized to QCOM_SDW_MAX_PORTS + 1 but loops use tx_num/rx_num directly).
8) Step 8: Detect TX/RX overwrite to the same destination — within the callback, if both the tx_slot loop and the rx_slot loop assign to the same target field (e.g., ctrl->pconfig[i].ch_mask) using the same index variable without offset or separation, flag a logic corruption risk (RX overwrites TX).
9) Step 9: Cross-check index source semantics — if elsewhere in the driver the same array is indexed by “port number” (e.g., ctrl->pconfig[params->port_num] or m_port and code comments/usage state “Port numbers are 1–14”), but the callback uses the loop index position i as the array index, flag the inconsistency as a likely misindexing.
10) Step 10: Aggregate and prioritize findings — raise a high-severity alert when the following coincide: (a) 0-based writes into a 1-based array (Step 6), (b) absence of bounds checks vs fixed capacity (Step 7), and/or (c) TX/RX write collision (Step 8). Provide separate notes for each signal present.

3. Limitations & Assumptions
- Assumes CodeQL can resolve the target array’s static size from the struct declaration; macro evaluation may be limited.
- Cannot prove actual runtime values of tx_num/rx_num; flags are based on missing validation relative to a fixed array capacity.
- Inferring “1-based indexing contract” relies on code patterns (e.g., pconfig[i + 1], set_bit(0, ...)) found in the same file; absence of such patterns may reduce confidence.
- The plan targets ASoC set_channel_map-style callbacks; similar flaws elsewhere may not be detected unless they match these patterns.