1. Plan Summary
Detect unsafe channel-map handlers in ASoC/SoundWire drivers that copy user-provided slot arrays into controller config arrays starting at index 0, without bounds checks, and that reuse the same target array for TX and RX, causing out-of-bounds writes and state overwrite (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).

2. Detection Steps
1) Step 1: Objective—Identify candidate handlers wired to the DAI channel-map API. Signals—Functions referenced by a .set_channel_map initializer in a snd_soc_dai_ops struct (as removed in [PATCH_DIFF]). FP mitigation—Limit to kernel ASoC/SoundWire drivers and further prioritize functions accessing a controller struct via dev_get_drvdata, matching the pattern in [PATCH_DIFF].

2) Step 2: Objective—Locate loops that write into a controller-owned array indexed by a loop variable derived from a channel count parameter. Signals—For-loops with i starting at 0, upper-bounded by a function parameter like tx_num or rx_num, with assignments to a target array element of a field (e.g., ctrl->pconfig[i].ch_mask) from a source array at the same index (tx_slot[i] or rx_slot[i]) as shown in [ROOTCAUSE_ANALYSIS]. FP mitigation—Require both the array target to be a field of a driver control structure and the source to be a function parameter; ignore local buffer copies.

3) Step 3: Objective—Detect absence of bounds checking against the target array’s capacity. Signals—No preceding clamp, min, or conditional that ensures the loop upper bound or parameter is ≤ the static/known size of the target array; if the target array size is resolvable, compare it with the parameter without any guard (per [ROOTCAUSE_ANALYSIS] “pconfig has only QCOM_SDW_MAX_PORTS + 1 (15) elements” vs tx_num up to 16). FP mitigation—If a check exists that restricts the effective iteration count to the target length (including off-by-one for reserved slots), do not flag.

4) Step 4: Objective—Flag writes that can touch index 0 on arrays with known reserved index-0 semantics. Signals—Loop initializes i to 0 with no offset, and the first write targets element [0] of a controller array such as pconfig (Bug #1 in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation—Restrict this sub-check to the SoundWire Qualcomm driver pattern (qcom_swrm_ctrl/pconfig in [PATCH_DIFF]) or to handlers bound via .set_channel_map to reduce generalization risk.

5) Step 5: Objective—Identify mismatched source/target capacities suggestive of overflow. Signals—If the loop upper bound is a parameter associated with a larger maximum (e.g., TX max ports) and the target array has fewer elements (as in [ROOTCAUSE_ANALYSIS] SLIM_MAX_TX_PORTS=16 vs pconfig size 15), and there is no capping, report potential OOB. FP mitigation—Only report when both sides’ sizes are statically comparable or when no array bound check is present anywhere in the function.

6) Step 6: Objective—Detect logic that overwrites TX mapping with RX mapping in the same target array. Signals—Presence of two independent loops in the same function: one gated by tx_slot and writing target[i] from tx_slot[i], followed by another gated by rx_slot writing target[i] from rx_slot[i], both starting at i=0 and targeting the same array (Bug 3 in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation—Do not flag if the second loop writes to a disjoint index range, uses different target arrays/fields, or preserves previous values explicitly.

7) Step 7: Objective—Confirm the target array is controller-global configuration, increasing severity. Signals—The left-hand side involves a dereference of a controller pointer obtained from dev_get_drvdata(dai->dev) (as in [PATCH_DIFF]), implying persistent state corruption. FP mitigation—Treat as a severity-boosting signal rather than a sole trigger; do not report solely on this signal.

8) Step 8: Objective—Detect missing directional separation between TX and RX. Signals—No direction discriminator used to compute the index or select a different target storage; both TX and RX write to the same base index sequence (from 0) of the same array (as in [ROOTCAUSE_ANALYSIS]). FP mitigation—Skip if the code uses distinct arrays/fields for TX and RX or applies index offsets/partitions.

9) Step 9: Objective—Reduce noise from defensive patterns. Signals—Presence of guards that enforce starting index at 1, or explicit skipping of index 0, or checks that reserve pconfig[0] unused. FP mitigation—Do not report if loop starts at 1, or writes target[i+1], or there is a clear condition that prevents writes to index 0.

10) Step 10: Objective—Highlight combined defect scenarios. Signals—When steps 2–6 all match in the same function (unchecked copy, index starts at 0, potential overrun, and TX→RX overwrite), elevate to a high-confidence finding that mirrors the crash cause in [PATCH_DESCRIPTION].

3. Target Elements
- Function definitions assigned to .set_channel_map in snd_soc_dai_ops.
- For/while loops using a loop variable to index arrays.
- Assignments writing to struct-field arrays (e.g., ctrl->pconfig[...].field).
- Function parameters representing counts and slot arrays (tx_num, rx_num, tx_slot, rx_slot).
- Initializers retrieving controller objects (dev_get_drvdata(dai->dev)).
- Constant-sized array declarations for target arrays to resolve capacity.

4. Dataflow / Taint Considerations
- Track dataflow from function parameters tx_num/rx_num into loop bounds and from tx_slot/rx_slot into RHS of assignments.
- Track the target of writes through pointer dereferences to controller-owned arrays (ctrl->pconfig[...]).
- Associate the function symbol with its use site in snd_soc_dai_ops .set_channel_map to scope analysis to DAI channel-map handlers.

5. Validation & Test Cases
- Positive: A function registered via .set_channel_map that contains two loops: for i=0..tx_num-1 writing ctrl->pconfig[i].ch_mask = tx_slot[i], and for i=0..rx_num-1 writing ctrl->pconfig[i].ch_mask = rx_slot[i], with no bounds checks (matches [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]); expect a high-confidence alert for OOB, reserved index write, and TX→RX overwrite.
- Negative: A handler that starts indexing at 1 or writes ctrl->pconfig[i+1], clamps counts to array length minus one, and uses separate arrays/partitions for TX and RX; expect no findings.
- Test harness notes: Include cases where target array size is resolvable and where it is not; ensure the checker still flags missing clamps when sizes are unknown but other risk signals hold.

6. Estimated Effort & Priority
High: Requires structural matching of function-pointer assignments, loop semantics, array-size resolution, and multi-loop correlation within a function.

7. Likely False-Positive Sources & Mitigations
- Handlers where index 0 is valid: mitigate by scoping to SoundWire/Qualcomm patterns or requiring explicit .set_channel_map binding (per [PATCH_DIFF]).
- Implicit bounds enforcement not recognized (e.g., external validators): mitigate by scanning for any upstream clamp/validation within the same function and adjacent call sites if easily traceable.
- Cases where RX intentionally overwrites TX: mitigate by requiring explicit separation signals absence and by prioritizing controller-global targets indicative of persistent config (per [ROOTCAUSE_ANALYSIS]).

8. Limitations & Assumptions
- Assumes pconfig[0] is reserved/unused for this driver, based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; this may not generalize beyond the SoundWire QCOM driver.
- Static resolution of array sizes defined via macros (e.g., QCOM_SDW_MAX_PORTS, SLIM_MAX_TX_PORTS) may be incomplete; the checker should still flag missing clamps when sizes are unknown.
- The plan infers correctness of TX/RX separation from writing to the same target array without offsets; intent cannot always be determined purely statically.