1. Plan Summary
Detect channel-map implementations that write into a 1-based, fixed-size port configuration array starting at index 0, without validating bounds, and that overwrite TX mappings with RX mappings in the same array.

2. Detection Steps
1) Step 1: Objective: find SoundWire/ASoC channel-map implementations. Signals: functions matching the qcom_swrm_set_channel_map signature or registered via .set_channel_map in a snd_soc_dai_ops struct (based on [PATCH_DIFF] and [FILE_CONTENT]). FP mitigation: restrict to drivers in soundwire_qcom-like contexts or functions that directly access ctrl->pconfig.

2) Step 2: Objective: detect writes into ctrl->pconfig[] using a loop index starting at 0. Signals: for-loops over i initialized to 0 with condition i < tx_num or i < rx_num, and body assigns ctrl->pconfig[i].ch_mask = ... (as in [FILE_CONTENT]). FP mitigation: require the array being written is the pconfig member of a struct qcom_swrm_ctrl.

3) Step 3: Objective: establish 1-based indexing semantics to justify that index 0 is invalid. Signals: look for other code in the same file using ctrl->pconfig[i + 1] and comments like “Port numbers are 1 - 14” and masking out port 0 (set_bit(0, &ctrl->port_mask)) (from [FILE_CONTENT]). FP mitigation: only flag when such 1-based usage is observed elsewhere in the same translation unit.

4) Step 4: Objective: detect absence of bounds validation for tx_num/rx_num against the fixed array capacity. Signals: pconfig declared as QCOM_SDW_MAX_PORTS + 1 and loops guarded by user-supplied tx_num/rx_num without preceding checks ensuring tx_num/rx_num ≤ QCOM_SDW_MAX_PORTS or similar (from [FILE_CONTENT]). FP mitigation: ignore cases where a prior explicit check or clamp to array capacity exists in the function or earlier call chain.

5) Step 5: Objective: detect potential out-of-bounds writes caused by i iterating up to tx_num/rx_num. Signals: array write ctrl->pconfig[i] where i range is tied to tx_num/rx_num and no guard that i < QCOM_SDW_MAX_PORTS + 1; array capacity deduced from its declaration (from [FILE_CONTENT]). FP mitigation: require confirmation that QCOM_SDW_MAX_PORTS constant is present in the file and used to size pconfig.

6) Step 6: Objective: identify logic corruption where RX mapping overwrites TX mapping. Signals: presence of a second loop writing ctrl->pconfig[i].ch_mask = rx_slot[i] after the TX loop, targeting the same array indices (from [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]). FP mitigation: only flag when both tx_slot and rx_slot loops write to the same field (ch_mask) and to the same array without distinct index offsets or separation.

7) Step 7: Objective: correlate the risk with downstream use of ch_mask to show impact. Signals: later functions (e.g., qcom_swrm_port_enable) reading pcfg->ch_mask to set enable_ch->ch_mask, indicating critical configuration is sourced from the modified array (from [FILE_CONTENT]). FP mitigation: restrict to cases where the written field (ch_mask) is read to configure hardware/streams.

8) Step 8: Objective: tie the detected function into the DAI ops to confirm runtime reachability. Signals: snd_soc_dai_ops structure containing .set_channel_map pointing to the function (shown removed in [PATCH_DIFF], present in [FILE_CONTENT]). FP mitigation: only raise high-severity alerts when the function is actually registered in ops; otherwise, downgrade severity.

3. Target Elements
- Function implementations matching the set_channel_map signature in ASoC drivers.
- snd_soc_dai_ops initializations and their .set_channel_map assignments.
- Array declarations of ctrl->pconfig sized by QCOM_SDW_MAX_PORTS + 1.
- For-loops indexing into pconfig with loop variable starting at 0.
- Precondition checks comparing tx_num/rx_num to QCOM_SDW_MAX_PORTS (presence or absence).
- Assignments to ctrl->pconfig[i].ch_mask and subsequent uses (e.g., in qcom_swrm_port_enable).

4. Dataflow / Taint Considerations
- Track tx_num and rx_num parameters to loop bounds and the derived index i used in writes to pconfig.
- Track tx_slot[i] and rx_slot[i] flows to ctrl->pconfig[i].ch_mask to spot sequential overwrites.
- Track array capacity from the declaration of ctrl->pconfig to reason about bounds vs loop ranges.
- Cross-function evidence of 1-based indexing (pconfig[i + 1]) to taint index-0 writes as unsafe.

5. Validation & Test Cases
- Positive: Function that writes ctrl->pconfig[i].ch_mask in loops i=0..tx_num-1 and i=0..rx_num-1 without bounds checks, and is registered via .set_channel_map (as in pre-patch qcom_swrm_set_channel_map in [FILE_CONTENT]); expect detection of index-0 misuse, missing bounds, and RX-overwrites-TX.
- Negative: A driver that either omits .set_channel_map (as per revert in [PATCH_DIFF]), or validates tx_num/rx_num against QCOM_SDW_MAX_PORTS and uses 1-based indexing (pconfig[i+1]) with disjoint TX/RX storage; expect no alert.
- Test harness notes: Run on the provided file pre- and post-revert; pre-revert should flag multiple issues, post-revert should be clean due to the removal of the vulnerable function and ops registration.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Arrays that legitimately use 0-based indexing: mitigate by requiring corroborating 1-based usage elsewhere (pconfig[i+1], masked port 0).
- Functions not reachable via .set_channel_map: mitigate by checking ops registration and downgrading severity when unregistered.
- Defensive code that later clamps ch_mask: mitigate by checking for explicit bounds checks before writes.

8. Limitations & Assumptions
- The checker assumes QCOM_SDW_MAX_PORTS reflects true capacity and that pconfig[0] is unused, based on [FILE_CONTENT]; it cannot infer external constants like SLIM_MAX_TX_PORTS without broader context.
- It cannot prove at compile time concrete values of tx_num/rx_num; detection is heuristic based on missing validation.
- Intentional sharing of TX/RX mappings in a single array cannot be disambiguated from logical corruption without design docs; we assume separate mappings are required based on [ROOTCAUSE_ANALYSIS].