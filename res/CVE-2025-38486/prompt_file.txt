1. CVE Identifier
CVE-2025-38486

2. Vulnerability Type
Memory corruption due to out-of-bounds write and incorrect indexing; logic corruption (TX mapping overwritten by RX mapping)

3. Root Cause Summary
The added qcom_swrm_set_channel_map() implementation wrote channel masks into ctrl->pconfig[] starting at index 0 and iterated up to tx_num/rx_num without validating bounds or respecting that valid SoundWire port indices are 1–14. Because ctrl->pconfig is sized to QCOM_SDW_MAX_PORTS + 1 (15 entries, indices 0..14 with index 0 explicitly unused), using i=0 and unbounded i<tx_num/rx_num resulted in: (a) writing to the unused pconfig[0], and (b) out-of-bounds writes when tx_num could be 16 (SLIM_MAX_TX_PORTS), corrupting memory past pconfig[14]. Additionally, the function wrote RX slot mappings into the same pconfig[].ch_mask entries used for TX, overwriting previously written TX configuration.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA System-on-Chip (ASoC) SoundWire Qualcomm master driver (soundwire_qcom) in the sound subsystem

2) Pre-Patch Flaw:
- Function: qcom_swrm_set_channel_map() added to soundwire_qcom and registered via .set_channel_map in qcom_swrm_pdm_dai_ops.
- Code wrote “ctrl->pconfig[i].ch_mask = tx_slot[i]” and then “ctrl->pconfig[i].ch_mask = rx_slot[i]” with i starting at 0 and running to tx_num/rx_num with no bounds checks.
- This contradicts existing driver semantics where valid port numbers are 1–14 and pconfig[0] is intentionally unused (e.g., qcom_swrm_get_port_config() populates ctrl->pconfig[i + 1], and port 0 is masked via set_bit(0, &ctrl->port_mask)).

3) Trigger Condition:
- snd_soc_dai_set_channel_map() is called during sound card initialization (e.g., sdm845_dai_init -> snd_soc_link_init -> snd_soc_bind_card), passing tx_num/rx_num and slot arrays sized to subsystem constants (e.g., SLIM_MAX_TX_PORTS = 16).
- With tx_num = 16, the loop writes indices 0..15 into ctrl->pconfig[], which has valid indices 0..14, causing an out-of-bounds write at i=15; it also writes to pconfig[0], which should be unused.

4) Impact Mechanism:
- Out-of-bounds writes corrupt adjacent fields in struct qcom_swrm_ctrl (ctrl->pconfig[15] overruns into following members such as sruntime[]), causing kernel exceptions and panics, as evidenced by the BRK exception and panic trace at qcom_swrm_set_channel_map+0x7c/0x80.
- Overwriting TX mapping with RX mapping destroys configuration state, leading to misconfigured ports and instability even without OOB.

5. Patch Analysis
1) Fix Approach:
A full revert of the “set_channel_map” API integration: remove qcom_swrm_set_channel_map() and its registration in the DAI ops to eliminate the unsafe path entirely.

2) Key Code Changes:
- Deleted qcom_swrm_set_channel_map() definition that performed the unsafe writes (PATCH_DIFF hunk removing the function block).
- Removed the .set_channel_map assignment from qcom_swrm_pdm_dai_ops (PATCH_DIFF shows deletion of “.set_channel_map = qcom_swrm_set_channel_map,”).

3) Locking/Concurrency Impact:
No locking changes; the fix avoids the flawed logic altogether. The original bug was not concurrency-related but a bounds/indexing and state corruption issue.

6. Broader Kernel Security Implications
Array bounds and index semantics must be preserved when integrating subsystem APIs like set_channel_map; drivers must validate tx_num/rx_num against internal limits and adjust for 1-based port numbering to prevent OOB writes. Mixing TX/RX mappings into a single array without separation or guards leads to silent state corruption. Such memory corruption in kernel drivers can escalate from device malfunction to system-wide instability or denial-of-service, highlighting the need for rigorous input validation and consistency with existing internal data structures.