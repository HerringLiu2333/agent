1. Plan Summary
Detect use-after-free risk from a global pointer array entry left dangling on an error path and accessed without synchronization (as in dev_lec[] in net/atm/lec.c).

2. Detection Steps
1) Step 1: Identify the shared global pointer array involved in device management. Signals: a file-scope declaration like "static struct net_device *dev_lec[MAX_LEC_ITF];" and its references across multiple functions.

2) Step 2: Locate deallocation sites that free elements of this array. Signals: calls to free_netdev() where the argument is dev_lec[i] (or an alias derived from dev_lec[i]) within functions that manipulate LEC devices (e.g., lecd_attach).

3) Step 3: Determine error-path control flow around the deallocation. Signals: free_netdev(dev_lec[i]) followed by an immediate return (e.g., "return -EINVAL") due to a preceding failure (such as register_netdev() failure) within the same function.

4) Step 4: Check whether the freed array entry is cleared before the function exits on that path. Signals: absence of an assignment "dev_lec[i] = NULL" along the path from free_netdev() to the return; report if no nullification occurs.

5) Step 5: Enumerate all functions that read or write dev_lec[]. Signals: references to dev_lec[] inside lecd_attach(), lec_vcc_attach(), lec_mcast_attach(), and lane_ioctl(); identify reads (dereferences, passing to other APIs) and writes (assignments).

6) Step 6: Identify the IOCTL entry point that orchestrates these operations. Signals: lane_ioctl() containing a switch on cmd that invokes lecd_attach(), lec_vcc_attach(), and lec_mcast_attach().

7) Step 7: Assess synchronization around dev_lec[] accesses in the IOCTL path. Signals: absence of mutex_lock/mutex_unlock calls in lane_ioctl() that consistently bracket the switch or the calls accessing dev_lec[]; pre-patch, no lec_mutex exists.

8) Step 8: Correlate the dangling-pointer condition with unsynchronized access. Signals: at least one path where dev_lec[i] is freed without nullification plus at least one other function reachable from lane_ioctl() that reads dev_lec[] without any mutual exclusion.

9) Step 9: Highlight flows where a freed dev_lec[i] may be dereferenced later. Signals: interprocedural flow from the error-path return in lecd_attach() to another IOCTL-triggered function that reads dev_lec[], with no locking to prevent race.

10) Step 10: Prioritize findings that match the specific kernel pattern. Signals: involvement of register_netdev() failure leading to free_netdev() on dev_lec[i], and dev_lec[] accessed in the ATM LEC subsystem functions named in the patch/analysis.

3. Limitations & Assumptions
- The checker assumes dev_lec[] is the shared global array of interest; it does not generalize to other globals without evidence here.
- It cannot prove at compile time that register_netdev() will fail or that concurrent IOCTL invocations occur; it flags structural risk based on control flow and missing synchronization.
- It relies on recognizing free_netdev() as the deallocator; other deallocators or custom frees are not covered by the supplied materials.
- Exact mutex naming (lec_mutex) and locking policy are inferred from the patch; pre-patch code has no such mutex, so the checker reports absence of any locking rather than specific lock misuse.
- The analysis does not include /proc/net/atm/lec access paths, which the patch notes as a follow-up.