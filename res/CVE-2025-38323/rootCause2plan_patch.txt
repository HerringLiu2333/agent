1. Plan Summary
Diff-driven checker template that flags code paths missing the specific validations/guards introduced by the patch for CVE-2025-38323 (elements to be instantiated from the patch once available).

2. Detection Steps
1) Step 1: Objective — Extract what changed in the fix; conceptual signals — from [PATCH_DIFF], enumerate functions/files modified, new/strengthened condition checks, new return-value handling, locking, parameter/type changes; FP mitigation — bind detection strictly to those concrete APIs/conditions and locations to avoid generalization.
2) Step 2: Objective — Identify “sensitive operations” gated by the new checks; conceptual signals — statements/calls that in the patched code are control-dependent on the added guard (e.g., operations executed only when the new condition holds); FP mitigation — require structural similarity (same callee names/field accesses) and same basic block/ordering as in [PATCH_DIFF].
3) Step 3: Objective — Find equivalent operations lacking those guards; conceptual signals — pre-guard versions of the same operations or call sites where the identified guard does not dominate the operation; FP mitigation — treat semantically equivalent or stronger guards as satisfying the requirement to avoid false positives.
4) Step 4: Objective — If the patch adds return-value/error-path checks, catch unchecked/incorrectly used results; conceptual signals — calls whose results are ignored or error-indicating returns not checked before proceeding, contrasted with new checks added in [PATCH_DIFF]; FP mitigation — exclude sites that funnel the result into a common validator function or wrapper (detected via interprocedural call to the same checker introduced in the patch).
5) Step 5: Objective — If the patch introduces bounds/size/length validation, detect unsafe size flows; conceptual signals — data/control flows where a size/length value (as identified in [PATCH_DIFF]) reaches allocation/copy/indexing without an intervening comparison to capacity or clamp that mirrors the patch; FP mitigation — recognize equivalent pre-validation via helper functions or safe wrappers and suppress those.
6) Step 6: Objective — If the patch adds null/initialization checks, detect unsafe dereferences; conceptual signals — dereference or use of a pointer/handle (named in [PATCH_DIFF]) not dominated by a non-null or “is_valid” predicate added by the patch; FP mitigation — consider constructors/initializers that provably establish non-null and suppress within those scopes.
7) Step 7: Objective — If the patch adds locking/atomicity around a shared resource, detect unsynchronized accesses; conceptual signals — accesses to the same global/field/region for which [PATCH_DIFF] shows lock acquisition, occurring outside a “lock-held” region; FP mitigation — model recognized alternative synchronization primitives guarding the same resource and suppress when any lock-equivalent is held.
8) Step 8: Objective — If the patch tightens privilege/capability/permission checks, detect operations performed without them; conceptual signals — operations identified in [PATCH_DIFF] as requiring a capability check now, appearing without a preceding positive check; FP mitigation — suppress when the check occurs in a caller or wrapper on all paths (interprocedural dominance).
9) Step 9: Objective — If input sanitization was added, track untrusted-to-sink flows; conceptual signals — sources corresponding to parameters/fields that gained validation in [PATCH_DIFF] reaching the same sinks without passing through the patch’s sanitizer; FP mitigation — whitelist known sanitizers and equivalent custom validators discovered via call-graph similarity to the patched validator.
10) Step 10: Objective — Rank and reduce noise by patch proximity; conceptual signals — prioritize findings in the same files/functions edited in [PATCH_DIFF] or along the same call chains; FP mitigation — deprioritize pattern matches in unrelated modules unless they invoke the exact same sensitive APIs.

3. Target Elements
- Functions and methods modified in the patch, and their call sites.
- Conditional guards introduced/modified by the patch and control-flow regions they dominate.
- Sensitive operations identified by the patch (calls, dereferences, memory ops) now guarded.
- Function return-value uses for calls whose handling changed.
- Allocation/copy/indexing sites tied to patch-added size/length checks.
- Lock acquisition/release sites and accesses to protected resources.
- Capability/permission checks and the operations they guard.

4. Dataflow / Taint Considerations
- Track flows of variables/parameters that the patch newly validates to the operations that use them, flagging paths without equivalent validation.
- Use control-dependence to ensure operations are dominated by the patch-introduced guards; treat those guards as sanitizers.
- Model lock-held state as a path predicate introduced by the lock API seen in [PATCH_DIFF] and require it to dominate protected accesses.
- For return-value handling, track the propagation and use of the call result; flag direct use without the patch’s check or error-path handling.

5. Validation & Test Cases
- Positive: A function performing the same operation/call identified in the patch but without the newly added guard (e.g., missing check/lock/return-value validation), leading to an unguarded sensitive operation.
- Negative: The same operation enclosed by the exact guard or via a wrapper that performs the same validation introduced by the patch; also a case with an equivalent or stronger guard.
- Test harness notes: Instantiate API names, variables, and guards from [PATCH_DIFF]; include interprocedural cases where validation occurs in a caller; include a synchronization variant if the patch added locking.

6. Estimated Effort & Priority
Medium — the checker is a diff-parameterized pattern detector requiring control/dataflow modeling and interprocedural dominance checks, but it is reusable once the patch elements are bound.

7. Likely False-Positive Sources & Mitigations
- Checks performed in wrapper/caller functions: mitigate with interprocedural dominance analysis.
- Equivalent custom validators not textually identical: mitigate by recognizing semantics (e.g., same operands/relations) and configurable allowlists.
- Alternative synchronization primitives: mitigate by modeling common lock APIs and allowing project-specific lock annotations.
- Benign ignored return values: mitigate by scoping to the specific calls whose handling changed in the patch and by requiring path continuation to a sensitive sink.

8. Limitations & Assumptions
- [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS] are not provided, so no concrete APIs, guards, or operations can be named; the checker must be instantiated once those are available.
- The plan assumes the patch adds explicit, statically-detectable guards/validations/locking or return-value handling; if the fix is purely architectural or runtime-config based, static detection may be insufficient.
- Source/sink classification and sanitizer identification depend entirely on the specific elements revealed by [PATCH_DIFF]; without them, only a generic template can be defined.