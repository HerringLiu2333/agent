1. Plan Summary
Insufficient information to derive a vulnerability-specific detection plan; propose a diff-driven, pattern-extraction approach that can be instantiated once PATCH_DIFF/FILE_CONTENT/ROOTCAUSE_ANALYSIS are available.

2. Detection Steps
1) Step 1: Objective: Confirm available evidence. Signals: Check [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS] exist and contain concrete changes and root cause; in this case they are missing/empty per [ROOTCAUSE_ANALYSIS]. FP mitigation: Abort specific pattern inference when evidence is absent to avoid speculative results.
2) Step 2: Objective: Identify code elements changed by the patch (once available). Signals: Functions, call sites, conditionals, or type/field changes present in [PATCH_DIFF]. FP mitigation: Limit scope to hunks directly modified by the patch rather than nearby refactors.
3) Step 3: Objective: Extract the semantic intent of added checks/guards. Signals: New null checks, bounds checks, permission checks, error handling branches, locking/unlocking, or lifetime/ownership changes added in [PATCH_DIFF]. FP mitigation: Verify that the added logic is not purely stylistic (e.g., formatting) by ensuring control/dataflow is affected.
4) Step 4: Objective: Derive the pre-patch flaw predicate. Signals: Absence of the newly added guard in the same function path or call pattern before dereference/use, allocation/copy, concurrency boundary, or sensitive operation indicated by the patch. FP mitigation: Require the sensitive sink (dereference, copy, syscall, lock usage) to be present to avoid flagging benign missing checks.
5) Step 5: Objective: Generalize from specific changed sites to a project-wide pattern. Signals: The same call sequences, data types, or API usage patterns across codebase that mirror the patched locations. FP mitigation: Constrain generalization to identical or close-variant API shapes (same callee name/signature, same struct/field use).
6) Step 6: Objective: Model the sensitive sink(s). Signals: Operations whose safety now depends on the newly added guard (e.g., dereference, indexing, memcpy/memmove, arithmetic, state transitions, lock acquisition). FP mitigation: Cross-verify with patch context to ensure the sink type matches what the patch guarded.
7) Step 7: Objective: Model required preconditions introduced by the patch. Signals: Conditions that must hold before the sink (e.g., pointer not null, length ≤ buffer, return value checked for error, lock held, reference count valid). FP mitigation: Ensure the precondition pertains to the same variables/objects reaching the sink via control/dataflow.
8) Step 8: Objective: Perform path-sensitive reachability from source to sink without the required preconditions. Signals: Paths where a variable reaches the sink and none of the guard conditions (as learned from the patch) dominate or post-dominate appropriately. FP mitigation: Exclude paths where equivalent checks exist under different but provably equivalent conditions.
9) Step 9: Objective: Handle interprocedural patterns. Signals: Guards added at callers vs. callees in [PATCH_DIFF]; detect similar missing checks at analogous boundaries. FP mitigation: Require consistent call graph edges and parameter-object mapping to avoid mismatched contexts.
10) Step 10: Objective: Reduce noise with exception/early-exit awareness. Signals: Control-flow edges that enforce safety via early returns or error propagation, which may satisfy the guard implicitly. FP mitigation: Accept alternative safety proofs that guarantee the precondition prior to the sink.
11) Step 11: Objective: Prioritize findings. Signals: Report only when the sink is high-impact (memory, privilege, concurrency, integrity) as inferred from the kind of guard added in [PATCH_DIFF]. FP mitigation: Deprioritize low-impact or dead-code instances using reachability and usage frequency.
12) Step 12: Objective: Produce actionable messages. Signals: Reference the exact missing guard derived from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] and the sink location; if unavailable, flag that specific guidance cannot be given due to missing evidence. FP mitigation: Suppress generic messages when evidence is insufficient.

3. Target Elements
- Functions and methods modified by the patch (names, parameters, return handling).
- Call sites of patched APIs across the codebase.
- Condition checks added by the patch (null, bounds, capability/permission, state).
- Sensitive operations guarded by the patch (dereference, memory copy, indexing, arithmetic, state transitions).
- Locking regions or reference-count operations added or reordered by the patch.
- Function return-value inspections and error-propagation branches introduced by the patch.

4. Dataflow / Taint Considerations
- Track variables from sources identified in patched sites to sinks the patch protects.
- Model preconditions as required predicates dominating the sink; report if data reaches the sink without satisfying them.
- Interprocedural propagation of object/parameter relationships to detect missing checks at callers vs. callees.
- Recognize equivalent guards (e.g., wrapper checks) to reduce false positives.

5. Validation & Test Cases
- Positive: A function performing a sensitive operation (e.g., dereference or memcpy) without the relevant guard, mirroring the pre-patch pattern inferred from [PATCH_DIFF] once available.
- Negative: The same operation with the exact guard added by the patch present; also a variant where an equivalent precondition is established via early return.
- Test harness notes: Create minimal files that isolate the sink and guard pattern derived from the patch; include interprocedural caller/callee variants to validate propagation.

6. Estimated Effort & Priority
High — specific vulnerability semantics cannot be defined without [PATCH_DIFF]/[FILE_CONTENT]/[ROOTCAUSE_ANALYSIS], requiring a two-phase workflow (ingest evidence, then instantiate checker patterns).

7. Likely False-Positive Sources & Mitigations
- Equivalent guards expressed differently (mitigate by dominance and equivalence reasoning).
- Context-specific safety invariants not evident interprocedurally (mitigate by call-graph and summary modeling).
- Benign uses where the sink is not actually sensitive (mitigate by aligning sink types with the patch’s protected operations).
- Dead or unreachable code (mitigate with reachability analysis).

8. Limitations & Assumptions
- No concrete [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], or actionable [ROOTCAUSE_ANALYSIS] were provided; [ROOTCAUSE_ANALYSIS] explicitly indicates missing content.
- The checker cannot name specific APIs, conditions, or sinks until patch evidence is available.
- Assumes the patch adds explicit guards or state changes that can be semantically identified; if the fix is non-local or architectural, this approach may not apply.
- Assumes availability of the pre- and post-patch codebase to derive patterns; otherwise only generic safety checks can be attempted.