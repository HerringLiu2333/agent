1. Plan Summary
Detect C code paths that gate access to a struct field by comparing only the field’s start offset (via offsetof) to a runtime item size, without ensuring the field’s end lies within bounds, then read the field, risking an out-of-bounds read.

2. Detection Steps
1) Step 1: Objective: Find start-only offset bound checks. Signals: A conditional comparing offsetof(Type, field) with a runtime “size-like” variable using <= or <; this mirrors the pre-patch pattern in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: Require the size operand to be non-constant and not a sizeof(), to focus on externally provided sizes (as in SMEM item_size in [ROOTCAUSE_ANALYSIS]).

2) Step 2: Objective: Tie the check to a subsequent field access. Signals: Inside the condition’s true branch (or dominated region), an access to ptr->field (or equivalent) where ptr’s static type matches Type and field. FP mitigation: Demand control dependence (the check dominates the access) to avoid unrelated nearby uses.

3) Step 3: Objective: Ensure the end-of-field is not validated elsewhere. Signals: Absence in the dominating path of any check equivalent to end-of-field within bounds (e.g., offset(field) + sizeof(field) <= size or a macro like offsetofend as per [PATCH_DIFF]). FP mitigation: If such an end-of-field bound exists and dominates the access, do not flag.

4) Step 4: Objective: Confirm the field has non-zero, fixed size. Signals: field is a scalar or fixed-size member (e.g., integer like serial_num from [ROOTCAUSE_ANALYSIS]); exclude flexible array members or zero-sized placeholders. FP mitigation: Skip fields that are flexible arrays or whose size cannot be resolved at compile time.

5) Step 5: Objective: Increase confidence the struct instance comes from externally sized memory. Signals: The struct pointer is derived from a raw buffer, mapping, or firmware/SMEM-like source, with an accompanying size variable used in the same function (as described in [ROOTCAUSE_ANALYSIS]). FP mitigation: Prefer cases where the same size variable controls both the check and is associated (by dataflow or naming) with the memory region holding the struct.

6) Step 6: Objective: Identify exposure to userspace to prioritize/report. Signals: The field’s value is converted/printed/formatted (e.g., via devm_kasprintf and le32_to_cpu, reflecting [PATCH_DIFF]) or used to initialize a sysfs attribute. FP mitigation: This is a boosting signal; do not require it to report, but raise severity if present.

7) Step 7: Objective: Confirm feasibility of OOB under the observed check. Signals: Compute the compile-time end offset (offset + sizeof(field)) and note that the condition only restricts the start; model a feasible range where size ∈ [offset(field), end(field)) is allowed by the check yet unsafe (per [ROOTCAUSE_ANALYSIS]). FP mitigation: Only report if such a feasible range exists (i.e., end(field) > offset(field)) and the size variable is runtime, not a compile-time constant equal to or exceeding the full struct size.

8) Step 8: Objective: Exclude redundant or stronger validations. Signals: Presence of any earlier check that ensures the entire struct (or at least field end) fits within size before the field access (e.g., comparing size against sizeof(struct) or explicit end-of-field checks). FP mitigation: If a dominating check ensures sufficient size for the accessed field, suppress the alert.

9) Step 9: Objective: Catch variants of the same flaw pattern. Signals: Equivalent comparisons with reversed operands or different relational operators (e.g., size > offsetof(...), size >= offsetof(...)), still lacking an end-of-field bound, followed by field access. FP mitigation: Apply the same end-of-field absence and control-dependence filters as above.

10) Step 10: Objective: Reduce noise from safe copies. Signals: If the code only copies raw bytes up to the available size and does not dereference the field (no typed access), do not flag. FP mitigation: Require a typed dereference/use of the field (e.g., reading info->serial_num) to match the info-leak read described in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Conditional expressions involving offsetof and a runtime size variable.
- Field accesses (struct_member expressions) dominated by the above condition.
- Macro invocations for offsetof/offsetofend and sizeof(field-type).
- Pointer initializations/casts where a raw buffer is treated as a struct instance.
- Calls that format or expose values (e.g., string formatting for sysfs attributes), to prioritize.

4. Dataflow / Taint Considerations
- Track control dependence from the start-only offset check to the field access.
- Track association between the “size-like” variable and the backing memory region for the struct pointer within the function (even if only by shared scope and usage).
- Optionally, treat size variables sourced from external/firmware/shmem APIs as higher confidence, consistent with SMEM item_size in [ROOTCAUSE_ANALYSIS].

5. Validation & Test Cases
- Positive: Code that does if (offsetof(struct socinfo, serial_num) <= item_size) { use info->serial_num; } where item_size is runtime, and no end-of-field check exists; expect a report (matches [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: Code using if (offsetofend(struct socinfo, serial_num) <= item_size) { use info->serial_num; } or if (offsetof + sizeof(field) <= item_size) ...; expect no report (per fix in [PATCH_DIFF]).
- Negative: Code that validates sizeof(struct socinfo) <= item_size before accessing info->serial_num; expect no report (end-of-field implied).
- Test harness notes: Include variants with reversed comparison operands, variant operators (<=, <, >, >=), and cases that only memcpy bytes without typed field access.

6. Estimated Effort & Priority
Medium: Requires modeling offsetof patterns, CFG dominance, and simple compile-time end-of-field computation; high value due to info-leak risk noted in [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Checks on flexible array members where start-bound checks may be intentional; mitigate by excluding FAMs/zero-sized members.
- Cases where a stronger size validation occurs in a separate dominating path; mitigate with dominance and path-sensitivity checks.
- Situations where the size is guaranteed by context (e.g., protocol contracts) but not evident locally; mitigate by prioritizing when exposure/formatting to userspace is present (as in [PATCH_DIFF]).

8. Limitations & Assumptions
- The checker assumes field sizes are statically known and that offsetof can be resolved; opaque macros/types may limit analysis.
- It may not reliably determine whether the struct layout version omits a field (as in SOCINFO_VERSION in [ROOTCAUSE_ANALYSIS]); it instead flags the unsafe start-only check pattern.
- Association of size variables with the backing memory may be heuristic if APIs are not identifiable from local context.