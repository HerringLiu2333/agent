1. CVE Identifier
CVE-2024-58007

2. Vulnerability Type
Out-of-bounds read due to improper bounds check, resulting in information disclosure via sysfs.

3. Root Cause Summary
The pre-patch logic in qcom_socinfo_probe validated only the start offset of the serial_num field against the SMEM-provided item_size using “if (offsetof(struct socinfo, serial_num) <= item_size)”. This allowed a read starting exactly at the end of the buffer or when the field did not exist in older SOCINFO versions, causing the subsequent 4-byte read to go past item_size. The missing validation of the field’s full extent (end offset) led to reading beyond the available socinfo structure, pulling arbitrary data from SMEM and exposing it as a serial number in sysfs.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm SoC information driver (drivers/soc/qcom/socinfo.c).

2) Pre-Patch Flaw:
In qcom_socinfo_probe, the bounds check used offsetof(struct socinfo, serial_num) ≤ item_size, which only ensures the field’s start lies within the buffer and ignores the field’s size. This is incorrect for fixed-size fields (u32 serial_num) and versioned structures where the field may not exist, enabling a read past the end of the structure.

3) Trigger Condition:
Devices using SOCINFO_VERSION(0, 8) (e.g., MSM8916) where the socinfo struct lacks serial_num and item_size is equal to the offset where newer versions place serial_num or smaller than the field’s end. On driver probe, the code attempts to format info->serial_num for the sysfs serial_number attribute.

4) Impact Mechanism:
le32_to_cpu(info->serial_num) reads 4 bytes beyond the socinfo buffer from SMEM; devm_kasprintf then exposes this value via sysfs as “serial_number”, leaking unintended memory content. The observed constant serial number on MSM8916 devices evidences a deterministic OOB read of adjacent data beyond the socinfo struct.

5. Patch Analysis
1) Fix Approach:
Strengthen the bounds check to validate that the entire serial_num field is contained within item_size by using offsetofend() rather than offsetof().

2) Key Code Changes:
In qcom_socinfo_probe:
- Replace “if (offsetof(struct socinfo, serial_num) <= item_size)” with “if (offsetofend(struct socinfo, serial_num) <= item_size)”, ensuring the end of the serial_num field is within bounds before reading.

3) Locking/Concurrency Impact:
None. The change is a pure bounds check correction executed during device probe; no locking or ordering modifications.

6. Broader Kernel Security Implications
Firmware-defined, versioned data structures must be validated using end-of-field checks to prevent boundary-adjacent OOB reads. Exposing data from shared memory or firmware blobs via sysfs without proper bounds validation can leak kernel/firmware memory and lead to deterministic, device-wide information disclosure. This fix highlights the need for rigorous size/offset verification in drivers parsing SMEM or other external layouts to avoid similar vulnerabilities.