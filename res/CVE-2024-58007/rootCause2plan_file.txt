1. Plan Summary
Detect guard conditions that validate presence of a struct field within a variable-sized buffer using only the field’s start offset (offsetof) compared to the buffer size, followed by dereferencing that field, which can cause out-of-bounds reads and information disclosure.

2. Detection Steps
1) Step 1: Objective: Find functions that obtain a pointer to a firmware/shared-memory-backed struct together with a size. Signals: Calls that return both a pointer and an item_size (e.g., as seen with qcom_smem_get in [FILE_CONTENT]) and then treat the pointer as a struct type. FP mitigation: Limit to cases where the size originates from an external source or API, not from sizeof or compile-time constants.

2) Step 2: Objective: Identify conditional guards that compare offsetof(struct T, field) to a size. Signals: Conditions using the offsetof macro with a struct and field, compared against a variable representing item_size (matching [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Require the macro use to be directly in a relational comparison with the same size variable obtained alongside the pointer.

3) Step 3: Objective: Determine whether the guard ignores the field’s size (end-of-field). Signals: The condition uses only offsetof(...) without adding sizeof(field) or using an equivalent end-of-field macro (e.g., offsetofend as in the fix in [PATCH_DIFF]). FP mitigation: Exclude cases that add sizeof(field) or call an end-of-field macro in the comparison.

4) Step 4: Objective: Confirm that the guarded block dereferences or reads the field. Signals: Inside the true branch, use of obj->field, conversions (e.g., le32_to_cpu(info->serial_num) in [FILE_CONTENT]), or formatting it for output (devm_kasprintf). FP mitigation: Require a dataflow from the field access to a use site (print/format/copy), ensuring a read occurs.

5) Step 5: Objective: Prioritize cases where the comparator allows equality or less-than on start offset only. Signals: Use of <= or < between offsetof(...) and item_size (as in the vulnerable code in [FILE_CONTENT] and described in [ROOTCAUSE_ANALYSIS]). FP mitigation: Still flag even with < (since it remains insufficient), but downgrade severity if additional checks exist nearby; exclude > or >= checks unrelated to the field.

6) Step 6: Objective: Identify that item_size is meant to bound a variable-length, versioned structure. Signals: Presence of version checks (e.g., SOCINFO_VERSION(...) gating in [FILE_CONTENT]) or comments indicating fields added by version, combined with a guard using only start offset. FP mitigation: Do not require the version checks; use them as a strengthening signal to reduce false positives by focusing on versioned structs.

7) Step 7: Objective: Classify severity when the read value is exposed to user space (information disclosure). Signals: Formatting the field into strings (devm_kasprintf) and assigning to sysfs-related attributes (e.g., qs->attr.serial_number in [FILE_CONTENT]); this aligns with the impact in [ROOTCAUSE_ANALYSIS]. FP mitigation: If the value stays local and is not exposed, still report as OOB read but with lower severity.

8) Step 8: Objective: Exclude safe patterns using end-of-field validation. Signals: Checks using offsetofend(struct T, field) <= size (as in the fix in [PATCH_DIFF]) or manual offset + sizeof(field) <= size. FP mitigation: Explicitly suppress any alert where the end-of-field is validated before the read.

9) Step 9: Objective: Detect alternate syntactic forms of the same flaw. Signals: Guards comparing start offset to size using different relational operators or intermediate variables (e.g., storing offsetof(...) into a temp and comparing that), followed by field dereference. FP mitigation: Ensure the temp variable’s value is derived solely from offsetof(...) without adding sizeof(field).

10) Step 10: Objective: Reduce noise by ensuring the size is the same bound used to retrieve the struct. Signals: The size variable used in the guard is the same returned alongside the pointer acquisition (e.g., item_size from qcom_smem_get in [FILE_CONTENT]). FP mitigation: Require that the size variable is dataflow-linked to the acquisition call.

3. Target Elements
- Functions that acquire external/firmware/shared-memory records and a corresponding size (e.g., qcom_smem_get call sites).
- Conditional guards using offsetof on struct fields compared to an item_size.
- Field dereferences inside guarded blocks (member accesses).
- Formatting or exporting of read values to device attributes/sysfs (e.g., devm_kasprintf to qs->attr.serial_number).
- Struct definitions that include version-dependent fields (e.g., serial_num introduced at SOCINFO Version 10 in [FILE_CONTENT]).

4. Dataflow / Taint Considerations
- Track dataflow from the acquisition call returning pointer+size to the guard condition (size variable).
- Track control-flow from the guard into the block where the field is dereferenced.
- Track dataflow from the field dereference into output sinks (formatting/printing/attribute assignment) to identify information disclosure.
- Do not require taint from untrusted sources; the focus is bounds adequacy within versioned/variable-sized structures.

5. Validation & Test Cases
- Positive: The pre-patch snippet in [FILE_CONTENT]: if (offsetof(struct socinfo, serial_num) <= item_size) followed by le32_to_cpu(info->serial_num) and devm_kasprintf to qs->attr.serial_number — should be flagged.
- Positive: Variation using if (offsetof(struct socinfo, serial_num) < item_size) with the same dereference — should be flagged.
- Negative: The patched code in [PATCH_DIFF] using if (offsetofend(struct socinfo, serial_num) <= item_size) — should not be flagged.
- Negative: Manual end-of-field check (offsetof + sizeof(field) <= item_size) before reading — should not be flagged.
- Negative: Code that checks start offset only but does not dereference the field — should not be flagged.
- Test harness notes: Ensure the checker links the size variable from the acquisition call to the guard and recognizes dereference and exposure patterns.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Guards that check start offset only but are followed by additional implicit guarantees elsewhere (e.g., version constraints guaranteeing field presence): mitigate by requiring dereference in the guarded block and no observed end-of-field check.
- Cases where size represents the entire struct (not a variable-length item): mitigate by focusing on acquisition APIs returning size alongside data and versioned structures as signals.
- Complex guard expressions that indirectly include field size: mitigate by excluding conditions that, via arithmetic, incorporate sizeof(field), even if not obvious macros.

8. Limitations & Assumptions
- Assumes that item_size bounds the actual available bytes of the variable-length record; the checker cannot verify firmware semantics from code alone.
- Cannot infer at compile time whether a version check elsewhere truly guarantees field presence; relies on structural signals as per [ROOTCAUSE_ANALYSIS].
- Relies on recognizing macros like offsetofend conceptually; actual macro resolution may vary across codebases.