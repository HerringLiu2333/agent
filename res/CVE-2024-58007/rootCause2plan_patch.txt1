1. Plan Summary
Detect kernel code that guards access to a struct field with a bounds check using only the field’s start offset (offsetof) against a source buffer size, without verifying the field’s end lies within bounds.

2. Detection Steps
1) Step 1: Identify struct field reads — find uses of a struct pointer dereference accessing a field (e.g., S_ptr->field) where S_ptr has type struct S and field is a member of S.
2) Step 2: Locate the guard condition — check if the field read occurs under an if-condition that compares offsetof(struct S, field) against a size-like variable (e.g., “<= item_size” or equivalent).
3) Step 3: Tie the size variable to the backing data — verify the compared size variable is conceptually the size/length of the serialized/memory-mapped item (e.g., a buffer from firmware/SMEM), by seeing it used as a bound for that data region or passed to APIs that retrieve the region.
4) Step 4: Confirm field access relies on the guard — ensure the guarded block dereferences S_ptr->field, not just computes the offset; the dereference must be data-dependent on the guard (e.g., within the block).
5) Step 5: Check for missing end-of-field validation — ensure the guard does not use an end-of-field check such as “offset + sizeof(field) <= size” or a helper equivalent (e.g., offsetofend); absence of any such end-bound arithmetic is required to flag.
6) Step 6: Exclude safe patterns — do not flag if there is a separate or combined condition ensuring the end of the field lies within the size (e.g., another conjunct that uses offset plus field size, or a known macro for end-of-field).
7) Step 7: Boost confidence by downstream use — optionally raise severity if the field value is transformed (e.g., le32_to_cpu) and then propagated to user-visible outputs (e.g., formatted string for sysfs attributes), indicating potential information disclosure.
8) Step 8: Report — emit a finding that the code uses a start-offset-only bounds check before reading a field from a variable-size struct, recommending an end-of-field bounds check.

3. Limitations & Assumptions
- The checker assumes the compared “size” variable represents the actual bounds of the backing data (e.g., SMEM item size); this may not always be statically provable.
- Custom end-of-field checks may exist under different names or inline arithmetic; the checker may miss them if they are non-standard or deeply inlined beyond simple pattern recognition.
- The checker does not verify structure versioning semantics (e.g., whether a firmware version omits a field); it flags the unsafe pattern regardless of platform-specific layout guarantees.
- Some patterns may be false positives if the struct is guaranteed to be fully present or the size check is redundant due to external invariants not visible to static analysis.