1. Plan Summary
Detect C code that guards access to a struct field using only the field’s start offset (via offsetof) compared against a buffer size, then reads that field, without verifying the field’s end lies within bounds (i.e., missing offset+size or offsetofend check).

2. Detection Steps
1) Step 1: Identify conditional guards that compare offsetof(struct S, F) with a size-like variable using relational operators (<=, <, >=, >) to justify safety. Conceptual signals: an expression containing offsetof(S, F) and a comparison to a variable plausibly representing a byte size.

2) Step 2: Extract S and F from the offsetof call in the guard and bind the size variable used in that comparison. Conceptual signals: match the exact struct type and field and the specific integer variable on the other side of the comparison.

3) Step 3: Confirm that the guarded region (true branch or path dominated by the guard) contains a read of the same field F from a pointer of type struct S*. Conceptual signals: member access P->F (or (*(S*)P).F) used as an rvalue or its address used in a read context (e.g., argument to a function expecting input).

4) Step 4: Pair the struct pointer P and the size variable as describing the same memory object. Conceptual signals: both produced by the same call (e.g., a function that returns P and writes to &sizeVar), or P assigned from a call/result while sizeVar is set via an out-parameter of the same call.

5) Step 5: Ensure the guard does not already check the field’s end. Conceptual signals: absence in the same boolean condition (and its dominating conditions) of patterns like offsetofend(S, F) or offset + sizeof(field) <= sizeVar or FIELD_SIZEOF(S, F) contributing to an “end within size” check.

6) Step 6: Ensure the field F has a known, nonzero static size. Conceptual signals: F is not a flexible array member; sizeof(F) is well-defined (e.g., scalar u32 or fixed-size array/struct).

7) Step 7: Treat equivalent guard forms consistently. Conceptual signals: accept commuted comparisons (sizeVar >= offsetof(S, F)), strict or non-strict variants, and simple arithmetic around sizeVar that still only compares start offset (e.g., offsetof(S, F) < sizeVar + c) without adding sizeof(F).

8) Step 8: Verify that the guarded read is semantically a read from memory, not just a write. Conceptual signals: value of P->F used in an expression or passed to a function that consumes it (e.g., le32_to_cpu(P->F), formatting functions).

9) Step 9: Exclude cases where a stronger end-of-field check dominates elsewhere on all paths to the read. Conceptual signals: a prior condition in control-flow that ensures offset + sizeof(field) <= sizeVar, or use of a known-safe helper/macro that computes/checks the end offset before the read.

10) Step 10: Report a result tying the guard and the subsequent field access. Conceptual signals: highlight the comparison using only offsetof(S, F) as insufficient and the read of P->F as relying on it; suggest checking end-of-field (offset + sizeof(F) <= sizeVar or offsetofend).

3. Limitations & Assumptions
- Assumes the size variable in the comparison corresponds to the same memory region as the struct pointer; pairing via shared call site or out-parameter is heuristic and may miss or mis-pair in complex flows.
- Only detects patterns that explicitly use offsetof; cases computing offsets via other means (manual constants, custom macros) may be missed.
- Considers correctness evidenced by presence of offset+sizeof(field) or offsetofend; other project-specific safe validations might not be recognized and could cause false positives/negatives.
- Interprocedural dominance of checks is limited; checks performed in different functions or via inlined helpers may be missed without whole-program reasoning.
- Does not verify actual structure layout versioning or firmware contracts; it flags the missing end-of-field check irrespective of whether the environment currently guarantees safety.