1. CVE Identifier
CVE-2024-58007

2. Vulnerability Type
Out-of-bounds read leading to information disclosure via sysfs

3. Root Cause Summary
In qcom_socinfo_probe() the driver determines whether the serial_num field is present by checking only the start offset against the SMEM item size: “if (offsetof(struct socinfo, serial_num) <= item_size)”. This validation is incorrect for variable-sized firmware structures because it does not ensure there is enough space for the entire field. On SOCINFO versions < 10 (e.g., MSM8916 reporting SOCINFO_VERSION(0, 8)), item_size can equal the start offset of serial_num, causing a 4-byte read past the end of the socinfo SMEM item. The out-of-bounds value is then exposed to userspace via the serial_number sysfs attribute.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm SoC info driver (drivers/soc/qcom/socinfo.c), platform driver “qcom-socinfo”

2) Pre-Patch Flaw:
Bounds validation used offsetof(struct socinfo, serial_num) <= item_size, which only checks the start of the field and ignores the field’s size; this allows reading info->serial_num even when the field is not fully within the SMEM item.

3) Trigger Condition:
Devices whose firmware provides SOCINFO versions below 10 (e.g., SOCINFO_VERSION(0, 8) on MSM8916) where item_size equals the offset of serial_num, causing the equality case to pass the check and permitting a read past the actual data.

4) Impact Mechanism:
A 4-byte out-of-bounds read of info->serial_num occurs, and the resulting value is formatted and exposed via qs->attr.serial_number under /sys/devices/soc0/serial_number, leaking adjacent SMEM contents (manifesting as a constant serial number across devices).

5. Patch Analysis
1) Fix Approach:
Strengthen bounds checking to validate that the entire serial_num field lies within the SMEM item, not just its start address.

2) Key Code Changes:
In qcom_socinfo_probe(), the condition was changed from:
- if (offsetof(struct socinfo, serial_num) <= item_size)
to:
+ if (offsetofend(struct socinfo, serial_num) <= item_size)
ensuring offset+sizeof(serial_num) is within item_size before reading.

3) Locking/Concurrency Impact:
None; the change is a validation fix executed during probe and does not alter locking, concurrency, or ordering.

6. Broader Kernel Security Implications
Parsing firmware-defined, variable-sized structures requires precise validation that the end of each field is within bounds; start-offset checks are insufficient and can cause OOB reads and information leaks. Exposing such values via sysfs can mislead userspace (e.g., fake “serial numbers”) and leak adjacent memory, potentially aiding fingerprinting or unintended disclosure. This fix emphasizes the need for correct size-aware validation patterns (e.g., offsetofend) across drivers accessing shared memory or versioned structures.