1. Plan Summary
Detect cases where a field in a firmware/shared-memory-backed struct is read after only checking the field’s start offset against a supplied size, without validating the end of the field, leading to an out-of-bounds read.

2. Detection Steps
1) Step 1: Identify functions that obtain a pointer to externally supplied struct data along with a size bound. Signals: a call returning a pointer and simultaneously populating a size variable via an out-parameter (e.g., qcom_smem_get with &item_size) per [FUNCTION_CONTENT]. FP mitigation: Require both pointer assignment and a size variable initialized by the same call.
2) Step 2: Locate subsequent accesses to fields of the returned struct pointer. Signals: expressions like info->field, especially immediately followed by conversions (e.g., le32_to_cpu(info->serial_num)) as in [FUNCTION_CONTENT]. FP mitigation: Ensure the accessed field belongs to the same struct type associated with the earlier pointer.
3) Step 3: Find conditional guards that compare the size variable to the start offset of the accessed field. Signals: checks of the form size >= offsetof(struct T, field) (as in [PATCH_DIFF] and [FUNCTION_CONTENT]). FP mitigation: Tie the referenced struct T and field to the same pointer and field used later in the read.
4) Step 4: Confirm that no end-of-field validation is present before the read. Signals: absence of a check ensuring end-of-field within bounds (no offsetofend(struct T, field) <= size or equivalent offset + sizeof(field) <= size), per [PATCH_DESCRIPTION]/[PATCH_DIFF]. FP mitigation: Search the controlling condition and surrounding guards; if any end-of-field check exists on the same path, do not flag.
5) Step 5: Determine the field’s concrete type and size is fixed and positive (e.g., u32). Signals: field type is a scalar/known fixed-size field (serial_num is u32 per [ROOTCAUSE_ANALYSIS]). FP mitigation: Skip flexible array members or unknown-sized fields where end-of-field validation semantics differ.
6) Step 6: Verify that the field read occurs under the control of the start-offset-only guard. Signals: dominance/postdomination of the field access by the guard; the field access is inside the guarded block (as shown in [FUNCTION_CONTENT]). FP mitigation: Ensure control-flow linkage; ignore accesses outside the guard or under stronger checks.
7) Step 7: Optionally assess whether the read value is propagated to user-visible sinks (e.g., sysfs through formatting). Signals: value passed to formatting functions like devm_kasprintf or stored into attributes (qs->attr.serial_number) as in [FUNCTION_CONTENT] and described in [ROOTCAUSE_ANALYSIS]. FP mitigation: This is a severity annotation; do not require a sink to flag, but record if present to prioritize.
8) Step 8: Exclude cases where the check uses offsetofend or equivalent corrected logic. Signals: explicit use of offsetofend(struct T, field) <= size (the patch change in [PATCH_DIFF]). FP mitigation: Treat any end-of-field check as safe and suppress findings.
9) Step 9: Confirm that the size bound originates from the same external data source backing the struct pointer. Signals: the size variable comes from the same API call that provided the pointer (e.g., item_size from qcom_smem_get as per [FUNCTION_CONTENT]). FP mitigation: If the size is unrelated or computed from a different source, deprioritize or skip to reduce spurious matches.
10) Step 10: Highlight paths where the size can equal the start offset, which still passes the guard but would fail end-of-field containment. Signals: conditional operator that allows equality (<=) and fixed field size > 0; this matches the root cause described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Require that the field size is known and non-zero so equality is unsafe.

3. Target Elements
- Function bodies that call external data retrieval APIs returning a pointer and a size (e.g., qcom_smem_get).
- Conditional checks comparing a size variable against offsetof(struct, field).
- Struct field accesses (pointer->field) guarded by the above checks.
- Calls that propagate field values to formatting or sysfs attribute storage (e.g., devm_kasprintf, assigning to qs->attr.*).

4. Dataflow / Taint Considerations
- Track the pair (pointer, size) from the retrieval call to the subsequent guard and field access.
- Ensure control-flow that the guard dominates the field read.
- Optionally track the field’s value to user-visible sinks to prioritize findings (sysfs exposure as in [ROOTCAUSE_ANALYSIS]).

5. Validation & Test Cases
- Positive: A function calling qcom_smem_get(&item_size) to get info, checking if offsetof(struct socinfo, serial_num) <= item_size, then reading info->serial_num and formatting it (matches [FUNCTION_CONTENT]).
- Negative: Same function but using offsetofend(struct socinfo, serial_num) <= item_size before reading info->serial_num (matches [PATCH_DIFF] fix).
- Negative: Code that validates end-of-field with offset + sizeof(field) <= size before accessing the field, even if it also checks start offset.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Uses of offsetof for presence checks where the field is guaranteed by versioning not shown in code: mitigate by requiring the size and pointer come from external data and the field is read afterward.
- Cases where another guard elsewhere ensures end-of-field containment: mitigate by scanning path-local guards and suppress if any end-of-field check exists.
- Flexible array or variable-sized fields: mitigate by requiring fixed-size field types.

8. Limitations & Assumptions
- Assumes the analysis can resolve sizeof(field) or treat offsetofend as an indicator; specific struct layouts beyond provided examples are not available.
- The presence of external version checks is not shown; the checker does not model firmware version semantics and focuses solely on bounds validation correctness as indicated in [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION].
- Assumes APIs like qcom_smem_get represent external/shared memory sources; generalization to other sources may require project-specific configuration not derivable from the provided materials.