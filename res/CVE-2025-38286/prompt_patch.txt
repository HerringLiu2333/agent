1. CVE Identifier
CVE-2025-38286

2. Vulnerability Type
Out-of-bounds array access due to missing input validation

3. Root Cause Summary
at91_gpio_probe() used the value returned by of_alias_get_id(np, "gpio") directly as an index into gpio_chips without validating that it was non-negative. When of_alias_get_id() failed (e.g., missing DT alias or other error) and returned a negative value, subsequent access like gpio_chips[alias_idx] became a negative index, causing out-of-bounds access before the start of the array. The only bound check present was BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)), which can be compiled out, leaving no runtime protection.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
pinctrl: AT91 GPIO driver

2) Pre-Patch Flaw:
- Missing lower-bound check for alias_idx returned by of_alias_get_id().
- Reliance on BUG_ON for upper-bound checking, which may be disabled at build time.
- Direct use of alias_idx as an array index: “if (gpio_chips[alias_idx])” without ensuring alias_idx >= 0.

3) Trigger Condition:
- The device tree lacks a valid “gpio” alias or of_alias_get_id(np, "gpio") returns a negative error code.
- Additionally, if BUG_ON is compiled out, an alias index greater than the array size could also proceed unchecked.

4) Impact Mechanism:
- Negative or excessively large alias_idx leads to out-of-bounds read/write on gpio_chips, causing memory corruption, kernel crashes, or undefined behavior during probe.

5. Patch Analysis
1) Fix Approach:
Add explicit validation of the alias index returned by of_alias_get_id() and abort probe early on error, preventing negative indexing into gpio_chips.

2) Key Code Changes:
- Introduced a separate declaration and assignment:
  - alias_idx = of_alias_get_id(np, "gpio");
- Added a lower-bound error check:
  - if (alias_idx < 0) return alias_idx;
- Kept the existing BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) and subsequent gpio_chips[alias_idx] access, which now only occurs with a non-negative alias_idx.

3) Locking/Concurrency Impact:
None. The change is purely input validation in the probe path and does not modify locking or ordering.

6. Broader Kernel Security Implications
Strengthening input validation at probe time prevents malformed or adversarial device trees from triggering memory-safety violations in early driver initialization. Reliance on BUG_ON for bounds checking is fragile in production builds; robust runtime checks should complement or replace BUG_ON to avoid silent OOB accesses when BUG is compiled out. This patch reduces a class of DT-driven OOB vulnerabilities by ensuring lower-bound validity, though comprehensive bounds validation (both lower and upper) at runtime remains advisable.