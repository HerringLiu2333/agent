1. CVE Identifier
CVE-2025-38286

2. Vulnerability Type
Out-of-bounds array access due to missing input validation (negative index handling)

3. Root Cause Summary
at91_gpio_probe() used the return value of of_alias_get_id(np, "gpio") directly as an array index without validating for negative errors. With a missing/invalid OF alias, alias_idx could be < 0, leading to gpio_chips[alias_idx] access with a negative index and subsequent writes, causing out-of-bounds memory access. The only bound check present was BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)), which neither covers the negative case nor is reliable because BUG() can be compiled out and cannot serve as runtime validation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
pinctrl/gpio driver for AT91 (function at91_gpio_probe in the pinctrl-at91 driver)

2) Pre-Patch Flaw:
- Direct use of alias_idx from of_alias_get_id without checking for < 0.
- Early array access: "if (gpio_chips[alias_idx])" and later "gpio_chips[alias_idx] = at91_chip" performed without ensuring alias_idx is within [0, ARRAY_SIZE(gpio_chips)).
- Reliance on BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) which does not catch negative indices and may be compiled out.

3) Trigger Condition:
of_alias_get_id(np, "gpio") returns a negative error (e.g., alias not present or retrieval failure) during device probe.

4) Impact Mechanism:
- Negative alias_idx results in out-of-bounds read/write to the global gpio_chips array, corrupting adjacent memory or causing a crash.
- Additional downstream misuse (e.g., chip->base = alias_idx * MAX_NB_GPIO_PER_BANK) propagates invalid state if execution continues.

5. Patch Analysis
1) Fix Approach:
Add explicit validation for alias_idx < 0 and return the error early, preventing any subsequent use of an invalid index.

2) Key Code Changes:
- Introduced a separate alias_idx variable assignment and immediate check:
  "alias_idx = of_alias_get_id(np, "gpio");"
  "if (alias_idx < 0) return alias_idx;"
- Retained existing BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) for upper-bound enforcement; the new check covers the missing negative-bound case.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely input validation and early error handling.

6. Broader Kernel Security Implications
Strengthens robustness against malformed or missing device-tree aliases by preventing memory corruption during probe. Eliminates dependence on BUG_ON for runtime validation, ensuring safety in production builds where BUG() may be disabled. Reduces risk of kernel crashes or silent corruption stemming from DT configuration errors or malicious overlays affecting GPIO registration.