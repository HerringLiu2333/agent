1. CVE Identifier
CVE-2025-38276

2. Vulnerability Type
Incorrect iterator state handling during lock drop (concurrency/ordering bug causing entry skip)

3. Root Cause Summary
The function wait_entry_unlocked_exclusive() used xas_pause(xas) before dropping the XArray lock to wait on a locked DAX entry. xas_pause advances the XArray iterator to the next index. Because both this function and its callers subsequently reload the entry using the xas state, the advanced state causes the current (locked) entry to be skipped. This violates the intended “don’t skip locked entries when scanning” behavior and leads to inconsistent handling of DAX exceptional entries, intermittently triggering warnings in truncate paths.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fs/dax (XArray-based DAX entry scanning/iteration)

2) Pre-Patch Flaw:
In wait_entry_unlocked_exclusive(struct xa_state *xas, void *entry), the code called xas_pause(xas) prior to xas_unlock_irq(xas). xas_pause advances the xas index; since the function and its callers use the xas state to reload the entry after the wait, the original entry is skipped rather than revisited.

3) Trigger Condition:
When scanning DAX entries and encountering a locked entry, the code waits for it (dropping the XArray lock) and then reloads via the xas state; e.g., during truncate_inode_pages_range in XFS with FS DAX enabled (as seen running xfstests generic/068).

4) Impact Mechanism:
Advancing the iterator state while dropping the lock causes the currently locked entry to be skipped upon reloading, leaving exceptional DAX entries unprocessed and leading to intermittent warnings, such as truncate_folio_batch_exceptionals() warning in mm/truncate.c.

5. Patch Analysis
1) Fix Approach:
Preserve the current iterator position across lock drop/wait by using xas_reset(xas) instead of xas_pause(xas), preventing unintended index advancement.

2) Key Code Changes:
Single-line change in wait_entry_unlocked_exclusive():
- Replaced “xas_pause(xas);” with “xas_reset(xas);” to avoid advancing the XArray iterator while preparing to drop the lock and wait.

3) Locking/Concurrency Impact:
The patch maintains correct iteration semantics across a lock release by resetting the XArray state without advancing the index. This avoids a mismatch between the iterator position and the entry being waited on, ensuring the entry is revisited after the lock is dropped and reacquired, and preventing skipped processing due to manual reloads that bypass xas_for_each()’s double-advance protection.

6. Broader Kernel Security Implications
Iterator state corruption when dropping locks can cause inconsistent resource or entry handling, leading to warnings and potential operational instability (e.g., incomplete truncation of DAX entries). While the provided evidence shows intermittent WARNs rather than memory safety violations, such logic errors in filesystem/DAX iteration paths can degrade reliability and could be leveraged to induce denial-of-service conditions via repeated triggers. No direct confidentiality or integrity compromise is demonstrated by the materials; the primary risk is robustness and correctness of DAX entry processing under concurrency.