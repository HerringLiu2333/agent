1. Plan Summary
Detect XArray iterator misuse where code calls xas_pause() before dropping the xa_lock and then reuses the same xa_state with xas_load() (or equivalent) without reinitializing the iterator, causing the current entry to be skipped.

2. Detection Steps
1) Step 1: Locate candidate sites that may drop and reacquire the xa_lock while waiting. Signals: a call to xas_pause(x) on some xa_state variable x, followed shortly by xas_unlock_irq(x), an intervening blocking/wait (e.g., schedule()/prepare_to_wait*()), and later xas_lock_irq(x).

2) Step 2: Confirm that the same xa_state variable is reused after the lock reacquisition. Signals: a subsequent call using the same x argument to xas_load(x) or other state-dependent fetch (e.g., xas_load/xas_store) in the same function/control-flow after xas_lock_irq(x).

3) Step 3: Check for missing iterator reinitialization before the reload. Signals: between xas_lock_irq(x) and xas_load(x), absence of any index reset/reinit calls such as xas_reset(x) or an explicit xas_set(x, ...) that would restore the intended index.

4) Step 4: Exclude safe patterns that already reset iterator state prior to dropping the lock. Signals: xas_reset(x) appears before xas_unlock_irq(x) in the same wait/drop-lock sequence (treat as safe; do not flag).

5) Step 5: Exclude patterns where iteration is driven by xas_for_each()/xas_for_each_marked() immediately after reacquiring the lock. Signals: use of these iterator macros (or their internal expansion) governing the next-step logic, indicating the code expects xas_pause()’s advancement and will not call xas_load(x) directly for the current index.

6) Step 6: Strengthen confidence by detecting a “wait-then-reload” loop. Signals: a loop conditioned on a lock-state predicate of the entry (e.g., a variable named entry used in calls like dax_is_locked(entry)) coupled with reassigning entry = xas_load(x) after the wait/unlock/relock sequence.

7) Step 7: Highlight higher-impact contexts (prioritize/report with higher severity). Signals: occurrences inside fs/dax code or functions that manage DAX exceptional entries (e.g., functions named like wait_entry_unlocked_exclusive, dax_layout_busy_page_range, __dax_clear_dirty_range, dax_delete_mapping_range) since the root cause and patch are in this subsystem.

8) Step 8: Report a diagnostic when Steps 1–3 are satisfied and Step 5 is not, optionally enhanced by Step 6/7 signals. Message should explain: xas_pause() advances the iterator; subsequently using xas_load() without xas_reset()/xas_set() can skip the intended entry; suggest replacing xas_pause() with xas_reset() or reinitializing xas before reload.

3. Limitations & Assumptions
- The plan assumes function names with known semantics (xas_pause, xas_unlock_irq, xas_lock_irq, xas_reset, xas_load) and that CodeQL can identify macro-like usage of xas_for_each; if macro expansion metadata is unavailable, excluding Step 5 may increase false positives. 
- It does not prove logical intent; it flags likely mistakes when reloading with xas_load() after xas_pause() without reinit. 
- Blocking/wait recognition relies on common wait primitives (prepare_to_wait*, schedule); other waiting mechanisms may be missed. 
- The checker does not simulate concurrency; it infers risk from call sequences and control flow. 
- Scope can be narrowed to fs/dax or kernel contexts using XArray to reduce noise if desired.