1. Plan Summary
Detect calls that pass a potentially ERR_PTR-encoded pointer to PM/device APIs without first guarding with IS_ERR/IS_ERR_OR_NULL, focusing on the inconsistent/non-robust checks seen in the pre-patch code.

2. Detection Steps
1) Step 1: Objective — Identify “sink” APIs that expect valid pointers. Conceptual signals — Calls to pm_runtime_suspended, device_link_del, dev_pm_domain_detach (as per PATCH_DIFF/ROOTCAUSE_ANALYSIS). FP mitigation — Limit initial scope to these named APIs only.

2) Step 2: Objective — Extract candidate argument expressions. Conceptual signals — The pointer argument expression E at each sink call (e.g., jpeg->pd_dev[i] or jpeg->pd_link[i]). FP mitigation — Normalize array subscripts/member access to treat the same base+index expression as the same resource.

3) Step 3: Objective — Determine evidence that E can be an ERR_PTR. Conceptual signals — In the same function, any condition using IS_ERR(E) or IS_ERR_OR_NULL(E) referencing the same E (PATCH_DIFF and FUNCTION_CONTENT show IS_ERR use on pd_dev/pd_link). FP mitigation — Require at least one such IS_ERR/IS_ERR_OR_NULL use in the same function to raise confidence that E may be an ERR_PTR.

4) Step 4: Objective — Find unguarded or weakly-guarded sink calls. Conceptual signals — A sink call on E that is not dominated by a guard using IS_ERR/IS_ERR_OR_NULL(E); only non-NULL (truthiness) checks or no checks precede the call (ROOTCAUSE_ANALYSIS shows first conditional only used non-NULL). FP mitigation — Use control-flow dominance: if any IS_ERR/IS_ERR_OR_NULL(E) guard dominates the call, do not flag.

5) Step 5: Objective — Specifically detect the pattern shown in the CVE. Conceptual signals — Compound if condition like “E && !pm_runtime_suspended(E)” (FUNCTION_CONTENT), where E appears both as a non-NULL boolean and as the argument to pm_runtime_suspended, without IS_ERR/IS_ERR_OR_NULL(E) in the condition. FP mitigation — Only flag when the same E is later tested with IS_ERR/IS_ERR_OR_NULL elsewhere in the function (inconsistency evidence).

6) Step 6: Objective — Flag inconsistent validation across multiple uses. Conceptual signals — Within the same function, E is passed to some sinks under IS_ERR/IS_ERR_OR_NULL guards (e.g., device_link_del/dev_pm_domain_detach pre-patch) but passed to another sink without such guard (pm_runtime_suspended pre-patch). FP mitigation — Require at least one guarded use and one unguarded use within the same function for E.

7) Step 7: Objective — Preferentially rank/report sinks that dereference immediately. Conceptual signals — pm_runtime_suspended is called to check runtime state and is highlighted as dereferencing (ROOTCAUSE_ANALYSIS). FP mitigation — Prioritize pm_runtime_suspended over the other sinks when both exist, to reduce noise.

8) Step 8: Objective — Exclude obviously safe cases. Conceptual signals — If the immediate guard uses IS_ERR_OR_NULL(E) (as in PATCH_DIFF), or uses a negated IS_ERR(E) alongside a non-NULL check before the sink, consider safe. FP mitigation — Recognize IS_ERR_NEGATIVE(-PTR) family patterns only as IS_ERR/IS_ERR_OR_NULL; do not speculate other safe guards.

9) Step 9: Objective — Avoid post-nullification confusion. Conceptual signals — If E is set to NULL before the call and not reassigned, do not flag. FP mitigation — Use simple intra-procedural dataflow to ensure there’s no intervening reassignment from a possibly erroneous source.

10) Step 10: Objective — Track E across loop constructs. Conceptual signals — E as array element in for-loops (e.g., jpeg->pd_dev[i]) should be treated as the same logical resource in guards and calls within the loop body. FP mitigation — Treat the same index variable and base pointer consistently; if index changes or aliasing is uncertain, require the guard and call to be within the same basic block or directly connected blocks.

3. Target Elements
- Function bodies containing calls to pm_runtime_suspended, device_link_del, dev_pm_domain_detach.
- Call sites and their argument expressions (pointer arguments).
- Conditional checks involving IS_ERR or IS_ERR_OR_NULL on the same expressions.
- Compound conditions combining pointer truthiness and calls using the same pointer.
- Loop constructs and array subscripts/member accesses referencing the same resource.

4. Dataflow / Taint Considerations
- Track identity of the pointer expression E (including base object and index) within the function.
- Guard-dominance analysis: determine whether an IS_ERR/IS_ERR_OR_NULL(E) check dominates the sink call path.
- Simple assignment tracking to see if E is set to NULL or reassigned between guard and call.
- Cross-use consistency: detect at least one guarded and one unguarded sink use of the same E in the same function.

5. Validation & Test Cases
- Positive: Pre-patch mxc_jpeg_detach_pm_domains() where “if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))” is present and IS_ERR checks exist elsewhere in the function for the same expression; expect a report on pm_runtime_suspended use.
- Negative: Post-patch version where guards use IS_ERR_OR_NULL before all relevant sinks; expect no findings.
- Negative: A function where device_link_del and dev_pm_domain_detach are both guarded by "!IS_ERR(E)" (and possibly non-NULL) before calls; expect no findings.
- Test harness notes: Run intra-procedural analysis; ensure equivalence of expressions like jpeg->pd_dev[i] across guards and calls inside the same loop.

6. Estimated Effort & Priority
Medium — Focused API set and intra-procedural dominance/dataflow are straightforward; important due to kernel Oops potential (ROOTCAUSE_ANALYSIS).

7. Likely False-Positive Sources & Mitigations
- Cases where E cannot be ERR_PTR despite IS_ERR checks used defensively; mitigation: require at least one IS_ERR/IS_ERR_OR_NULL guard elsewhere in the same function as evidence.
- Complex aliasing or index variation causing E misidentification; mitigation: be conservative and require syntactic equivalence of base and index.
- Guards in helper functions not visible intra-procedurally; mitigation: initially limit to intra-procedural checks and document limitation.

8. Limitations & Assumptions
- Assumes the listed sinks (pm_runtime_suspended, device_link_del, dev_pm_domain_detach) are the primary APIs that must not receive ERR_PTR (from PATCH_DIFF/ROOTCAUSE_ANALYSIS); other similar APIs are out of scope.
- Cannot conclusively prove E is an ERR_PTR producer; uses presence of IS_ERR/IS_ERR_OR_NULL checks in the same function as the proxy signal (ROOTCAUSE_ANALYSIS mentions inconsistent handling).
- Path sensitivity is approximated via dominance within the same function; inter-procedural guards are not considered.