1. Plan Summary
Detect calls that dereference or pass potentially ERR_PTR values (from power-domain attach APIs) to PM/device-link routines without guarding with IS_ERR_OR_NULL, as seen in mxc_jpeg_detach_pm_domains() before the fix.

2. Detection Steps
1) Step 1: Identify variables and fields assigned from APIs that can yield error pointers. Signals: assignments where the RHS is dev_pm_domain_attach_by_id(…) producing a struct device* candidate that may be ERR_PTR; track arrays/fields like jpeg->pd_dev[i]. FP mitigation: restrict to known error-pointer-producing APIs evidenced in the materials (dev_pm_domain_attach_by_id) per [ROOTCAUSE_ANALYSIS].
2) Step 2: Find subsequent uses where these variables are passed to PM/device-link routines that expect valid pointers. Signals: calls to pm_runtime_suspended, pm_runtime_force_suspend, dev_pm_domain_detach, device_link_del with the variable as argument in the same function/teardown path (mxc_jpeg_detach_pm_domains) per [PATCH_DIFF]. FP mitigation: require exact callee name matches from [PATCH_DIFF].
3) Step 3: Check guarding conditions immediately enclosing or dominating these calls. Signals: conditions like “var && …” or “var != NULL” guarding the call; absence of IS_ERR(var) or IS_ERR_OR_NULL(var) in these guards. Why: root cause is only NULL-checking while ignoring ERR_PTR per [PATCH_DESCRIPTION]. FP mitigation: ensure the guard is the nearest dominating condition in the CFG for the call site.
4) Step 4: Flag the specific pattern “var && !pm_runtime_suspended(var)” where var may be ERR_PTR. Signals: the same variable used both as a boolean/non-NULL check and as argument to pm_runtime_suspended without IS_ERR_OR_NULL. Why: this exactly maps to the first-line bug described in [PATCH_DESCRIPTION]. FP mitigation: require var’s provenance includes a path from dev_pm_domain_attach_by_id without a subsequent assignment overwriting it with a known-good pointer.
5) Step 5: Detect similar unsafe calls to dev_pm_domain_detach(var) guarded only by “var && !IS_ERR(var)” or only non-NULL. Signals: guards that don’t use IS_ERR_OR_NULL and calls to dev_pm_domain_detach. Why: [PATCH_DIFF] strengthened these checks, indicating potential misuse. FP mitigation: prioritize warnings where provenance includes possible ERR_PTR; downgrade if the guard includes IS_ERR even if not OR_NULL for APIs documented to return NULL rather than ERR.
6) Step 6: Detect unsafe calls to device_link_del(var) with guards not using IS_ERR_OR_NULL. Signals: “pd_link[i] && !IS_ERR(pd_link[i])” replaced with IS_ERR_OR_NULL in [PATCH_DIFF], so flag if only partial checks exist. Why: patch uniformly applied IS_ERR_OR_NULL for clarity and robustness. FP mitigation: treat device_link_del as lower-severity unless provenance suggests ERR_PTR (if any) or NULL; avoid flagging when a consistent API returns only NULL.
7) Step 7: Verify failure-path flows that invoke the detach routine after attach failure. Signals: call chains where a failure (“goto fail”) reaches mxc_jpeg_detach_pm_domains(), per [ROOTCAUSE_ANALYSIS] fail path. Why: ensures the ERR_PTR path is feasible. FP mitigation: require existence of a fail label or error path calling the detach function in the same file to raise confidence.
8) Step 8: Ensure the variable remains possibly ERR_PTR along the path to the unsafe call. Signals: no intervening IS_ERR_OR_NULL guard that dominates the call; no reassignment to a guaranteed valid object. Why: reduces false positives by honoring control/data flow. FP mitigation: conservative dominance and SSA-like reasoning; if uncertain, require “closest guard lacks IS_ERR_OR_NULL.”
9) Step 9: Report findings with contextual evidence. Signals: include function name (e.g., mxc_jpeg_detach_pm_domains), the variable, the guard expression, and the callee. Why: ties directly to the root cause and patch change for developer action. FP mitigation: only flag once per distinct variable/callee pair in the function.

3. Target Elements
- Function bodies implementing teardown/detach logic (e.g., mxc_jpeg_detach_pm_domains).
- Assignments from dev_pm_domain_attach_by_id to fields/arrays (e.g., jpeg->pd_dev[i]).
- Call sites to pm_runtime_suspended, pm_runtime_force_suspend, dev_pm_domain_detach, device_link_del.
- Condition checks guarding these call sites (boolean tests, IS_ERR, IS_ERR_OR_NULL).
- Failure-path constructs leading to detach (goto fail and subsequent calls).

4. Dataflow / Taint Considerations
- Track “error-pointer taint” from dev_pm_domain_attach_by_id results into variables/fields (e.g., pd_dev[i]).
- Propagate through arrays and struct fields without losing identity (jpeg->pd_dev[i]).
- Validate reachability from failure paths (goto fail) to the detach routine to confirm feasibility.
- Check dominance: ensure no IS_ERR_OR_NULL guard dominates the unsafe call; ensure no sanitizing reassignment occurs before the call.

5. Validation & Test Cases
- Positive: Pre-patch pattern “if (pd_dev[i] && !pm_runtime_suspended(pd_dev[i])) pm_runtime_force_suspend(pd_dev[i]);” with pd_dev[i] assigned from dev_pm_domain_attach_by_id; expect a finding.
- Positive: “if (pd_dev && !IS_ERR(pd_dev)) dev_pm_domain_detach(pd_dev, true);” in a context where pd_dev later used in pm_runtime_suspended without IS_ERR_OR_NULL; expect a finding on the pm_runtime_suspended call.
- Negative: Post-patch pattern “if (!IS_ERR_OR_NULL(pd_dev[i]) && !pm_runtime_suspended(pd_dev[i])) …” and “if (!IS_ERR_OR_NULL(pd_dev[i])) dev_pm_domain_detach(pd_dev[i], true);” should not be flagged.
- Test harness notes: Run on the provided file mxc-jpeg.c and confirm only the pre-patch lines trigger; after applying changes in [PATCH_DIFF], the checker should be quiet.

6. Estimated Effort & Priority
Medium effort; high priority for kernel code given Oops potential on error paths.

7. Likely False-Positive Sources & Mitigations
- Variables proven non-ERR via earlier guards not recognized due to complex control flow; mitigate by requiring dominance of IS_ERR_OR_NULL checks when present.
- APIs that return NULL but not ERR_PTR (e.g., device_link_add) causing over-reporting; mitigate by treating device_link checks as lower severity unless provenance indicates ERR_PTR behavior.
- Reassigned variables to known-good pointers between source and sink; mitigate by tracking reassignment and clearing taint.

8. Limitations & Assumptions
- Only dev_pm_domain_attach_by_id is confirmed to return ERR_PTR from the materials; other APIs’ return conventions are assumed based on [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF].
- The checker assumes PM/device-link routines dereference their pointer arguments as implied by [ROOTCAUSE_ANALYSIS], but it does not model their internals.
- Precise feasibility (e.g., specific domains failing) cannot be proven statically; the checker flags potential unsafe patterns consistent with the described CVE.