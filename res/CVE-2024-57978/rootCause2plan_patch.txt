1. Plan Summary
Detect kernel code paths where a pointer that may hold an ERR_PTR is only NULL-checked (or truthy-checked) before being passed to APIs expecting valid device/link pointers, instead of being validated with IS_ERR/IS_ERR_OR_NULL, as evidenced by the pre-patch imx-jpeg detach path.

2. Detection Steps
1) Step 1: Objective — Find calls to APIs that require valid pointers (based on patch). Signals — Call sites of pm_runtime_suspended, pm_runtime_force_suspend, device_link_del, dev_pm_domain_detach with a pointer argument taken from a variable/array element (e.g., jpeg->pd_dev[i], jpeg->pd_link[i]) per [PATCH_DIFF]. FP mitigation — Limit to these named functions since they are explicitly implicated in the patch.

2) Step 2: Objective — Determine if the argument variable is treated as possibly an ERR_PTR in the same function. Signals — In the same function body, look for any usage of IS_ERR or IS_ERR_OR_NULL on the same variable/array (e.g., jpeg->pd_dev[i] or jpeg->pd_link[i]) as shown by the replaced conditions in [PATCH_DIFF]. FP mitigation — Only flag if at least one IS_ERR/IS_ERR_OR_NULL check exists on that variable in the same function, indicating it may carry ERR_PTR (per [ROOTCAUSE_ANALYSIS] point 3).

3) Step 3: Objective — Assess guarding conditions dominating the sink call. Signals — Identify the nearest dominating conditional(s) guarding the call and check if they use only a NULL/truthiness check (e.g., ptr, ptr != NULL) and do not include IS_ERR/IS_ERR_OR_NULL on the same variable, matching the pre-patch pattern “if (jpeg->pd_dev[i] && !pm_runtime_suspended(...))” in [PATCH_DIFF]/[PATCH_DESCRIPTION]. FP mitigation — Require absence of IS_ERR/IS_ERR_OR_NULL on that same variable along all dominating guard branches leading to the call.

4) Step 4: Objective — Flag inconsistent guarding of the same variable within the function. Signals — If the same variable is elsewhere guarded by IS_ERR or IS_ERR_OR_NULL before being passed to related APIs (as in the other branches pre-/post-patch), but at the sink call it’s only NULL/truthiness-checked before use. FP mitigation — Require at least one contrasting use (safe vs. unsafe) in the same function to strengthen evidence (per [ROOTCAUSE_ANALYSIS] “inconsistent and unsafe handling”).

5) Step 5: Objective — Detect looped or indexed uses that mirror the imx-jpeg pattern. Signals — Loops over an index with array element arguments (e.g., ptr_array[i]) used in calls to the sinks; ensure the guard for the loop body or the call site itself lacks IS_ERR/IS_ERR_OR_NULL protection, as shown in [PATCH_DIFF]. FP mitigation — Prefer reports inside loops where one or more calls on the same element do include IS_ERR/IS_ERR_OR_NULL, highlighting inconsistency.

6) Step 6: Objective — Exclude already-safe paths. Signals — If the sink argument is post-dominated by IS_ERR/IS_ERR_OR_NULL filtering or preceded by early returns on IS_ERR/IS_ERR_OR_NULL that guarantee validity at the call, then do not report. FP mitigation — Use simple control-flow dominance/post-dominance to confirm the call cannot be reached when the pointer is an ERR_PTR.

7) Step 7: Objective — Focus on the most crash-prone sink from the root cause. Signals — Prioritize calls to pm_runtime_suspended with possibly unchecked pointers, since passing ERR_PTR there caused the Oops (per [ROOTCAUSE_ANALYSIS] point 4 and [PATCH_DESCRIPTION]). FP mitigation — Rank findings higher for pm_runtime_suspended; optionally suppress others unless corroborated by inconsistent checks.

8) Step 8: Objective — Identify simple non-guarded calls. Signals — Calls to the listed sinks with the variable argument not dominated by any guard that references that variable at all (no NULL nor IS_ERR checks). FP mitigation — Only flag if the same variable elsewhere in the function/file is checked with IS_ERR/IS_ERR_OR_NULL, implying it may be erroneous.

9) Step 9: Objective — Group findings by variable to reduce noise. Signals — Aggregate all sink uses per variable within a function; report once per variable highlighting at least one unsafe call path versus at least one safe usage. FP mitigation — Avoid duplicate reports and keep context focused on variables demonstrably requiring ERR checks.

3. Target Elements
- Function bodies and loops performing teardown/detach logic.
- Call sites to pm_runtime_suspended, pm_runtime_force_suspend, device_link_del, dev_pm_domain_detach.
- Conditional checks guarding these calls (truthiness checks, NULL checks, IS_ERR/IS_ERR_OR_NULL checks).
- Variables/array elements used as arguments at these call sites (e.g., struct fields like jpeg->pd_dev[i], jpeg->pd_link[i]).

4. Dataflow / Taint Considerations
- Track the specific variable/array element passed to the sink within the function, following aliases and field/index expressions.
- Determine control-flow guards dominating the call: whether the variable is validated with IS_ERR/IS_ERR_OR_NULL versus only NULL/truthiness checks before the call.
- Treat any occurrence of IS_ERR/IS_ERR_OR_NULL on the variable within the function as evidence the value may be an ERR_PTR, thus tainting unchecked uses.

5. Validation & Test Cases
- Positive: Pre-patch pattern “if (ptr && !pm_runtime_suspended(ptr))” where the same function also uses “if (!IS_ERR(ptr)) …” or “if (!IS_ERR_OR_NULL(ptr)) …” on the same ptr (as in [PATCH_DIFF]/[PATCH_DESCRIPTION]); expect a finding.
- Negative: Post-patch pattern where all uses are guarded with “!IS_ERR_OR_NULL(ptr)” before calling pm_runtime_suspended/device_link_del/dev_pm_domain_detach (as in [PATCH_DIFF]); expect no finding.
- Test harness notes: Include variants with looped array elements and with/without inconsistent checks to ensure the dominance and inconsistency heuristics behave as intended.

6. Estimated Effort & Priority
Medium effort; high priority for kernel code due to crash potential (per [ROOTCAUSE_ANALYSIS] impact/Oops).

7. Likely False-Positive Sources & Mitigations
- Variables that can never be ERR_PTR in practice: mitigate by requiring evidence of IS_ERR/IS_ERR_OR_NULL usage on the same variable in-scope.
- Guards performed in helper functions not analyzed: mitigate by limiting to intra-procedural dominance and requiring local IS_ERR evidence.
- Alternate sanitization patterns (e.g., conversion from ERR_PTR to NULL) not recognized: mitigate by checking for explicit IS_ERR handling before NULL assignment.

8. Limitations & Assumptions
- Assumes that any variable checked with IS_ERR/IS_ERR_OR_NULL in a function may hold ERR_PTR; the exact producer of ERR_PTR is not identified (not provided).
- The list of risky sinks is limited to those named in the patch ([PATCH_DIFF]); other APIs expecting valid pointers are out of scope due to lack of evidence.
- Type information for arguments (e.g., struct device*) is inferred from context but not strictly required; precise typing may be unavailable.