1. Plan Summary
Detect functions that index the last byte of an input buffer (page[len-1] or page[l-1]) without a dominating check that the input length is nonzero, as in configfs store handlers.

2. Detection Steps
1) Step 1: Scope to candidate store-like functions taking a buffer and length, e.g., functions with parameters (const char* page, size_t len), optionally with a leading struct config_item* and returning ssize_t.
2) Step 2: Identify local “length variables” derived from len (signals: direct assignment l = len; or l computed from len via expressions like min/limits, e.g., l = min_t(int, len, ...)).
3) Step 3: Find tail-index accesses of the buffer: any array/subscript expression page[expr] where expr is (len - 1) or (l - 1) for a length variable l dataflow-dependent on len.
4) Step 4: For each tail-index access, check control-flow dominance for a guard ensuring nonzero length: a preceding condition that guarantees len > 0 or l > 0 on all paths reaching the access (e.g., if (!len) return ...; or if (l > 0) ... wrapping the access).
5) Step 5: Flag cases where the tail-index access occurs without a dominating nonzero-length guard; typical signal is an immediate newline-stripping pattern “if (page[lengthVar - 1] == '\n')” executed before any len==0 handling.
6) Step 6: Treat l computed via min/max with len as unsafe unless there is an explicit nonzero-length guard; l can be zero when len is zero (e.g., l = min_t(int, len, CONST) followed by page[l - 1]).
7) Step 7: Exempt cases where an early return or path exclusion for len == 0 precedes the access (signals: if (!len) return len; or equivalent return/skip before any use of page[lengthVar - 1]).
8) Step 8: Exempt cases where the tail-index access is syntactically inside a branch conditioned on (len > 0) or (l > 0) and that branch dominates the access.
9) Step 9: Report findings with the specific buffer access location and the length variable involved, emphasizing the missing nonzero-length validation before page[lengthVar - 1].

3. Limitations & Assumptions
- Assumes the buffer parameter is named “page” and the length is “len”, as per the provided functions; other naming conventions may require broader matching not specified here.
- Assumes dataflow from len to derived variables like “l” can be recognized conceptually (e.g., via min_t); complex transformations beyond direct assignment/min are not covered.
- Does not determine runtime feasibility beyond static guards; if other invariants guarantee len > 0 but are not syntactically evident, they may cause false positives.
- Focuses on out-of-bounds reads from tail inspection; other OOB patterns (e.g., head/other indices) are out of scope.