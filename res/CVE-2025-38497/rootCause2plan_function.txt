1. Plan Summary
Detect out-of-bounds read patterns in configfs/sysfs store handlers where the last byte of an input buffer is read (e.g., page[l-1]) without first proving that the input length is nonzero.

2. Detection Steps
1) Step 1: Objective — Identify candidate store handlers; Signals — functions named with a “_store” suffix that take (struct config_item* …, const char* buffer, size_t len/count) as in [FUNCTION_CONTENT]; FP mitigation — restrict to functions with signatures matching configfs/sysfs store style noted in [ROOTCAUSE_ANALYSIS] and [FUNCTION_CONTENT].
2) Step 2: Objective — Find last-byte reads; Signals — array indexing or pointer-dereference of the input buffer at index “X - 1” where X is a variable, and the base pointer is the buffer parameter (e.g., page[l - 1]) as in both functions in [FUNCTION_CONTENT]; FP mitigation — require the access is a read in a comparison or conditional, not a write.
3) Step 3: Objective — Bind the index variable to the input length; Signals — dataflow from the size parameter (len/count) to the index variable (l) via direct assignment or bounded assignment (e.g., l = len; or l = min(len, CONST)) as in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]; FP mitigation — if dataflow proves X ≥ 1 on all paths before use, do not flag.
4) Step 4: Objective — Recognize newline-stripping intent to focus on the demonstrated bug; Signals — the last-byte read is compared to '\n' or used in a condition checking equality with '\n' (if (page[l - 1] == '\n')) as in [FUNCTION_CONTENT]; FP mitigation — narrow to this tail-inspection pattern to avoid unrelated indexing.
5) Step 5: Objective — Ensure there is no guarding check against zero length; Signals — absence of a dominating control-flow check that ensures len > 0 or X > 0 before the dereference; FP mitigation — treat as safe if there is an early return on !len (as added in [PATCH_DIFF]) or a guard like “if (X > 0) { … page[X-1] … }” that dominates the access.
6) Step 6: Objective — Treat short-circuit guards correctly; Signals — conditions like “if (X && page[X-1] == '\n')” where the first conjunct guarantees X > 0; FP mitigation — model logical AND short-circuit so such cases are not reported.
7) Step 7: Objective — Handle bounded index computations; Signals — assignments using min_t/min or similar (l = min_t(int, len, CONST)) as in [FUNCTION_CONTENT], which still permit l == 0 when len == 0; FP mitigation — unless there is a separate proof that the bound enforces l ≥ 1, consider l potentially zero.
8) Step 8: Objective — Exclude transformed bases; Signals — ensure the dereference base is the original buffer parameter or a zero-offset alias (no added positive offset that could imply different length semantics); FP mitigation — exclude cases where the base is a different array or a pointer already advanced by ≥1 with matched length adjustments.
9) Step 9: Objective — Ensure the bug is reachable pre-guard; Signals — the risky dereference occurs before any early exit that handles len == 0 (the fix in [PATCH_DIFF] moves return before the deref); FP mitigation — if all control-flow paths to the dereference pass through a guard returning on len == 0, do not flag.
10) Step 10: Objective — Report only once per function; Signals — coalesce multiple similar last-byte reads in the same function into a single alert; FP mitigation — improves signal quality and reduces noise.

3. Target Elements
- Functions: configfs/sysfs-style store handlers (_store suffix) with parameters (struct config_item* …, const char* buffer/page, size_t len).
- Expressions: array indexing and pointer dereference where index is “length-derived variable minus 1”.
- Condition checks: equality with '\n' for tail-inspection.
- Assignments: from length parameter to index variable, including bounded forms (min_t/min).
- Control-flow: dominating guards that assert len > 0 or return on !len; logical AND short-circuit patterns.
- Return statements: early returns on zero-length inputs as in [PATCH_DIFF].

4. Dataflow / Taint Considerations
- Track dataflow from the size_t length parameter (len/count) to the index variable used in “X - 1” indexing, through simple assignments, casts, and min-like bounding.
- Track aliasing from the buffer parameter (page) to the dereference base; treat direct aliases and zero-offset pointers as equivalent.
- Treat min/bounds operations as not guaranteeing X ≥ 1 unless explicitly compared against 0 along the path.
- Model boolean short-circuit to treat “X && use(X-1)” as proving X > 0 at the dereference site.

5. Validation & Test Cases
- Positive: A function webusb_landingPage_store(...) with l = len; then if (page[l - 1] == '\n') … and no prior len > 0 guard (matches [FUNCTION_CONTENT] pre-patch).
- Positive: A function os_desc_qw_sign_store(...) with l = min_t(int, len, CONST); then if (page[l - 1] == '\n') … and no prior len > 0 guard (matches [FUNCTION_CONTENT] pre-patch).
- Negative: Same functions with “if (!len) return len;” placed before the page[l - 1] access (matches [PATCH_DIFF]).
- Negative: A store handler that uses “if (len && page[len - 1] == '\n') …” or “if (l > 0) { if (page[l - 1] == '\n') … }”.
- Test harness notes: Run on a codebase containing both pre- and post-patch versions to confirm only the pre-patch sites are flagged; include artificial variants to test short-circuit recognition and dominance analysis.

6. Estimated Effort & Priority
High — the pattern is common in kernel attribute handlers, the impact is kernel OOB read per [ROOTCAUSE_ANALYSIS], and the analysis required (dataflow + dominance) is moderate.

7. Likely False-Positive Sources & Mitigations
- Preceding non-obvious guards proving X ≥ 1 that the analysis fails to recognize; mitigate via CFG dominance and short-circuit modeling.
- Index variable normalized to ≥1 via helper macros/functions not modeled; mitigate by conservatively assuming potential zero unless a ≥1 proof exists.
- Cases where the buffer base is not user-controlled input but a different array; mitigate by requiring the base to be the store buffer parameter or its direct alias.

8. Limitations & Assumptions
- Assumes store handlers follow the signature/style shown in [FUNCTION_CONTENT]; alternative frameworks or renamed parameters may be missed.
- Does not reason about external contracts ensuring len > 0 (e.g., higher-level VFS guarantees), which are not evidenced in the provided materials.
- Focuses on newline-tail inspection as in [FUNCTION_CONTENT]; other last-byte inspections (e.g., for '\r' or '\0') may not be caught if not included in signals.