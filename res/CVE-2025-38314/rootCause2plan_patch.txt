1. Plan Summary
Detect cases where the byte-count returned by virtqueue_get_buf() is used as a payload/result length without excluding the trailing status structure, or without clamping short writes, in virtio-pci admin queue completion handlers.

2. Detection Steps
1) Step 1: Objective — find completion handlers that process virtqueue buffers for admin commands. Signals — functions that call virtqueue_get_buf() in a loop (often bracketed by virtqueue_disable_cb/virtqueue_enable_cb) and manipulate a command object (e.g., cmd) in vp_modern_avq_done-like contexts from virtio-pci; FP mitigation — prioritize functions in virtio-pci admin vq code and with names/fields matching “admin” or “virtio_pci_admin”.
2) Step 2: Objective — capture the total-bytes-written value. Signals — identify the out-parameter variable assigned by virtqueue_get_buf() (e.g., len) representing “total bytes written (data + status)” as described in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; FP mitigation — ensure the variable’s value originates directly from virtqueue_get_buf() without intervening unrelated computation.
3) Step 3: Objective — detect misuse of the total length as the result payload size. Signals — assignments where the virtqueue_get_buf()-derived length is written to a field representing command result data length (e.g., cmd->result_sg_size), as in the pre-patch “cmd->result_sg_size = len;” from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]; FP mitigation — focus on fields with names indicating result/payload size (e.g., result_sg_size, result_size) within a virtio_admin_cmd-like struct.
4) Step 4: Objective — verify exclusion of the status trailer from the reported result size. Signals — check that the assignment subtracts sizeof(struct virtio_admin_cmd_status) (or an equivalent status_size) from the total length, as per the fix in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]; FP mitigation — do not flag when a subtraction of the status structure size is present in the assignment computation.
5) Step 5: Objective — detect missing short-write clamping. Signals — check for a conditional that sets the result size to 0 if len < sizeof(struct virtio_admin_cmd_status), matching the clamping added in [PATCH_DIFF]; FP mitigation — require that either such a clamp exists or equivalent guarding logic is present before subtracting the status size.
6) Step 6: Objective — trace indirect assignments of the total length into result-size fields. Signals — simple dataflow where len flows through temporaries or arithmetic that does not subtract the status size and ends up in cmd->result_sg_size; FP mitigation — limit to same function/scope and to linear flows tied to the same completion iteration to avoid cross-iteration conflation.
7) Step 7: Objective — raise confidence when the status structure is part of the context. Signals — presence of a sizeof(struct virtio_admin_cmd_status) identifier in the same compilation unit or nearby code, or variable named status_size used in length calculations as in [PATCH_DIFF]; FP mitigation — rank findings higher when the code references the status struct type/name and still omits subtraction/clamping.
8) Step 8: Objective — corroborate potential impact by downstream use. Signals — detect uses where the assigned result size (e.g., result_sg_size) flows to length parameters of reads/copies from the result buffer or to state serialization/migration routines, consistent with [ROOTCAUSE_ANALYSIS] impacts; FP mitigation — increase severity when such sinks are found, but still report primary pattern without requiring sinks due to asynchronous consumption.
9) Step 9: Objective — avoid flagging legitimate uses of total descriptors. Signals — if the length is stored in fields clearly denoting “total bytes including status/control” (not “result/payload”), or if subsequent code separately parses and strips the status prior to use; FP mitigation — suppress when explicit later separation (subtract or parse-out) is observed before the length is consumed.
10) Step 10: Objective — identify other admin-queue variants using similar patterns. Signals — other functions that handle admin virtqueue completions and assign virtqueue_get_buf() lengths into fields named like result_* or *_sg_size without status subtraction; FP mitigation — restrict to virtio/virtio-pci components where admin queues are implemented, as recommended by [ROOTCAUSE_ANALYSIS] broader implications.

3. Target Elements
- Function definitions and bodies handling virtqueue completion (e.g., vp_modern_avq_done).
- Call sites of virtqueue_get_buf() and the out-parameter that receives the length.
- Assignments to size fields on command/descriptor structs (e.g., cmd->result_sg_size).
- Arithmetic operations involving the length (presence/absence of subtraction of sizeof(struct virtio_admin_cmd_status)).
- Condition checks guarding short-write cases (len < sizeof(struct virtio_admin_cmd_status)).
- Dataflow from result size fields to copy/read/migration functions.
- Presence of identifiers/types like struct virtio_admin_cmd_status or variables like status_size.

4. Dataflow / Taint Considerations
- Track the value returned via virtqueue_get_buf()’s length out-parameter as a “tainted total-length” representing data+status.
- Follow intra-procedural flows from this length into fields that represent payload/result size; flag if no subtraction/clamp occurs before assignment.
- Optionally, trace flows from the result size field to sinks such as memcpy/memdup/serialization where it is used as a byte count to increase confidence.

5. Validation & Test Cases
- Positive: Pre-patch pattern in vp_modern_avq_done where len from virtqueue_get_buf() is assigned directly to cmd->result_sg_size without subtraction or clamping, as described in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
- Negative: Post-patch pattern that subtracts sizeof(struct virtio_admin_cmd_status) and clamps to 0 when len < status_size, per [PATCH_DIFF].
- Test harness notes: Include a variant where len flows through a temporary variable before assignment (still no subtraction) to ensure indirect flow detection; include a case where subtraction exists but clamping is missing to verify the checker flags the missing clamp.

6. Estimated Effort & Priority
High: The pattern is security-relevant (buffer over-read/state corruption per [ROOTCAUSE_ANALYSIS]) and requires modest intra-procedural dataflow plus semantic checks for arithmetic and condition presence.

7. Likely False-Positive Sources & Mitigations
- Code paths where the total length is intended to include status/control (mitigate by focusing on fields named as “result/payload” and by detecting subsequent parsing).
- Virtqueue users without a status trailer (mitigate by prioritizing virtio-pci admin queue code and presence of struct virtio_admin_cmd_status identifiers).
- Asynchronous consumption where analysis can’t see sinks (mitigate by not requiring sinks, but using them to increase confidence when present).

8. Limitations & Assumptions
- Assumes virtqueue_get_buf() length includes a status trailer for admin commands, based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; the checker may not know this for other queues.
- The exact status structure size/type (struct virtio_admin_cmd_status) and its presence may vary; the checker relies on naming/type cues from [PATCH_DIFF] and may miss differently named trailers.
- Cross-thread/async consumers of result_sg_size may be outside analysis scope, limiting sink-based validation.