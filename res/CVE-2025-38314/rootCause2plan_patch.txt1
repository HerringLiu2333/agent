1. Plan Summary
Detect cases where completion handlers use the total length from virtqueue_get_buf() as the result payload size without subtracting the trailing status structure, leading to buffer over-read and state corruption.

2. Detection Steps
1) Step 1: Objective — find completion handlers that process virtqueue buffers. Signals — locate functions containing a loop over virtqueue_get_buf() and a length output variable (e.g., “len”) with callbacks disabled/enabled around the loop (virtqueue_disable_cb/enable_cb).
2) Step 2: Objective — identify the variable receiving the byte count from virtqueue_get_buf(). Signals — capture the second argument passed by reference to virtqueue_get_buf() and track the corresponding local variable later referenced in the function.
3) Step 3: Objective — find assignments of the returned length to a result data size field for admin commands. Signals — within the same loop, detect assignments where a field of the command object (e.g., cmd->result_sg_size) is set directly to the length variable from virtqueue_get_buf().
4) Step 4: Objective — establish context that the command object is an admin command. Signals — confirm the type or naming of the command object (e.g., struct virtio_admin_cmd) and/or that the code path completes a command via complete(&cmd->completion) after setting the size.
5) Step 5: Objective — detect absence of status trailer handling. Signals — check whether any status size symbol or sizeof(struct virtio_admin_cmd_status) is present in the function or translation unit; if present, verify it is not used to adjust the length before assigning to the result size field.
6) Step 6: Objective — detect missing subtraction of the status size. Signals — ensure there is no arithmetic that subtracts a constant or sizeof(struct virtio_admin_cmd_status) from the length prior to assigning it to the command-specific result size.
7) Step 7: Objective — detect missing clamp for short writes. Signals — ensure there is no conditional that sets the result size to zero when the returned length is less than the status structure size (e.g., len < sizeof(struct virtio_admin_cmd_status)).
8) Step 8: Objective — confirm the problematic assignment occurs per-buffer in the completion loop. Signals — ensure the assignment to the result size is inside the loop that consumes virtqueue_get_buf() results (i.e., per “cmd” entry).
9) Step 9: Objective — strengthen confidence by checking downstream usage of the result size as a payload length. Signals — within the same function or subsequent code, identify uses of the assigned field to read/copy result data (e.g., using the field as a byte count), without accounting for a status trailer.
10) Step 10: Objective — reduce noise by focusing on admin virtqueue contexts. Signals — prioritize functions or modules related to virtio-pci admin vq handling (e.g., vp_modern_avq_done) and presence of types/identifiers like virtio_admin_cmd_status, virtio_pci_admin_vq, to target the admin command completion path.

3. Limitations & Assumptions
- Assumes the returned length from virtqueue_get_buf() includes a trailing status; this is specific to the admin virtqueue path described and may not universally apply elsewhere.
- Relies on visible identifiers (virtio_admin_cmd, virtio_admin_cmd_status, result_sg_size); variants with different naming may be missed.
- Does not infer actual buffer allocation sizes or prove over-read; flags the miscalculation pattern (length used without subtracting status) as a potential vulnerability.
- The presence of sizeof(struct virtio_admin_cmd_status) in the translation unit is used as a heuristic; code that handles status differently or defines it indirectly may evade detection.