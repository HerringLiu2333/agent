1. Plan Summary
Detect cases where a virtqueue completion handler uses the total bytes returned by virtqueue_get_buf() as the command-specific result size even though the request included a separate status buffer, leading to an oversized result length and potential out-of-bounds read/information leak.

2. Detection Steps
1) Step 1: Identify completion handlers that consume virtqueue_get_buf().
- Objective: Find functions that retrieve a buffer with a length from a virtqueue on completion.
- Signals: Calls to virtqueue_get_buf(vq, &len) inside a loop, with the return value assigned to a command pointer (e.g., struct virtio_admin_cmd *cmd).

2) Step 2: Correlate the completion’s cmd with the submission cookie in virtqueue_add_sgs().
- Objective: Confirm that the same cmd pointer is used as the “cookie” argument when the request was enqueued.
- Signals: A call to virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, ...) where cmd has the same type/role as in the completion function using virtqueue_get_buf().

3) Step 3: Detect that the submitted request included a separate status buffer.
- Objective: Establish that the enqueued scatter-gather list contains an in-buffer for status of type struct virtio_admin_cmd_status.
- Signals: An sg_init_one(&stat, va_status, sizeof(*va_status)) where va_status has type struct virtio_admin_cmd_status, and the &stat entry is placed among “in” sgs (e.g., sgs[out_num + in_num] = &stat; in_num++).

4) Step 4: Detect that the submitted request also included a command-specific result buffer.
- Objective: Ensure the request has a second in-buffer intended for result data.
- Signals: Presence of a result SG entry added after the status SG (e.g., if (cmd->result_sg) sgs[out_num + in_num] = cmd->result_sg; in_num++;).

5) Step 5: Flag direct assignments of the completion length to a “result size” field/variable.
- Objective: Detect when the len from virtqueue_get_buf() is used as the result size without adjustment.
- Signals: An assignment where the right-hand side is the unmodified len (e.g., cmd->result_sg_size = len) and the left-hand side name/field suggests result length (e.g., contains “result” and “size”, such as result_sg_size).

6) Step 6: Check for absence of subtraction of the status size from the reported result size.
- Objective: Confirm the code does not account for the status buffer in the reported result size.
- Signals: No arithmetic subtracting sizeof(struct virtio_admin_cmd_status) (or a variable holding it) from len in the assignment to the result size; absence of a conditional handling len < sizeof(status).

7) Step 7: Optionally strengthen confidence by observing downstream use of the misreported size as an output size.
- Objective: Show that the assigned result size flows to external consumers (potential over-read).
- Signals: Data flow from cmd->result_sg_size (or analogous field) to an outward parameter (e.g., *res_size = cmd.result_sg_size) or to size arguments of memory copy/transfer operations associated with the result buffer.

8) Step 8: Report a finding when Steps 1–6 are satisfied within the same driver path.
- Objective: Minimize false positives by requiring the pattern of “status + result” in request submission and “unadjusted len as result size” in completion.
- Signals: The same cmd type links submission and completion; presence of a status SG; a result SG; and unadjusted assignment of len to result size.

9) Step 9: Optional secondary check for underflow guards in partial-write scenarios.
- Objective: Detect potential underflow if code subtracts the status size but lacks a guard for len < sizeof(status).
- Signals: Assignment using len - sizeof(struct virtio_admin_cmd_status) without a preceding conditional that sets result size to 0 (or otherwise guards) when len < sizeof(struct virtio_admin_cmd_status).

3. Limitations & Assumptions
- Assumes availability of API semantics: virtqueue_get_buf() returns total bytes written across in-buffers, and virtqueue_add_sgs() enqueues a status SG followed by an optional result SG; this is inferred from provided code.
- Assumes the status structure name is struct virtio_admin_cmd_status; if renamed or wrapped, name-based matching may miss cases.
- Inter-procedural linkage (submission site to completion handler) relies on recognizing the same cmd type used as the add_sgs cookie and in the completion; complex aliasing may evade matching.
- The checker infers “result size” from identifier names (e.g., result_sg_size); if projects use atypical naming, the signal weakens.
- The plan targets patterns shown in virtio-pci admin VQ; other subsystems with similar “status + result” protocols may require analogous type/field recognition to avoid false positives.