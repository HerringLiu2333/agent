1. CVE Identifier
CVE-2025-38314

2. Vulnerability Type
Integer/length misuse causing out-of-bounds read and information leak

3. Root Cause Summary
The admin virtqueue completion handler stored the total number of bytes returned by virtqueue_get_buf() (which includes both the command-specific result and an 8-byte status) directly into cmd->result_sg_size. As a result, callers treated the result buffer as larger than it actually was by sizeof(struct virtio_admin_cmd_status) and could read past the end of the allocated result buffer. This led to copying 8 extra bytes during state transfer and could cause read-overruns in the kernel when the returned size exceeded the allocated buffer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
virtio PCI modern admin virtqueue handling (virtio-pci driver), specifically vp_modern_avq_done() and users of cmd->result_sg_size such as virtio_pci_admin_dev_parts_get()

2) Pre-Patch Flaw:
In vp_modern_avq_done(), the completion handler executed:
“cmd->result_sg_size = len;”
where len is from virtqueue_get_buf() and includes both the status buffer and the command-specific result. No subtraction of the status size (sizeof(struct virtio_admin_cmd_status)) was performed.

3) Trigger Condition:
Any admin command that posts both a status SG and a result SG (e.g., VIRTIO_ADMIN_CMD_DEV_PARTS_GET via virtio_pci_admin_dev_parts_get()) and completes on the admin VQ. The device writes status + result, virtqueue_get_buf() returns len = status_size + result_size, and the driver propagates len as the result size to callers.

4) Impact Mechanism:
- The returned result size is 8 bytes larger than the actual result data, so downstream code may read/copy res_size bytes from the result buffer, overrunning it by 8 bytes (out-of-bounds read).
- When used for live migration, the state copied to the destination includes 8 extra trailing bytes, leaking data beyond the intended payload.
- If the consumer allocates buffers based on the returned size, subsequent accesses read beyond the allocation, causing faults or information disclosure of adjacent memory.

5. Patch Analysis
1) Fix Approach:
Adjust the reported result size to exclude the status bytes and guard against short writes by the device. The handler now subtracts sizeof(struct virtio_admin_cmd_status) from len, and sets the result size to 0 if the device wrote fewer than the status bytes.

2) Key Code Changes:
- Introduced status_size = sizeof(struct virtio_admin_cmd_status) in vp_modern_avq_done().
- Replaced “cmd->result_sg_size = len;” with:
  - if (len < status_size) cmd->result_sg_size = 0;
  - else cmd->result_sg_size = len - status_size;
- Added explanatory comment about zero-initialized status buffer and size handling.

3) Locking/Concurrency Impact:
No locking model changes. The existing spin_lock_irqsave/virtqueue_disable_cb/virtqueue_enable_cb and complete(&cmd->completion) sequencing remain unchanged; only the arithmetic for result size was corrected.

6. Broader Kernel Security Implications
- Correct length accounting in virtqueue completions is critical to prevent buffer over-reads and inadvertent data exposure across admin command paths.
- The fix reduces the risk of kernel memory disclosure and improves robustness of live migration flows using virtio administrative commands.
- The underflow guard prevents misreporting non-existent result data when a device writes fewer bytes than the status size, avoiding misleading sizes that could propagate to consumers.