1. CVE Identifier
CVE-2025-38309

2. Vulnerability Type
Improper initialization/cleanup ordering leading to null pointer dereference (lifecycle bug)

3. Root Cause Summary
In fault-mode VM creation, xe_vm_close_and_put() unconditionally calls xe_svm_fini(vm) when cleaning up, even on error paths that occur before xe_svm_init(vm) is executed. Pre-patch, xe_svm_init(vm) was invoked late in xe_vm_create(), after multiple steps that could fail and jump to err_close. This mismatch (cleanup before initialization) results in xe_svm_fini() operating on uninitialized SVM state, causing “splats” and a fatal NULL pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM Xe virtual memory (VM) management in fault mode (USM/page-fault mode), functions xe_vm_create() and xe_vm_close_and_put().

2) Pre-Patch Flaw:
- xe_svm_init(vm) was called near the end of xe_vm_create() (only after exec queue setup and other allocations).
- Several earlier failure points in xe_vm_create() (e.g., vm lock failure, PT root allocation, scratch creation, bind queue creation) jumped to err_close, which invoked xe_vm_close_and_put(vm).
- xe_vm_close_and_put() includes “if (xe_vm_in_fault_mode(vm)) xe_svm_fini(vm);” even when SVM was never initialized, leading to cleanup of uninitialized state.

3) Trigger Condition:
Creating a VM with DRM_XE_VM_CREATE_FLAG_FAULT_MODE set, where any early failure in xe_vm_create() before the pre-patch xe_svm_init(vm) (e.g., xe_vm_lock(vm, true) error or page table root allocation failure) leads to err_close and then xe_vm_close_and_put(vm), which calls xe_svm_fini(vm) on uninitialized SVM.

4) Impact Mechanism:
Calling xe_svm_fini() without prior xe_svm_init() dereferences or manipulates SVM structures that are NULL/uninitialized, causing kernel “splats” and a fatal NULL pointer dereference; practically exploitable as a denial-of-service via the VM create ioctl under fault mode.

5. Patch Analysis
1) Fix Approach:
Ensure initialization precedes any potential cleanup by moving xe_svm_init(vm) much earlier in xe_vm_create(), and add a dedicated early-error cleanup label that safely finalizes the SVM state.

2) Key Code Changes:
- In xe_vm_create(), xe_svm_init(vm) is now executed immediately when flags & XE_VM_FLAG_FAULT_MODE is set, before resv object allocation:
  “if (flags & XE_VM_FLAG_FAULT_MODE) { err = xe_svm_init(vm); if (err) goto err_no_resv; }”
- On vm_resv_obj allocation failure, the error path now goes to err_svm_fini rather than err_no_resv:
  “goto err_svm_fini;”
- New err_svm_fini block:
  “vm->size = 0; /* close the vm */ xe_svm_fini(vm);”
- The previous late xe_svm_init(vm) block was removed to avoid double-init and retain correct order.

3) Locking/Concurrency Impact:
- Setting vm->size = 0 in err_svm_fini emulates VM closure state prior to xe_svm_fini(vm), aligning with xe_vm_close() semantics and reducing races with fault-mode notifier logic (xe_svm_* locks). No new locks are introduced; the critical change is lifecycle ordering to guarantee fini is only called after a successful init or with a consistent “closed” state.

6. Broader Kernel Security Implications
This bug allowed unprivileged users to crash the kernel by triggering fault-mode VM creation errors, making it a reliable DoS vector in environments with Xe DRM enabled and USM/fault mode supported. Correcting the init/fini ordering hardens the VM lifecycle against error-path crashes, a common class of bugs in complex subsystem initialization. The approach underscores the importance of pairing initialization and teardown across all error paths and maintaining consistent object state (e.g., vm->size) before invoking subsystem-specific finalizers.