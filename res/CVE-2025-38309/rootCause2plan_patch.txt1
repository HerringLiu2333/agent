1. Plan Summary
Detect constructor-style functions whose error paths invoke a component finalizer (directly or via a cleanup helper) before the corresponding initializer has run, under conditional initialization, risking NULL pointer dereference.

2. Detection Steps
1) Step 1: Identify constructor-like functions that build a VM/resource and use error labels with gotos and return ERR_PTR(err).
   - Signals: function names like “*_create”, presence of labels such as err_close/err_no_resv, and returns of ERR_PTR(err).

2) Step 2: Locate cleanup helper calls on error paths that perform teardown of the constructed object.
   - Signals: calls at error labels to helpers like xe_vm_close_and_put(vm) prior to return on error.

3) Step 3: Resolve (interprocedurally) whether the cleanup helper calls a specific finalizer for a subsystem state.
   - Signals: inside the helper, a call to a matching “*_fini” function (e.g., xe_svm_fini(vm)) acting on the same object.

4) Step 4: Find the corresponding subsystem initializer call within the constructor function.
   - Signals: call to a matching “*_init” function (e.g., xe_svm_init(vm)) that targets the same object and subsystem (shared prefix/scope, same parameter).

5) Step 5: Check whether the initializer is guarded by a runtime condition, especially a flag check.
   - Signals: conditional like “if (flags & XE_VM_FLAG_FAULT_MODE) xe_svm_init(vm);” controlling whether initialization occurs.

6) Step 6: Compare the positions of the initializer and early error sites to determine if some error paths bypass the initializer.
   - Signals: resource allocation/initialization steps (e.g., drm_gpuvm_resv_object_alloc) that, on failure, goto an error label executed before the “*_init” block.

7) Step 7: Confirm that the error path ultimately reaches the cleanup helper (and thus the finalizer) without any prior execution of the initializer along that path.
   - Signals: control-flow path from function entry through an early error goto to the cleanup label, with the initializer located strictly later or under a false branch.

8) Step 8: Detect asymmetry: finalizer reachable on error without an initialization guard, while initializer is conditional.
   - Signals: “*_fini” invoked unconditionally (or only gated by the same flag) in cleanup, with no check that “*_init” ran; “*_init” is conditional and late.

9) Step 9: Prioritize findings where the initializer and finalizer operate on the same object and subsystem namespace.
   - Signals: both calls share the same ‘vm’ object and matching subsystem prefix (e.g., xe_svm_*), strengthening the pairing.

10) Step 10: Report the specific error sites and labels that create the vulnerable path.
   - Signals: identify failing call sites (e.g., reservation object alloc failure), the goto target labels (err_no_resv/err_close), and the location of the late init block that is skipped.

3. Limitations & Assumptions
- The exact body of xe_vm_close_and_put() is not provided; the plan assumes it calls xe_svm_fini(vm) as stated in the analysis.
- Runtime feasibility (actual flag values, allocation failures) cannot be proven statically; detection relies on control-flow and conditional structure.
- The checker infers init/fini pairing by naming/argument patterns (e.g., “*_init”/“*_fini” on the same object), which may cause false positives if unrelated functions share similar names.
- Specific dereference behavior inside xe_svm_fini() is not available; the risk is inferred from asymmetric lifecycle sequencing rather than confirmed unsafe memory access.