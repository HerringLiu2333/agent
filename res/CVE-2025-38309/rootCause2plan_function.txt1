1. Plan Summary
Find functions where a cleanup/finalizer (xe_svm_fini or via xe_vm_close_and_put) is reachable on error paths before the corresponding initializer (xe_svm_init), especially when initialization is conditionally guarded and placed late, causing fini on uninitialized state.

2. Detection Steps
1) Step 1: Identify the initializer/finalizer pair for the SVM subsystem. Signals: calls to xe_svm_init(vm) as initializer; calls to xe_svm_fini(vm) as finalizer; and calls to xe_vm_close_and_put(vm) as an indirect finalizer per the analysis.

2) Step 2: Scope target functions that orchestrate VM creation/teardown. Signals: functions that allocate/initialize struct xe_vm (e.g., return type struct xe_vm*), perform multiple setup steps, and contain error labels that jump to cleanup (e.g., err_close, err_no_resv).

3) Step 3: Build control-flow and locate all calls that may trigger cleanup. Signals: labels and gotos leading to a block that calls xe_vm_close_and_put(vm) or directly calls xe_svm_fini(vm).

4) Step 4: Determine the position of xe_svm_init(vm) within the function relative to cleanup triggers. Signals: whether xe_svm_init is located after other calls with error checks and gotos (e.g., “if (!vm_resv_obj) { err = -ENOMEM; goto err_close; }” or similar fail-and-goto patterns).

5) Step 5: For each path from function entry to a cleanup/finalizer call, check if the path bypasses any call to xe_svm_init(vm). Signals: reachability where no prior xe_svm_init is encountered before hitting xe_vm_close_and_put or xe_svm_fini.

6) Step 6: Model conditional guarding of initialization that increases risk. Signals: xe_svm_init(vm) executed under “if (flags & XE_VM_FLAG_FAULT_MODE)” while cleanup is reachable regardless of having executed xe_svm_init (e.g., via err_close).

7) Step 7: Identify error checks before xe_svm_init that can jump to cleanup. Signals: common patterns such as null checks, IS_ERR/PTR_ERR handling, return-value checks (err) followed by “goto err_close” or equivalent labels executed prior to the xe_svm_init block.

8) Step 8: Exclude safe cases where all cleanup/finalizer calls are exclusively reachable after a successful xe_svm_init. Signals: dominance of the xe_svm_init call site over all paths to xe_vm_close_and_put/xe_svm_fini, plus explicit early-failure path that does not call xe_svm_fini on init failure (e.g., goto err_no_resv when xe_svm_init fails).

9) Step 9: Flag a potential bug when any cleanup/finalizer call is reachable on a path that does not include xe_svm_init. Signals: existence of at least one such path (e.g., early goto err_close leading to xe_vm_close_and_put), with initialization occurring later or conditionally.

10) Step 10: Prioritize findings where the initializer is guarded by the FAULT_MODE flag and the cleanup is not equivalently guarded within the function. Signals: finalizer reachable regardless of whether the guarded init ran, matching the pre-patch flaw.

3. Limitations & Assumptions
- Assumes, per analysis, that xe_vm_close_and_put(vm) invokes xe_svm_fini(vm); the checker must model this indirect relationship without seeing the callee’s body.
- Does not prove runtime success of xe_svm_init; it checks structural path ordering/dominance and conditional guarding only.
- Limited to the specific pair (xe_svm_init/xe_svm_fini) described; generalization to other subsystems requires additional mapping data.
- Cannot determine internal guards inside xe_vm_close_and_put or xe_svm_fini; flags are inferred from the call site context, not callee internals.