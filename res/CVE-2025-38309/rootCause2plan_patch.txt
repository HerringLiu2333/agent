1. Plan Summary
Detect creator/error-path patterns where a component finalizer can be invoked (directly or via a generic close routine) on an object whose corresponding initializer may not have run under the same flag/predicate, leading to NULL dereference/cleanup of uninitialized state.

2. Detection Steps
1) Step 1: Objective — discover init/fini pairs. Signals — functions whose names or documentation suggest a pair (e.g., *_init vs *_fini) operating on the same primary object argument; supported by xe_svm_init/xe_svm_fini in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation — restrict to pairs referenced in the same subsystem/file group or connected via a common “close” routine per [ROOTCAUSE_ANALYSIS].

2) Step 2: Objective — identify “creator” functions that allocate/setup an object and have error labels. Signals — presence of gotos to labels like err_* and a tail label that calls a generic close/put, e.g., err_close calling xe_vm_close_and_put() in [PATCH_DIFF]. FP mitigation — ensure the creator also contains at least one call site to the discovered *_init function for the same object.

3) Step 3: Objective — model the cleanup chain to the finalizer. Signals — interprocedural reachability from the creator’s error label to a close/put routine that invokes the *_fini on the same object (xe_vm_close_and_put() → xe_svm_fini()) as described in [ROOTCAUSE_ANALYSIS]. FP mitigation — if the close/put routine guards the finalizer on an explicit “initialized/closed” state, suppress.

4) Step 4: Objective — find early-failure edges preceding init. Signals — checks of allocation/initialization steps (e.g., if (!vm_resv_obj) goto err_close;) that occur syntactically/semantically before the first call to *_init in the creator, as shown pre-patch in [PATCH_DIFF]. FP mitigation — require at least one such early failure path to be feasible under normal error conditions (e.g., NULL checks or negative err codes).

5) Step 5: Objective — correlate gating predicates controlling init and fini. Signals — a shared condition like (flags & FAULT_MODE) guarding both *_init and the cleanup path that leads to *_fini (based on “XE_VM_FLAG_FAULT_MODE” in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation — only flag when the same predicate (or an implied stronger one) is used for both sides, indicating a realistic path where predicate is true yet init not executed before fini.

6) Step 6: Objective — detect asymmetry: fini reachable without prior init. Signals — existence of a path from function entry to the error label invoking close/put where no *_init call occurs along that path, while the path to *_fini via close/put is reachable; this is the core ordering flaw described in [ROOTCAUSE_ANALYSIS]. FP mitigation — require object identity equivalence (same variable/argument flows) between *_init and *_fini calls.

7) Step 7: Objective — distinguish legitimate post-init unwind. Signals — presence of a dedicated unwind label that conditionally calls *_fini only after *_init has succeeded (e.g., new err_svm_fini in [PATCH_DIFF]); this indicates correct symmetry. FP mitigation — if such dedicated unwind exists and is used for failures occurring after the init point, do not report.

8) Step 8: Objective — recognize late init as risky when generic close is used earlier. Signals — *_init positioned late in the creator (near end) while earlier blocks can goto a label that triggers close/put (as removed late block around ~1757 in [PATCH_DIFF]). FP mitigation — only flag when step 6 confirms reachability of close/put before any init, not merely on textual order.

9) Step 9: Objective — account for implicit state guards. Signals — before calling *_fini, check whether the code enforces a “closed” or “initialized” state transition explicitly (e.g., vm->size manipulation pre-*_fini in [PATCH_DIFF] suggests intended state gating). FP mitigation — if fini is conditioned on a state that’s only set after init, suppress; otherwise, proceed.

10) Step 10: Objective — produce findings when all conditions align. Signals — creator has early error path to close/put, close/put calls *_fini, *_init is gated/late and may not have executed, and both are under the same flag (XE_VM_FLAG_FAULT_MODE), matching [ROOTCAUSE_ANALYSIS]. FP mitigation — require at least one concrete early-failure site (allocation failure) and shared object parameter to minimize spurious matches.

3. Target Elements
- Functions: creator/setup functions, generic close/put routines, *_init and *_fini functions.
- Call sites: calls to *_init, *_fini, and to close/put routines.
- Control-flow: goto-based error labels, error-unwind sections, return-on-error patterns.
- Conditions: flag/bit tests (e.g., flags & XE_VM_FLAG_FAULT_MODE), NULL/ERR checks.
- Data elements: the constructed object variable (e.g., vm) passed across init/close/fini.
- Interprocedural edges: from creator error labels to close/put to finalizer.

4. Dataflow / Taint Considerations
- Track the object variable flowing from creator to close/put and then into *_fini to ensure identity.
- Track the “flags” variable (or equivalent predicate) to determine if the same guard controls both init and fini sites.
- Path feasibility: ensure at least one error path reaches close/put before any init call, under the same flag condition.
- Recognize state-guard variables/fields used to gate fini (e.g., an “initialized/closed” field) and treat them as suppressors when proven set only after init.

5. Validation & Test Cases
- Positive: A creator function with (flags & FAULT_MODE) where allocation failure (if (!res)) goto err_close occurs before any call to component_init(), and err_close calls close_and_put() which calls component_fini() unconditionally; expect a finding (as in pre-patch xe_vm_create → xe_vm_close_and_put → xe_svm_fini per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: The same creator with component_init() moved before the first possible goto to close, plus a dedicated err_unwind that calls component_fini() only if init succeeded (as in added early init and err_svm_fini in [PATCH_DIFF]); expect no finding.
- Test harness notes: Include a variant where fini is guarded by an explicit initialized flag set only by init to confirm suppression, and a variant where flags/predicates differ to ensure no false linkage.

6. Estimated Effort & Priority
High — requires interprocedural path reasoning, guard correlation, and error-path modeling typical of kernel-style goto unwinds.

7. Likely False-Positive Sources & Mitigations
- Misidentifying init/fini pairs by name only; mitigate by requiring shared object argument and subsystem locality.
- Infeasible error paths due to complex conditions; mitigate with simple feasibility heuristics (concrete NULL/ERR checks).
- Finalizers internally guarding against uninitialized state; mitigate by checking for external guards or state flags around fini calls.
- Different flags guarding init vs fini; mitigate by requiring guard equivalence or implication analysis.

8. Limitations & Assumptions
- We assume access to interprocedural call graphs to see close/put invoking fini, as implied in [ROOTCAUSE_ANALYSIS]; exact body of close/put is not provided here.
- We assume naming or pairing heuristics (init/fini) are applicable, supported by xe_svm_init/xe_svm_fini in [PATCH_DIFF].
- The checker cannot fully prove semantic “initialized” state without explicit guards; it uses conservative indicators like flag equivalence and state-setting patterns (e.g., vm->size) from [PATCH_DIFF].
- Concurrency and locking effects are out of scope; [ROOTCAUSE_ANALYSIS] states no locking changes in the fix.