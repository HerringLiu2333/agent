1. Plan Summary
Detect lifecycle-ordering bugs where a subsystem’s fini/cleanup is reachable on error paths before its corresponding init has been executed for the same object, specifically when cleanup is gated only by a mode flag and not by an “initialized” state (as in xe_svm_fini called from xe_vm_close_and_put when xe_svm_init may not have run).

2. Detection Steps
1) Step 1: Identify init/fini pairs for the same subsystem. Signals: functions whose names and namespaces match an init/fini pair (e.g., xe_svm_init(vm) vs xe_svm_fini(vm)); confirm both take the same object type/variable flowing through. FP mitigation: restrict to exact namespace pairs and matching parameter type/variable identity.

2) Step 2: Locate cleanup wrappers that invoke the fini under a mode predicate. Signals: functions like xe_vm_close_and_put(vm) that call xe_svm_fini(vm) guarded by xe_vm_in_fault_mode(vm) or flags & MODE; ensure the guard has no explicit “initialized” check. FP mitigation: require absence of any explicit initialized-state guard (e.g., flag or non-NULL field) before calling fini.

3) Step 3: Find constructors/creators that set the mode bit early. Signals: assignments of vm->flags = flags and mode-dependent predicates (xe_vm_in_fault_mode(vm) or flags & XE_VM_FLAG_FAULT_MODE) in the same function (xe_vm_create) before the init; this indicates that later cleanup will think the mode is enabled. FP mitigation: require the flags assignment dominates potential error exits.

4) Step 4: Enumerate all early error paths leading to cleanup that call fini. Signals: in the creator function, identify goto labels/returns (e.g., goto err_close) that eventually invoke the cleanup wrapper which calls fini; build interprocedural CFG from creator to cleanup. FP mitigation: only consider paths where the same vm variable flows to the cleanup call.

5) Step 5: Check ordering between init and early error exits. Signals: determine the first program point that calls xe_svm_init(vm); detect any path from function entry to a cleanup-leading exit that occurs strictly before xe_svm_init(vm). FP mitigation: path-sensitivity requiring dominance analysis: flag only if there exists at least one such path.

6) Step 6: Validate that the fini guard can be true along the error path. Signals: along the identified error path, confirm vm->flags has been set and the mode predicate (fault mode) is satisfiable (e.g., vm->flags = flags occurs pre-error, and the predicate reads vm->flags); treat flags as potentially containing the mode bit unless proven otherwise. FP mitigation: if flags is definitively known not to contain the mode bit, suppress.

7) Step 7: Exclude cases where init is invoked earlier or via an earlier branch. Signals: consider conditional init (if (flags & MODE) xe_svm_init(vm)); if this init block dominates all error edges to cleanup, do not flag. FP mitigation: require absence of any dominating init call before the first cleanup-reaching error edge.

8) Step 8: Account for dedicated “early fini” labels added by fixes. Signals: presence of a label (e.g., err_svm_fini:) where cleanup calls xe_svm_fini only after init would have run; ensure error jumps that happen after init use this label instead of the general cleanup path. FP mitigation: if such a label is used for all errors after the init site, do not report.

9) Step 9: Verify object identity across calls. Signals: ensure the same vm instance allocated/assigned in the creator flows into xe_svm_init and into the cleanup call; reject if different variables/aliases are used. FP mitigation: dataflow-based same-object confirmation.

10) Step 10: Detect return-value checks on init and their relation to error jumps. Signals: if xe_svm_init(vm) has err checked and jumps to a cleanup label that calls fini unconditionally, determine if that path could double-fini or is protected; otherwise, focus only on pre-init error-to-cleanup paths. FP mitigation: avoid flagging error paths that follow init immediately (expected fini).

11) Step 11: Highlight mode-only guards as risky. Signals: if fini is guarded solely by a mode predicate (no initialized-state), treat as high-risk unless the creator enforces early init (as the patch does). FP mitigation: lower severity if additional state is set prior to fini indicating initialized.

12) Step 12: Report with path evidence. Signals: include function name (creator), earliest error edge to cleanup, absence of prior init on that path, and the mode-setting site (vm->flags = flags) supporting satisfiable guard. FP mitigation: require all four elements for a finding.

3. Target Elements
- Functions: creator/constructor (xe_vm_create), cleanup (xe_vm_close_and_put), init (xe_svm_init), fini (xe_svm_fini).
- Call sites: calls to xe_svm_init and xe_svm_fini; calls to cleanup from error labels.
- Assignments: vm->flags = flags and any mode checks (xe_vm_in_fault_mode or flags & XE_VM_FLAG_FAULT_MODE).
- Control flow: goto error labels (e.g., err_close), return ERR_PTR paths, interprocedural edges to cleanup.
- Return-value checks: error checks on init and earlier operations that can jump to cleanup.

4. Dataflow / Taint Considerations
- Track the vm object from allocation through:
  - flags assignment (mode enabling),
  - potential init call,
  - error-jump edges to cleanup that perform fini.
- Model the predicate dependency: fini is gated by mode predicate that depends on vm->flags set earlier.
- Treat flags as tainted with “may contain fault-mode” unless constrained; if definitively proven false, suppress.
- Ensure object identity: same vm flows to both init and fini candidates.

5. Validation & Test Cases
- Positive: In a creator function, vm->flags = flags; several early allocations/locks can fail and goto err_close; xe_svm_init(vm) appears later; err_close calls xe_vm_close_and_put(vm); xe_vm_close_and_put calls xe_svm_fini(vm) if xe_vm_in_fault_mode(vm). Expected: flagged.
- Negative: Init moved before first possible err_close (as per patch), and an early err_svm_fini label is used after init; no path to cleanup calls fini before init. Expected: no finding.
- Negative: Cleanup calls fini only if an initialized-state flag or non-NULL field is set (not just mode). Expected: no finding.
- Test harness notes: Use small mock functions mimicking xe_vm_create/xe_vm_close_and_put with goto-label error paths and guarded fini, verifying path-sensitive detection.

6. Estimated Effort & Priority
Medium-High: requires interprocedural, path-sensitive analysis of error labels, dataflow on object identity and mode flags, and recognition of init/fini pairs.

7. Likely False-Positive Sources & Mitigations
- Implicit initialization in helper functions not modeled: mitigate by restricting to explicit init call sites for the object.
- Mode flags proven false at runtime but unknown statically: assume may-be-true; reduce severity if flags are only set after error edges.
- Idempotent fini implementations: unknown statically; require absence of initialized-state guards to report and provide path evidence.
- Aliasing of vm pointer: require strong dataflow confirmation of the same variable.

8. Limitations & Assumptions
- Assumes init/fini pair can be identified by naming and parameter congruence (based on xe_svm_init/xe_svm_fini in [PATCH_DIFF]/[FILE_CONTENT]).
- Does not prove that fini is unsafe post-init; relies on [ROOTCAUSE_ANALYSIS] stating NPD when fini runs without prior init.
- Assumes mode guard (xe_vm_in_fault_mode or flags & FAULT_MODE) depends on earlier vm->flags assignment in creator (per [FILE_CONTENT]).
- Cannot verify concurrency nuances (locks/notifiers) beyond ordering; focuses on init-before-cleanup along error paths.