1. Plan Summary
Detect constructor/creation functions whose error paths call a teardown/finalizer (directly or via a close/put aggregator) before the corresponding initialization has run, especially when initialization is conditional on flags, leading to NULL pointer dereference in finalizers.

2. Detection Steps
1) Step 1: Objective — Find creator-like functions. Conceptual signals — Functions that allocate/initialize an object (e.g., kzalloc) and return a pointer or ERR_PTR with multiple error labels (err_*), as in xe_vm_create shown in [FUNCTION_CONTENT]. FP mitigation — Require at least one allocator call and at least one err_* label with a cleanup call.

2) Step 2: Objective — Identify teardown calls reachable on error. Conceptual signals — Goto to an error label that invokes a teardown/aggregator like close/put/destroy/fini (e.g., err_close: xe_vm_close_and_put(vm); in [FUNCTION_CONTENT]). FP mitigation — Limit to calls whose names indicate teardown semantics (close, put, fini, destroy) and that operate on the object allocated in this function.

3) Step 3: Objective — Pair subcomponent init/fini operations. Conceptual signals — Presence of a subcomponent initializer named *init (e.g., xe_svm_init(vm)) and a corresponding finalizer named *fini (e.g., xe_svm_fini(vm)) mentioned as being called during teardown in [ROOTCAUSE_ANALYSIS]. FP mitigation — Require name-stem pairing (same prefix/scope, e.g., xe_svm_) and same base object argument variable (vm).

4) Step 4: Objective — Determine relative ordering of init vs. error teardowns. Conceptual signals — The subcomponent init call occurs late (after other operations) while an earlier failure can jump to a label that calls teardown (e.g., xe_svm_init was late per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS], but err_close path existed earlier in [FUNCTION_CONTENT]). FP mitigation — Use path analysis to ensure at least one syntactic failure check (if (err) goto err_close;) precedes the init call.

5) Step 5: Objective — Prove a path where teardown runs without prior init. Conceptual signals — Construct a path from function entry to the teardown-invoking label that does not pass through the matching *init call; examples include failures at xe_vm_lock or exec queue creation leading to err_close before xe_svm_init (as described in [ROOTCAUSE_ANALYSIS] and shown in [FUNCTION_CONTENT]). FP mitigation — Require explicit error-dependent control transfer (goto to teardown label) before the init call.

6) Step 6: Objective — Detect conditional initialization mismatches. Conceptual signals — The *init is guarded by a condition on flags (e.g., if (flags & XE_VM_FLAG_FAULT_MODE) xe_svm_init(vm); in [PATCH_DIFF]/[FUNCTION_CONTENT]) while the teardown path (e.g., xe_vm_close_and_put(vm)) is invoked unconditionally on error ([FUNCTION_CONTENT]). FP mitigation — Suppress if the teardown call at that error site is guarded by the same condition or if analysis can prove the subcomponent will not be finalized for that condition.

7) Step 7: Objective — Account for teardown indirection via aggregators. Conceptual signals — Error label calls an aggregator (e.g., xe_vm_close_and_put) and [ROOTCAUSE_ANALYSIS] states it calls xe_svm_fini; treat the aggregator as a potential dispatcher to *fini on the same base object. FP mitigation — Prefer evidence from same module/file or analysis hints; if body not visible, lower confidence unless a paired *init/*fini is known in this subsystem (xe_svm_init/xe_svm_fini per [ROOTCAUSE_ANALYSIS]).

8) Step 8: Objective — Recognize safe early-init and early-fini patterns (do not flag). Conceptual signals — Init moved before first failure and an early cleanup label that conditionally finalizes only if init ran (e.g., new early xe_svm_init and err_svm_fini with flags check in [PATCH_DIFF]). FP mitigation — If such an early-failure finalization path exists and is reachable on the same error, or if init is positioned before all gotos to teardown, suppress the alert.

9) Step 9: Objective — Highlight missing defensive teardown guards. Conceptual signals — No local guard or state check before teardown that would prevent finalizing uninitialized subcomponents, which [ROOTCAUSE_ANALYSIS] attributes to “lack of guarding in teardown.” FP mitigation — Only report when Steps 4–6 already demonstrate an execution path where teardown precedes init; use this step as supporting evidence, not a standalone trigger.

10) Step 10: Objective — Prioritize findings in flag-driven modes likely to be user-triggerable. Conceptual signals — Init gated on runtime flags (flags & XE_VM_FLAG_FAULT_MODE) as in [PATCH_DIFF]/[FUNCTION_CONTENT], and early failures can be induced by error returns (e.g., resource alloc/lock failures). FP mitigation — Require the conditional to depend on function parameters or fields, not compile-time constants.

3. Target Elements
- Functions that allocate/initialize objects and return pointers or ERR_PTR.
- Error-handling labels and goto edges leading to cleanup.
- Calls to teardown/aggregator functions (close, put, destroy, fini).
- Calls to subcomponent initializers (*init) and finalizers (*fini).
- Condition checks guarding initialization (e.g., flags & ...).
- Failure checks that lead to gotos (if (err) goto err_*;).
- Call graph edges from aggregators to subcomponent finalizers (when visible).

4. Dataflow / Taint Considerations
- Track the base object variable from allocation (e.g., vm) through calls to init and fini/aggregators to ensure we pair the same instance.
- Track control dependencies where function return values (err) trigger gotos to cleanup before init.
- Track predicate flows for conditional initialization (flags & XE_VM_FLAG_FAULT_MODE) to identify mismatches with teardown call sites.

5. Validation & Test Cases
- Positive: A function like pre-patch xe_vm_create where an error path (goto err_close; xe_vm_close_and_put(vm);) exists before a conditional late xe_svm_init(vm), and the aggregator is known to call xe_svm_fini(vm) per [ROOTCAUSE_ANALYSIS]; expect a report.
- Positive: Conditional init on flags with at least one preceding failure path to an unconditional teardown; expect a report.
- Negative: Post-patch layout where xe_svm_init(vm) is performed before any err_close path and an early err_svm_fini label conditionally finalizes on failure ([PATCH_DIFF]); expect no report.
- Negative: A function where teardown is guarded by the same condition as init (matching flags) and analysis proves teardown can’t run unless init has run; expect no report.
- Test harness notes: Include variants where the aggregator body is visible (direct call to *fini) and not visible (assume via subsystem knowledge per [ROOTCAUSE_ANALYSIS]) to validate confidence handling.

6. Estimated Effort & Priority
High — Requires interprocedural path analysis, name-based init/fini pairing, and reasoning about conditional guards and error gotos.

7. Likely False-Positive Sources & Mitigations
- Aggregator teardown not actually calling the suspected subcomponent *fini: mitigate by preferring evidence from call graph or same-module references; otherwise lower severity.
- Name-based pairing mismatches (*init/*fini not true pairs): mitigate by requiring same base object argument and consistent naming stem.
- Unseen defensive guards inside teardown: mitigate by reducing confidence when aggregator body is not available.
- Paths that are syntactically possible but semantically impossible: mitigate by requiring explicit error-checked gotos and concrete failure-producing call sites before init.

8. Limitations & Assumptions
- Assumes that aggregators like xe_vm_close_and_put call subcomponent finalizers as stated in [ROOTCAUSE_ANALYSIS]; if bodies are unavailable, the checker infers based on names and subsystem context.
- Does not infer runtime reachability beyond static error checks; hardware/driver-specific invariants are not modeled.
- Mapping of init/fini pairs relies on naming conventions and argument consistency; atypical APIs may be missed.
- Specific internal guards (e.g., in xe_svm_fini) are not analyzed; the plan uses [ROOTCAUSE_ANALYSIS]’s statement of “lack of guarding in teardown” as the basis for flagging.