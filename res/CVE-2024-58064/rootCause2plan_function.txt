1. Plan Summary
Detect missing NULL checks after memory allocation calls (e.g., kunit_kzalloc) when the returned pointer is subsequently dereferenced, mirroring the pre-patch flaw in test_cfg80211_parse_colocated_ap.

2. Detection Steps
1) Step 1: Objective — identify allocation sites that may return NULL. Signals — calls to kunit_kzalloc (and optionally kzalloc) whose return type is a pointer stored in a variable; based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS noting kunit_kzalloc may return NULL. FP mitigation — initially focus on KUnit contexts (files/funcs using KUNIT_* macros or under tests paths) to match the evidence.

2) Step 2: Objective — bind the allocated pointer and its aliases. Signals — the LHS variable receiving the allocator’s return value and simple local aliases via assignments. FP mitigation — confine analysis to local function scope and exclude complex interprocedural aliasing to reduce noise.

3) Step 3: Objective — detect null-guard patterns that validate the allocated pointer. Signals — checks/asserts dominating the first use, e.g., KUNIT_ASSERT_NOT_NULL(test, ptr) as shown in PATCH_DIFF, or explicit conditionals if (!ptr) followed by an abort path (return/goto that prevents further execution) as implied by ROOTCAUSE_ANALYSIS. FP mitigation — require the guard to dominate all control-flow paths to the dereference site.

4) Step 4: Objective — identify unsafe dereferences of the allocated pointer. Signals — member access ptr->field (e.g., ies->len in FUNCTION_CONTENT), dereference via unary * or array indexing on the pointer, and passing the pointer (or its field) as a memory buffer to known memory ops (e.g., memcpy(ies->data, ...)) which imply dereference per ROOTCAUSE_ANALYSIS. FP mitigation — ensure the pointer is the base of the dereferenced expression or a direct field thereof (not just compared or stored).

5) Step 5: Objective — establish unguarded path from allocation to dereference. Signals — control-flow reachability from the allocation to any dereference without encountering a recognized null-guard as in Step 3. FP mitigation — use path-sensitive reasoning and dominance checks to require that no guard exists on at least one feasible path.

6) Step 6: Objective — exclude cases with early-exit null handling. Signals — patterns like if (!ptr) return; or if (!ptr) goto cleanup; where all dereferences are post-dominated by the exit/cleanup. FP mitigation — require that all dereferences are unreachable on the null path.

7) Step 7: Objective — avoid false positives due to reassignments or reinitialization. Signals — detect reassignment of the pointer after allocation; if dereference occurs only after a later assignment guarded by a null-check, suppress. FP mitigation — constrain the dereference to use the specific allocation instance and ignore uses after a different assignment.

8) Step 8: Objective — rank/report only relevant contexts first. Signals — prioritize findings inside KUnit tests (functions referencing KUNIT_* macros or paths like net/wireless/tests) as in PATCH_DIFF and FUNCTION_CONTENT. FP mitigation — mark non-KUnit allocator uses (e.g., generic kzalloc without known failure semantics) as lower confidence or behind an option.

9) Step 9: Objective — detect memcpy/memmove-style implicit deref uses faithfully. Signals — treat standard memory functions (e.g., memcpy) as dereferencing both source and destination buffers; in FUNCTION_CONTENT, memcpy(ies->data, ...) is a deref of ies. FP mitigation — maintain a curated list of such functions; avoid flagging for functions without clear memory access semantics.

10) Step 10: Objective — ensure reporting points are actionable. Signals — attach primary location at the first unguarded dereference (e.g., ies->len assignment), with secondary at the allocation call. FP mitigation — suppress duplicates when multiple dereferences follow the same missing check.

3. Target Elements
- Function bodies (local control flow).
- Call sites to kunit_kzalloc (and optionally kzalloc).
- Variable assignments receiving allocation results and their local aliases.
- Condition checks and assert macros (KUNIT_ASSERT_NOT_NULL).
- Pointer dereference expressions: member access (->), unary *, array indexing.
- Calls to known memory-access functions (e.g., memcpy) where the allocated pointer is an argument.
- Early-exit constructs (return/goto) and their dominance/post-dominance relationships.

4. Dataflow / Taint Considerations
- Track dataflow from the allocation call result to local variables and simple aliases.
- Model guards as “sanitizers” that validate non-NULL on all paths dominating dereferences (e.g., KUNIT_ASSERT_NOT_NULL and if (!ptr) return;).
- Perform path-sensitive reachability from allocation to dereference ensuring no intervening guard.
- Stop tracking upon reassignment to the pointer; do not conflate dereferences after new values.

5. Validation & Test Cases
- Positive: Pre-patch snippet from FUNCTION_CONTENT where ies = kunit_kzalloc(...); followed by ies->len = ...; memcpy(ies->data, ...); with no KUNIT_ASSERT_NOT_NULL — expect a finding.
- Positive: Allocation followed by memcpy(ies, src, n) or ies[0] = ... without any null-check — expect a finding.
- Negative: Patched code from PATCH_DIFF with KUNIT_ASSERT_NOT_NULL(test, ies) immediately after allocation — expect no finding.
- Negative: Allocation followed by if (!ies) return; then dereferences — expect no finding.
- Test harness notes: Run on net/wireless/tests/scan.c to ensure the checker recognizes KUNIT_ASSERT_NOT_NULL as a guard and flags the pre-patch pattern.

6. Estimated Effort & Priority
Medium — common pattern with moderate control-flow and guard modeling; high value due to crash potential noted in ROOTCAUSE_ANALYSIS.

7. Likely False-Positive Sources & Mitigations
- Unrecognized assert/guard macros: mitigate by recognizing KUNIT_ASSERT_NOT_NULL explicitly (from PATCH_DIFF) and allow configuration for others.
- Complex interprocedural dereferences: limit to local function scope initially.
- Cases where allocator is guaranteed non-NULL by context: prioritize KUnit/test code as per ROOTCAUSE_ANALYSIS; allow suppressions or lower confidence outside tests.
- Macros obscuring dereferences or guards: rely on preprocessor-expanded AST where possible; otherwise, restrict to clear patterns (-> and known mem* calls).

8. Limitations & Assumptions
- Assumes kunit_kzalloc can return NULL and must be checked (per PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS); broader allocator semantics for kzalloc are not fully specified here.
- Assumes KUNIT_ASSERT_NOT_NULL aborts the test on failure and thus is a valid guard (per PATCH_DIFF and ROOTCAUSE_ANALYSIS).
- Does not model deep aliasing or interprocedural flows; focused on local, immediate uses as exemplified in FUNCTION_CONTENT.
- The list of “known memory functions” is inferred from FUNCTION_CONTENT (memcpy); other functions may need manual curation beyond provided materials.