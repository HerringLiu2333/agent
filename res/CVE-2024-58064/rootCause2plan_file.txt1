1. Plan Summary
Detect missing NULL-checks for the result of kunit_kzalloc before the pointer is dereferenced in KUnit test code, preventing potential NULL pointer dereferences like the one fixed in test_cfg80211_parse_colocated_ap().

2. Detection Steps
1) Step 1: Identify candidate allocations — find calls to kunit_kzalloc(...) and capture the assigned result variable (e.g., ies) and its function scope.
   Signals: call to kunit_kzalloc with any size argument, result stored in a pointer-typed local/field/parameter.

2) Step 2: Narrow to KUnit test contexts to reduce noise — prioritize functions that take a struct kunit * parameter or contain KUnit macros (e.g., KUNIT_*).
   Signals: function signature includes struct kunit * or presence of KUNIT_ASSERT/KUNIT_EXPECT macros in the same function.

3) Step 3: Collect dereference uses of the allocated pointer within the same function.
   Signals: expressions like ptr->field, *ptr, ptr[index], memcpy/memset/memmove with ptr or ptr->field as argument, or passing ptr to functions commonly expecting non-NULL where it is immediately dereferenced.

4) Step 4: For each dereference, compute path feasibility from the allocation site to the dereference with no reassignment that guarantees non-NULL (i.e., assume allocation may return NULL).
   Signals: control-flow path where the pointer is unchanged (or only assigned aliases) and reaches a dereference.

5) Step 5: Recognize strong guards that dominate the dereference — treat KUNIT_ASSERT_NOT_NULL(test, ptr) as a non-null guarantee on all subsequent paths.
   Signals: a preceding macro/call site with name KUNIT_ASSERT_NOT_NULL taking the same pointer, whose execution dominates the dereference.

6) Step 6: Recognize conventional NULL guards — if (ptr) { ... deref ... } or if (!ptr) { return/goto/end of function } that syntactically or semantically dominate the dereference site.
   Signals: boolean checks on the exact pointer or its aliases; the dereference must be post-dominated by the true branch of if (ptr) or unreachable from the false branch of if (!ptr).

7) Step 7: Do not consider KUNIT_EXPECT_NOT_NULL as a sufficient guard (it does not abort the test), and flag dereferences that follow only an EXPECT.
   Signals: presence of KUNIT_EXPECT_NOT_NULL(test, ptr) without an accompanying dominating ASSERT or conventional guard before dereference.

8) Step 8: Exempt cases where the pointer is proven non-NULL by earlier failing control flow (e.g., if (!ptr) KUNIT_ASSERT_*(..., false) that aborts), only when the aborting statement syntactically prevents continuation to the dereference.
   Signals: preceding check whose body unconditionally aborts/returns/gotos away from the dereference on NULL.

9) Step 9: Report a potential issue when a dereference of the kunit_kzalloc result is reachable without any dominating strong guard from Steps 5–8.
   Signals: allocation → reachable dereference path with no intervening non-NULL proof.

10) Step 10: Aggregate and de-duplicate findings per allocation site, listing all first dereference locations lacking guards to aid remediation.
    Signals: group dereferences by the allocated variable; report the earliest unguarded deref per path.

3. Limitations & Assumptions
- Assumes kunit_kzalloc may return NULL; no attempt is made to model allocator flags that could change this behavior.
- Macro expansion of KUnit assertions may not be fully visible in AST; the checker relies on macro-like call patterns by name (e.g., KUNIT_ASSERT_NOT_NULL) and simple control-flow outcomes.
- Alias tracking is limited to straightforward assignments; complex pointer aliasing, interprocedural propagation, or side effects in helper functions are not exhaustively modeled.
- The checker is scoped to KUnit-style test contexts to minimize noise; similar issues outside tests (with other allocators) are not covered by this plan.