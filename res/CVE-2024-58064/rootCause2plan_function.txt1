1. Plan Summary
Detect missing NULL validation after kunit_kzalloc allocations that are dereferenced without an intervening non-NULL guard in KUnit test code.

2. Detection Steps
1) Step 1: Identify target allocations — find local variables assigned from calls to kunit_kzalloc(...) whose type is a pointer. Objective: capture the allocated pointer variable (e.g., ies) and the program point of allocation.

2) Step 2: Constrain context to KUnit-style tests — optionally prioritize functions that take a struct kunit* parameter or use KUnit macros, to reduce noise. Objective: focus on allocations in KUnit test code where KUNIT_ASSERT_NOT_NULL is the expected guard.

3) Step 3: Enumerate dereferences of the allocated pointer — locate subsequent uses that imply dereference, such as pointer member access (p->field), unary *p, or array-style p[index], including nested forms like p->field used as arguments (e.g., memcpy(p->data, ...)). Objective: identify all potential dereference sites of the allocated value.

4) Step 4: Track variable identity — ensure that the dereferenced variable is the same allocation result (no intervening reassignment to a different value). Objective: avoid reporting on dereferences of a different or reinitialized pointer.

5) Step 5: Model guarding conditions — detect a dominating non-NULL guard for the pointer on all paths to each dereference, including: KUNIT_ASSERT_NOT_NULL(test, p), or a conditional check against NULL that ensures early exit/abort before the dereference on the false path. Objective: distinguish safe dereferences from unguarded ones.

6) Step 6: Path feasibility check — for each dereference, compute whether there exists any path from the allocation to the dereference without passing through a recognized non-NULL guard for that pointer. Objective: report only when at least one unguarded path exists.

7) Step 7: Special-case KUnit assert semantics — treat KUNIT_ASSERT_NOT_NULL(test, p) as establishing non-NULL for p after the call, i.e., a strong guard that prevents further reporting for that pointer in the current function scope. Objective: align with the patch’s fix pattern.

8) Step 8: Immediate use after allocation — give higher confidence to cases where dereferences occur immediately or shortly after allocation (e.g., next statements), as in ies->len and memcpy(ies->data, ...) following kunit_kzalloc. Objective: prioritize high-signal instances matching the root cause.

9) Step 9: Report finding — when a dereference of the kunit_kzalloc result is reachable without any guarding check, flag the dereference site(s) and reference the allocation site. Objective: make diagnostics actionable with clear source locations.

3. Limitations & Assumptions
- Assumes kunit_kzalloc can return NULL and must be checked before dereference; other allocation APIs are out of scope unless similarly named, as only kunit_kzalloc is evidenced.
- Assumes KUNIT_ASSERT_NOT_NULL(test, ptr) is a valid non-NULL guard; other KUnit macros or project-specific abort/exit idioms are not enumerated from the provided materials.
- Complex aliasing, interprocedural flows, and macro expansion semantics may limit precise guard recognition; the plan focuses on intra-procedural, same-variable checks.
- The checker cannot infer external guarantees (e.g., test harness never returns NULL) not visible in code, potentially yielding conservative findings.