1. Plan Summary
Detect missing NULL validation after kunit_kzalloc() when the allocated pointer is subsequently dereferenced in KUnit test code.

2. Detection Steps
1) Step 1: Identify pointer variables assigned the result of a call to kunit_kzalloc(). Signals: a call expression named “kunit_kzalloc” whose return value is stored in a variable of pointer type.

2) Step 2: Treat the result of kunit_kzalloc() as potentially NULL. Signals: use of kunit_kzalloc per the root cause description stating it “may return NULL.”

3) Step 3: Locate the first dereference of the allocated pointer on any path after the assignment. Signals: member access via “->”, unary “*” on the pointer, array indexing using the pointer, or writes to fields (e.g., “ptr->len = …”, “memcpy(ptr->data, …)”).

4) Step 4: Build the control-flow from the allocation to the dereference to determine path reachability. Signals: intra-procedural CFG showing that the dereference is reachable after the allocation without early exit.

5) Step 5: Check for an explicit non-NULL validation of the pointer that dominates the dereference. Signals: presence of KUNIT_ASSERT_NOT_NULL(test, ptr) before the dereference, or an if-condition checking ptr == NULL (e.g., “if (!ptr) { return/abort/goto; }”) whose guarded exit or assertion prevents reaching the dereference when ptr is NULL.

6) Step 6: Consider only validations that actually guard the dereference on all paths. Signals: the validation statement must dominate the dereference in CFG; ignore checks that occur after the dereference or within unrelated branches.

7) Step 7: Exclude cases where the pointer is reassigned to a different value before the dereference and that reassignment is provably non-NULL. Signals: a subsequent assignment to the same variable with a value known to be non-NULL (e.g., address-of of a local variable), occurring before the dereference on all paths.

8) Step 8: Optionally focus on KUnit test contexts to reduce noise. Signals: functions with a parameter of type “struct kunit *” or code under test directories (e.g., net/wireless/tests), or use of KUnit macros in the function.

9) Step 9: Flag a potential NULL dereference vulnerability when a dereference is reachable after kunit_kzalloc() and no dominating non-NULL validation exists. Signals: at least one path from allocation to dereference lacking KUNIT_ASSERT_NOT_NULL or equivalent guard.

3. Limitations & Assumptions
- Only kunit_kzalloc() is confirmed to “may return NULL” from the inputs; other allocators are out of scope unless similarly documented.
- The plan assumes intra-procedural analysis; validations in helper functions or interprocedural contracts may be missed.
- Validation macros other than KUNIT_ASSERT_NOT_NULL are not specified; custom assertions or error-handling patterns may cause false positives/negatives.
- The exact semantics of functions called with the pointer are not considered; detection focuses on explicit dereference operations in the analyzed function.