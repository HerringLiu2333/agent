1. Plan Summary
Detect missing NULL-result validation of kunit_kzalloc allocations that are subsequently dereferenced in KUnit tests, leading to potential NULL pointer dereference.

2. Detection Steps
1) Step 1: Objective — find allocation results that may be NULL. Signals — identify calls to kunit_kzalloc(...) whose return value is stored in a pointer variable (based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS stating kunit_kzalloc may return NULL). FP mitigation — restrict initial scope to call sites in functions that appear to be KUnit tests (e.g., have a struct kunit* parameter or use KUNIT_* macros as seen in PATCH_DIFF).

2) Step 2: Objective — track the allocated pointer’s value to its uses. Signals — establish intra-procedural dataflow from the kunit_kzalloc return to the same variable and its simple aliases/assignments. FP mitigation — stop tracking when the variable is reassigned to a different value or escapes to another function unless re-aliased back locally.

3) Step 3: Objective — find unsafe dereferences of the allocated pointer. Signals — locate member accesses via “->” or “*p” dereferences of the pointer (e.g., ies->len) and derived field accesses (e.g., ies->data) as shown in ROOTCAUSE_ANALYSIS and PATCH_DIFF. FP mitigation — ensure the dereference is reachable on at least one path after the allocation.

4) Step 4: Objective — include indirect dereference via standard library/memory functions. Signals — identify uses where fields derived from the pointer are passed to functions like memcpy (e.g., memcpy(ies->data, ...)) as in PATCH_DIFF; treat these as dereferences because they require the base pointer to be non-NULL. FP mitigation — ensure the base pointer for the field is the tracked allocation result.

5) Step 5: Objective — confirm absence of a dominating NULL check or assertion. Signals — search for a KUNIT_ASSERT_NOT_NULL(test, var) on the allocated pointer (explicitly added in PATCH_DIFF) or an explicit NULL check (if (!var) { abort/return }) that dominates the dereference and prevents execution when NULL. FP mitigation — require that the guard dominates all paths to the dereference; otherwise flag.

6) Step 6: Objective — model KUnit assertion behavior as aborting execution on failure. Signals — treat KUNIT_ASSERT_NOT_NULL as a terminating guard for the pointer on the path (per PATCH_DIFF and ROOTCAUSE_ANALYSIS describing the fix). FP mitigation — do not consider non-terminating expectations; only treat assertions that abort/return (here, KUNIT_ASSERT_NOT_NULL) as sufficient.

7) Step 7: Objective — ensure the dereference occurs before any potential guard could run. Signals — perform path-sensitive ordering to verify that no valid guard is encountered between allocation and dereference on the path. FP mitigation — if a guard exists but is after the dereference or in a non-dominating branch, still report.

8) Step 8: Objective — reduce noise to KUnit test contexts where this pattern is intended. Signals — prioritize/report findings in functions with a struct kunit* parameter or using KUNIT_* macros (as in PATCH_DIFF: function “test_cfg80211_parse_colocated_ap(struct kunit *test)” and use of KUNIT_ASSERT_NOT_NULL). FP mitigation — optionally downgrade severity outside such contexts rather than report as errors.

9) Step 9: Objective — avoid reporting when allocation is known to be followed by immediate error handling that stops execution. Signals — recognize patterns where the NULL branch returns from the function or otherwise prevents the dereference (e.g., return, goto error that exits before dereference). FP mitigation — require a guaranteed stop (return) on NULL to suppress.

10) Step 10: Objective — produce precise findings tied to the root cause. Signals — report the pair: allocation site (kunit_kzalloc call) and first dereference site (e.g., ies->len or memcpy with ies->data) without an intervening dominating guard, directly reflecting ROOTCAUSE_ANALYSIS.

3. Target Elements
- Function definitions (to identify KUnit test context via parameters/macros).
- Call sites to kunit_kzalloc and their result variables.
- Pointer dereference expressions (member access via “->”, unary dereference, array indexing on pointers).
- Calls like memcpy where arguments are derived from pointer fields.
- Condition checks comparing the pointer to NULL.
- KUnit assertion calls, specifically KUNIT_ASSERT_NOT_NULL.
- Control-flow constructs (if/else, early returns) to assess dominance and path feasibility.

4. Dataflow / Taint Considerations
- Track the allocation result from kunit_kzalloc to its uses via local variable assignments and field derivations (e.g., p->field).
- Treat the pointer as “tainted with potential NULL” until a dominating KUNIT_ASSERT_NOT_NULL or explicit NULL-check with early exit is encountered.
- Do not propagate through function calls unless the same variable is used afterward unchanged; focus on intra-procedural paths.
- Stop tracking when the variable is reassigned to a non-allocation value.

5. Validation & Test Cases
- Positive: A function with struct kunit* test parameter that does p = kunit_kzalloc(...); p->len = n; memcpy(p->data, src, n); with no prior KUNIT_ASSERT_NOT_NULL or NULL check — expected: flagged at p->len (and/or memcpy) with allocation site context.
- Positive: Allocation followed by an if (p) branch where dereference occurs only in the else branch (i.e., deref on possible NULL path) — expected: flagged.
- Negative: Allocation followed immediately by KUNIT_ASSERT_NOT_NULL(test, p); then dereferences — expected: no findings.
- Negative: Allocation followed by if (!p) return; then dereferences — expected: no findings.
- Test harness notes: Run on net/wireless/tests-like code and ensure paths with guards that dominate dereferences are correctly recognized.

6. Estimated Effort & Priority
Medium effort and medium priority, as it targets a well-scoped API (kunit_kzalloc) and a clear misuse pattern with significant stability impact in tests.

7. Likely False-Positive Sources & Mitigations
- Unrecognized guard macros that semantically abort on NULL: mitigate by adding known KUnit guard (KUNIT_ASSERT_NOT_NULL) and explicit NULL-check patterns; allow configurable guard macro list.
- Complex control-flow where the guard dominates via indirect constructs (e.g., helper wrappers): mitigate by conservative dominance analysis and limiting to intra-procedural checks.
- Cases where subsequent code cannot execute after allocation failure due to external framework behavior not modeled: mitigate by restricting to clear, local guards.

8. Limitations & Assumptions
- Assumes kunit_kzalloc may return NULL (per PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS); no broader allocator set is considered.
- Assumes KUNIT_ASSERT_NOT_NULL aborts test execution on failure (per PATCH_DIFF/ROOTCAUSE_ANALYSIS); other KUnit macros are not modeled.
- Inter-procedural guarantees (e.g., helper functions that validate and abort) are not captured, potentially yielding FPs or FNs.
- Scope is focused on KUnit test contexts; applicability to non-test code is not established by the supplied materials.