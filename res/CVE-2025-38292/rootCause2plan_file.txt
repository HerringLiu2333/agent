1. Plan Summary
Detect use-after-free reads where fields derived from a struct sk_buff pointer (e.g., ATH12K_SKB_RXCB(skb)) are accessed after the skb has been freed via dev_kfree_skb_any in the same function.

2. Detection Steps
1) Step 1: Objective: Identify deallocation points for sk_buff. Signals: Call sites of dev_kfree_skb_any with an argument of type struct sk_buff* (from [FILE_CONTENT]). FP mitigation: Restrict to the exact functions seen in the file (e.g., dev_kfree_skb_any) to avoid misclassifying other APIs.

2) Step 2: Objective: Identify aliases derived from a given skb that are later dereferenced. Signals: Assignments like rxcb = ATH12K_SKB_RXCB(skb) or direct macro deref ATH12K_SKB_RXCB(skb)->field before the free (from [FILE_CONTENT], used in ath12k_dp_rx_msdu_coalesce). FP mitigation: Ensure the alias is dataflow-equivalent to the same skb argument passed to dev_kfree_skb_any without intervening writes changing rxcb or skb.

3) Step 3: Objective: Track control/dataflow after the free. Signals: Intra-procedural paths that proceed beyond dev_kfree_skb_any(skb) without early return/goto and reach a dereference of rxcb->field or ATH12K_SKB_RXCB(skb)->field. Why: Maps directly to the UAF in [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION]. FP mitigation: Require that the dereference post-dominates the free call on at least one feasible path and is not guarded by code that reassigns rxcb or skb.

4) Step 4: Objective: Recognize the specific Linux RX coalescing loop pattern. Signals: A while loop over skb list, assignment rxcb = ATH12K_SKB_RXCB(skb), dev_kfree_skb_any(skb), followed by a condition using rxcb->is_continuation to decide break (as pre-patch in [PATCH_DIFF]). Why: This captures the precise root cause instance. FP mitigation: Only flag when the dereferenced field is used after the free in the same iteration and prior to any reassignment of rxcb or skb.

5) Step 5: Objective: Allow safe caching patterns to suppress findings. Signals: Scalar copies like bool cached = rxcb->field taken before the free and using cached afterward, with no post-free deref of rxcb or ATH12K_SKB_RXCB(skb) (as fixed in [PATCH_DIFF]). FP mitigation: If the only post-free uses are of scalars not pointing into skb memory, do not flag.

6) Step 6: Objective: Detect post-free direct macro uses independent of rxcb temp. Signals: Any ATH12K_SKB_RXCB(skb)->field after dev_kfree_skb_any(skb) along the same path. Why: Macro re-evaluation also re-dereferences freed memory (matching [ROOTCAUSE_ANALYSIS]). FP mitigation: Ensure skb was not reassigned to a new dequeued skb between the free and the macro deref.

7) Step 7: Objective: Avoid false positives when skb is reinitialized. Signals: Recognize reassignments like skb = __skb_dequeue(...), or skb = <new alloc>, between the free and the deref. FP mitigation: If such reassignments reach the deref on all paths, consider the deref safe.

8) Step 8: Objective: Ensure we only flag dereferences, not harmless pointer comparisons. Signals: Flag member access (field read/write, array indexing through derived pointers) on rxcb or ATH12K_SKB_RXCB(skb); ignore pointer equality checks or NULL tests. FP mitigation: This narrows to memory access UAF rather than control-only uses.

9) Step 9: Objective: Confirm the free is effective on the tracked value. Signals: The dev_kfree_skb_any callâ€™s argument must be dataflow-equal to the same skb used to compute rxcb (no casts that change identity). FP mitigation: If aliasing could point to a different skb, require must-alias equivalence.

10) Step 10: Objective: Prioritize high-risk paths with multiple-buffer MSDU handling. Signals: Presence of code computing continuation or buffer-length logic (e.g., fields is_continuation and buffer sizes, from [FILE_CONTENT]) in the same loop reinforces applicability to the RX coalescing pattern. FP mitigation: Use this contextual signal for ranking/prioritization rather than gating, to focus alerts relevant to [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Function bodies containing:
  - Calls to dev_kfree_skb_any with struct sk_buff* arguments.
  - Assignments from ATH12K_SKB_RXCB(skb) to local pointers (e.g., rxcb).
  - Direct uses of ATH12K_SKB_RXCB(skb)->field.
- Control-flow constructs (loops/conditionals) around RX processing (e.g., ath12k_dp_rx_msdu_coalesce).
- Field accesses on aliases derived from skb (e.g., rxcb->is_continuation).
- Reassignments to skb (e.g., __skb_dequeue calls) that can rebind the variable.

4. Dataflow / Taint Considerations
- Track a taint/alias from a specific skb variable through ATH12K_SKB_RXCB(skb) to a pointer like rxcb.
- Mark dev_kfree_skb_any(skb) as a free sink for that taint source.
- Flag any dereference (field access) of the tainted alias (rxcb) or direct macro deref ATH12K_SKB_RXCB(skb) occurring after the free on a feasible path.
- Kill/clear taint on rxcb if it is reassigned from a different skb, and on skb if it is reassigned to a new value before deref.
- Treat scalar copies of fields (e.g., bool cached = rxcb->field) as sinks that produce untainted scalars to avoid false positives when only the scalar is used post-free.

5. Validation & Test Cases
- Positive: The pre-patch ath12k_dp_rx_msdu_coalesce code where rxcb->is_continuation is read after dev_kfree_skb_any(skb) (from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]); expect a finding.
- Negative: The patched version that caches is_continuation into a local bool before the free and only uses the cached bool afterward; expect no finding.
- Negative: A function that reads rxcb->field, then frees skb, and never accesses rxcb or ATH12K_SKB_RXCB(skb) after the free; expect no finding.
- Test harness notes: Use intra-procedural analysis on functions with while loops and queue operations (__skb_dequeue) and verify path sensitivity (free vs. reassign).

6. Estimated Effort & Priority
Medium: The pattern is common in networking drivers and the analysis requires alias and path-sensitivity but remains intra-procedural in typical cases.

7. Likely False-Positive Sources & Mitigations
- Rebinding of skb to a new buffer between free and deref: mitigate with reassignment detection and must-alias checks.
- Scalars cached before free and used after free: mitigate by exempting scalar uses with no subsequent pointer deref.
- Free-like wrappers not modeled: restrict to dev_kfree_skb_any as per [FILE_CONTENT] to avoid overreach.

8. Limitations & Assumptions
- Assumes dev_kfree_skb_any always frees the skb passed (based on usage in [FILE_CONTENT]); other free APIs are not modeled due to lack of evidence.
- Assumes ATH12K_SKB_RXCB(skb) yields a pointer into memory owned by skb (implied by [ROOTCAUSE_ANALYSIS]).
- Inter-procedural flows (aliases passed across calls) are not covered; plan focuses on intra-procedural UAF as in the reported bug.
- Macro expansions are treated conceptually; exact macro body is not provided, but its usage pattern is evident from [FILE_CONTENT].