1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-after-free (UAF)

3. Root Cause Summary
The receive coalescing routine ath12k_dp_rx_msdu_coalesce() caches a pointer to the SKB RX control block (rxcb) and then accesses rxcb->is_continuation after the SKB has been freed with dev_kfree_skb_any(skb). Because ATH12K_SKB_RXCB(skb) refers to memory owned by the freed SKB, dereferencing rxcb post-free is a UAF. The root cause is a lifetime/ordering bug: necessary state (is_continuation) was not captured before freeing the underlying SKB, leading to use of invalid memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver ath12k, data path RX handling (MSDU coalescing).

2) Pre-Patch Flaw:
- In the while-loop processing msdu_list, code does:
  - rxcb = ATH12K_SKB_RXCB(skb);
  - dev_kfree_skb_any(skb);
  - if (!rxcb->is_continuation) break;
- The check “if (!rxcb->is_continuation)” occurs after the SKB is freed, causing rxcb to reference freed memory.

3) Trigger Condition:
- When receiving an MSDU split across multiple RX buffers (rem_len > 0) and the loop dequeues SKBs from msdu_list, the code reaches the post-free check of rxcb->is_continuation. Any path that processes at least one SKB and proceeds to the break decision will trigger the UAF.

4) Impact Mechanism:
- Reading rxcb->is_continuation after dev_kfree_skb_any(skb) is a read from freed memory. This can lead to kernel memory corruption symptoms, including incorrect control flow decisions, crashes, or potential exploitation if the freed memory is reallocated and manipulated.

5. Patch Analysis
1) Fix Approach:
- Capture the continuation flag into a local variable before freeing the SKB, and use that local copy afterward. This eliminates post-free dereferences of the SKB’s control block.

2) Key Code Changes:
- Added local variable: “bool is_continuation;”
- Before freeing, assigned: “is_continuation = rxcb->is_continuation;”
- Replaced both uses of “rxcb->is_continuation” with “is_continuation”, including the post-free break condition.
- Evidence in diff:
  - “dev_kfree_skb_any(skb);”
  - Previously: “if (!rxcb->is_continuation)”
  - Now: “if (!is_continuation)”

3) Locking/Concurrency Impact:
- No locking changes. The fix is purely about variable lifetime; it avoids accessing freed memory without altering synchronization or ordering beyond capturing the flag prior to free.

6. Broader Kernel Security Implications
- UAF in a hot RX path of a wireless driver can be remotely triggerable by crafted network traffic, potentially leading to kernel crashes or controlled memory reads. While this patch prevents the immediate UAF, similar lifetime issues in SKB handling are common sources of kernel vulnerabilities; auditing other post-free accesses and ensuring state is captured before free is critical for robustness.