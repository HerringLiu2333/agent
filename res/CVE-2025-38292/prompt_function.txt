1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-after-free (UAF) due to accessing freed sk_buff control block (skb->cb)

3. Root Cause Summary
In ath12k_dp_rx_msdu_coalesce(), the code reads rxcb->is_continuation after calling dev_kfree_skb_any(skb) within the per-buffer processing loop. Since rxcb is derived from ATH12K_SKB_RXCB(skb), accessing rxcb after freeing skb dereferences memory that has already been returned to the allocator, causing a use-after-free. The patch caches is_continuation in a local variable before freeing skb and uses that cached value afterward, eliminating the UAF.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath12k Wi-Fi driver, RX datapath coalescing

2) Pre-Patch Flaw:
Within ath12k_dp_rx_msdu_coalesce(), the loop processing chained RX buffers frees skb and then immediately evaluates “if (!rxcb->is_continuation) break;”. Because rxcb comes from ATH12K_SKB_RXCB(skb), this reads from freed memory (skb->cb). Example pre-patch line: “if (!rxcb->is_continuation)”.

3) Trigger Condition:
When an MSDU spans multiple RX buffers (rem_len > 0 and msdu_list has entries), the function dequeues a buffer, computes buf_len, copies data, calls dev_kfree_skb_any(skb), and then checks rxcb->is_continuation to decide whether to continue or break. This check after free triggers the UAF.

4) Impact Mechanism:
Dereferencing rxcb (stored in the freed sk_buff) may access invalid or reallocated memory, leading to UAF read, potential memory corruption, unpredictable control flow (incorrect loop termination), and possible kernel crash or sanitizer violations.

5. Patch Analysis
1) Fix Approach:
Avoid accessing fields of rxcb after the skb is freed by caching rxcb->is_continuation in a local variable prior to dev_kfree_skb_any(skb) and using that cached value for subsequent logic.

2) Key Code Changes:
- Introduced a local variable: “bool is_continuation;”.
- Before freeing skb, assigned: “is_continuation = rxcb->is_continuation;”.
- Replaced post-free checks from “if (!rxcb->is_continuation)” to “if (!is_continuation)”.
- Also replaced the pre-free conditional branch from “if (rxcb->is_continuation)” to “if (is_continuation)” to consistently use the cached value.
These changes are localized to ath12k_dp_rx_msdu_coalesce() at the loop starting near line ~1889 in the diff.

3) Locking/Concurrency Impact:
No locking changes. The fix removes a UAF by ensuring the loop’s continuation decision does not read from freed memory; it neither adds nor modifies locks or ordering.

6. Broader Kernel Security Implications
This correction eliminates a common class of memory safety bugs in drivers (UAF on skb->cb) that can lead to crashes or potential exploitation when attacker-controlled inputs (RX frames) influence buffer chaining. Ensuring fields needed after freeing are captured before kfree improves robustness of network RX paths and reduces risk of hard-to-diagnose runtime faults under stress or malicious traffic.