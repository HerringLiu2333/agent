1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-After-Free (UAF) read

3. Root Cause Summary
In ath12k_dp_rx_msdu_coalesce(), the code accesses rxcb->is_continuation after the associated sk_buff has been freed with dev_kfree_skb_any(skb). Since rxcb is derived from ATH12K_SKB_RXCB(skb), reading rxcb fields after freeing skb is a lifetime bug causing a use-after-free read. The patch fixes this by caching rxcb->is_continuation into a local variable before freeing skb and using the cached value afterward.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
wifi datapath (ath12k), RX buffer coalescing in ath12k_dp_rx_msdu_coalesce()

2) Pre-Patch Flaw:
Within the RX coalescing loop, the function frees the current skb and then uses rxcb->is_continuation from that freed skb to control loop termination. Specifically, in the while loop, after dev_kfree_skb_any(skb), the code evaluates “if (!rxcb->is_continuation) break;”, which dereferences the cb area of a freed skb.

3) Trigger Condition:
When processing an MSDU that spans multiple RX buffers (msdu_list contains multiple skbs), the function enters the loop that dequeues buffers, copies data, frees the current skb, and then checks rxcb->is_continuation of the just-freed skb to decide whether to continue coalescing. This sequence triggers a use-after-free on any multi-buffer MSDU.

4) Impact Mechanism:
Reading from the freed skb’s control block (rxcb) after dev_kfree_skb_any() leads to undefined behavior: stale or reclaimed memory may be read, potentially causing incorrect loop control (premature break or unintended continuation), kernel warnings under KASAN/UAF detectors, or crashes. Although the access is a read, it can still destabilize the RX path and lead to denial-of-service.

5. Patch Analysis
1) Fix Approach:
The patch introduces a local boolean to cache the continuation flag before freeing the skb, eliminating the post-free dereference of rxcb.

2) Key Code Changes:
- Declares a new local variable “bool is_continuation;”.
- Before freeing, assigns “is_continuation = rxcb->is_continuation;”.
- Replaces post-free condition checks:
  - “if (rxcb->is_continuation)” -> “if (is_continuation)”
  - “if (!rxcb->is_continuation)” -> “if (!is_continuation)”
This ensures the loop decisions use a safe, pre-fetched value rather than accessing freed memory.

3) Locking/Concurrency Impact:
No locking changes. The fix is purely a lifetime/read-after-free correction and does not alter synchronization, RCU, or atomicity.

6. Broader Kernel Security Implications
This bug highlights a common kernel pattern hazard: accessing sk_buff or its control block after freeing. In high-throughput network drivers, such UAF reads can be remotely triggerable via crafted packets that induce multi-buffer coalescing, leading to instability or crashes. The fix reinforces careful handling of object lifetimes and suggests auditing similar RX/TX buffer processing paths to prevent post-free access, improving overall robustness of network stack drivers.