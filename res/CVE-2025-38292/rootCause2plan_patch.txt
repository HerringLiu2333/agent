1. Plan Summary
Detect use-after-free where a pointer/alias derived from an sk_buff (skb) control block is dereferenced after the skb is freed, matching the pattern fixed by caching rxcb->is_continuation before dev_kfree_skb_any().

2. Detection Steps
1) Step 1: Objective: Identify aliases derived from skb-owned memory. Signals: Assignments like rxcb = ATH12K_SKB_RXCB(skb) or equivalent expressions that compute a pointer from an skb (as shown in [PATCH_DIFF] and described in [ROOTCAUSE_ANALYSIS]). FP mitigation: Restrict to known derivations seen here (ATH12K_SKB_RXCB) and to variables immediately assigned from such an expression.

2) Step 2: Objective: Identify frees of the owning skb object. Signals: Calls to dev_kfree_skb_any(skb) on the same skb variable used to derive the alias (per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Require argument identity match with the alias’s originating skb variable.

3) Step 3: Objective: Map alias-to-owner relationships. Signals: Record that the alias variable’s memory region is owned by the specific skb variable passed into ATH12K_SKB_RXCB. FP mitigation: Discard aliases if they are re-assigned from a different source before any dereference.

4) Step 4: Objective: Find post-free dereferences of the alias. Signals: Field/indirection operations on the alias (e.g., rxcb->is_continuation) that occur on a control-flow path after dev_kfree_skb_any(skb), as in the “if (!rxcb->is_continuation)” pattern in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: Ensure path-feasibility where the free precedes the dereference without an intervening alias redefinition.

5) Step 5: Objective: Ensure pre-free dereferences are not flagged. Signals: Uses of alias fields that occur strictly before any matching dev_kfree_skb_any(skb) along the same path (e.g., the pre-free buf_len decision in [PATCH_DIFF]). FP mitigation: Use ordering constraints so only post-free dereferences are reported.

6) Step 6: Objective: Handle loop bodies with dequeue and immediate free. Signals: While/loop constructs where skb is dequeued, alias computed, skb freed, and alias is used for a break/decision (exact CVE pattern in [ROOTCAUSE_ANALYSIS] step 2). FP mitigation: Scope analysis per iteration and ensure the dereference belongs to the same iteration as the free.

7) Step 7: Objective: Treat both reads and writes as unsafe post-free accesses. Signals: Any dereference (read for branching like if (!rxcb->is_continuation) or write) after free. FP mitigation: Exclude uses that copy scalar fields before free and only use the scalar afterward (as per fix in [PATCH_DIFF]).

8) Step 8: Objective: Confirm same owner is freed. Signals: The free call’s argument is the same symbolic skb that created the alias; exclude cases where a different skb is freed. FP mitigation: Track variable identity and alias origin; ignore potential frees of unrelated variables.

9) Step 9: Objective: Prioritize proximity to reduce noise. Signals: Dereference appears within a short statement distance after the free or within the same basic block/loop segment, mirroring [PATCH_DIFF]. FP mitigation: Rank/report highest when deref is immediate; optionally suppress very long-range matches unless strongly path-confirmed.

10) Step 10: Objective: Recognize the fixed pattern as non-issues. Signals: Introduction of a local scalar (e.g., bool is_continuation) assigned from alias before free, and post-free checks use only the scalar (per [PATCH_DIFF]/[PATCH_DESCRIPTION]). FP mitigation: If post-free control flow relies solely on the cached scalar and not on alias dereferences, do not flag.

11) Step 11: Objective: Avoid flags when alias is re-established after free from a new skb. Signals: A new assignment rxcb = ATH12K_SKB_RXCB(new_skb) occurs between the free and the dereference. FP mitigation: Require that the dereference uses the pre-free alias instance tied to the freed skb.

12) Step 12: Objective: Kernel-specific calibration for this CVE class. Signals: Known skb APIs from the evidence: ATH12K_SKB_RXCB as alias source and dev_kfree_skb_any as deallocator (per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Limit initial rule to these APIs; allow configuration to add more aliases/frees if later evidence is provided.

3. Target Elements
- Local variable assignments deriving control-block pointers from skb (e.g., ATH12K_SKB_RXCB(skb)).
- Calls to skb deallocation routines (dev_kfree_skb_any).
- Field/indirection expressions on derived aliases (e.g., rxcb->field).
- Loop constructs and in-loop control-flow (e.g., break conditions) that may use the alias post-free.
- Basic-block and path ordering around free and subsequent dereference.

4. Dataflow / Taint Considerations
- Track dataflow from skb to alias via ATH12K_SKB_RXCB to establish ownership dependency.
- Model dev_kfree_skb_any(skb) as a lifetime-kill for any aliases derived from that skb.
- Report any dereference of such aliases reachable after the kill along a feasible path without redefinition.
- Treat scalar copies made before free as safe sinks; only dereferences of the alias itself are flagged post-free.

5. Validation & Test Cases
- Positive: Pre-patch pattern: rxcb = ATH12K_SKB_RXCB(skb); ... dev_kfree_skb_any(skb); if (!rxcb->is_continuation) break; Expect a report for post-free dereference of rxcb.
- Negative: Post-patch pattern: is_continuation = rxcb->is_continuation; dev_kfree_skb_any(skb); if (!is_continuation) break; Expect no report since no alias deref occurs after free.
- Negative: Alias used only before free to compute buf_len; free happens afterward; no later dereference of alias; Expect no report.
- Test harness notes: Include loop context with __skb_dequeue and ensure per-iteration analysis; confirm path feasibility and variable identity are respected.

6. Estimated Effort & Priority
High: Critical UAF class in kernel RX paths; requires path-sensitive alias-to-owner tracking but within a constrained API set from the evidence.

7. Likely False-Positive Sources & Mitigations
- Cases where the free does not actually release the underlying memory (not evident here): mitigate by limiting to dev_kfree_skb_any as a definite free per evidence.
- Aliases re-established from a new skb after free: mitigate by tracking alias reassignments and owner identity.
- Very long-range paths with uncertain feasibility: mitigate by prioritizing close-proximity dereferences and requiring clear path ordering.

8. Limitations & Assumptions
- Assumes ATH12K_SKB_RXCB(skb) returns a pointer into memory owned by skb and that dev_kfree_skb_any(skb) releases it, as per [ROOTCAUSE_ANALYSIS].
- Does not model other potential skb deallocation APIs or aliasing macros beyond those evidenced (ATH12K_SKB_RXCB, dev_kfree_skb_any).
- Concurrency, refcounting, or ownership transfers are not modeled due to lack of evidence; only direct free-then-dereference is considered.