1. Plan Summary
Detect missing non-zero validation of migrated DMA base addresses before programming hardware during VF live migration resume, and missing initialization of VF QM state to a safe NOT_READY value.

2. Detection Steps
1) Step 1: Objective — Identify candidate “resume/load migration data” functions. Signals: functions that take a migration-related struct (e.g., contains vf_data) and a device context, similar to vf_qm_load_data in [FUNCTION_CONTENT]. FP mitigation: Restrict to functions that also call low-level device programming routines afterward.

2) Step 2: Objective — Locate assignments from migrated data to device DMA fields. Signals: assignments where fields from a migration container (e.g., migf->vf_data.*) are copied into device context fields named with “dma” (e.g., qm->*dma) as shown in [FUNCTION_CONTENT]. FP mitigation: Require at least one such field to later flow into hardware programming calls in the same function.

3) Step 3: Objective — Identify device programming calls that use these DMA values. Signals: calls like hisi_qm_mb(..., ..., qm->sqc_dma, ...) and register/queue programming helpers (e.g., qm_set_regs) following the assignments, as seen in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: Only flag when DMA values are passed as parameters or otherwise consumed by these calls, not when merely stored.

4) Step 4: Objective — Check for presence of size-only guards that don’t validate DMA contents. Signals: guards like “total_length == QM_MATCH_SIZE” or “total_length < sizeof(...)” (seen in [FUNCTION_CONTENT]) but no checks on individual DMA fields. FP mitigation: Ensure the path from DMA assignments to device programming calls is reachable beyond these size checks.

5) Step 5: Objective — Detect absence of non-zero validation on all required DMA fields before use. Signals: lack of any conditional checks “if (!<dma_field>) ... return/skip” on the set of DMA fields that are assigned and/or used (eqe_dma, aeqe_dma, sqc_dma, cqc_dma per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Accept partial validation if every DMA field actually used in programming is checked for non-zero along all paths.

6) Step 6: Objective — Flag paths where any used DMA field may be zero when reaching programming calls. Signals: dataflow from migrated struct fields to device programming calls without dominating non-zero checks on those variables or fields. FP mitigation: Treat constants, earlier sanitization, or validations in dominating basic blocks as suppressors.

7) Step 7: Objective — Identify batch usage requirements across related DMA fields. Signals: multiple DMA fields copied from the same migrated struct in one block (eqe_dma, aeqe_dma, sqc_dma, cqc_dma) indicating they form a required set per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: Require at least one member of the set to be used in a device command to report; otherwise, downgrade or ignore.

8) Step 8: Objective — Detect missing state fallback on invalid/empty queue data. Signals: in the same resume/load function, absence of setting a state field (e.g., vf_qm_state) to a safe value before returning when data is invalid or empty, contrasted with [PATCH_DIFF] adding vf_qm_state = QM_NOT_READY. FP mitigation: Only apply when the function both validates migration inputs and performs device programming; avoid reporting when no state variable exists.

9) Step 9: Objective — Detect missing initialization of VF QM state during migration init. Signals: migration init functions that set migration flags/ops (as in hisi_acc_vfio_pci_migrn_init_dev in [FUNCTION_CONTENT]) but don’t initialize a state field to NOT_READY (added in [PATCH_DIFF]). FP mitigation: Restrict to functions that assign mig_ops/migration_flags and operate on a device context containing a “state” field used by resume paths.

10) Step 10: Objective — Correlate resume function usage of state with init-time initialization. Signals: if the resume function references or should gate behavior on a state field (per [ROOTCAUSE_ANALYSIS]), but the init function omits initialization. FP mitigation: Only warn when both a resume function exists in the compilation unit and an init function configures migration ops without state initialization.

3. Target Elements
- Functions that parse/consume migration data and program device state (e.g., vf_qm_load_data).
- Assignments from migration data structs to device context fields, especially fields suffixed with “dma”.
- Call sites to low-level device programming interfaces (e.g., hisi_qm_mb with QM_MB_CMD_* and register setup helpers like qm_set_regs).
- Conditional checks guarding these calls.
- Migration initialization functions that set migration_flags/mig_ops and initialize device state.

4. Dataflow / Taint Considerations
- Track flow from fields of a migration data container (e.g., migf->vf_data.*) to device context fields (qm->*dma) and then to arguments of device programming calls.
- Treat zero/NULL as unsafe taint for DMA addresses; verify presence of dominating non-zero checks clearing that taint before use.
- Group related DMA fields copied together; ensure each used field along a path is validated.

5. Validation & Test Cases
- Positive: A function that copies vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma} to qm->{...} and calls hisi_qm_mb with qm->sqc_dma/cqc_dma without any non-zero checks beyond total_length guards (matches [FUNCTION_CONTENT] pre-patch).
- Negative: The same function with an early guard that returns or marks NOT_READY when any of those DMA fields are zero (as in [PATCH_DIFF]) and only proceeds to hisi_qm_mb after validation.
- Negative: A function that validates each used DMA field for non-zero before any device programming call, or that never uses the assigned DMA fields in programming calls.
- Test harness notes: Exercise both paths respecting the “match-only” guard (QM_MATCH_SIZE) to ensure the checker ignores the early-return path and focuses on the unsafe programming path.

6. Estimated Effort & Priority
High: Requires interprocedural dataflow to connect migrated fields to hardware calls and path reasoning to confirm absence of dominating non-zero checks.

7. Likely False-Positive Sources & Mitigations
- Heuristics on field names containing “dma” capturing unrelated pointers; mitigate by requiring downstream use in device programming calls.
- Cases where zero DMA is a valid sentinel for no-op configuration; mitigate by requiring that the function proceeds to program hardware after observing potential zero values.
- Validation performed in callers rather than locally; mitigate by looking for dominating checks in the same function and optionally allowing configurable caller-side guards.

8. Limitations & Assumptions
- Assumes zero/NULL DMA addresses are invalid in this context, based on [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION]; may not generalize to all drivers.
- The checker infers “device programming calls” from known functions in the analyzed unit (e.g., hisi_qm_mb, qm_set_regs) as evidenced in [FUNCTION_CONTENT]; other drivers may use different APIs not covered.
- Semantics of vf_qm_state and QM_NOT_READY are inferred from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]; exact enum definitions are not provided.
- Cannot confirm runtime conditions (e.g., guest driver presence) and relies purely on static absence of non-zero validation before programming.