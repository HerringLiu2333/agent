1. Plan Summary
Detect live-migration recovery code that consumes migrated queue DMA addresses without prior non-NULL validation and lacks safe state initialization, leading to NULL pointer dereference or invalid DMA use.

2. Detection Steps
1) Step 1: Identify “migration data load/recovery” functions that copy fields from a migrated data struct into runtime device/queue manager state. Signals: assignments like vf_data->eqe_dma/aeqe_dma/sqc_dma/cqc_dma to qm->*, or analogous migrated-to-runtime DMA address transfers, as evidenced by [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; FP mitigation: focus on functions that also check migrated blob size (e.g., total_length vs struct size), indicating migration context.
2) Step 2: In those functions, flag when required DMA queue fields are assigned without a prior check ensuring all such fields are non-NULL. Signals: absence of any condition guarding eqe_dma, aeqe_dma, sqc_dma, cqc_dma before assignment/use (pre-patch behavior described in [ROOTCAUSE_ANALYSIS]); FP mitigation: do not flag if there is a consolidated check for all required DMA fields followed by an early return.
3) Step 3: Trace dataflow from migrated DMA fields (sources) to device/queue manager fields (sinks) and onward to operations that imply dereference or hardware programming. Signals: subsequent reads/writes, DMA programming, or queue recovery using qm->eqe_dma/aeqe_dma/sqc_dma/cqc_dma; FP mitigation: require at least one downstream use that would dereference or depend on the pointer as an address, and ensure no intervening non-NULL validation exists along the path.
4) Step 4: Detect explicit early-return patterns on NULL migrated DMA addresses that mark code as safe. Signals: conditional blocks that test any of eqe_dma/aeqe_dma/sqc_dma/cqc_dma for NULL, log, set a safe state, and return without assigning or recovering (as added in [PATCH_DIFF]); FP mitigation: if such a guard exists covering all required fields, suppress the finding.
5) Step 5: Identify migration init functions that are expected to gate recovery via a device state variable. Signals: initialization functions that set up hisi_acc_vf_core_device-like structures and should set vf_qm_state (added in [PATCH_DIFF]); FP mitigation: limit to init routines in the VFIO PCI vendor driver context (e.g., device setup paths tied to migration).
6) Step 6: Flag init routines that do not initialize the recovery state to a safe “NOT_READY” value prior to data verification. Signals: absence of an assignment to vf_qm_state = QM_NOT_READY or equivalent safe state in the init function (pre-patch condition in [ROOTCAUSE_ANALYSIS]); FP mitigation: if a safe state assignment occurs elsewhere before any recovery attempts, do not flag.
7) Step 7: Check that recovery logic is conditionally gated by the device state before using migrated DMA addresses. Signals: conditions referencing vf_qm_state to prevent recovery when state is NOT_READY; FP mitigation: suppress if such gating is present and enforced before any use of qm->eqe_dma/aeqe_dma/sqc_dma/cqc_dma.
8) Step 8: Raise a high-confidence alert when both patterns occur: (a) migrated DMA addresses flow to use without non-NULL validation, and (b) no safe state initialization in migration init. Rationale: this combination matches the root cause described in [ROOTCAUSE_ANALYSIS] and mirrors the fix in [PATCH_DIFF]; FP mitigation: require both criteria where possible, otherwise lower confidence if only one criterion is met.

3. Target Elements
- Functions that load or recover migration data (e.g., vf_qm_load_data-like routines).
- Assignments from migrated data structs (vf_data->*) to runtime device/queue manager structs (qm->*).
- Condition checks for NULL on required DMA fields (eqe_dma, aeqe_dma, sqc_dma, cqc_dma).
- Early-return/logging blocks tied to NULL migrated addresses.
- Migration init functions and assignments to state variables (vf_qm_state).
- Uses of DMA addresses in queue recovery or hardware programming paths.
- State gating checks in recovery code paths.

4. Dataflow / Taint Considerations
- Track flow of potentially NULL migrated DMA fields (eqe_dma, aeqe_dma, sqc_dma, cqc_dma) into device/queue manager state and onward to dereference/usage points.
- Treat absence of non-NULL validation prior to assignment/use as taint propagation risk.
- Model a control-state gate (vf_qm_state) as a guard; consider flows unsafe if gate is not set to NOT_READY at init and not checked before usage.
- Note that size checks (e.g., total_length vs struct size) do not sanitize pointer nullness.

5. Validation & Test Cases
- Positive: A function assigns vf_data->eqe_dma/aeqe_dma/sqc_dma/cqc_dma directly to qm->* and later uses them in recovery without any preceding NULL check; migration init does not set vf_qm_state = QM_NOT_READY. Expected: flagged.
- Negative: A function checks all migrated DMA addresses for NULL, logs, sets vf_qm_state = QM_NOT_READY, and returns before assignment/use; migration init sets vf_qm_state = QM_NOT_READY. Expected: not flagged.
- Test harness notes: Include interprocedural dataflow from migrated struct to device struct to use-site; ensure control-flow gating by vf_qm_state is modeled in path pruning.

6. Estimated Effort & Priority
High (kernel driver safety during live migration; null DMA address use can cause crashes).

7. Likely False-Positive Sources & Mitigations
- Optional DMA fields that may legitimately be NULL: mitigate by focusing on sets used for queue recovery (eqe_dma, aeqe_dma, sqc_dma, cqc_dma per [ROOTCAUSE_ANALYSIS]).
- Gating or validation occurring in a different function: mitigate with interprocedural analysis to recognize upstream checks and state gating.
- Macros or inline helpers obscuring NULL checks: mitigate by expanding calls/helpers conceptually and recognizing equivalent validation patterns.
- Hardware-specific semantics where zero is acceptable: mitigate with conservative reporting only when downstream dereference/use is evident.

8. Limitations & Assumptions
- Assumes eqe_dma, aeqe_dma, sqc_dma, cqc_dma are required for recovery, based on [ROOTCAUSE_ANALYSIS]; optional semantics elsewhere are not determinable.
- Cannot infer runtime guest conditions (missing VF driver); relies solely on static absence of NULL checks and state gating.
- Exact names/types (e.g., acc_vf_data, vf_qm_state, QM_NOT_READY) may vary; the checker must use conceptual roles, not identifiers.
- Concurrency and locking impacts are unknown per [ROOTCAUSE_ANALYSIS]; the checker does not model races.