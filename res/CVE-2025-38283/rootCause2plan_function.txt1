1. Plan Summary
Detect use of migrated VF DMA addresses without non-zero validation before programming hardware during live migration resume, and missing VF QM state initialization in migration init.

2. Detection Steps
1) Step 1: Identify the migration resume handler that consumes struct hisi_acc_vf_migration_file and struct acc_vf_data (e.g., vf_qm_load_data). Signals: function parameters of these types and local extraction of migf->vf_data.

2) Step 2: Find assignments that copy vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma} into device state qm->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma}. Signals: direct field-to-field assignments from vf_data to qm within the same function.

3) Step 3: Locate subsequent hardware-programming calls that use these DMA addresses as arguments (sinks), specifically hisi_qm_mb with QM_MB_CMD_SQC_BT or QM_MB_CMD_CQC_BT using qm->sqc_dma or qm->cqc_dma. Signals: call expressions to hisi_qm_mb where the third argument is one of the qm DMA fields.

4) Step 4: For each sink, check for a dominating guard that tests the relevant DMA fields (vf_data->* or qm->*) against NULL/zero and aborts or returns early when invalid. Signals: if/early-return patterns like "!vf_data->eqe_dma || !vf_data->aeqe_dma || !vf_data->sqc_dma || !vf_data->cqc_dma" before the assignments or sinks.

5) Step 5: Flag a violation when any sink uses qm->sqc_dma or qm->cqc_dma that originated from vf_data without any prior non-zero/NULL validation of those fields. Signals: absence of a conditional guarding all used DMA fields on the path from assignment to sink.

6) Step 6: Treat unrelated checks such as migf->total_length comparisons as insufficient; do not count them as DMA address validation. Signals: conditions comparing sizes (QM_MATCH_SIZE, sizeof(struct acc_vf_data)) rather than checking dma fields.

7) Step 7: Record the full dataflow path for diagnostics: vf_data field → assignment to qm field → use in hisi_qm_mb, with no guarding condition. Signals: intra-procedural flow from assignment statements to call arguments within vf_qm_load_data.

8) Step 8: Check whether the resume handler sets a safe state when invalid data is detected; look for assignments to hisi_acc_vdev->vf_qm_state = QM_NOT_READY tied to invalid/empty addresses. Signals: absence of any state downgrade before sinks while using possibly zero DMA addresses.

9) Step 9: Inspect the migration init function hisi_acc_vfio_pci_migrn_init_dev for explicit initialization of hisi_acc_vdev->vf_qm_state. Signals: presence/absence of an assignment to vf_qm_state (e.g., QM_NOT_READY) before exposing migration ops.

10) Step 10: Flag missing initialization in Step 9 when the function sets up migration (migration_flags/mig_ops) but never assigns vf_qm_state. Signals: assignments to core_vdev->migration_flags/core_vdev->mig_ops with no prior vf_qm_state write.

3. Limitations & Assumptions
- Assumes zero/NULL DMA addresses are invalid and must be checked; other sentinel values are unknown from the inputs.
- Assumes hisi_qm_mb calls with QM_MB_CMD_SQC_BT/CQC_BT program hardware and are the relevant sinks; other sinks (e.g., within qm_set_regs) are not analyzable from the provided content.
- Interprocedural guarantees (e.g., prior validation elsewhere) are not considered; the checker focuses on local validation within the resume/init functions shown.
- Exact enum/constant value of QM_NOT_READY is not needed; the checker looks for any assignment to vf_qm_state, but cannot verify correctness of the value without additional context.