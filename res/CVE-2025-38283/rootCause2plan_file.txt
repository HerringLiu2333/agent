1. Plan Summary
Detect cases where migration-sourced DMA base addresses are consumed to program hardware without prior non-NULL validation, as in vf_qm_load_data using vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma}.

2. Detection Steps
1) Step 1: Identify resume/load-state functions that consume migration data — look for functions taking a hisi_acc_vf_migration_file or acc_vf_data pointer and accessing migf->vf_data fields — these are the entry points for untrusted migration input based on ROOTCAUSE_ANALYSIS and FILE_CONTENT.
2) Step 2: Model untrusted sources — treat fields of migf->vf_data as tainted if they are written via copy_from_user paths (e.g., hisi_acc_vf_resume_write updates migf->vf_data) — this maps to the root cause since migration streams are untrusted input.
3) Step 3: Find DMA-like fields — within acc_vf_data, focus on eqe_dma, aeqe_dma, sqc_dma, cqc_dma (64-bit addresses) referenced after basic size checks — these are the precise fields implicated per ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION.
4) Step 4: Identify hardware programming sinks — detect calls that program hardware using these values: hisi_qm_mb(qm, QM_MB_CMD_SQC_BT, …) with sqc_dma and hisi_qm_mb(qm, QM_MB_CMD_CQC_BT, …) with cqc_dma, and assignment of eqe_dma/aeqe_dma/sqc_dma/cqc_dma to qm->... followed by register programming via qm_set_regs — these match the described misuse in ROOTCAUSE_ANALYSIS.
5) Step 5: Build dataflow from vf_data fields to sinks — flag flows where vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma} are assigned to local/device variables or passed directly to sink calls — this confirms the untrusted address reaches hardware programming.
6) Step 6: Check for dominating non-NULL validation — require a control-flow dominating condition that checks each of eqe_dma, aeqe_dma, sqc_dma, cqc_dma for non-zero before any sink use; absence of such checks indicates the flaw — this mirrors the fix added in PATCH_DIFF.
7) Step 7: Exempt “early return” safe paths — if the function exits before sinks when migf->total_length == QM_MATCH_SIZE or migf->total_length < sizeof(struct acc_vf_data), but still proceeds to sinks otherwise without address validation, still report — size checks alone did not prevent the bug per ROOTCAUSE_ANALYSIS.
8) Step 8: Require migration recovery context — increase precision by ensuring the identified function is on the RESUMING/STOP transition path (e.g., called from hisi_acc_vf_load_state → vf_qm_load_data) — this aligns with the trigger condition in ROOTCAUSE_ANALYSIS and reduces cross-context noise.
9) Step 9: Prefer sink specificity — only report when the tainted value flows into hisi_qm_mb with QM_MB_CMD_SQC_BT or QM_MB_CMD_CQC_BT or into qm_set_regs immediately before those mailbox commands — per ROOTCAUSE_ANALYSIS these are the operations that fault with NULL.
10) Step 10: Secondary heuristic for state misuse (optional) — flag when hisi_acc_vdev->vf_qm_state is set or used as ready without prior initialization to QM_NOT_READY in the migration init path — this reflects the safety initialization change in PATCH_DIFF and can catch related readiness assumptions.
11) Step 11: Suppress if equivalent validation exists — do not report if the function sets vf_qm_state to NOT_READY and returns before any sink when any of the four DMA fields are zero — this mirrors the fixed pattern in PATCH_DIFF and avoids false positives.
12) Step 12: Consolidate report — emit one finding per function when any of the four DMA fields reach a sink without dominating non-NULL checks — this aligns with the class of issues described in ROOTCAUSE_ANALYSIS.

3. Target Elements
- Functions handling migration resume/load: e.g., vf_qm_load_data, hisi_acc_vf_load_state, hisi_acc_vf_set_device_state paths.
- Struct field accesses: migf->vf_data.{eqe_dma, aeqe_dma, sqc_dma, cqc_dma}.
- Call sites: hisi_qm_mb(..., QM_MB_CMD_SQC_BT, ...), hisi_qm_mb(..., QM_MB_CMD_CQC_BT, ...), qm_set_regs(...).
- Assignments to device fields: qm->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma}.
- Condition checks and early returns guarding these paths.
- copy_from_user sites writing into migf->vf_data (hisi_acc_vf_resume_write).

4. Dataflow / Taint Considerations
- Treat data written into migf->vf_data via copy_from_user as tainted.
- Track field-level flows from vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma} through assignments to locals/device struct members to sink arguments.
- Require that the tainted value is used as a DMA/base address in a hardware programming operation (mailbox commands or register programming).
- Demand a lack of dominating non-NULL checks on each specific field that reaches a sink.

5. Validation & Test Cases
- Positive: Pre-patch vf_qm_load_data that assigns vf_data->sqc_dma/cqc_dma and calls hisi_qm_mb with those values without any non-NULL checks; expect a report. Similarly, usage of eqe_dma/aeqe_dma via qm_set_regs without pre-validation; expect a report.
- Negative: Post-patch vf_qm_load_data with early if (!eqe_dma || !aeqe_dma || !sqc_dma || !cqc_dma) { set NOT_READY; return 0; } before any sink; expect no report.
- Test harness notes: Build minimal stubs for hisi_qm_mb, qm_set_regs, and the acc_vf_data/migf structures; simulate copy_from_user into migf->vf_data and validate taint flow to sinks.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Alternate validation in helper functions not recognized as dominating checks; mitigate by interprocedural control-dependence analysis for common guard helpers.
- Contexts where zero could be a valid hardware sentinel; mitigate by restricting to the specific mailbox commands and fields named in FILE_CONTENT and ROOTCAUSE_ANALYSIS.
- Paths where size checks prevent reaching sinks; mitigate by path-sensitive analysis ensuring the sink is reachable after the size check.

8. Limitations & Assumptions
- Assumes zero DMA addresses are invalid in this context, as stated in ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION.
- Assumes availability of constants (QM_MB_CMD_SQC_BT, QM_MB_CMD_CQC_BT) and function identities (hisi_qm_mb, qm_set_regs) for sink recognition from FILE_CONTENT.
- Does not generalize to other drivers without analogous evidence of untrusted migration inputs and specific sink functions.