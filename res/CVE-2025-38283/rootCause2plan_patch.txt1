1. Plan Summary
Detect missing NULL validation and unsafe use of migrated DMA address fields during live migration recovery, and missing initialization of migration state to a safe NOT_READY value.

2. Detection Steps
1) Step 1: Scope candidate functions likely on the migration restore path — look for function names or call contexts indicating live migration/recovery (e.g., names containing “load”, “migr”, “resume”, “recover”), as exemplified by vf_qm_load_data.
2) Step 2: Within such a function, identify a “migration data” struct variable whose size is validated against sizeof(struct …) (e.g., a check like total_length < sizeof(struct acc_vf_data)); mark fields of this struct as externally migrated inputs.
3) Step 3: Find assignments where the source is a field on the migration data struct (e.g., vf_data->eqe_dma/aeqe_dma/sqc_dma/cqc_dma) and the destination is a device/queue-manager context field (e.g., qm->… or hisi_acc_vdev->…); group multiple assignments that occur together from the same migration data variable.
4) Step 4: Among those grouped assignments, prioritize fields with names suggesting DMA addresses (e.g., member names containing “dma”, as in eqe_dma, aeqe_dma, sqc_dma, cqc_dma) or pointer/integral address-typed fields; these are high-risk if NULL.
5) Step 5: For each such group, check if there exists a guard prior to assignment that explicitly ensures all relevant migrated address fields are non-NULL (e.g., a combined or individual non-NULL checks for each eqe_dma/aeqe_dma/sqc_dma/cqc_dma); if no such guard is found, flag as missing input validation.
6) Step 6: If there is a guard, verify completeness: ensure every migrated DMA field assigned in the group is covered by the non-NULL checks; if any assigned field lacks a corresponding NULL check in the guarding condition, flag as partial/insufficient validation.
7) Step 7: Check for an early exit path tied to NULL detection that prevents recovery from proceeding (e.g., a branch that logs a NULL, sets a “NOT_READY” state, and returns); if no such early return or equivalent gating exists, increase severity of the finding.
8) Step 8: Assess whether the assigned destination fields are used later on a non-error path (e.g., read, dereferenced, or passed to operations configuring hardware) within the same function or via immediate calls; if such uses exist without prior NULL validation, prioritize the alert.
9) Step 9: Identify a device state variable used to gate recovery (e.g., a member like vf_qm_state) that is set to a “NOT_READY”-like enumerator upon invalid input; if such a variable is referenced in recovery logic but never assigned a NOT_READY value in the recovery function when inputs are empty/NULL, flag additional missing gating.
10) Step 10: Locate the migration initialization function(s) (e.g., names containing “migrn_init”, “init_dev”) for the same device context; check if the state variable identified in Step 9 is initialized to a safe NOT_READY value there, and if not, flag missing safe initialization.
11) Step 11: Correlate findings: prefer reporting when both conditions co-occur for the same device context — (a) migrated DMA fields assigned without comprehensive NULL checks and (b) state not initialized to NOT_READY in the migration init function — as this mirrors the pre-patch flaw scenario.
12) Step 12: Provide result details pointing to the assignments lacking validation and the absence of guarding/initialization (file/function names and the specific fields like eqe_dma/aeqe_dma/sqc_dma/cqc_dma) to guide remediation.

3. Limitations & Assumptions
- Heuristics rely on naming (e.g., “load/migr/resume/recover”, “*_dma”, “NOT_READY/QM_NOT_READY”); other drivers may use different names, which may reduce recall.
- Type information for “DMA address” fields may be ambiguous (integer vs pointer); the plan assumes name-based hints like “*_dma” to prioritize candidates.
- Determining whether later uses actually dereference/program hardware is approximated by detecting reads/passes-on; exact hardware effects are not inferable statically from the provided info.
- Cross-function gating by state variables depends on recognizing the same device context field across functions; complex aliasing or indirect initialization patterns may be missed.
- Concurrency/locking implications are out of scope and not analyzed per the provided materials.