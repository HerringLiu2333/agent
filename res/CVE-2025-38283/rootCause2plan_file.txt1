1. Plan Summary
Detect use of migration-supplied DMA addresses being programmed into hardware without non-zero validation in the HiSilicon VFIO PCI live migration path.

2. Detection Steps
1) Step 1: Identify untrusted migration data sources — reads of fields from migf->vf_data (acc_vf_data), specifically eqe_dma, aeqe_dma, sqc_dma, cqc_dma. Signal: copy_from_user populates migf->vf_data in hisi_acc_vf_resume_write, marking subsequent field reads as user-controlled.

2) Step 2: Locate migration resume/load functions that consume vf_data to configure the device, e.g., vf_qm_load_data and callers such as hisi_acc_vf_load_state. Signal: functions that take hisi_acc_vf_core_device and hisi_acc_vf_migration_file and reference migf->vf_data.

3) Step 3: Within such functions, find assignments from vf_data DMA fields into device state (qm->eqe_dma, qm->aeqe_dma, qm->sqc_dma, qm->cqc_dma). Signal: statements of the form qm->X_dma = vf_data->X_dma for X in {eqe, aeqe, sqc, cqc}.

4) Step 4: Identify hardware-programming sinks that consume these addresses, notably hisi_qm_mb calls that set SQC/CQC base tables. Signal: call hisi_qm_mb(qm, QM_MB_CMD_SQC_BT, <addr>, …) or hisi_qm_mb(qm, QM_MB_CMD_CQC_BT, <addr>, …) where <addr> is qm->sqc_dma/cqc_dma or directly derived from vf_data->sqc_dma/cqc_dma.

5) Step 5: Also consider register programming paths that rely on migration data preceding or surrounding mailbox commands. Signal: calls to qm_set_regs(qm, vf_data) in the same function that are followed by mailbox calls using sqc_dma/cqc_dma.

6) Step 6: For each sink, compute the control-flow dominators and search for protective validation gating its execution. Signal: presence of an early-return/skip branch that checks any of eqe_dma, aeqe_dma, sqc_dma, cqc_dma (or the corresponding qm-> fields) for non-zero before assignments or sinks.

7) Step 7: Treat checks that only validate migf->total_length (e.g., size comparisons against QM_MATCH_SIZE/sizeof(acc_vf_data)) as insufficient. Signal: detect size checks with no subsequent non-zero validation of the relevant DMA addresses before hardware programming.

8) Step 8: Report a finding when a mailbox sink (SQC_BT/CQC_BT) is reachable from the user-controlled vf_data->sqc_dma/cqc_dma (directly or via qm-> fields) without any preceding non-zero validation in the same function or a directly enclosing guard. Signal: dataflow from vf_data->sqc_dma/cqc_dma to hisi_qm_mb argument, absence of protective if/return guarding that path.

9) Step 9: Optionally expand coverage to eqe_dma/aeqe_dma if they are ever used to program hardware or drive queue recovery operations. Signal: sinks that use eqe_dma/aeqe_dma (writes/doorbells) without non-zero checks; if none are found, focus on sqc_dma/cqc_dma sinks.

10) Step 10: Prioritize paths in the RESUMING->STOP recovery sequence. Signal: calls through hisi_acc_vf_load_state -> vf_qm_load_data where mailbox programming happens, as these are the documented trigger points.

3. Limitations & Assumptions
- Assumes zero (NULL) DMA addresses are invalid for hardware programming; this is inferred from the root cause and patch notes but not formally typed in the code.
- Semantics of hisi_qm_mb command values (e.g., that SQC_BT/CQC_BT expect DMA addresses) are inferred from the file content; other sinks may exist but are not enumerated.
- The full definition of struct acc_vf_data is not provided; detection relies on observed field names and uses.
- Validation in external helpers not present in the file may exist but cannot be accounted for; the checker focuses on local guards dominating the sinks.