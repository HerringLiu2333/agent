1. Plan Summary
Detect kernel driver workqueues created without WQ_UNBOUND (and optionally without WQ_MEM_RECLAIM) that can lead to CPU-bound workqueue starvation and denial-of-service, as exemplified by the IDPF driver issue.

2. Detection Steps
1) Step 1: Objective — locate all alloc_workqueue call sites to gather candidate workqueue allocations; Signals — identify calls to alloc_workqueue and extract the flags argument and the destination variable/field; FP mitigation — restrict initial scope to code under drivers/ and prefer functions named *probe based on the idpf_probe context in [ROOTCAUSE_ANALYSIS].

2) Step 2: Objective — flag workqueues created as per-CPU bound; Signals — detect flags that are the literal 0 or expressions lacking the token WQ_UNBOUND (as in pre-patch “alloc_workqueue(..., 0, 0, ...)” from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]); FP mitigation — exclude any allocation where flags syntactically include WQ_UNBOUND.

3) Step 3: Objective — elevate severity when WQ_MEM_RECLAIM is also missing; Signals — check whether flags omit WQ_MEM_RECLAIM (patch adds WQ_UNBOUND | WQ_MEM_RECLAIM per [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS] states it “ensuring forward progress”); FP mitigation — treat missing WQ_MEM_RECLAIM as secondary (warn-not-error) unless in driver init paths, to avoid penalizing queues where reclaim is irrelevant.

4) Step 4: Objective — connect allocations to downstream usage that enqueues work; Signals — track the allocated workqueue pointer through assignments (including struct fields like adapter->init_wq) to calls of queue_work, queue_delayed_work, mod_delayed_work, and their *_on variants, per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS] references to “queue_delayed_work and friends”; FP mitigation — report only if at least one enqueue call is found for the workqueue, to avoid flagging unused or dead allocations.

5) Step 5: Objective — identify binding risk via enqueue patterns; Signals — mark as risky when enqueue functions are called without specifying a CPU (default behavior) or when *_on variants explicitly pin to a CPU, since both are vulnerable if the workqueue is per-CPU bound as explained in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; FP mitigation — none needed beyond Step 2, because the absence of WQ_UNBOUND is the primary risk indicator regardless of enqueue variant.

6) Step 6: Objective — focus on likely critical driver work; Signals — prioritize workqueues created in probe/init contexts (e.g., idpf_probe) and/or with names suggesting critical roles like “init”, “service”, “mbx”, “stats”, “vc_event”, matching [PATCH_DIFF]; FP mitigation — apply a lower severity or suppress if the queue name suggests highly local/CPU-specific work and there are no delayed or periodic enqueues detected.

7) Step 7: Objective — deprioritize cases that already use global unbound pools; Signals — exclude queues if the code uses system_unbound_wq or equivalent unbound constructs instead of alloc_workqueue for the same work items; FP mitigation — ensure alias analysis ties the same work item to an unbound pool to avoid accidental suppression.

8) Step 8: Objective — reduce noise from test or debug-only code; Signals — downrank findings in files or functions marked as test, debug, or tracing and with no evidence of timeouts or service tasks (heuristic scope reduction aligned with [ROOTCAUSE_ANALYSIS] emphasis on performance/timeouts in drivers); FP mitigation — require that the workqueue participates in at least one delayed or periodic enqueue to be considered non-test.

9) Step 9: Objective — rank findings by impact; Signals — raise priority for drivers/net/* (per [ROOTCAUSE_ANALYSIS] “Intel IDPF network driver”) and workqueues used for repeated service/maintenance (e.g., queue_delayed_work with nonzero delay); FP mitigation — keep findings outside network drivers but mark them lower priority.

10) Step 10: Objective — produce actionable explanations; Signals — for each finding, report the alloc_workqueue flags, the first enqueue call-site(s), and whether WQ_UNBOUND and WQ_MEM_RECLAIM are missing (as per [PATCH_DIFF] fix); FP mitigation — include context (function name like *probe and queue name) to aid triage.

3. Target Elements
- Function calls: alloc_workqueue; queue_work, queue_delayed_work, mod_delayed_work, and their *_on variants.
- Function contexts: probe/init functions (e.g., *probe) in drivers/, especially drivers/net/*.
- Arguments: flags parameter to alloc_workqueue; CPU parameter presence in *_on enqueue calls.
- Variables/fields: destinations receiving the workqueue (locals, globals, struct fields like adapter->init_wq/serv_wq/mbx_wq/stats_wq/vc_event_wq from [PATCH_DIFF]).
- String/name arguments used to name workqueues (to match “init”, “service”, “mbx”, “stats”, “vc_event”).

4. Dataflow / Taint Considerations
- Track the workqueue pointer from alloc_workqueue through variable assignments, struct field writes/reads, and aliases to its use in enqueue APIs.
- Model field-sensitive flows (e.g., adapter->X_wq) and interprocedural passing to helper functions that perform the enqueue.
- No user-taint is needed; the flow is purely from allocation site to usage site to confirm that the risky queue is actually used.

5. Validation & Test Cases
- Positive: In a driver probe function, create wq = alloc_workqueue("drv-service", 0, 0, ...); later call queue_delayed_work(wq, &work, msecs_to_jiffies(100)); Expect a finding: missing WQ_UNBOUND (and possibly WQ_MEM_RECLAIM), high severity under drivers/net.
- Positive: alloc_workqueue("drv-mbx", 0, 0, ...); later call queue_work_on(cpu, wq, &work); Expect a finding due to per-CPU bound wq used with explicit CPU pinning.
- Negative: alloc_workqueue("drv-service", WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...); use queue_delayed_work(wq, ...); Expect no finding.
- Negative: Use system_unbound_wq for enqueues without creating a custom bound workqueue; Expect no finding.
- Test harness notes: Validate interprocedural and field-sensitive flow (e.g., store wq in adapter->serv_wq and enqueue in another function) and ensure flags parsing correctly recognizes presence/absence of WQ_UNBOUND.

6. Estimated Effort & Priority
Medium: requires AST matching, flag-constant inspection, and moderate interprocedural/field-sensitive dataflow to connect allocation to use.

7. Likely False-Positive Sources & Mitigations
- Intentional per-CPU workqueues designed for locality: mitigate by prioritizing probe/init/service queues and delayed/periodic enqueues; provide lower severity option for others.
- Queues used only in short-lived or debug contexts: mitigate by requiring evidence of actual enqueue usage and downranking test/debug files.
- Cases where missing WQ_MEM_RECLAIM is acceptable: treat absence of WQ_MEM_RECLAIM as advisory unless in driver init/service paths.

8. Limitations & Assumptions
- Assumes the risk model that per-CPU bound workqueues can be starved as described in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; runtime CPU load and scheduling conditions are not observable statically.
- Cannot prove that a given queue is “critical”; naming and location heuristics (from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]) are used to approximate importance.
- Does not detect other scheduling mitigations outside alloc_workqueue flags (e.g., runtime affinity changes) due to lack of evidence in the provided materials.