1. Plan Summary
Detect kernel drivers that create bound workqueues (alloc_workqueue without WQ_UNBOUND) and then queue work via default APIs that don’t specify a CPU, exposing them to workqueue starvation and DoS.

2. Detection Steps
1) Step 1: Locate calls to alloc_workqueue and identify the flags argument; signal when the flags are 0 or otherwise do not include WQ_UNBOUND. Record the returned workqueue handle for subsequent tracking.

2) Step 2: Capture where the workqueue handle is stored (e.g., struct fields like adapter->init_wq, serv_wq, mbx_wq, stats_wq, vc_event_wq) and the function context (e.g., probe/init code). This associates the workqueue with driver-critical paths.

3) Step 3: Identify initialization of delayed work items tied to the driver (e.g., INIT_DELAYED_WORK on tasks such as init_task, serv_task, mbx_task, stats_task, vc_event_task). Link these work items to the previously recorded workqueue handle via dataflow or usage patterns.

4) Step 4: Find queue operations that do not specify a CPU (queue_delayed_work, mod_delayed_work, queue_work) using the recorded workqueue handle. Exclude CPU-specific variants (e.g., ..._on) to ensure default execution affinity is used.

5) Step 5: Confirm that the queuing call uses the default behavior (no CPU argument) and is not overridden by any local CPU-selection logic in the visible scope. The signal is the direct use of the above default queue APIs with the bound workqueue handle.

6) Step 6: Correlate that the same workqueue handle was created without WQ_UNBOUND and is subsequently used by default queue APIs. This conjunction indicates bound semantics plus default CPU-inheritance, which the root cause identifies as vulnerable to starvation.

7) Step 7: Elevate priority if the workqueue name string or variable names indicate critical driver functions (e.g., strings containing “init”, “service”, “mbx”, “stats”, “vc_event”), matching the affected tasks in the materials. This mirrors the documented impact areas (service routines, mailbox, statistics, virtchnl events).

8) Step 8: Note the absence of WQ_MEM_RECLAIM in the flags as an additional resilience gap; mark such findings as stronger when occurring in probe/init code or for control-plane tasks. This reflects the patch’s addition of WQ_MEM_RECLAIM to ensure forward progress under pressure.

9) Step 9: Report an issue when Steps 1, 4, and 6 are true: a workqueue created without WQ_UNBOUND and used with default, non-CPU-specific queuing. Summarize the risk as potential DoS via CPU-bound worker starvation per the root cause analysis.

3. Limitations & Assumptions
- Static analysis cannot determine runtime CPU load or actual starvation; the checker infers risk from scheduling semantics only.
- The plan assumes alloc_workqueue flags are statically visible; macros or indirect flag composition may obscure WQ_UNBOUND/WQ_MEM_RECLAIM presence.
- CPU selection outside the immediate call context (e.g., via indirect APIs or scheduler configuration) may not be detectable.
- Severity heuristics based on name strings (e.g., “service”, “mbx”, “stats”, “vc_event”) are best-effort and may miss other critical paths or produce false positives.