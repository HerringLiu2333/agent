1. Plan Summary
Detect driver workqueues created without WQ_UNBOUND that host delayed, progress-critical tasks (init/service/mailbox/stats/event), making them vulnerable to CPU-bound kworker starvation (DoS).

2. Detection Steps
1) Step 1: Identify calls to alloc_workqueue and capture the name format string, flags argument, and target variable receiving the workqueue. Signals: function call to alloc_workqueue with four arguments; assignment to fields like adapter->init_wq, adapter->serv_wq, adapter->mbx_wq, adapter->stats_wq, adapter->vc_event_wq.

2) Step 2: Determine whether the flags argument is CPU-bound (i.e., literal 0 or an expression that does not include WQ_UNBOUND). Signals: flags equal to 0 or bitwise-or list lacking WQ_UNBOUND.

3) Step 3: Prioritize workqueues whose format string or target variable name denotes critical driver roles. Signals: name substrings in the format string or variable identifiers matching “init”, “service”, “mbx”, “stats”, “vc_event”.

4) Step 4: Check if the workqueue is used for delayed work items. Signals: presence of INIT_DELAYED_WORK for tasks like init_task, serv_task, mbx_task, stats_task, vc_event_task and subsequent queueing with queue_delayed_work or mod_delayed_work using the same workqueue variable.

5) Step 5: Verify the allocation occurs in device probe/initialization paths to confirm long-lived, core driver workqueues. Signals: alloc_workqueue calls inside functions like idpf_probe or other probe-like init routines referenced by a pci_driver structure.

6) Step 6: Confirm the workqueue is stored in a driver/adapter struct and destroyed on driver removal, indicating global, lifespan-wide use. Signals: assignment to adapter->... fields and matching destroy_workqueue calls in teardown (e.g., idpf_remove).

7) Step 7: Check for queuing APIs that imply CPU affinity or default CPU binding. Signals: usage of queue_delayed_work (default CPU) or queue_delayed_work_on (explicit CPU); treat either as risky when flags lack WQ_UNBOUND.

8) Step 8: Assess whether WQ_MEM_RECLAIM is also absent to identify weaker progress guarantees under pressure. Signals: flags not including WQ_MEM_RECLAIM, especially for the critical roles identified in Step 3.

9) Step 9: Report a finding when all of the following hold: alloc_workqueue without WQ_UNBOUND, used for delayed work items (Step 4), and represents a critical, long-lived driver workqueue allocated in probe and torn down in remove (Steps 5–6). Include the allocation site, flags summary, work items queued on it, and naming evidence.

3. Limitations & Assumptions
- Mapping name patterns (“init”, “service”, “mbx”, “stats”, “vc_event”) to “progress-critical” is heuristic; some drivers may use different naming.
- The checker cannot infer runtime CPU contention or actual starvation; it flags risky configurations based on static usage.
- Determining whether WQ_MEM_RECLAIM is required beyond WQ_UNBOUND is context-dependent; the plan treats its absence as a secondary signal per the patch.
- Scope is derived from the provided IDPF driver; generalization to other subsystems may require broader path/context filters not present here.