1. Plan Summary
Detect kernel drivers that allocate progress-critical workqueues without WQ_UNBOUND (and optionally without WQ_MEM_RECLAIM), leading to potential CPU-bound kworker starvation and DoS, as seen in pre-patch IDPF.

2. Detection Steps
1) Step 1: Objective: Find workqueue allocations that are CPU-bound. Signals: Call sites of alloc_workqueue where the flags argument is 0 or lacks the WQ_UNBOUND bit (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS], pre-patch used 0). FP mitigation: Exclude calls where flags include WQ_UNBOUND.

2) Step 2: Objective: Identify long-lived driver workqueues. Signals: The alloc_workqueue result is stored in a device/adapter struct field (e.g., adapter->init_wq/serv_wq/mbx_wq/stats_wq/vc_event_wq in [FILE_CONTENT]) and created in a probe/initialization routine (e.g., idpf_probe in [FILE_CONTENT]). FP mitigation: Require that the same field is destroyed via destroy_workqueue in a remove/shutdown path (e.g., idpf_remove in [FILE_CONTENT]).

3) Step 3: Objective: Confirm these queues service critical driver tasks prone to DoS impact. Signals: Associated work items are enqueued via queue_delayed_work, mod_delayed_work, or queue_work using the same workqueue variable (e.g., queue_delayed_work(adapter->vc_event_wq, ...) in [FILE_CONTENT]); names or functions tied to init, service, mailbox, stats, or virtchnl events (from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Prioritize queues whose names or associated work item symbols include “init”, “service”, “mbx”, “stats”, “vc_event” as in [PATCH_DIFF]/[FILE_CONTENT].

4) Step 4: Objective: Correlate INIT_DELAYED_WORK with the queued tasks to establish criticality. Signals: Look for INIT_DELAYED_WORK initializations for tasks later queued on the identified workqueues (e.g., INIT_DELAYED_WORK(&adapter->vc_event_task, ...) then queued on adapter->vc_event_wq in [FILE_CONTENT]). FP mitigation: Require at least one such INIT_DELAYED_WORK-to-queue linkage to avoid flagging unused or test-only workqueues.

5) Step 5: Objective: Detect absence of WQ_MEM_RECLAIM on critical queues. Signals: For the queues identified in steps 2–4, check if flags lack WQ_MEM_RECLAIM (patch adds WQ_MEM_RECLAIM in [PATCH_DIFF], rationale in [ROOTCAUSE_ANALYSIS]). FP mitigation: Only flag missing WQ_MEM_RECLAIM when the queue services init/control paths (init/service/mbx/vc_event/stats) to avoid over-reporting non-critical queues.

6) Step 6: Objective: Increase confidence of starvation risk by recognizing CPU pinning. Signals: Identify queue_delayed_work_on/queue_work_on uses or calls that otherwise imply CPU-specific execution, which exacerbate starvation when flags lack WQ_UNBOUND (test scenario in [PATCH_DESCRIPTION]). FP mitigation: Treat this as a risk amplifier and not a sole trigger; only report when combined with Step 1 conditions.

7) Step 7: Objective: Confirm default CPU-bound behavior under typical usage. Signals: Calls to queue_delayed_work/queue_work without specifying CPU on a bound workqueue (flags without WQ_UNBOUND), consistent with [PATCH_DESCRIPTION] noting default configuration runs on CPU-local per-cpu kworkers. FP mitigation: Ensure the queue is long-lived and used in probe/control paths (Steps 2–4).

8) Step 8: Objective: Exclude obviously non-critical utility queues. Signals: Workqueues not tied to device lifecycle (not created in probe nor destroyed in remove) or used only in debug/test code. FP mitigation: Require the probe/remove lifecycle linkage or critical-name heuristic before reporting.

9) Step 9: Objective: Aggregate and report only when multiple risk indicators align. Signals: Combine (a) bound workqueue flags, (b) lifecycle linkage (probe/remove), and (c) critical usage (init/service/mbx/stats/vc_event enqueues). FP mitigation: Suppress findings lacking at least (a) + (b) + (c).

3. Target Elements
- Function call sites: alloc_workqueue; queue_delayed_work, mod_delayed_work, queue_work; queue_delayed_work_on/queue_work_on.
- Struct field assignments: storing workqueue pointers (e.g., adapter->..._wq).
- INIT_DELAYED_WORK initializations and their target functions.
- Probe/initialization functions (e.g., idpf_probe) and remove/shutdown (e.g., idpf_remove/idpf_shutdown).
- Flags expressions at workqueue allocation (bitwise combinations).

4. Dataflow / Taint Considerations
- Track the workqueue pointer from alloc_workqueue through assignments into struct fields and uses in enqueue calls.
- Relate INIT_DELAYED_WORK work items to the specific workqueue they are enqueued on.
- Propagate through member accesses (adapter->wq) and function arguments to match allocation sites with enqueue sites.

5. Validation & Test Cases
- Positive: Pre-patch IDPF (from [FILE_CONTENT]): alloc_workqueue with flags=0 for init_wq/serv_wq/mbx_wq/stats_wq/vc_event_wq; these are queued via queue_delayed_work (e.g., vc_event_wq) and destroyed in idpf_remove — should be reported.
- Negative: Post-patch IDPF (from [PATCH_DIFF]): same queues allocated with WQ_UNBOUND | WQ_MEM_RECLAIM — should not be reported.
- Test harness notes: Include variations where flags are symbolic expressions; include cases with queue_work_on to verify risk amplification; verify lifecycle linkage by matching create in probe and destroy in remove.

6. Estimated Effort & Priority
High: Requires cross-function dataflow (alloc → struct field → enqueue) and semantic heuristics for criticality.

7. Likely False-Positive Sources & Mitigations
- Queues intentionally CPU-bound for locality but not progress-critical; mitigate via lifecycle linkage and critical-name/usage heuristic.
- Non-driver or short-lived queues; mitigate by requiring probe/remove linkage.
- Symbolic flags where WQ_UNBOUND is conditionally included; mitigate by conservative analysis and flag only when WQ_UNBOUND is provably absent.

8. Limitations & Assumptions
- Criticality is inferred heuristically from names/contexts (init/service/mbx/stats/vc_event) as evidenced in [PATCH_DIFF]/[FILE_CONTENT]/[ROOTCAUSE_ANALYSIS]; true runtime criticality cannot be fully deduced statically.
- The checker assumes Linux kernel-style driver patterns (probe/remove lifecycle) as in [FILE_CONTENT]; other subsystems may diverge.
- Cannot statically determine scheduling contention or actual CPU hogging; detection is based on configuration (bound vs unbound) per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].