1. Plan Summary
Detect kernel driver code that creates per-CPU bound workqueues by calling alloc_workqueue without WQ_UNBOUND (and optionally without WQ_MEM_RECLAIM), which can cause worker starvation and DoS under CPU contention as seen in the IDPF driver.

2. Detection Steps
1) Step 1: Identify workqueue creations — find calls to alloc_workqueue (or its visible macro front) and collect the second argument (flags) and the returned workqueue value.
2) Step 2: Evaluate flags — determine whether the flags argument is a constant/compile-time bitmask that does not include WQ_UNBOUND, or is explicitly 0; mark such calls as candidates.
3) Step 3: Prioritize reclaim-safety — for candidates, also check whether WQ_MEM_RECLAIM is absent in the same flags; record this to highlight additional risk during memory pressure.
4) Step 4: Scope to driver contexts — prioritize calls located in kernel driver code paths (e.g., under drivers/net/ethernet/intel/idpf or similar drivers), or inside probe/initialization functions (function names containing “probe” as in idpf_probe) to mirror the affected initialization path.
5) Step 5: Track assignment targets — check if the alloc_workqueue result is assigned into driver state fields (e.g., struct members like adapter->init_wq, adapter->serv_wq, adapter->mbx_wq, adapter->stats_wq, adapter->vc_event_wq); elevate confidence when stored in persistent driver structures.
6) Step 6: Correlate with queue usage — locate subsequent uses of the created workqueue in calls like queue_delayed_work or mod_delayed_work that use the default scheduling (no explicit CPU argument); this indicates reliance on kworkers tied to the originating CPU.
7) Step 7: Name-based heuristics — when the workqueue name literal suggests driver service tasks (substrings like “-init”, “-service”, “-mbx”, “-stats”, “-vc_event”), raise the priority as these match the vulnerable cases.
8) Step 8: Report finding — for each candidate, report location of alloc_workqueue, the exact flags expression, whether WQ_UNBOUND and WQ_MEM_RECLAIM are absent, and any linked queue usage sites that confirm active reliance on the workqueue.

3. Limitations & Assumptions
- The checker cannot infer runtime CPU contention or whether per-CPU binding is an intentional optimization; some flagged instances may be acceptable by design.
- It assumes flags are determinable at compile time; flags built via opaque variables, config-dependent macros, or inline wrappers may evade precise evaluation.
- It does not verify NUMA-node behavior or prove downstream timeouts/crashes; it only flags the risky workqueue configuration (lack of WQ_UNBOUND and optionally WQ_MEM_RECLAIM).
- Scoping to drivers and probe-like functions reduces false positives but may miss vulnerable workqueue creations elsewhere.