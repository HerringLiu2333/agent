1. Plan Summary
Detect kernel drivers that create bound workqueues for latency/critical tasks and then queue work without specifying a CPU, making them susceptible to CPU-local starvation; recommend WQ_UNBOUND (and ideally WQ_MEM_RECLAIM).

2. Detection Steps
1) Step 1: Objective: find workqueue allocations. Signals: calls to alloc_workqueue and collect the flags argument and result variable; this maps to the creation site per [FUNCTION_CONTENT] and [PATCH_DIFF]. FP mitigation: ignore non-kernel contexts and non-alloc_workqueue APIs.
2) Step 2: Objective: identify bound workqueues. Signals: flags that are literal zero or flag expressions that do not include WQ_UNBOUND, matching pre-patch “0, 0” usage in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: if flags are not statically known, conservatively skip unless a clear absence of WQ_UNBOUND is evident.
3) Step 3: Objective: trace the allocated workqueue to its uses. Signals: dataflow from the alloc_workqueue return value into fields (e.g., adapter->init_wq/serv_wq/mbx_wq/stats_wq/vc_event_wq) and locals; this aligns with [FUNCTION_CONTENT] where fields store the pointers. FP mitigation: require at least one observed downstream scheduling use to consider the site relevant.
4) Step 4: Objective: detect default-CPU queuing that inherits enqueue CPU. Signals: calls to queue_delayed_work, mod_delayed_work, queue_work, or similar “default” variants that take a workqueue but do not specify a CPU, as described in [ROOTCAUSE_ANALYSIS] and shown in [FUNCTION_CONTENT] (queue_delayed_work on adapter->vc_event_wq). FP mitigation: exclude CPU-explicit variants (e.g., *_on) to stay aligned with the documented trigger (default configuration).
5) Step 5: Objective: correlate a bound workqueue with default-CPU queuing. Signals: pair the workqueue variable from Step 2/3 with the callee argument in Step 4; this indicates tasks will run on the enqueue CPU and risk starvation per [ROOTCAUSE_ANALYSIS]. FP mitigation: require at least one queuing call per workqueue to avoid speculative flags.
6) Step 6: Objective: prioritize likely critical/latency-sensitive queues. Signals: string literals used as the workqueue name contain suffixes like “-init”, “-service”, “-mbx”, “-stats”, “-vc_event” (as in [PATCH_DIFF]) or associated work items named similarly (INIT_DELAYED_WORK for idpf_* tasks per [FUNCTION_CONTENT]). FP mitigation: elevate severity only when such naming or task initialization patterns are present; otherwise report as lower priority.
7) Step 7: Objective: increase confidence by checking driver initialization context. Signals: allocation occurs in functions named like probe (e.g., idpf_probe) or in driver setup paths under drivers/net/…, consistent with [ROOTCAUSE_ANALYSIS] and [FUNCTION_CONTENT]. FP mitigation: if outside driver init/probe context, reduce severity.
8) Step 8: Objective: detect absence of WQ_MEM_RECLAIM as risk amplifier. Signals: flags missing WQ_MEM_RECLAIM in addition to missing WQ_UNBOUND, recognizing the patch added WQ_MEM_RECLAIM per [PATCH_DIFF] and its rationale in [ROOTCAUSE_ANALYSIS]. FP mitigation: do not flag solely on missing WQ_MEM_RECLAIM; only augment findings already missing WQ_UNBOUND.
9) Step 9: Objective: confirm presence of delayed or periodic work items tied to the queue. Signals: INIT_DELAYED_WORK initializing tasks enqueued to the identified workqueue (idpf_init_task, idpf_service_task, idpf_mbx_task, idpf_statistics_task, idpf_vc_event_task in [FUNCTION_CONTENT]). FP mitigation: if no delayed/periodic work is found, lower confidence but still consider if default queueing exists.
10) Step 10: Objective: produce the final finding when conditions match the root cause. Signals: bound workqueue (no WQ_UNBOUND) + default-CPU queuing of work items + driver/control-plane context; maps directly to the starvation scenario in [ROOTCAUSE_ANALYSIS]. FP mitigation: suppress if the workqueue is documented to require CPU locality via other flags not covered here (not determinable; see Limitations), or if no queueing calls are found.

3. Target Elements
- Function call sites to alloc_workqueue.
- Arguments of alloc_workqueue (flags, name).
- Variables/fields receiving the workqueue pointer (e.g., adapter->*_wq).
- Calls to queue_delayed_work, mod_delayed_work, queue_work and their CPU-explicit variants.
- INIT_DELAYED_WORK initializations of work items associated with the workqueue.
- Function boundaries for probe/init routines (e.g., *probe) and file paths under drivers/net/... .

4. Dataflow / Taint Considerations
- Track value flow from alloc_workqueue return to struct fields and local variables.
- Track the same workqueue value into scheduling calls as the queue argument.
- Optionally relate work items initialized via INIT_DELAYED_WORK to the workqueue they are queued on via call-graph/dataflow context.

5. Validation & Test Cases
- Positive: Pre-patch idpf_main.c where adapter->init_wq/serv_wq/mbx_wq/stats_wq/vc_event_wq are created with flags 0 and later used in queue_delayed_work without CPU selection (as in [FUNCTION_CONTENT]); expect findings with high severity and note missing WQ_UNBOUND and WQ_MEM_RECLAIM.
- Negative: Patched version in [PATCH_DIFF] where all alloc_workqueue calls use WQ_UNBOUND | WQ_MEM_RECLAIM; expect no findings.
- Test harness notes: Include cases where alloc_workqueue flags are computed via macros/expressions to ensure the checker can still determine absence/presence of WQ_UNBOUND; include a case where only CPU-explicit queuing APIs are used to ensure suppression.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Intentionally bound per-CPU workqueues designed for locality: mitigate by prioritizing probe/init context and control-plane naming patterns.
- Flags hidden behind macros or platform conditionals: mitigate by requiring clear absence of WQ_UNBOUND or marking uncertain cases as lower confidence.
- Workqueues never used for default-CPU queuing: mitigate by requiring observed queueing calls before reporting.
- Subsystems where starvation is acceptable or non-critical: mitigate via path and naming heuristics (drivers/net and control-plane task names).

8. Limitations & Assumptions
- Cannot prove at compile time that CPU starvation will occur; we infer risk from semantics described in [ROOTCAUSE_ANALYSIS].
- Cannot determine subsystem-specific requirements for bound vs unbound queues; we assume control-plane/latency-sensitive queues should be unbound based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].
- Detection of WQ_UNBOUND presence may be impeded by complex macro expansions not visible to the analyzer.
- The checker focuses on default-CPU queuing; cases using CPU-explicit queuing may still be vulnerable but are out of scope per the described trigger.