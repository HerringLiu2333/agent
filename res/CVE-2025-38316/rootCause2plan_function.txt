1. Plan Summary
Detect functions that dereference a pointer parameter before performing an in-function NULL sanity check on that parameter, mirroring the pre-patch flaw in mt7996_set_monitor.

2. Detection Steps
1) Step 1: Objective — find candidate functions with pointer parameters; Signals — function definitions where a parameter has a pointer type (e.g., struct mt7996_phy *phy in [FUNCTION_CONTENT]); FP mitigation — only consider parameters that are actually used in the function body.

2) Step 2: Objective — confirm the function treats the pointer as potentially NULL; Signals — presence of an explicit NULL sanity check on the parameter (e.g., if (!phy) return) as in [FUNCTION_CONTENT]/[PATCH_DIFF]; FP mitigation — require the check leads to an early exit (return) or equivalent termination of the current path.

3) Step 3: Objective — locate unsafe dereferences before the NULL check; Signals — any field/member access or dereference of the parameter (e.g., phy->dev) occurring along a path from function entry prior to the NULL check block, as seen pre-patch in [FUNCTION_CONTENT]; FP mitigation — ensure reachability from entry without prior guarding conditions.

4) Step 4: Objective — emphasize variable-initialization patterns that dereference the pointer; Signals — local variable declaration initialized from the parameter dereference (e.g., struct mt7996_dev *dev = phy->dev in [FUNCTION_CONTENT]); FP mitigation — require that the initialized variable is subsequently used, preventing flags on unused initializations.

5) Step 5: Objective — assess control-flow dominance of the NULL check; Signals — confirm the NULL check does not dominate the earlier dereference (i.e., dereference precedes it on at least one path); Why — maps to the order-of-operations bug described in [ROOTCAUSE_ANALYSIS]; FP mitigation — exclude dereferences that are syntactically inside earlier checks guaranteeing non-NULL.

6) Step 6: Objective — verify that the function continues to use the parameter or derived objects after the NULL check; Signals — later dereferences or calls using the parameter or variables derived from it (e.g., dev used in mt76_rmw_field after the check in [FUNCTION_CONTENT]); FP mitigation — require at least one post-check dereference or use to confirm the check’s guarding intent.

7) Step 7: Objective — avoid cases where the NULL check is unrelated; Signals — tie the check to the same parameter being dereferenced (e.g., check is on phy and dereference is phy->...); FP mitigation — exclude checks on different variables or aliases unless aliasing to the parameter is evident in the same function body.

8) Step 8: Objective — highlight early, unconditional dereferences; Signals — dereferences in top-level statements near function entry (e.g., at declaration) that execute prior to any conditional, as in [PATCH_DIFF] pre-patch; FP mitigation — exclude dereferences occurring only in branches guarded by a non-NULL test.

9) Step 9: Objective — detect similar patterns during assignments after declaration; Signals — assignments like dev = p->field before the NULL check, matching the patched relocation in [PATCH_DIFF]; FP mitigation — require assignment to be reachable from entry without prior guard.

10) Step 10: Objective — aggregate findings per function; Signals — report when a pointer parameter has at least one pre-check dereference and a later NULL check; Why — directly maps to the root cause in [ROOTCAUSE_ANALYSIS]; FP mitigation — require both conditions to be met and de-duplicate multiple dereferences per parameter.

3. Target Elements
- Function definitions with pointer parameters.
- In-function NULL checks on those parameters that exit early (return).
- Member access or pointer dereference expressions of the parameter.
- Local variable declarations/assignments initialized from parameter dereferences.
- Subsequent uses of the parameter or derived variables (calls or field accesses) after the NULL check.

4. Dataflow / Taint Considerations
- Track flow from the pointer parameter to any dereference (p->field, *p) occurring before a guarding NULL check.
- Track derived locals initialized from the parameter (e.g., dev from phy->dev) and confirm later use to indicate the dereference was semantically significant.
- Use simple control-flow reachability from entry to dereference without passing through a dominating non-NULL guard.

5. Validation & Test Cases
- Positive: A function like mt7996_set_monitor with “struct mt7996_dev *dev = phy->dev;” at entry and “if (!phy) return;” afterwards; expect a finding (based on [FUNCTION_CONTENT]/pre-patch and [ROOTCAUSE_ANALYSIS]).
- Negative: The patched version where dev is declared uninitialized, the function checks “if (!phy) return;” first, then assigns “dev = phy->dev;”; expect no finding (based on [PATCH_DIFF]).
- Test harness notes: Include variants with dereference in assignment and in function calls before the check, and ensure control-flow reachability analysis handles straight-line and simple conditional blocks.

6. Estimated Effort & Priority
Medium — the pattern is common and impactful (kernel DoS per [ROOTCAUSE_ANALYSIS]), but requires control-flow and basic dataflow to avoid noise.

7. Likely False-Positive Sources & Mitigations
- Functions where the pointer parameter is guaranteed non-NULL by contract but still contain redundant NULL checks; mitigate by requiring presence of a post-check dereference/use to infer guarding intent.
- Alias confusion where the check is on an alias not recognized; mitigate by restricting to direct parameter checks unless simple assignment aliasing is present.
- Complex macro/wrapper-based checks not recognized as early exits; mitigate by focusing on explicit returns in the same function, acknowledging reduced coverage rather than over-reporting.

8. Limitations & Assumptions
- The precise call paths that can pass NULL are unknown (per [ROOTCAUSE_ANALYSIS]), so the checker infers risk from in-function checks rather than interprocedural guarantees.
- Attributes or contracts declaring parameters non-NULL are not provided; the checker assumes that the presence of an in-function NULL check indicates potential NULL.
- Concurrency/locking context is out of scope (per [ROOTCAUSE_ANALYSIS] no change); the checker does not account for thread-safety or races.