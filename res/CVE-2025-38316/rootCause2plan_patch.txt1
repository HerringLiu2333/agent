1. Plan Summary
Detect function parameters that are dereferenced before a subsequent NULL check on the same parameter, i.e., check-after-dereference ordering that can lead to a NULL pointer dereference.

2. Detection Steps
1) Step 1: Identify candidate pointers — find functions with at least one pointer-typed parameter P used within the function body.
2) Step 2: Find late NULL checks — within the same function, locate conditionals that test P for nullness (e.g., negation or comparison to NULL) followed by an immediate safe exit (e.g., return) or equivalent early-out.
3) Step 3: Collect dereferences of P — within the function, record expressions that dereference P (e.g., member access via "->", unary dereference "*P", or array indexing "P[...]" that implies dereference).
4) Step 4: Order analysis — for each dereference D of P, determine if there exists a control-flow path from the function entry to D that does not pass through any dominating NULL-check of P found in Step 2.
5) Step 5: Path feasibility — confirm that the late NULL check is reachable after D along some path, ensuring that the check is indeed “after” the dereference in at least one feasible path.
6) Step 6: Exclude guarded dereferences — do not flag dereferences that are strictly nested under an earlier condition that ensures P is non-NULL on all paths to D (e.g., D occurs only in the true branch of an if(P) where that check dominates D).
7) Step 7: Highlight initializer cases — give priority to dereferences that occur in variable initializers at declaration (e.g., local = P->field) before any NULL check in the function’s first basic blocks.
8) Step 8: Report with context — for each finding, report the earliest dereference location D of P and the later NULL-check site C in the same function, indicating that C occurs after D and thus the NULL check is too late.
9) Step 9: Severity heuristic — elevate severity when the late NULL check is an immediate return (or early exit), since this strongly indicates the author anticipated P could be NULL and intended a guard before use.

3. Limitations & Assumptions
- Assumes pointer parameters can be NULL unless proven otherwise; absence of annotations/contracts may cause false positives if P is guaranteed non-NULL by convention.
- Only reliably matches explicit NULL checks; checks hidden in macros, helper functions, or non-standard idioms may be missed.
- Does not fully model complex aliasing; dereferences via aliases of P may be missed unless trivially identifiable.
- Does not reason about interprocedural guarantees (e.g., callers or wrappers ensuring non-NULL) or concurrency effects; analysis is intra-procedural.
- Treats “->”, “*P”, and “P[index]” as dereferences; other implicit memory accesses via library calls are not considered.