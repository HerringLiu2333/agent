1. Plan Summary
Detect cases where a function dereferences a pointer parameter before validating it against NULL, focusing on the exact misordering shown in mt7996_set_monitor: a dereference (e.g., p->field) occurring prior to an if (!p) return; guard.

2. Detection Steps
1) Step 1: Objective — Identify candidate pointer parameters. Signals — Functions with at least one pointer-typed parameter (e.g., struct ptr*), as in mt7996_set_monitor(struct mt7996_phy *phy) from [PATCH_DIFF]. FP mitigation — Exclude non-pointer parameters.

2) Step 2: Objective — Find dereferences of the parameter that can fault if NULL. Signals — Direct uses of “->”, unary “*”, or array indexing on the parameter (e.g., phy->dev), including within initializers/assignments (as in dev = phy->dev from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation — Model short-circuit contexts to avoid flagging safe uses like (p && p->f).

3) Step 3: Objective — Locate NULL checks for the same parameter. Signals — Conditionals testing the parameter against NULL or negation (if (!p), if (p == NULL), if (!phy) return) as described in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation — Require the check to gate an early-return or error path (e.g., immediate return) to reflect the intended guard pattern.

4) Step 4: Objective — Establish ordering: dereference occurs before the NULL check on some path. Signals — In the control-flow graph, a dereference node that dominates or is reachable prior to the first NULL-check node for the same parameter (i.e., deref-before-check). FP mitigation — Ensure path feasibility (no guarding prior checks or assertions dominate the deref).

5) Step 5: Objective — Confirm the dereference is not itself guarded by a prior equivalent check. Signals — Verify no earlier dominating condition ensures the pointer is non-NULL (e.g., an if (p == NULL) return; that precedes the deref). FP mitigation — Respect dominance; do not report if any dominating check guarantees non-NULL.

6) Step 6: Objective — Handle intra-statement short-circuit semantics correctly. Signals — For expressions like p && p->f, p is evaluated for truthiness before dereferencing; treat deref as guarded. FP mitigation — Model short-circuit operators (&&, ||) and ternary operators to avoid false alarms.

7) Step 7: Objective — Prioritize the specific misordering pattern fixed in the patch. Signals — A variable initialization or assignment draws from param->field at function top or early basic blocks, followed by an if (!param) return; as in dev = phy->dev preceding if (!phy) return; ([PATCH_DIFF]). FP mitigation — Rank these higher; optionally report only if a subsequent NULL-check on the same pointer exists (reduces noise per [ROOTCAUSE_ANALYSIS] “incorrect ordering of the NULL check”).

8) Step 8: Objective — Reduce noise from non-crashing dereferences. Signals — Exclude address-of (&p->f) without actual deref, and uses in sizeof/offsetof where no runtime dereference occurs. FP mitigation — Limit to runtime-read/write dereferences.

9) Step 9: Objective — Exclude cases proven non-NULL by annotations or earlier invariants (if available). Signals — Recognize explicit non-NULL assertions or kernel macros analogous to BUG_ON(!p) that dominate. FP mitigation — Do not alert if any dominating fatal/assertive check guarantees non-NULL on all paths.

10) Step 10: Objective — Report only when the dereference is reachable with param possibly NULL. Signals — Dataflow reasoning that parameter’s value at function entry can be NULL (absence of preconditions) and the deref is on an entry-reachable path before the first NULL-check. FP mitigation — Ignore paths post-NULL check that are dead when NULL.

3. Target Elements
- Functions and their pointer-typed parameters.
- Member-access, pointer dereference, and array-index expressions using the parameter.
- If-statements testing the parameter against NULL (negation or equality).
- Early returns/guard patterns immediately following NULL checks.
- Variable initializations/assignments that dereference the parameter (e.g., p->field on RHS).
- Control-flow structure (dominance/reachability) within the function.

4. Dataflow / Taint Considerations
- Track the parameter value from function entry to dereference sites to establish path order relative to NULL checks.
- Model control dependencies: a dereference is safe if dominated by a non-NULL check on the same parameter.
- Respect short-circuit evaluation to treat p && p->f as guarded.
- Conservative aliasing: focus on direct dereferences of the parameter variable itself (as in phy->dev) to match [PATCH_DIFF]; optional extensions to handle trivial aliases can be deferred.

5. Validation & Test Cases
- Positive: A function with pointer parameter p that performs x = p->f; before an if (!p) return; later (mirrors [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]); expect a report.
- Positive: A function that does *p = 1; and only later checks if (p == NULL) return; expect a report.
- Negative: A function that checks if (!p) return; before any p->f; expect no report.
- Negative: A condition like if (p && p->f == 0) { ... } with no prior p deref; expect no report.
- Test harness notes: Include paths with multiple conditionals, early returns, and initializers at declaration; validate dominance and short-circuit modeling.

6. Estimated Effort & Priority
Medium effort; High priority due to kernel crash/DoS risk demonstrated in [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Complex macro expansions obscuring checks; mitigate by expanding CFG across macros where possible.
- Implicit non-NULL contracts not modeled; mitigate by requiring presence of a later in-function NULL check to prioritize likely bugs.
- Unreachable deref paths due to prior conditions; mitigate with path feasibility and dominance analysis.
- Contexts without runtime dereference (sizeof/offsetof); mitigate by filtering non-evaluated operands.

8. Limitations & Assumptions
- Assumes no external contracts guarantee non-NULL; the checker cannot infer driver-specific invariants from outside the function.
- Aliasing beyond direct parameter dereferences is not fully addressed to stay aligned with the concrete case in [PATCH_DIFF].
- The plan relies on accurate modeling of short-circuit semantics and CFG dominance; mis-modeling could affect precision.