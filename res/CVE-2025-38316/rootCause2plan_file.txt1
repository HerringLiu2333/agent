1. Plan Summary
Detect cases where a function dereferences a pointer parameter (or its trivial alias) before performing a later null check/early-exit on that same pointer, as in the pre-patch mt7996_set_monitor() bug.

2. Detection Steps
1) Step 1: Identify candidate pointers — function parameters (and locals initialized from parameters) of pointer type that are referenced in a null-check condition within the same function. Signals: conditions like “if (!p) …” or “if (p == NULL) …” tied to an early-exit (return/goto out/err) for that pointer p.

2) Step 2: Locate null-guard constructs for each candidate pointer p that terminate execution on the null branch. Signals: conditional tests of p against null whose true branch leads to return, or goto to a label that quickly returns/exits the function.

3) Step 3: Collect explicit dereference uses of p (and its trivial aliases) anywhere in the function. Signals: member access via “p->field”, unary “*p”, or pointer indexing “p[i]”; include dereferences inside variable initializers (e.g., “type *d = p->dev;”).

4) Step 4: Build intra-procedural control flow for the function and determine reachability from function entry to each dereference site. Signals: there exists a path from entry to the dereference without first passing through a non-null establishing branch for p.

5) Step 5: Determine whether a dereference site is protected by a non-null condition for p. Signals: the dereference is control-dependent on “p != NULL” (e.g., inside an else branch of “if (!p) return;” or inside an “if (p)” guarded block) or post-dominated by an early-return guard that kills the null path.

6) Step 6: For each dereference that is not proven protected (Step 5), check whether there exists at least one null-guard (Step 2) for the same pointer p elsewhere in the function. Signals: presence of a later null check implies the developer expected p could be NULL.

7) Step 7: Flag as a finding any dereference of p that is reachable before any effective null-guard for p and is not control-dependent on “p != NULL”. Signals: dereference occurs in a block that may be executed with p == NULL, with a separate null-guard occurring later (the pre-patch pattern “struct dev *d = p->dev; … if (!p) return;”).

8) Step 8: Include trivial-alias tracking for p when evaluating dereferences. Signals: local variables assigned directly from p (e.g., “q = p;”) and not reassigned before dereference are treated as equivalent to p at dereference sites.

9) Step 9: Prioritize and annotate high-confidence instances matching the specific pattern in the root cause. Signals: variable declaration or assignment that directly reads “p->field” before the null-guard (exactly as in mt7996_set_monitor with “dev = phy->dev;” preceding “if (!phy) return;”).

10) Step 10: Reduce false positives by excluding dereferences proven dominated by a guard that eliminates the null path. Signals: dominance/path-sensitive reasoning that all paths to the dereference must pass through a guard where the null branch returns/exits (e.g., code after “if (!p) return;” on the fall-through path).

11) Step 11: Optionally, detect additional pre-guard uses of p that imply dereference through member access in conditions/expressions (e.g., “enabled == !(p->rxfilter & …)”) prior to a null-guard, and report similarly. Signals: any “p->…” read before the guard.

12) Step 12: For each finding, report the dereference location and the corresponding null-guard location to aid remediation (move dereference after the guard). Signals: pair the earliest unsafe dereference with the nearest subsequent null-guard for p.

3. Limitations & Assumptions
- Only explicit dereferences are considered (->, *p, p[i]); calls that may dereference p internally are not modeled.
- Aliasing is limited to trivial direct assignments; complex aliasing, pointer arithmetic, or interprocedural flows are not handled.
- Null-guards recognized are simple, local conditions with immediate return/goto-exit; complex guard macros, assertions, or nonlocal effects may be missed.
- The checker assumes that the presence of a null-guard indicates p can be NULL; in code relying on external preconditions, this may yield false positives.
- Macro expansion and inline assembly nuances are not fully modeled; some dereferences inside macros may be missed or misattributed.