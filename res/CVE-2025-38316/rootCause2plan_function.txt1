1. Plan Summary
Detect functions where a pointer parameter is dereferenced before an explicit in-function NULL check of that parameter, as exemplified by mt7996_set_monitor dereferencing phy prior to if (!phy) return.

2. Detection Steps
1) Step 1: Identify candidate functions that have at least one pointer parameter and contain an explicit NULL check of that same parameter. Signals: an if condition testing "!param" or "param == NULL" that leads to an early exit (return, goto, or equivalent).
2) Step 2: Within those functions, locate all uses that dereference the parameter. Signals: member access "param->field", unary "*param", array indexing "param[index]", or nested dereferences "param->a->b".
3) Step 3: For each dereference, determine if it appears on a control-flow path reachable from function entry before any NULL check of that parameter that would guard it. Signals: dereference occurs in a basic block not dominated by a block containing a NULL-check of the parameter.
4) Step 4: Specifically flag dereferences that initialize local variables at declaration time near the function start. Signals: local variable declaration with initializer "param->..." preceding the NULL check (e.g., "struct X *dev = param->dev;").
5) Step 5: Exclude dereferences that occur strictly after a guarding NULL check of the parameter on all paths leading to the dereference. Signals: the check dominates the dereference; dereference resides in blocks post-guard where the then-path returns or ensures non-null.
6) Step 6: Exclude dereferences in the guarded branch where the code immediately returns or otherwise exits upon detecting NULL. Signals: dereference inside the else branch when the guard is "!param", or after a return taken on NULL.
7) Step 7: Treat dereferences before the first observed NULL check as unsafe when the function also contains a later explicit NULL check of the same parameter. Signals: presence of any later "!param" or "param == NULL" check is evidence the parameter may be NULL and should be validated first.
8) Step 8: Report each unsafe site with context: function name, parameter name, dereference expression location, and the location of the later NULL check to indicate the intended validation order.

3. Limitations & Assumptions
- Assumes that the presence of an explicit in-function NULL check implies the parameter may be NULL; the checker cannot determine external invariants guaranteeing non-null at call sites.
- Intraprocedural focus: does not account for interprocedural contracts, annotations, or macros that may imply non-null.
- May miss dereferences hidden inside macros or inlined constructs if not modeled as dereference operations by the analysis.
- Does not reason about alternative “assert” mechanisms or kernel-specific predicates; only explicit "!param" or "param == NULL" checks are considered.
- The precise call paths that pass NULL are not determinable from the inputs; the checker flags patterns regardless of reachability from external callers.