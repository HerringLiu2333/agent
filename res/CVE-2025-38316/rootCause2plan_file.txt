1. Plan Summary
Detect check-after-dereference bugs where a function dereferences a pointer parameter before validating it against NULL, as in mt7996_set_monitor() pre-patch.

2. Detection Steps
1) Step 1: Objective: Find candidate functions that intend to accept a possibly-NULL pointer parameter. Signals: A function takes a pointer parameter P and contains at least one explicit NULL check on P (e.g., if (!P) return or equivalent). FP mitigation: Require the check to lead to an early exit (return/goto out) to indicate a genuine defensive NULL guard (based on [PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS]).

2) Step 2: Objective: Identify dereferences of the candidate pointer before the first NULL guard executes. Signals: Any expression using P as the base of a dereference (member access via "->", unary "*", array indexing "P[i]") that occurs on a path from function entry to the guard. FP mitigation: Use control-flow dominance/path analysis to ensure the dereference can be reached prior to the guard without passing through an equivalent prior non-NULL check.

3) Step 3: Objective: Specifically catch the pattern of initializing locals via P->field before the NULL check. Signals: An assignment or initialization like local = P->field, where P is the candidate pointer, that occurs syntactically or semantically before the guard. FP mitigation: Exclude cases where the assignment is itself guarded by a prior check of P being non-NULL.

4) Step 4: Objective: Ensure the guard actually checks the same pointer variable and is not a different alias. Signals: The conditional compares the same SSA/name for P against NULL; consider simple aliases like P2 = P without modification. FP mitigation: Exclude cases where P may have been reassigned to a non-NULL value prior to dereference (e.g., P = &local), or where the dereference base is provably not the original P.

5) Step 5: Objective: Confirm there is no earlier dominating non-NULL check that makes the dereference safe. Signals: Any condition in control-flow that must be true before the dereference and implies P != NULL (e.g., if (P) { ... deref ... }). FP mitigation: Only report if no such dominating guard exists for the dereference statement/block.

6) Step 6: Objective: Recognize early-return guards that occur after the dereference. Signals: A pattern where the first executable NULL guard of P (leading to return or goto) textually or CFG-wise follows the dereference, matching the pre-patch ordering in mt7996_set_monitor(). FP mitigation: Ignore guards in unreachable branches or post-dominated by the dereference.

7) Step 7: Objective: Account for null-check idioms used in kernel code. Signals: Guards implemented as if (unlikely(!P)) return; or WARN_ON(!P) with subsequent return/goto; treat these as NULL guards. FP mitigation: Require the guard to produce an early exit or a safe recovery path before further dereferences to avoid flagging diagnostics-only checks without control-flow impact.

8) Step 8: Objective: Reduce noise from calls that implicitly validate P. Signals: A call between entry and dereference that may validate P is not reliable without specifications; prefer not to assume such behavior. FP mitigation: Do not consider callee-side validation unless the condition is explicit and dominates in the same function; document this under limitations.

9) Step 9: Objective: Flag cases where the dereferenced field is used transitively after the guard (like dev = P->dev before guard, then using dev later). Signals: The dereference action itself happens before guard, regardless of later use; the presence of a later guard indicates developer intent that P can be NULL (based on [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation: Ensure at least one later NULL guard on P exists to avoid flagging deliberate contracts where P is guaranteed non-NULL.

10) Step 10: Objective: Prioritize diagnostics for kernel driver patterns. Signals: Functions in driver files and operations invoked from subsystem ops (as in [FILE_CONTENT], mt7996_set_monitor()). FP mitigation: Optional ranking boost for functions matching subsystem patterns; does not change correctness.

3. Target Elements
- Function definitions and their pointer parameters.
- Conditional statements that compare pointers against NULL and lead to early exit (return/goto).
- Expressions that dereference pointer parameters: member access, unary dereference, array indexing.
- Assignments initializing locals from dereferenced pointer parameters (e.g., local = P->field).
- Control-flow dominance and reachability between entry, dereference, and NULL guard.
- Simple pointer aliases within the function (P2 = P).

4. Dataflow / Taint Considerations
- Track the flow of the pointer parameter within the function to detect simple aliases used in dereferences or NULL checks.
- Model guards: a branch condition asserting P != NULL dominates a dereference if all paths to the dereference pass through it; otherwise, consider the dereference unguarded.
- Treat early-exit checks (return/goto) as guarding only subsequent code; dereferences occurring before such checks are vulnerable.
- Do not assume callee-side validation; only use in-function conditions to establish non-NULL guarantees.

5. Validation & Test Cases
- Positive: The pre-patch mt7996_set_monitor(struct mt7996_phy *phy, bool enabled) where struct mt7996_dev *dev = phy->dev; precedes if (!phy) return; (from [FILE_CONTENT]); expect a finding on the dereference of phy.
- Negative: The post-patch form where dev is assigned after if (!phy) return; (from [PATCH_DIFF]); expect no finding.
- Negative: A function that does if (!p) return; then x = p->f; expect no finding (guard dominates).
- Positive: A function that does q = p->f; if (!p) goto out; ...; out: return; expect a finding (dereference before guard).
- Test harness notes: Run across the provided file to ensure mt7996_set_monitor is flagged pre-patch and clean post-patch; include synthetic minimal examples for domination edge cases.

6. Estimated Effort & Priority
Medium: Requires control-flow dominance and simple intra-procedural dataflow over pointer aliases and common kernel NULL-check idioms.

7. Likely False-Positive Sources & Mitigations
- P is guaranteed non-NULL by external contract or calling convention not visible in code; mitigation: require presence of an explicit in-function NULL guard to signal developer’s intent that P may be NULL.
- Non-standard guard macros that don’t alter control flow; mitigation: only treat guards that lead to early exit or proven non-NULL condition dominating the dereference.
- Complex aliasing that obscures which variable is checked; mitigation: limit to simple aliases (direct assignments) within the function and same SSA identity.

8. Limitations & Assumptions
- The checker assumes only in-function evidence; it cannot use external specifications to prove non-NULL parameters.
- It does not model callee-side validations; only explicit guards in the same function are considered.
- It assumes dereference operators and member access reflect actual pointer dereferences; macros that hide dereferences may require preprocessing support.
- Exact call paths that pass NULL are unknown (as noted in [ROOTCAUSE_ANALYSIS]); the presence of a NULL guard is used as a proxy for potential NULL.