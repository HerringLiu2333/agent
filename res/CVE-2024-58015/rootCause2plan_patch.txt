1. Plan Summary
Generic differential-analysis-driven CodeQL checker template to detect pre-patch flaws by identifying the absence of safety checks or semantics newly introduced by the patch and explained in the root-cause analysis. Note: No [PATCH_DESCRIPTION], [PATCH_DIFF], or [ROOTCAUSE_ANALYSIS] content was provided, so this plan uses placeholders to be instantiated once those materials are available.

2. Detection Steps
1) Step 1: Objective — derive the security invariant from the patch and root cause; Signals — enumerate added constructs (e.g., conditionals, early returns, argument validation, locking, return-value checks) and their guarded operations; FP mitigation — restrict to elements directly referenced in the diff and root-cause write-up. 
2) Step 2: Objective — model the “guard” predicate(s) introduced by the patch; Signals — identify boolean checks, precondition helpers, capability/permission checks, bounds/null/state checks added before sensitive operations; FP mitigation — consider equivalent guards (e.g., helper wrappers, earlier dominating checks) as satisfying the predicate. 
3) Step 3: Objective — model the “sensitive operation(s)” that the guard protects; Signals — calls/dereferences/alloc-frees/state transitions that moved under the new guard or got new precondition checks; FP mitigation — anchor to the specific APIs/fields/operations highlighted by the diff to avoid overgeneralization. 
4) Step 4: Objective — detect pre-patch patterns where sensitive operation executes without the required guard; Signals — control-flow paths where the operation is reachable and the guard does not dominate or is absent; FP mitigation — require path feasibility and dominance (no intervening mutations that invalidate the guard). 
5) Step 5: Objective — enforce return-value/error-check requirements added by the patch; Signals — uses of a function’s return/outputs without checking status codes/errors where the patch added such checks; FP mitigation — treat uses within already-validated wrappers or APIs with documented “no-fail” semantics as non-issues. 
6) Step 6: Objective — enforce resource/state lifecycle corrections added by the patch; Signals — missing release/close/unref or missing initialization/state transitions that the patch added on all paths; FP mitigation — ensure path completeness (only flag when a path to exit/return lacks the operation and no equivalent cleanup is present). 
7) Step 7: Objective — enforce synchronization/locking rules newly introduced; Signals — operations now wrapped with lock/unlock pairs or atomic sections; FP mitigation — accept equivalent synchronization (e.g., higher-level lock already held) by recognizing known lock hierarchies or annotations in the same module. 
8) Step 8: Objective — handle input validation/sanitization newly added; Signals — tainted or external inputs that now flow through validators/transforms before reaching sinks; FP mitigation — model common validators and sanitizers as sufficient to reduce false positives. 
9) Step 9: Objective — scope and context restriction to reduce noise; Signals — same files/modules/functions touched by the patch, same API entrypoints, and similar call contexts; FP mitigation — require structural similarity (e.g., same callee set, parameter roles) to the patched sites before reporting.

3. Target Elements
- Functions and methods modified by the patch, and their call sites.
- Condition checks and guard predicates preceding sensitive operations.
- Function return-value uses and error-handling branches.
- Resource allocation/deallocation sites and state transitions.
- Synchronization constructs (lock/unlock, atomics) and critical sections.
- Sensitive API calls/dereferences/memory or state accesses gated by new checks.

4. Dataflow / Taint Considerations
- Track values/objects that are validated by the newly introduced guard(s) to their use in sensitive operations; require guard dominance along control-flow paths.
- Track return values/status codes to their subsequent uses to detect unchecked-error patterns.
- Track lifecycle of resources/objects to ensure initialization before use and release on all paths.
- Track lock ownership across control-flow to ensure required lock is held when performing sensitive operations.

5. Validation & Test Cases
- Positive: A pre-patch-like function that performs the sensitive operation without the newly required guard, uses a return value without checking as per the patch, or accesses a resource without required synchronization/cleanup; expect a detection.
- Negative: The same function with the guard in place, with proper error checks, and with correct synchronization/cleanup equivalent to the patch; expect no detection.
- Test harness notes: Instantiate tests with concrete guard G and operation S derived from the actual [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS], including interprocedural cases and alternate equivalent validations.

6. Estimated Effort & Priority
Medium — requires instantiation from the actual patch to define guard(s), sensitive operation(s), and equivalences, plus modest interprocedural/dominance analysis.

7. Likely False-Positive Sources & Mitigations
- Alternate validation helpers or framework-level guards not recognized — mitigate by modeling known validators and requiring dominance.
- Pre-validated call contexts (e.g., higher-level API guarantees) — mitigate by scoping to entrypoints lacking those guarantees.
- Equivalent synchronization via different locks or regions — mitigate by recognizing lock hierarchies/aliases within the affected module.
- Infeasible paths causing apparent missing cleanup — mitigate by basic path feasibility and exit-path analysis.

8. Limitations & Assumptions
- No [PATCH_DESCRIPTION], [PATCH_DIFF], or [ROOTCAUSE_ANALYSIS] content was provided; concrete guards, operations, and APIs cannot be enumerated here.
- The plan assumes the patch introduces explicit, statically detectable guards, checks, or synchronization constructs that can be modeled.
- Assumes availability of module context to recognize equivalent validations and synchronization; may require library/SDK models once identified from the patch.