1. CVE Identifier
CVE-2025-38312

2. Vulnerability Type
Integer overflow leading to divide-by-zero (kernel crash/DoS)

3. Root Cause Summary
fb_find_mode_cvt() did not validate that the refresh rate (cvt.f_refresh) stayed within a safe upper bound before it could be doubled for interlaced modes. With cvt.f_refresh stored as u32, doubling a value of 0x80000000 wraps to 0, which is then used as a divisor in fb_cvt_hperiod(). Specifically, fb_cvt_hperiod() computes “u32 num = 1000000000/cvt->f_refresh;” and thus triggers a division-by-zero. The pre-patch validation only checked for zero (cvt.refresh == 0), missing the wrap-to-zero after multiplication overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fbdev core, CVT timing generator (drivers/video/fbcvt.c), functions fb_find_mode_cvt() and fb_cvt_hperiod().

2) Pre-Patch Flaw:
- Missing upper-bound validation on cvt.f_refresh prior to scaling for interlaced modes in fb_find_mode_cvt().
- No guard against u32 overflow when doubling cvt.f_refresh (cvt.f_refresh *= 2) under FB_VMODE_INTERLACED.
- fb_cvt_hperiod() uses cvt->f_refresh as a divisor without ensuring it cannot become 0 after overflow.

3) Trigger Condition:
- mode->vmode has FB_VMODE_INTERLACED set, and mode->refresh equals 0x80000000.
- In fb_find_mode_cvt(), cvt.f_refresh is set from refresh and then doubled for interlaced, wrapping 0x80000000 to 0 due to u32 overflow.
- fb_cvt_hperiod() is called and divides by cvt->f_refresh (now 0).

4) Impact Mechanism:
- Division-by-zero in fb_cvt_hperiod() at “u32 num = 1000000000/cvt->f_refresh;” causes a kernel oops, leading to denial of service.

5. Patch Analysis
1) Fix Approach:
Input sanitization by bounding the acceptable range of cvt.f_refresh before any arithmetic that could overflow to 0. The check rejects values that could wrap to 0 when doubled, ensuring the divisor in fb_cvt_hperiod() is never zero.

2) Key Code Changes:
- In fb_find_mode_cvt(), the precondition check was extended from:
  “if (!cvt.xres || !cvt.yres || !cvt.refresh)”
  to:
  “if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX)”
- This ensures any initial cvt.f_refresh >= 0x80000000 (including 0x80000000) is treated as invalid, preventing the wrap-to-zero on doubling and the subsequent divide-by-zero.

3) Locking/Concurrency Impact:
None; the change is pure input validation in a computational path with no shared-state concurrency.

6. Broader Kernel Security Implications
- Arithmetic on untrusted or out-of-range inputs must consider overflow effects before values are used as divisors or scaled further; u32 wrap-around can silently convert nonzero inputs into zero.
- Similar timing and refresh computations elsewhere should be reviewed for overflow-before-division patterns; adopting explicit range checks or using wider types (u64) with overflow detection can prevent such faults.
- Early input validation is a low-cost mitigation that prevents kernel oopses and improves robustness against malformed user-provided display modes.