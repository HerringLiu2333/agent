1. Plan Summary
Detect integer-overflow-to-zero risks where a value destined to be used as a divisor (directly or in a callee) is derived from an external/input field, then scaled (e.g., doubled) without an adequate upper-bound check, so that overflow can convert it to zero before the division.

2. Detection Steps
1) Step 1: Identify divisor sinks — conceptual signals: variables/fields used as division/modulo denominators, or arguments passed to functions known (or modeled) to divide by specific fields (e.g., fb_cvt_hperiod uses cvt.f_refresh per ROOTCAUSE_ANALYSIS). FP mitigation: Prefer sinks with concrete evidence (actual “/” usage) or a curated list of modeled sinks (include fb_cvt_hperiod as per ROOTCAUSE_ANALYSIS).

2) Step 2: For each sink, locate the denominator value definition chain — conceptual signals: backward dataflow from the denominator to assignments and updates (e.g., cvt.f_refresh = cvt.refresh; cvt.f_refresh *= 2). FP mitigation: Require that the scaling operation (multiplication or left shift) occurs on the same variable that reaches the sink along at least one feasible path.

3) Step 3: Detect overflow-prone scaling before the sink — conceptual signals: integer multiplications by constants >1 (notably “*= 2” or shifts) on types bounded by INT_MAX (supported by PATCH_DIFF referencing INT_MAX and ROOTCAUSE_ANALYSIS stating signed int overflow). FP mitigation: Exclude cases where the variable is demonstrably wider (e.g., explicit 64-bit type) or where a prior cast/checked conversion ensures sufficient range.

4) Step 4: Determine whether the source value is externally influenced — conceptual signals: the value originates from a function parameter or struct field tied to input/state (e.g., mode->refresh into cvt.refresh per FUNCTION_CONTENT). FP mitigation: Require that the value flows from parameters/fields rather than constants or local loop counters, increasing confidence it can take extreme values.

5) Step 5: Check validation coverage before scaling — conceptual signals: presence of only zero checks on the pre-scaled variable (e.g., if (!cvt.refresh) in FUNCTION_CONTENT) without an upper-bound constraint pre-scaling. FP mitigation: Suppress if there is an explicit upper-bound check guarding overflow (e.g., comparisons to INT_MAX or equivalent limits) performed before any scaling.

6) Step 6: Check validation coverage after scaling — conceptual signals: absence of checks that the post-scaled value is non-zero or within range before reaching the sink (no validation of cvt.f_refresh after “*= 2” in FUNCTION_CONTENT). FP mitigation: Suppress if a post-scaling check ensures non-zero or bounds (e.g., check against INT_MAX or verify not zero) prior to the division or call to the modeled sink.

7) Step 7: Correlate conditional scaling with input-controlled flags — conceptual signals: scaling guarded by a branch dependent on externally influenced flags (e.g., if (cvt.flags & FB_CVT_FLAG_INTERLACED) set from mode->vmode per FUNCTION_CONTENT). FP mitigation: Require evidence that the guard condition is reachable from input-controlled state to avoid dead-path reports.

8) Step 8: Detect “mismatched check vs. use” — conceptual signals: the code validates variable A (cvt.refresh) but uses a transformed variable B (cvt.f_refresh) as the divisor after arithmetic; highlight the mismatch (ROOTCAUSE_ANALYSIS #3–#5). FP mitigation: Suppress if A and B are equivalent at the sink (no intervening arithmetic) or if a subsequent validation specifically targets B.

9) Step 9: Flag missing upper-bound checks tied to INT_MAX semantics — conceptual signals: absence of comparisons against INT_MAX (or equivalent limits) on the value that will be scaled (PATCH_DIFF added “|| cvt.f_refresh > INT_MAX” as a sanity check). FP mitigation: Suppress if an equivalent safe-range check exists (e.g., value <= INT_MAX/scale) even if the exact macro differs.

10) Step 10: Confirm sink proximity and ordering — conceptual signals: the scaling occurs before the sink on all flagged paths, with no intervening re-assignment to a safe value (FUNCTION_CONTENT shows fb_cvt_hperiod(&cvt) invoked after scaling). FP mitigation: Require ordering dominance (definition and scaling dominate the sink) and no intervening safeguarding assignments.

11) Step 11: Prefer high-impact outcomes — conceptual signals: denominators used in core calculations or in frequently executed paths (e.g., display timing generation per ROOTCAUSE_ANALYSIS #4), and division-by-zero potential leads to crashes. FP mitigation: Lower priority if denominator is only used in test/debug code or results are immediately discarded.

12) Step 12: Report with path explanation — conceptual signals: include the source (mode->refresh), the transformation (cvt.f_refresh *= 2), the missing check, and the sink (fb_cvt_hperiod) with indication of potential zero via overflow (ROOTCAUSE_ANALYSIS example: 0x80000000). FP mitigation: Only report when all prior criteria align to avoid speculative paths.

3. Target Elements
- Functions where derived values are used as denominators.
- Struct field assignments and copies (e.g., cvt.f_refresh = cvt.refresh).
- Arithmetic updates (multiplication/left shift) on potential denominators.
- Conditional branches that guard scaling (e.g., flags set from input fields).
- Validation condition checks (comparisons to zero or INT_MAX-like bounds).
- Call sites to modeled sinks that use the value as a divisor (e.g., fb_cvt_hperiod(&cvt)).

4. Dataflow / Taint Considerations
- Track taint from external/parameter-backed fields (e.g., mode->refresh, mode->vmode) into derived fields (cvt.refresh → cvt.f_refresh).
- Propagate through copies and arithmetic updates, especially scaling operations.
- Model interprocedural flow to sinks where the tainted value/field becomes a divisor (direct division or via known functions like fb_cvt_hperiod).
- Treat validation as potential sanitizers: zero checks and upper-bound checks; recognize when sanitization applies to the post-transformation value versus only the pre-transformation one.

5. Validation & Test Cases
- Positive: Pre-patch fb_find_mode_cvt where cvt.f_refresh is set from mode->refresh, conditionally doubled for interlaced, only cvt.refresh is checked for zero, and fb_cvt_hperiod(&cvt) is called; expect a finding.
- Negative: Post-patch variant adding a sanity check on cvt.f_refresh against INT_MAX before proceeding; expect no finding.
- Negative: Variant that checks the post-scaling value (e.g., after doubling, confirm non-zero or within upper bound) before calling fb_cvt_hperiod; expect no finding.
- Positive: Variant where a different input field undergoes “*= 2” and flows into a division denominator without upper-bound checks; expect a finding.
- Test harness notes: Ensure interprocedural model recognizes fb_cvt_hperiod as a sink using cvt.f_refresh as a divider (per ROOTCAUSE_ANALYSIS), or stub its behavior as such.

6. Estimated Effort & Priority
High: Requires interprocedural dataflow to modeled division sinks, arithmetic pattern recognition for overflow, and validation-mismatch reasoning.

7. Likely False-Positive Sources & Mitigations
- Cases where value ranges are constrained by earlier logic not recognized: mitigate by requiring explicit upper-bound checks or proven non-overflow types.
- Callees not modeled (unknown whether they divide): mitigate by focusing on explicit division uses or curated sink list (include fb_cvt_hperiod).
- Implicit promotions to wider types preventing overflow: mitigate by type-aware reasoning (exclude 64-bit safe computations).
- Dead or infeasible paths: mitigate with basic path feasibility (require that scaling guard depends on reachable, input-influenced conditions).

8. Limitations & Assumptions
- Assumes availability or modeling of sinks like fb_cvt_hperiod using cvt.f_refresh as a divisor (per ROOTCAUSE_ANALYSIS); without callee bodies, coverage may be partial.
- Assumes cvt.f_refresh is an int-sized bounded type and that overflow semantics can zero the value (supported by ROOTCAUSE_ANALYSIS and PATCH_DIFF references to INT_MAX).
- Cannot determine all user-control avenues for inputs (e.g., how mode fields are set) from provided materials; treats struct fields from parameters as potentially attacker-influenced.
- The exact safe threshold (e.g., INT_MAX/2) is not specified in PATCH_DIFF; checker will look for presence/absence of any upper-bound guard rather than a specific constant.