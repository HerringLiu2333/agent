1. Plan Summary
Detect integer-overflow-to-zero that turns a later division denominator into zero, due to missing upper-bound validation before scaling a refresh-like value that is passed to a function performing division (as in fb_find_mode_cvt → fb_cvt_hperiod).

2. Detection Steps
1) Step 1: Objective — identify division sinks where a denominator can be zero due to overflow; Signals — division/modulo operations and calls into known divisors (e.g., fb_cvt_hperiod) where a parameter is used as a divider; FP mitigation — prefer known kernel patterns from [ROOTCAUSE_ANALYSIS], especially calls to fb_cvt_hperiod.
2) Step 2: Objective — trace denominator origin; Signals — backward dataflow from the denominator/argument into local variables/fields with integer types, including interprocedural flow into fb_cvt_hperiod’s corresponding parameter; FP mitigation — require the flow to traverse at least one assignment/propagation from a function parameter or struct field (input-like).
3) Step 3: Objective — confirm risky arithmetic scaling before use; Signals — along the flow to the denominator, detect integer multiplication by a constant (e.g., 2) or equivalent left shift that can cause overflow (“doubling for interlaced modes” per [ROOTCAUSE_ANALYSIS]); FP mitigation — ensure the multiply occurs on a bounded integer type (e.g., int) rather than a wider type.
4) Step 4: Objective — check type width and overflow domain; Signals — the variable being multiplied is a signed/32-bit int or narrower, and post-multiply is still in that type (no widening before multiply); FP mitigation — suppress when the value is promoted to a wider type before the multiply or the denominator is 64-bit or larger.
5) Step 5: Objective — assess missing upper-bound validation pre-scaling; Signals — presence of zero-checks on the source (e.g., “!refresh”) without a corresponding upper-bound check (e.g., against INT_MAX or an equivalent limit) before the risky multiply, as shown pre-patch in [PATCH_DIFF] and described in [ROOTCAUSE_ANALYSIS]; FP mitigation — require evidence of some precondition logic nearby (a zero-check) to distinguish intended validation from its incompleteness.
6) Step 6: Objective — detect absence of post-scaling nonzero checks; Signals — after the multiply, the resulting variable is used as denominator or is passed to a function using it as a divider without a check like “result != 0”; FP mitigation — if any check on the scaled value’s nonzero-ness exists on all paths, do not report.
7) Step 7: Objective — identify specific fbdev CVT path; Signals — flows involving variables named like refresh/f_refresh/interlace and calls to fb_cvt_hperiod within fb_find_mode_cvt (per [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION]); FP mitigation — when this exact pattern appears, raise priority of the finding (lower confidence threshold).
8) Step 8: Objective — detect the exact missing bound fixed by the patch; Signals — in functions similar to fb_find_mode_cvt, presence of input validation that checks xres/yres/refresh nonzero but omits a bound on f_refresh relative to INT_MAX, as shown in [PATCH_DIFF]; FP mitigation — suppress if any explicit upper-bound check (e.g., “f_refresh > INT_MAX” or equivalent) exists before use.
9) Step 9: Objective — confirm path feasibility to division; Signals — ensure a control-flow path from the multiply to the division/call is not dominated by an early return handling invalid input; FP mitigation — require that the same variable instance reaches the sink without reassignment that adds safety checks.
10) Step 10: Objective — prioritize input-driven triggers; Signals — the source value comes from a function parameter or externally populated struct field (e.g., mode->refresh), per [ROOTCAUSE_ANALYSIS]; FP mitigation — de-prioritize when the source is a local constant or computed within small bounded ranges.

3. Target Elements
- Division and modulo expressions (denominator expressions).
- Calls to functions that use a parameter as a divisor (specifically fb_cvt_hperiod).
- Integer arithmetic sites along the dataflow to denominators, especially multiplications by constants or shifts.
- Input validation condition checks preceding these operations (if/guard conditions).
- Assignments from function parameters or struct fields to local variables used in denominators.
- Return statements or error-exit paths associated with validation guards.

4. Dataflow / Taint Considerations
- Track dataflow from parameters/struct fields (e.g., mode->refresh) into local variables (e.g., cvt.f_refresh).
- Propagate through assignments and arithmetic, specifically multiplication by constants (e.g., multiply by 2) before use as a denominator or as an argument to fb_cvt_hperiod.
- Model interprocedural flow: map the call argument to fb_cvt_hperiod’s parameter that is used as a divisor inside the callee.
- Treat sources as “input-like” when they originate from function arguments or externally populated structures; increase confidence when no upper-bound checks constrain them.

5. Validation & Test Cases
- Positive: A function sets f_refresh = refresh; sets interlace = 1; then f_refresh *= 2; later calls fb_cvt_hperiod(f_refresh); only checks “!xres || !yres || !refresh” before proceeding; expect a finding.
- Negative: Same as above but with an added guard “if (f_refresh > INT_MAX) return;” (or equivalent upper bound) before the multiply; expect no finding (mirrors [PATCH_DIFF]).
- Negative: Same as positive but with f_refresh declared as 64-bit, multiply happens in 64-bit, and a nonzero check on the scaled value precedes division; expect no finding.
- Positive: Denominator of a division is derived from (int)val * 2 with val from a parameter and no upper bound or post-multiply nonzero check; expect a finding.
- Test harness notes: Run with interprocedural analysis enabled to resolve fb_cvt_hperiod’s use of its parameter as a divisor; include path pruning to honor early returns.

6. Estimated Effort & Priority
Medium — requires interprocedural dataflow, type reasoning, and guard analysis; high priority due to crash potential (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Arithmetic that cannot overflow due to implicit widening: mitigate by checking operand/result types and promotions.
- Code with implicit bounds (e.g., enums or validated constructors) not visible to analysis: mitigate by requiring explicit guards or post-multiply nonzero checks.
- Denominators later clamped or sanitized in unrecognized helper functions: mitigate by recognizing common clamp patterns or whitelisting known sanitizers.
- Paths that are infeasible due to complex conditions: mitigate with path feasibility checks and dominance analysis of guards and returns.

8. Limitations & Assumptions
- Internal implementation of fb_cvt_hperiod is not provided; we assume one parameter is used as a divisor based on [ROOTCAUSE_ANALYSIS].
- Exact arithmetic sites (where doubling occurs) are not shown; we infer a multiply-by-2 step from [ROOTCAUSE_ANALYSIS], which may limit precise location matching.
- The patch’s specific bound “> INT_MAX” is taken from [PATCH_DIFF]; although typical safe bounds would consider the multiplier (e.g., half of INT_MAX), the checker will look for any explicit upper-bound guard akin to the patch.
- We assume 32-bit int semantics where overflow wraps and can reach zero, as described in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].