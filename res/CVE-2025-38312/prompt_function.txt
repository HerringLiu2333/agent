1. CVE Identifier
CVE-2025-38312

2. Vulnerability Type
Integer overflow leading to divide-by-zero (kernel crash/DoS)

3. Root Cause Summary
fb_find_mode_cvt() failed to validate that the computed refresh factor (cvt.f_refresh) would remain within a safe numeric range before later use as a divisor in fb_cvt_hperiod(). When interlacing is requested, the code doubles cvt.f_refresh (“cvt.f_refresh *= 2”), which can overflow for extreme refresh values (e.g., 0x80000000), silently turning cvt.f_refresh into 0. This zero value is then used as a divider in fb_cvt_hperiod(), causing a division-by-zero and a kernel oops. The pre-patch input validation only checked for zero refresh, not for values that would overflow upon doubling.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fbdev core, CVT timing generation (fbcvt)

2) Pre-Patch Flaw:
fb_find_mode_cvt() performed insufficient validation of mode->refresh/cvt.f_refresh, lacking an upper-bound check to prevent overflow when cvt.f_refresh is multiplied by 2 in the interlaced path. The function only rejected zero refresh (“if (!cvt.xres || !cvt.yres || !cvt.refresh)”) but did not consider overflow-induced zero after arithmetic.

3) Trigger Condition:
- mode->refresh set to 0x80000000 (as described), and
- mode->vmode includes FB_VMODE_INTERLACED, causing “cvt.f_refresh *= 2”.
This results in cvt.f_refresh wrapping to 0 due to integer overflow.

4) Impact Mechanism:
With cvt.f_refresh becoming 0, fb_cvt_hperiod(&cvt) uses it as a divider, leading to a division by zero and kernel oops (crash).

5. Patch Analysis
1) Fix Approach:
Introduce a sanity check on cvt.f_refresh to reject inputs that would overflow the refresh factor, preventing later division by zero in fb_cvt_hperiod().

2) Key Code Changes:
- In fb_find_mode_cvt(), the validation condition was expanded:
  Pre-patch: if (!cvt.xres || !cvt.yres || !cvt.refresh) …
  Post-patch: if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX) …
This early return prevents proceeding with unsafe cvt.f_refresh values that could overflow when doubled.

3) Locking/Concurrency Impact:
None. The change is purely input validation; no locks, ordering, or concurrency primitives were modified.

6. Broader Kernel Security Implications
Strengthening arithmetic bounds checking in display mode computation reduces crash surfaces reachable via malformed or extreme framebuffer mode inputs, improving kernel robustness against DoS. Preventing divide-by-zero in widely used subsystems like fbdev helps maintain system stability, especially where user-controlled parameters may flow into kernel mode setting paths. This fix exemplifies the need for rigorous validation of derived values before arithmetic operations that can overflow or become divisors.