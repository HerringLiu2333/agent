1. Plan Summary
No vulnerability-specific signals are available in the supplied materials; this is a template detection plan that outlines how to build a CodeQL checker once [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] are provided.

2. Detection Steps
1) Step 1: Establish scope — signals to look for cannot be determined because [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] are missing — mitigate false positives by not flagging anything until concrete vulnerable patterns are identified.
2) Step 2: Derive the vulnerable function/API set from code changes — conceptually target functions and call sites modified in [PATCH_DIFF] that introduce checks or guards — reduce false positives by scoping analysis to functions explicitly changed by the patch.
3) Step 3: Identify the guard condition added by the patch (e.g., null/bounds/permission/lock/error check) — conceptually detect preconditions newly introduced and map the root cause to their prior absence — mitigate false positives by requiring the exact guard pattern and its relative placement to the subsequent operation.
4) Step 4: Find unsafe operations dependent on the guard (e.g., pointer dereference, buffer copy, state mutation, privileged call) — conceptually locate operations that would be unsafe if the guard is missing — reduce false positives by ensuring the operation is reachable without an equivalent guard on all paths.
5) Step 5: Model dataflow from the guard’s subject to the unsafe sink — conceptually track values (pointers, lengths, state flags, return codes) from source to sink without intervening validation — mitigate false positives by requiring same-function or inter-procedural flow that matches the patch’s subject variable.
6) Step 6: If the patch adds locking or atomicity, detect shared-state accesses without the new lock boundary — conceptually recognize reads/writes to the same object/field outside the introduced critical section — reduce false positives by confirming the state is shared (global/static or captured across threads) and the access pattern matches the patched locations.
7) Step 7: If the patch adds error handling of a return value, flag call sites that ignore or misuse the return code — conceptually detect calls to the same API where the return value is unused or used as success without checking — mitigate false positives by requiring the exact API and a known error-signaling convention consistent with the patch.
8) Step 8: If the patch adds input normalization or capability checks, detect sinks using unnormalized/unchecked input — conceptually identify flows from external or untrusted sources into operations that the patch now guards — reduce false positives by requiring the same normalization/check pattern referenced by the patch.
9) Step 9: Confirm pre-patch context (version or code state) — conceptually tie findings to code states lacking the patch-added elements — reduce false positives by excluding code that already contains equivalent guards or safe wrappers.

3. Target Elements
- Functions modified by the patch; their call sites.
- Condition checks added in the patch (null, bounds, permission, lock, error).
- Sinks: dereferences, memory copies, array indexing, state mutation, privileged or sensitive API calls.
- Lock boundaries and critical sections introduced by the patch.
- Function return-value uses and error-handling paths.

4. Dataflow / Taint Considerations
- Track values guarded by the new checks (pointer/length/state/return code) from source to sink without equivalent validation.
- Model inter-procedural propagation through parameters and return values to reach unsafe operations.
- Treat inputs from external/untrusted origins as tainted when the patch implies validation/normalization is required.

5. Validation & Test Cases
- Positive: Pre-patch code that performs an unsafe operation (e.g., dereference/copy/state update/privileged call) on a value without the guard the patch later adds; the checker should flag paths lacking the guard.
- Negative: Post-patch code or pre-patch code that already includes an equivalent guard or uses a safe wrapper enforcing the condition; the checker should not flag.
- Test harness notes: Create minimal examples mirroring the guard type introduced by the patch (null/bounds/lock/error/permission) and ensure dataflow from source to sink is captured across function boundaries.

6. Estimated Effort & Priority
Medium — finalization depends on access to [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]; once available, pattern extraction and guard-to-sink mapping are straightforward.

7. Likely False-Positive Sources & Mitigations
- Alternative but semantically equivalent guards not textually identical to the patch; mitigate by normalizing guard semantics (e.g., null-check variants).
- Sinks that are safe due to invariants or prior checks outside the local scope; mitigate via inter-procedural guard recognition and dominance/post-dominance analysis.
- Context-specific APIs with nonstandard error conventions; mitigate by constraining to APIs explicitly referenced in the patch.
- Benign shared-state accesses in single-threaded contexts; mitigate by confirming concurrency relevance (locks/atomic operations introduced in patch).

8. Limitations & Assumptions
- [ROOTCAUSE_ANALYSIS] is missing, so the specific vulnerability class cannot be determined.
- [PATCH_DIFF] and [FUNCTION_CONTENT] are absent, so exact functions, guard patterns, and sinks are unknown.
- Assumes the patch adds explicit checks or boundaries that can be contrasted against pre-patch code; if the fix is architectural or non-local, additional project context will be required.