1. CVE Identifier
CVE-2024-58058

2. Vulnerability Type
Denial of service via infinite loop (RCU stall) caused by improper error handling in RX monitor ring processing.

3. Root Cause Summary
The ath11k driver’s monitor destination ring reaping logic failed to correctly handle an invalid buf_id returned by hardware. When no valid buffer could be obtained for a given buf_id, the code did not advance to the next MSDU/ring entry and instead kept reprocessing the same problematic descriptor, resulting in an infinite loop. This tight loop in softirq/NAPI context led to an RCU stall and kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath11k Wi-Fi driver (data path RX monitor destination ring processing).

2) Pre-Patch Flaw:
- Missing robust error handling for invalid buf_id during MSDU pop: on failure, the code did not skip/advance to the next ring entry.
- Control flow used a break/return path that left the problematic descriptor effectively “stuck,” causing the processing loop to revisit the same entry continuously.
- Evidenced by kernel logs: “data msdu_pop: invalid buf_id 309” and “dp_rx_monitor_link_desc_return failed” repeating.

3) Trigger Condition:
Receiving a destination ring entry whose buf_id does not map to a valid buffer (hardware occasionally returns such an invalid buf_id). Once encountered, the loop keeps hitting the same invalid entry.

4) Impact Mechanism:
Continuous reprocessing of the same invalid ring entry creates an infinite loop in the RX monitor processing path, starving RCU and triggering an RCU stall/soft lockup, ultimately leading to a kernel crash.

5. Patch Analysis
1) Fix Approach:
- Skip the problematic buf_id and continue reaping the next MSDU instead of breaking out in a way that leaves the same descriptor to be retried.
- In practice, this changes the error path to advance the ring pointer/state and continue processing, preventing the infinite loop.

2) Key Code Changes:
- Replace the previous break/early-exit on invalid buf_id with logic to:
  - Advance to the next MSDU/ring entry.
  - Continue processing (effectively a “continue” rather than “break”).
- Ensure the link descriptor handling aligns with this advancement so the ring progresses even on error.
(Note: Function names inferred from logs: msdu_pop and dp_rx_monitor_link_desc_return.)

3) Locking/Concurrency Impact:
- No locking primitives or RCU usage semantics were changed.
- The RCU stall is resolved indirectly by eliminating the tight loop that prevented RCU quiescent states; the fix is purely in control flow and error handling during RX ring iteration.

6. Broader Kernel Security Implications
- Demonstrates the importance of defensive handling of hardware-provided indices/identifiers in fast-path drivers; unvalidated or unhandled error cases can escalate to system-wide hangs.
- Highlights that forward progress guarantees (always advancing ring state on error) are critical to prevent livelocks and RCU stalls in networking/driver NAPI contexts.
- Similar monitor/ring-processing paths in other drivers should be reviewed for proper advancement on error conditions to avoid DoS via livelock.