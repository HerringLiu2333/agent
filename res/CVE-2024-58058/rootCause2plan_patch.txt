1. Plan Summary
Detect driver loops that process hardware RX “ring” entries where, upon failing to map a hardware-provided identifier (e.g., buf_id) to a buffer, the code exits (break/return) without advancing/consuming the ring entry, causing potential infinite reprocessing and RCU stalls.

2. Detection Steps
1) Step 1: Identify candidate “ring reaping” loops — look for loops that iterate over descriptors/MSDUs and reference hardware-provided identifiers (signals: variables or calls related to “msdu”, “descriptor”, “ring”, “buf_id”, “monitor/destination”, or functions like msdu_pop as per ROOTCAUSE_ANALYSIS). Mitigate FPs by prioritizing paths in driver/RX processing functions (names mentioning rx/monitor/dp/msdu) per ROOTCAUSE_ANALYSIS.

2) Step 2: Locate the mapping from identifier to buffer — within those loops, find a call or sequence that attempts to map an ID to a buffer (e.g., msdu_pop) and is followed by an error/invalid check (null, error code, or condition indicating “invalid buf_id”). Reduce FPs by requiring that the mapped result is subsequently used as a buffer pointer on the success path.

3) Step 3: Model the loop’s “advance/consume” action — determine how the loop advances to the next ring entry (increment of an index, update of a head pointer, or a call that conceptually advances the ring, e.g., a link descriptor return/consume function as per ROOTCAUSE_ANALYSIS). Reduce FPs by confirming such advancement/consume operations appear on the normal (success) path of the loop.

4) Step 4: Analyze the error branch for forward progress — on the error path (after detecting invalid buffer/ID), check whether control flow uses break/return that exits the loop/function without performing any ring advancement/consume action. Reduce FPs by requiring an absence of any index/pointer update or advancement-call in that error branch.

5) Step 5: Check for reprocessing risk — verify that the variable(s) selecting the current descriptor (e.g., consumer index, descriptor pointer) remain unchanged along the error path and at loop back-edge, implying the next iteration will revisit the same entry. Reduce FPs by confirming those variables are updated on success but not on the error path.

6) Step 6: Distinguish continue vs break/return semantics — if the error path uses continue after advancing/skipping the descriptor, do not flag; flag only when the path breaks/returns (or falls through) with no advancement. Reduce FPs by detecting explicit advancement before any continue or by recognizing any “skip/next MSDU” equivalent on the error path (per ROOTCAUSE_ANALYSIS fix description).

7) Step 7: Consider loop termination conditions — if the loop is gated by a budget counter or emptiness check, ensure the error path does not update the counter or cause the emptiness condition to change; this increases confidence that the loop will livelock. Reduce FPs by requiring that only the success path affects the budget/emptiness state.

8) Step 8: Account for ring reset or reinit on error — suppress findings if the error path calls functions that likely reset/reinitialize/flush the ring (e.g., names indicating reset/flush/replenish) that could change the head pointer. Reduce FPs by recognizing such calls as forward progress even if not a simple index increment.

9) Step 9: Prioritize monitor/destination processing in ath11k-like paths — raise confidence when function/call names resemble msdu_pop or dp_rx_monitor_link_desc_return, or strings indicating “monitor destination ring” (as per ROOTCAUSE_ANALYSIS), since this precisely matches the described flaw. Reduce FPs by giving lower scores to unrelated subsystems.

10) Step 10: Validate repeated logging patterns statically when present — if the error path contains logging with terms like “invalid buf_id” and no advancement, increase confidence that the path handles hardware invalid IDs without progress (as seen in ROOTCAUSE_ANALYSIS logs). Reduce FPs by requiring the presence of both the log and the lack of advancement.

3. Target Elements
- Loop constructs in driver receive paths (while/for) processing ring descriptors/MSDUs.
- Calls that map hardware identifiers to buffers (e.g., msdu_pop-like functions).
- Variables representing ring consumer index/head pointer and descriptor pointers.
- Condition checks for invalid/failed mappings and their associated error branches.
- Function calls that advance/consume/return link descriptors or increment indices.
- Control-flow exits (break/return/goto) within RX ring processing loops.

4. Dataflow / Taint Considerations
- Track the hardware-provided identifier and its flow into buffer-lookup calls.
- Track the descriptor/ring index variables from fetch at loop top through success and error branches to see where they are updated.
- Model advancement/consume semantics as writes to index/pointers or calls with side-effects on ring state; confirm absence on error branches.
- Track budget/emptiness state variables to ensure only success paths change them.

5. Validation & Test Cases
- Positive: A loop that fetches a ring descriptor and calls a buffer lookup; on failure (invalid ID), it logs and breaks/returns without incrementing the ring index or consuming the descriptor; success path increments index or returns descriptor via a consume call. Expected: flagged as potential infinite reprocessing/RCU stall risk.
- Negative: A loop that, on invalid ID, explicitly advances the ring pointer or returns the descriptor (skip) and continues to next entry; or calls a reset/flush that advances state. Expected: not flagged.
- Test harness notes: Include a variant with a budget counter to ensure the checker confirms the budget is unchanged on error; include ath11k-like naming (msdu_pop, link_desc_return) to validate higher-confidence signals.

6. Estimated Effort & Priority
High — Requires inter-procedural reasoning about advancement semantics and control-flow analysis within performance-critical driver loops.

7. Likely False-Positive Sources & Mitigations
- Ambiguity in identifying advancement/consume operations (mitigate by requiring clear state updates on success and none on error).
- Error paths that exit to a caller that advances the ring later (mitigate by preferring same-function loops and requiring evidence that success path advances locally).
- Non-driver loops with similar patterns (mitigate via naming/context heuristics for rx/monitor/ring/MSDU as per ROOTCAUSE_ANALYSIS).

8. Limitations & Assumptions
- Exact function names for advancement (e.g., dp_rx_monitor_link_desc_return) and buffer lookup (msdu_pop) are inferred from ROOTCAUSE_ANALYSIS; other drivers may use different names not detectable by heuristics.
- The checker cannot definitively model hardware side-effects; it assumes ring advancement is visible via index/pointer updates or specific calls.
- [PATCH_DIFF] is unrelated to ath11k and does not inform this checker; design is based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS] only.