1. Plan Summary
Detect cases where pm_genpd_init() is invoked on a generic_pm_domain instance before its name field is assigned, causing a potential NULL-pointer dereference later due to an unnamed embedded device.

2. Detection Steps
1) Step 1: Objective — identify sensitive API invocations; Signals — call sites to pm_genpd_init() with first argument referring to a struct generic_pm_domain instance (direct variable, address-of field like &X->genpd, or equivalent through casts); FP mitigation — restrict to calls in C code where type resolution confirms the argument’s type is struct generic_pm_domain or an embedded field thereof (based on [PATCH_DIFF]/[FILE_CONTENT]).

2) Step 2: Objective — resolve the specific genpd instance per call; Signals — bind the base object whose field genpd is passed (e.g., pm_domain in &pm_domain->genpd, or a standalone generic_pm_domain variable); FP mitigation — ensure aliasing through simple field/address-of chains only within the same function to keep high precision.

3) Step 3: Objective — find assignments to the .name field of the identified genpd instance; Signals — writes like X->genpd.name = ... or genpd.name = ... that target the same instance as in Step 2; FP mitigation — require that the LHS instance matches by alias analysis (same base object/field chain) and is not a different variable with coincidental name.

4) Step 4: Objective — detect misordered initialization (post-call assignment); Signals — presence of any assignment to that instance’s .name occurring after the pm_genpd_init() call along at least one control-flow path; FP mitigation — require that the post-call .name assignment is executed on the same instance and reachable without intermediate reinitialization that would justify the order.

5) Step 5: Objective — detect missing pre-call assignment (definite absence); Signals — lack of any dominating assignment to that instance’s .name on all paths leading to pm_genpd_init(); FP mitigation — use dominance/path coverage: only flag when no pre-call write exists on any path in the same function.

6) Step 6: Objective — strengthen confidence when the instance is freshly zero-initialized; Signals — the enclosing object allocated via kzalloc/calloc or memset to zero before the call (as in [FILE_CONTENT] kzalloc of mmp_pm_domain) or a static/stack aggregate with zero-init and no prior .name assignment; FP mitigation — only treat this as confirming evidence, not a standalone trigger, to avoid flagging reused instances.

7) Step 7: Objective — correlate with initialization sequences typical for genpd; Signals — detect that other genpd fields (e.g., power_on/power_off callbacks) are assigned after pm_genpd_init(), similar to [PATCH_DIFF], as a heuristic that the init call was placed too early; FP mitigation — use this only as a boosting heuristic when combined with Steps 4 or 5, not as a sole criterion.

8) Step 8: Objective — minimize false positives due to external initialization; Signals — check for calls to helper functions on the same instance immediately before pm_genpd_init() that may set .name (unknown side effects); FP mitigation — if such helpers are present and the instance escapes to them, lower severity or suppress unless a post-call .name assignment is also observed (clear misorder per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).

9) Step 9: Objective — suppress benign cases with guaranteed pre-initialization; Signals — static const initializers of the generic_pm_domain with .name set at declaration, or constructor-like helpers that are inlined and clearly write .name before pm_genpd_init(); FP mitigation — require evidence of a pre-call write in the same function or an inlined callee to clear the alert.

10) Step 10: Objective — report with actionable context; Signals — include the pm_genpd_init() call, the location (or absence) of pre-call .name writes, and any post-call .name writes; FP mitigation — only report when either (a) a post-call .name write exists, or (b) no pre-call write exists and the instance is freshly zero-initialized, aligning with the root cause in [ROOTCAUSE_ANALYSIS] and fix in [PATCH_DIFF].

3. Target Elements
- Function bodies where pm_genpd_init() is called.
- Call sites that pass a struct generic_pm_domain pointer or &X->genpd.
- Assignments to fields: *.genpd.name and genpd.name on the same instance.
- Allocation sites (e.g., kzalloc) and zero-initialization patterns for enclosing structs.
- Control-flow and dominance relations within the same function.
- Calls to nearby helper functions that may mutate the same instance.

4. Dataflow / Taint Considerations
- Track the specific generic_pm_domain instance from the pm_genpd_init() argument back to its base object/field.
- Track writes to the .name field of that instance and their order relative to the init call along feasible control-flow paths.
- Track object creation/zeroing (kzalloc/memset) reaching the init call to infer NULL initial state.
- Consider simple alias flows (assignments of the base pointer, address-of field passing) within the same function; interprocedural flows are considered only for inlined/simple helpers.

5. Validation & Test Cases
- Positive: A function that kzallocs an mmp_pm_domain, calls pm_genpd_init(&pm_domain->genpd, ...), then assigns pm_domain->genpd.name = name; expect a report (matches [FILE_CONTENT] pre-patch and [PATCH_DIFF] movement).
- Positive: No pre-call .name write anywhere, and the object is zero-initialized before pm_genpd_init(); expect a report (risk per [ROOTCAUSE_ANALYSIS]).
- Negative: Assign pm_domain->genpd.name = name before pm_genpd_init(), then call pm_genpd_init(); expect no report (matches fixed order in [PATCH_DIFF]).
- Negative: Static struct generic_pm_domain genpd = {.name = "X"}; pm_genpd_init(&genpd,...); expect no report (pre-initialized).
- Test harness notes: Run on drivers/clk/mmp/pwr-island.c before and after the patch to confirm detection only in the pre-patch version.

6. Estimated Effort & Priority
Medium — requires accurate type/field resolution, dominance analysis, and modest intra-procedural dataflow; high priority for kernel code due to boot-time crash potential (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Name set in an unseen external helper before pm_genpd_init(): mitigate by requiring either a post-call .name write or fresh zero-initialization evidence.
- Complex aliasing of the genpd instance: mitigate by restricting to clear alias patterns (same base object/field) and same-function analysis.
- Alternative API semantics in other environments: mitigate by scoping to Linux kernel code and known pm_genpd_init() patterns.

8. Limitations & Assumptions
- Assumes pm_genpd_init() uses genpd->name to set a device name (based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]); the checker encodes this API contract.
- Interprocedural initialization of .name may be missed if not visible/inlined; the plan favors precision over completeness.
- Cannot determine runtime nullability of the source value assigned to .name; the checker focuses on order, not value validity.