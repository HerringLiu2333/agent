1. Plan Summary
Detect calls to pm_genpd_init() that occur before initializing the associated generic_pm_domain.name field, which can leave the embedded device name NULL and later cause a NULL dereference (as in CVE-2024-58081).

2. Detection Steps
1) Step 1: Objective: identify target API usage. Conceptual signals: locate all calls to pm_genpd_init and extract the first argument as the “genpd object.” FP mitigation: restrict to calls where the first argument is a struct generic_pm_domain or the address-of a genpd field within a container (based on [PATCH_DIFF]).

2) Step 2: Objective: resolve the concrete genpd instance. Conceptual signals: compute the base object of the first argument (e.g., &container->genpd or a genpd* variable), tracking pointer/field dereferences to tie later field writes to the same instance. FP mitigation: require alias-consistent base across the call and field writes (Step 8).

3) Step 3: Objective: find initialization writes to the name field. Conceptual signals: within the enclosing function, collect assignments to genpd.name (either genpd->name or container->genpd.name) that may reach the call. FP mitigation: use control-flow to require a dominating assignment that reaches the call on all paths.

4) Step 4: Objective: detect the “init-after-use” ordering bug. Conceptual signals: flag when the only assignment(s) to genpd.name in the function occur after the pm_genpd_init call (post-dominating or following in the same basic block), matching the pre-patch order in [PATCH_DIFF]. FP mitigation: ensure the assignment and the call operate on the same genpd object (Step 8) and that no prior assignment dominates the call.

5) Step 5: Objective: detect missing initialization in init-like routines. Conceptual signals: if there is no intra-procedural write to genpd.name before the call, but the function sets other genpd init fields (e.g., genpd.power_on/off) near the call, treat as suspicious (based on [PATCH_DIFF]). FP mitigation: only flag when at least one of genpd.power_on or genpd.power_off is assigned within the same function to indicate an initialization context.

6) Step 6: Objective: strengthen evidence using parameter-to-name assignment. Conceptual signals: increase confidence if a function parameter (e.g., “name”) is assigned to genpd.name after the call, as shown in [PATCH_DIFF] and explained in [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure the parameter flows directly (or via a simple local) to genpd.name without complex transformations.

7) Step 7: Objective: avoid false positives on correctly ordered code. Conceptual signals: if a dominating assignment to genpd.name exists before the call along all paths, do not report (mirrors the fixed order in [PATCH_DIFF]). FP mitigation: require control-flow dominance and same-object alias match.

8) Step 8: Objective: ensure object identity for field writes. Conceptual signals: unify field writes and call argument via field-sensitive alias analysis (e.g., same container pointer leading to .genpd or the same genpd pointer variable). FP mitigation: discard cases where object identity cannot be proven.

9) Step 9: Objective: handle both container and direct-genpd patterns. Conceptual signals: support patterns where &container->genpd is passed and container->genpd.name is written, as well as where a genpd* variable is passed and genpd->name is written (pattern seen in [PATCH_DIFF]). FP mitigation: same as Step 8.

10) Step 10: Objective: catch explicit NULL name scenarios. Conceptual signals: if genpd.name is explicitly set to NULL before or after pm_genpd_init (and no prior non-NULL assignment dominates), flag as high risk since pm_genpd_init relies on genpd->name to set a device name (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation: ensure the NULL write reaches the call and refers to the same genpd object.

3. Target Elements
- Function calls to pm_genpd_init (call sites).
- Field assignments to generic_pm_domain.name (writes).
- Field assignments to generic_pm_domain.power_on and .power_off (heuristic for init context).
- Expressions taking the address of a genpd field within a container (e.g., &pm_domain->genpd).
- Function parameters or locals used as the source for name assignment.

4. Dataflow / Taint Considerations
- Track object identity for the first argument of pm_genpd_init to the corresponding genpd.name writes (field-sensitive, alias-aware).
- Control-flow dominance analysis to determine whether any genpd.name assignment occurs before the call along all paths.
- Simple value-flow from function parameters/locals to genpd.name when assigned post-call to strengthen confidence.
- Optional nullability: detect explicit assignments of NULL to genpd.name reaching the call.

5. Validation & Test Cases
- Positive: A function that calls pm_genpd_init(&pm_domain->genpd, …) and only afterward does pm_domain->genpd.name = name; expected: flagged with high confidence (matches [PATCH_DIFF] pre-fix and [ROOTCAUSE_ANALYSIS]).
- Positive: A function that sets genpd.power_on/off, calls pm_genpd_init(genpd, …), and never assigns genpd.name before the call; expected: flagged as suspicious (init-context heuristic).
- Negative: A function that assigns pm_domain->genpd.name = name; then sets power_on/off; then calls pm_genpd_init(&pm_domain->genpd, …); expected: no finding (matches [PATCH_DIFF] fixed order).
- Negative: A function where genpd.name is clearly assigned on all paths before pm_genpd_init; expected: no finding.
- Test harness notes: Validate alias resolution with both container-based (&container->genpd) and direct genpd* usages; include branching to test dominance analysis.

6. Estimated Effort & Priority
Medium effort; high priority due to NULL dereference and boot-time DoS impact (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Name set in a different function or prior initialization not visible intra-procedurally; mitigate by prioritizing cases with a post-call assignment in the same function (Step 4) and init-context heuristics (Step 5).
- Multiple genpd instances where alias resolution is ambiguous; mitigate by requiring proven same-object identity (Step 8).
- Complex control flow where dominance cannot be established; mitigate by requiring clear dominance or post-dominance patterns for high-confidence reports.

8. Limitations & Assumptions
- Assumes pm_genpd_init reads genpd->name to set the embedded device name, as stated in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; deeper semantics of pm_genpd_init are not analyzed.
- Inter-procedural initialization (e.g., name set in a prior helper) may evade detection or cause false positives; this plan focuses primarily on intra-procedural evidence.
- The checker does not verify non-NULLness of the assigned name value beyond explicit NULL assignments; it only enforces initialization-before-use ordering.