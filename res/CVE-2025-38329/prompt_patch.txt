1. CVE Identifier
CVE-2025-38329

2. Vulnerability Type
Out-of-bounds memory read

3. Root Cause Summary
In cs_dsp_mock_wmfw_add_info, when the info string length was not a multiple of 4, the code rounded info_len up to the padded allocation size and then used this enlarged value as the memcpy length. This caused memcpy to read past the end of the original source buffer (“info”), resulting in an out-of-bounds read. The flaw stems from conflating destination padded length with the actual source data length.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test code, wmfw info handling)

2) Pre-Patch Flaw:
After rounding up info_len to a multiple of 4 and allocating a zeroed buffer of that size, the code performed memcpy(tmp, info, info_len), where info_len had been increased. Evidence: the pre-patch line “memcpy(tmp, info, info_len)” immediately follows “info_len = round_up(info_len, 4);”.

3) Trigger Condition:
When info_len % 4 != 0, the padded path executes and info_len is increased; memcpy then reads the rounded-up number of bytes from the original info pointer, exceeding its actual length.

4) Impact Mechanism:
Out-of-bounds read from the source buffer “info” during memcpy; KASAN reports OOB access. Potential to read adjacent memory beyond the string’s actual bounds (information exposure or fault), though in this KUnit context it manifests as a detected OOB read.

5. Patch Analysis
1) Fix Approach:
Decouple the source copy length from the padded destination size: capture the original info_len as copy_len before rounding, allocate using the rounded length, and copy only copy_len bytes.

2) Key Code Changes:
- Introduced size_t copy_len = info_len prior to rounding.
- Maintained padding behavior: info_len = round_up(info_len, 4) and kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL) for destination.
- Changed memcpy to use memcpy(tmp, info, copy_len) instead of the rounded info_len, leaving the padded tail zero-initialized.

3) Locking/Concurrency Impact:
None. The change addresses a bounds/length misuse in a local memcpy; no locking, RCU, or ordering modifications were involved.

6. Broader Kernel Security Implications
This fix removes an OOB read pattern that could otherwise lead to memory disclosure or stability issues if similar logic existed outside test code. It reinforces correct handling of padded allocations by ensuring copy lengths reflect source data size, a common pitfall in alignment/padding routines. Ensuring separation of source length from destination padding is broadly applicable to prevent OOB reads in firmware and DSP-related data handling paths.