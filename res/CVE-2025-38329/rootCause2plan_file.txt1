1. Plan Summary
Detect out-of-bounds reads where a string’s measured length is rounded up for destination allocation and the rounded value is mistakenly used as the memcpy size from the original string.

2. Detection Steps
1) Step 1: Identify variables assigned from a string length function on a pointer (e.g., len = strlen(info)). Signals: assignment capturing strlen(...) result and the corresponding source pointer used with that length.
2) Step 2: Track that same length variable being overwritten by a rounding-to-alignment operation (e.g., len = round_up(len, 4)). Signals: reassignment via round_up(...) using the previously recorded length variable.
3) Step 3: Confirm an allocation uses the rounded length as the destination size. Signals: calls like kunit_kzalloc(..., len, ...) or similar, with the rounded length variable as the size and the result stored in a destination pointer.
4) Step 4: Find a memcpy that copies from the original string pointer into the allocated destination using the rounded length variable as the copy size. Signals: memcpy(dest, src, size) where src equals the original pointer from Step 1, dest equals the allocation from Step 3, and size equals the rounded length from Step 2.
5) Step 5: Strengthen confidence by requiring a guard condition that indicates padding is needed (e.g., if (orig_len % 4) ...). Signals: a conditional that references the original, pre-rounding length variable’s modulo with the alignment value.
6) Step 6: Ensure the memcpy occurs before any reassignment of the source pointer to the padded buffer (i.e., the copy reads from the unpadded source). Signals: data-flow shows src in memcpy is still the original pointer, not the newly allocated tmp.
7) Step 7: Verify that the rounded length is used both for allocation and memcpy size, but the original unrounded length is not used for memcpy. Signals: no memcpy alternative that uses the pre-rounding length; the memcpy third argument is the rounded variable.
8) Step 8: Exclude safe variants where a separate variable preserves the original length and is used for memcpy (as in the patch). Signals: presence of a distinct copy_len capturing pre-rounding value and used as memcpy size should prevent a report.
9) Step 9: Report a potential OOB read when the pattern matches: measured string length -> round_up overwrite -> allocation with rounded length -> memcpy from original string using the rounded length. Signals: consolidated match across steps 1–7 within a single control-flow path.

3. Limitations & Assumptions
- Assumes round_up is the alignment function; other alignment helpers are not covered by this plan.
- Does not prove at analysis time that rounded length is strictly greater than original length; relies on the presence of a modulo guard to imply padding.
- Focuses on memcpy; similar misuse in other copy APIs is not included due to lack of examples in supplied materials.
- Assumes the source is a null-terminated string because it was measured via strlen; cases where the source has at least rounded_len bytes by construction are not distinguished.