1. CVE Identifier
CVE-2025-38329

2. Vulnerability Type
Out-of-bounds read due to incorrect length handling during memory copy

3. Root Cause Summary
In cs_dsp_mock_wmfw_add_info(), the code rounded up the string length to a 4-byte boundary for padding and then used this inflated length as the source size in memcpy(tmp, info, info_len). This reused, padded length exceeded the actual source string length (computed by strlen), causing memcpy to read past the end of the source buffer. The destination buffer was zero-initialized and sized to the padded length, so the overflow occurred on the read side, not the write side. The patch separates the original length from the padded length and uses the original (pre-rounded) length for the memcpy, preventing the OOB read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware utilities for Cirrus Logic DSP (cs_dsp), specifically KUnit test utilities

2) Pre-Patch Flaw:
In cs_dsp_mock_wmfw_add_info(), after padding, the variable info_len was overwritten with the rounded-up size and then used as the memcpy length: “memcpy(tmp, info, info_len)”. This conflated the destination allocation size with the true source string length.

3) Trigger Condition:
Any info string whose length is not a multiple of 4 (info_len % 4 != 0), which causes padding via round_up(info_len, 4). Under this condition, the memcpy length exceeds the actual source length by up to 3 bytes.

4) Impact Mechanism:
memcpy() reads past the end of the source string (info), producing an out-of-bounds read detectable by KASAN. While the destination buffer is large enough, the read beyond the source can lead to access of unrelated kernel memory, potential faulting under sanitizers, or unintended data exposure in testing.

5. Patch Analysis
1) Fix Approach:
Maintain the original string length for the source copy and use the padded length only for allocation, padding, and metadata. Zero-initialization ensures the padded bytes are safe without reading from the source.

2) Key Code Changes:
- Introduced a separate variable to capture the pre-rounded length: “size_t copy_len = info_len;” before modifying info_len.
- Changed memcpy to use the original length: from “memcpy(tmp, info, info_len)” to “memcpy(tmp, info, copy_len)”.
- Kept info_len as the padded size for subsequent block creation (cs_dsp_mock_wmfw_add_raw_block), ensuring correct payload length.

3) Locking/Concurrency Impact:
None. The change is localized to copy length calculation in a KUnit helper and does not alter locking, synchronization, or ordering.

6. Broader Kernel Security Implications
This fix underscores a common class of bugs where a size variable is repurposed after alignment/padding and then incorrectly applied to source operations. Proper separation of source length and padded/aligned size is essential to prevent OOB reads during serialization and block construction. Zero-initialization and using pre-padding lengths for memcpy/str operations should be standard practice. KUnit and KASAN caught this issue, demonstrating the value of runtime sanitizers in test code that mirrors production data handling patterns.