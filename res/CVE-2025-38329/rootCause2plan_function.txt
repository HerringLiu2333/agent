1. Plan Summary
Detect cases where a length originally derived from a string’s actual length is increased for padding/alignment and then (mis)used as the memcpy source length, causing an out-of-bounds read.

2. Detection Steps
1) Step 1: Objective — Identify candidate string-length seeds. Conceptual signals — A variable L assigned from strlen(S) (source pointer S is a char/const char*), as seen in cs_dsp_mock_wmfw_add_info() in the provided function content. FP mitigation — Require direct or dataflow-equivalent assignment from strlen; exclude unknown library aliases unless identifiable.

2) Step 2: Objective — Find alignment/padding transformation of L. Conceptual signals — L is reassigned using round_up(L, K) or similar alignment operation (based on PATCH_DIFF introducing round_up(info_len, 4) and ROOTCAUSE_ANALYSIS). FP mitigation — Prefer exact match to a known alignment helper like round_up; optionally require K to be a small integer constant (e.g., 4) to mirror the evidence.

3) Step 3: Objective — Confirm padding path is intended only when misaligned. Conceptual signals — A control predicate on L % K (e.g., if (L % 4)) guarding the reassignment (FUNCTION_CONTENT). FP mitigation — Require that the memcpy occurs within the same guarded region or dominated by it, so the path corresponds to L being increased.

4) Step 4: Objective — Ensure destination allocation uses the padded size. Conceptual signals — An allocation call (e.g., kunit_kzalloc) whose size argument is L after padding (FUNCTION_CONTENT and PATCH_DIFF). FP mitigation — Require destination pointer D from the allocation feeds the memcpy destination; optionally prefer zero-initializing allocators (kzalloc/kunit_kzalloc) to match evidence.

5) Step 5: Objective — Detect risky memcpy that reads from the original source using padded length. Conceptual signals — memcpy(D, S, L) where S is the same pointer used in the initial strlen and L is the padded value (FUNCTION_CONTENT shows memcpy(tmp, info, info_len)). FP mitigation — Require that S has not been reassigned to the destination before the memcpy (e.g., “info = tmp” occurs only after memcpy), matching the pre-patch flaw.

6) Step 6: Objective — Establish that L increased beyond the original strlen result. Conceptual signals — Dataflow shows L’s value after round_up differs from pre-alignment L, plus the presence of the misalignment guard (L % K). FP mitigation — If static reasoning can’t prove increase, demand both the modulo guard and the round_up transformation are present before the memcpy.

7) Step 7: Objective — Exclude correct fixes where original length is preserved for copy. Conceptual signals — Presence of a distinct variable (e.g., copy_len) bound to pre-rounded length and used as memcpy length (PATCH_DIFF uses copy_len). FP mitigation — If memcpy’s third argument aliases the pre-rounded length or min(original, padded), do not flag.

8) Step 8: Objective — Exclude cases where source buffer is known to be at least padded size. Conceptual signals — If S aliases D or another allocation sized with L (i.e., memcpy copies within buffers of padded size, not from the original shorter string), or if there is an explicit bounds check showing source size ≥ L. FP mitigation — Require S to flow from the original string input (e.g., function parameter) without an intervening reallocation/copy to padded-size storage before the memcpy.

9) Step 9: Objective — Confirm the pattern is a read-side overflow, not a write overflow. Conceptual signals — Destination allocation size is L (padded), so write fits; risk is only on the read side from S of original length (ROOTCAUSE_ANALYSIS clarifies read-side OOB). FP mitigation — Ensure the analysis ties L’s use as memcpy length to the source derived from strlen and distinguishes from unrelated size variables.

10) Step 10: Objective — Report with contextual evidence to reduce noise. Conceptual signals — Include links to: the strlen seed, the alignment transformation, the allocation using padded L, and the memcpy using padded L (PATCH_DIFF and FUNCTION_CONTENT demonstrate this sequence). FP mitigation — Only report when all four elements are found along a single feasible path.

3. Target Elements
- Function bodies where strings are serialized or padded.
- Calls to strlen and subsequent uses of the resulting variable.
- Alignment/padding operations (e.g., round_up) and modulo guards (length % K).
- Allocation sites sized by the (potentially padded) length variable.
- memcpy (and close equivalents) call sites consuming the padded length.
- Assignments that may rebind the source pointer before/after memcpy.

4. Dataflow / Taint Considerations
- Track dataflow from strlen(S) into a length variable L1.
- Track transformation L1 → L2 via round_up/alignment; mark L2 as “padded length.”
- Track S through the control flow to the memcpy source argument; ensure it remains the original buffer until the memcpy.
- Track allocation of D using L2 and subsequent memcpy(D, S, L2); flag when these align.
- Recognize a safe pattern when memcpy length is a variable that dataflows from L1 (pre-rounded) rather than L2 (padded).

5. Validation & Test Cases
- Positive: A function that computes len = strlen(info); if (len % 4) { len = round_up(len, 4); tmp = kzalloc(len); memcpy(tmp, info, len); info = tmp; } → should be flagged for OOB read (matches FUNCTION_CONTENT pre-patch and ROOTCAUSE_ANALYSIS).
- Negative: Same function but uses copy_len = len before round_up; memcpy(tmp, info, copy_len); use padded len only for allocation and metadata (matches PATCH_DIFF).
- Negative: Code that copies from a source buffer that was itself allocated/capped to the padded length before memcpy (no OOB read).
- Test harness notes: Include path-sensitive cases where the memcpy is within the misalignment branch; verify the checker requires the full sequence: strlen → round_up → alloc(padded) → memcpy using padded length.

6. Estimated Effort & Priority
Medium: Requires inter-procedural dataflow for tracking strlen-derived lengths through alignment and into memcpy, plus control-flow sensitivity for the guarded branch.

7. Likely False-Positive Sources & Mitigations
- Source buffer is not a string but a larger buffer known to be ≥ padded length; mitigation: require strlen seed on the same source pointer.
- Alignment helpers other than round_up; mitigation: initially restrict to round_up and modulo guard to reduce noise.
- Complex aliasing where S is replaced by a padded copy before memcpy; mitigation: track pointer reassignments to ensure S remains the original until the memcpy.

8. Limitations & Assumptions
- Assumes alignment is performed via round_up and guarded by a modulo check, as shown in PATCH_DIFF and FUNCTION_CONTENT; other alignment idioms may be missed.
- Cannot always prove at compile time that padded length > original; relies on the presence of modulo guard and round_up to approximate.
- Does not attempt to reason about non-standard memcpy-like wrappers unless modeled.
- Scope inferred from ROOTCAUSE_ANALYSIS focuses on read-side OOB in memcpy sourced from strlen-derived strings; other APIs (e.g., memmove) are not guaranteed covered by this plan.