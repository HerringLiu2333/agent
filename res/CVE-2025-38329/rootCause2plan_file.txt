1. Plan Summary
Detect memcpy/memmove calls that copy from an original string using a length that was rounded up for destination padding, causing potential out-of-bounds reads on the source (as in the pre-patch cs_dsp_mock_wmfw_add_info bug).

2. Detection Steps
1) Step 1: Identify a length variable derived from a string source — look for assignments like L = strlen(S) (or equivalent) where S is used as a memcpy/memmove source later; this mirrors “size_t info_len = strlen(info)” in [FILE_CONTENT]. Reduce FPs by requiring the RHS be a known string-length operation (strlen/strnlen) and retaining the specific source pointer S.

2) Step 2: Detect a conditional path that implies padding is needed — look for tests L % K != 0 (or L % K used in a condition) as in “if (info_len % 4)” in [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS]. This increases confidence that subsequent rounding will increase L, mitigating FPs.

3) Step 3: Detect rounding/alignment of the same length variable — find reassignments of L via round_up(L, K) or equivalent “next multiple of K” transformation, as shown in [PATCH_DIFF] and described in [ROOTCAUSE_ANALYSIS]. Reduce FPs by requiring the reassigned L dominates later uses along the same path (path-sensitivity).

4) Step 4: Detect allocation using the padded/rounded length — find an allocation where the size argument is L after rounding (e.g., kunit_kzalloc(..., L, ...)) as in [FILE_CONTENT]. This ties L to the destination size, matching the root cause pattern.

5) Step 5: Find a memcpy/memmove that copies from the original source S into a destination buffer using the padded L — specifically, memcpy(D, S, L) in the same padded branch as in the buggy “memcpy(tmp, info, info_len)” (pre-patch) in [PATCH_DIFF]/[FILE_CONTENT]. Reduce FPs by requiring that S in the copy is the same variable whose length was measured (dataflow from S in strlen to memcpy source).

6) Step 6: Ensure the memcpy occurs before any reassignment of S to the padded buffer — e.g., S is still the original pointer at copy time (as info was reassigned to tmp only after memcpy in [FILE_CONTENT]). This avoids flagging cases where both source and destination are the padded buffer.

7) Step 7: Exclude the fixed pattern — if a separate variable C is captured before rounding (e.g., “size_t copy_len = info_len;”) and the copy size equals C (not the padded L), do not report, per the fix in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. This reduces FPs and aligns with the intended remediation.

8) Step 8: Consider unguarded rounding variants — optionally flag cases where L is rounded unconditionally then used as memcpy size from S, but deprioritize unless there is evidence L may increase (e.g., presence of round_up and prior L from strlen) to limit FPs. This extends coverage beyond the specific modulo-guard form in [ROOTCAUSE_ANALYSIS].

9) Step 9: Restrict to memcpy/memmove-like raw copies — exclude safer string APIs (strscpy, strlcpy) and cases where the copy size is explicitly min(original_length, padded_length). This focuses on the OOB-read mechanism described in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Assignments where a size is derived from string length functions (strlen, strnlen).
- Conditional checks involving modulo of that size (L % K).
- Reassignments applying rounding/alignment to that size (e.g., round_up).
- Allocation sites that use the padded size.
- memcpy/memmove call sites and their source/destination/size arguments.
- Variable reassignments of the source pointer around the copy.

4. Dataflow / Taint Considerations
- Track dataflow from source pointer S into the strlen result L0 and then into the rounded L.
- Track control-flow predicates ensuring L % K != 0 before rounding, establishing L > L0 on that path.
- Track that the memcpy/memmove size argument is L (rounded) while the source argument aliases S (pre-padded).
- Track that the destination aliases the allocation using L, and that S is not yet reassigned to the padded buffer at copy time.
- Recognize and exempt flows where a distinct preserved pre-rounded size variable is used for the copy.

5. Validation & Test Cases
- Positive: Pre-patch pattern from [FILE_CONTENT] — info_len = strlen(info); if (info_len % 4) { info_len = round_up(info_len, 4); tmp = kzalloc(info_len); memcpy(tmp, info, info_len); } → flagged.
- Negative: Patched pattern from [PATCH_DIFF] — copy_len = info_len; info_len = round_up(info_len, 4); tmp = kzalloc(info_len); memcpy(tmp, info, copy_len); → not flagged.
- Negative: Using strscpy or memcpy with the original (unrounded) length or min(original, padded) → not flagged.
- Test harness notes: Ensure path-sensitivity (within the padding branch), dataflow tracking across simple reassignments, and recognition of kernel-specific round_up and allocation functions.

6. Estimated Effort & Priority
Medium effort and priority; the pattern is concise and well-scoped, and it generalizes to similar padding bugs as highlighted in [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Source buffers that are actually larger than the strlen value due to manual padding: require the modulo-guard and explicit round_up evidence.
- Custom alignment logic instead of round_up: restrict initial version to known round_up-like calls to reduce FPs.
- Cases where S is reassigned to the padded buffer before copy: enforce ordering check (Step 6).

8. Limitations & Assumptions
- Assumes the analyzer can recognize round_up semantics and modulo guards; custom rounding patterns may not be detected.
- Cannot prove actual memory bounds of S at runtime; relies on the logical guarantee from L % K != 0 and round_up that the padded L exceeds the measured string length (per [ROOTCAUSE_ANALYSIS]).
- Focused on memcpy/memmove; other copy primitives are not comprehensively covered unless enumerated.