1. Plan Summary
Detect missing NULL-checks after kunit_kzalloc() allocations when the returned pointer is dereferenced or passed to known dereferencing APIs (e.g., sg_alloc_table) before validation, leading to potential NULL pointer dereference (as in CVE-2025-38274).

2. Detection Steps
1) Step 1: Objective — identify allocation sites returning heap pointers via kunit_kzalloc. Signals — calls to kunit_kzalloc assigned to a pointer-typed local variable. FP mitigation — restrict to intraprocedural analysis and to variables directly assigned from kunit_kzalloc (based on PATCH_DESCRIPTION and FILE_CONTENT).

2) Step 2: Objective — identify first potentially hazardous uses of the allocated pointer. Signals — any of: member access through the pointer (ptr->field), unary dereference, or passing the pointer as an argument to known sinks (sg_alloc_table as first parameter). FP mitigation — ignore uses in NULL-check conditions, sizeof, or debug-only contexts; treat sg_alloc_table as a concrete high-confidence sink (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).

3) Step 3: Objective — recognize path-dominating validation guards on the allocated pointer. Signals — calls to KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr) or KUNIT_ASSERT_FALSE(test, IS_ERR_OR_NULL(ptr)) that dominate the hazardous use along all paths. FP mitigation — only consider ASSERT-style macros as path-terminating guards; do not treat KUNIT_EXPECT_* as sufficient (based on FILE_CONTENT and PATCH_DESCRIPTION).

4) Step 4: Objective — ensure the validation actually precedes the first hazardous use along all control-flow paths. Signals — dominance check: the assertion occurs on all paths from the allocation to the sink/use. FP mitigation — if any path reaches the sink/use without a prior dominating assert/guard, report.

5) Step 5: Objective — prioritize known dangerous call-site sink. Signals — call expression to sg_alloc_table where the first argument is the allocated pointer variable. Why — sg_alloc_table ultimately calls memset on the pointer, which dereferences it (based on ROOTCAUSE_ANALYSIS). FP mitigation — this specific signature yields high confidence.

6) Step 6: Objective — catch generic dereferences when no known sink is present. Signals — AST patterns of ptr->field or *ptr on the allocated variable. FP mitigation — exclude occurrences within explicit NULL checks (if (!ptr) ...), within guards that immediately return/abort, or right-hand sides guarded by dominating assertions.

7) Step 7: Objective — account for immediate-use pattern after allocation. Signals — hazardous use appearing with minimal intervening statements after kunit_kzalloc (e.g., next few statements). Why — mirrors the pre-patch flaw where sg_alloc_table immediately follows allocation (based on PATCH_DIFF). FP mitigation — raise priority for “immediate use without check” while still reporting longer-range cases.

8) Step 8: Objective — handle simple aliasing of the allocated pointer. Signals — direct assignments (q = ptr) and simple parameter passing within the same function before the hazardous use. FP mitigation — limit to intraprocedural flow and single-level aliases to reduce noise.

9) Step 9: Objective — distinguish safe early exits. Signals — paths where a NULL-check leads to function return, goto error, or KUnit ASSERT that aborts test execution prior to the hazardous use. FP mitigation — if such a guard dominates the sink, suppress the alert.

10) Step 10: Objective — produce actionable diagnostics. Signals — include the allocation site, the first hazardous use site (e.g., sg_alloc_table call or member deref), and absence of a dominating KUNIT_ASSERT_NOT_ERR_OR_NULL. FP mitigation — suggest inserting the assertion immediately after allocation (based on PATCH_DESCRIPTION fix).

3. Target Elements
- Function bodies (intraprocedural).
- Allocation call sites: kunit_kzalloc return-value assignments.
- Pointer dereference expressions: member access (->), unary *.
- Call sites to known dereferencing APIs: sg_alloc_table with allocated pointer as first argument.
- Condition checks and assertions: KUNIT_ASSERT_NOT_ERR_OR_NULL, KUNIT_ASSERT_FALSE(IS_ERR_OR_NULL(...)), explicit if (!ptr) guards.
- Control-flow edges to evaluate dominance between allocation, checks, and uses.

4. Dataflow / Taint Considerations
- Track the pointer returned by kunit_kzalloc to its first hazardous use along control-flow.
- Allow simple aliases via direct assignments and simple rebindings within the same function.
- Model path-dominating guards: assertions and if-conditions that abort/return before the hazardous use.
- Treat KUNIT_ASSERT_* as path-terminating for the guarded variable; do not treat KUNIT_EXPECT_* as terminating.

5. Validation & Test Cases
- Positive: Pre-patch fpga_mgr_test_img_load_sgt — sgt allocated with kunit_kzalloc, immediately passed to sg_alloc_table without a prior ASSERT; expect a finding (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS).
- Negative: Patched fpga_mgr_test_img_load_sgt — ASSERT inserted immediately after allocation; no finding (based on PATCH_DIFF).
- Negative: init_test_buffer — kunit_kzalloc followed by KUNIT_ASSERT_NOT_ERR_OR_NULL before any deref; no finding (based on FILE_CONTENT).
- Positive: A synthetic test where sgt = kunit_kzalloc(...); sgt->sgl used before any check; expect a finding.
- Test harness notes: Run intraprocedural analysis over KUnit tests (functions taking struct kunit *), and validate dominance of assertions over uses.

6. Estimated Effort & Priority
Medium effort and High priority for kernel KUnit code, as missing checks can cause kernel crashes during testing (based on ROOTCAUSE_ANALYSIS).

7. Likely False-Positive Sources & Mitigations
- Functions that internally guarantee non-NULL returns from kunit_kzalloc in specific environments: mitigate by focusing on actual dereferences/sinks rather than allocation alone.
- Checks performed in helper functions or macros not recognized: mitigate by limiting to dominating in-function guards and well-known assertion macros.
- Passing the pointer to functions that are NULL-tolerant: mitigate by prioritizing known dangerous sinks (sg_alloc_table) and generic explicit dereferences.

8. Limitations & Assumptions
- Assumes kunit_kzalloc can return NULL and requires explicit validation (based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS).
- Only sg_alloc_table is confirmed as a dangerous sink from supplied materials; other sinks are treated generically via dereference patterns, not by name.
- Interprocedural validation (checks in callees) is not covered; the plan assumes checks should occur in the same function before use.
- Recognition of assertion macros is limited to those evident in the provided code: KUNIT_ASSERT_NOT_ERR_OR_NULL and KUNIT_ASSERT_FALSE(IS_ERR_OR_NULL(...)).