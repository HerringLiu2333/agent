1. Plan Summary
Detect unchecked results of kunit_kzalloc that are subsequently used as if non-NULL (e.g., passed to sg_alloc_table or dereferenced), matching the pre-patch flaw that caused a NULL pointer dereference.

2. Detection Steps
1) Step 1: Objective — Identify allocation sites that may return NULL. Signals — Calls to kunit_kzalloc whose return value is stored in a pointer variable. FP mitigation — Restrict to allocations whose result is stored and used later (not immediately asserted or discarded).

2) Step 2: Objective — Establish the usage paths of the allocated pointer. Signals — Path-sensitive tracking from the allocation variable to its first non-trivial uses (function arguments, member access, or dereference). FP mitigation — Ignore uses dominated by an immediate guard/assertion that enforces non-NULL.

3) Step 3: Objective — Detect calls that are known to dereference the pointer. Signals — Passing the allocated pointer as the first argument to sg_alloc_table, as per the described path to __sg_alloc_table and memset on the pointer. FP mitigation — Require that this call occurs on a path without a prior dominating non-NULL check.

4) Step 4: Objective — Detect direct dereference of the allocated pointer. Signals — Member access on the pointer (e.g., sgt->...) or other operations that dereference it before any validation. FP mitigation — Ensure the dereference appears on a path without a dominating non-NULL check.

5) Step 5: Objective — Recognize the specific intended guard used in the fix. Signals — Presence of KUNIT_ASSERT_NOT_ERR_OR_NULL(test, <var>) that dominates the sink (sg_alloc_table call or dereference). FP mitigation — Treat this assertion as sufficient to discharge the alert on guarded paths.

6) Step 6: Objective — Identify equivalent control-flow validations that abort on NULL before the sink. Signals — A conditional that checks the allocation variable for NULL and performs an aborting action (e.g., early return from the test) that post-dominates the NULL branch before the sink. FP mitigation — Only accept guards that syntactically dominate the sink and ensure the sink is unreachable when the pointer is NULL.

7) Step 7: Objective — Confirm the vulnerability pattern matches the root cause. Signals — The specific sequence: kunit_kzalloc result not validated, then used in sg_alloc_table or dereferenced (consistent with [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation — Require that no intervening function calls reassign the pointer to a known non-NULL value before the sink.

8) Step 8: Objective — Reduce noise by focusing on KUnit test contexts where this pattern was observed. Signals — Enclosing function taking struct kunit *test or presence of KUnit assertion APIs in the same function. FP mitigation — Preferentially rank or restrict results to such contexts to match [PATCH_DESCRIPTION]; optionally report others with lower confidence.

3. Target Elements
- Function definitions (to detect KUnit test context via struct kunit *test parameter).
- Call sites to kunit_kzalloc (allocation sites).
- Variables receiving allocation results.
- Call sites to sg_alloc_table (sinks known to dereference the pointer).
- Member access or dereference expressions on the allocated pointer (additional sinks).
- Assertion/check calls (notably KUNIT_ASSERT_NOT_ERR_OR_NULL) and conditional guards.
- Control-flow constructs for dominance and reachability (guards vs. sinks).

4. Dataflow / Taint Considerations
- Track the allocation result variable from kunit_kzalloc through assignments, aliases, and argument passing to identify its uses.
- Define sinks as: (a) argument position 1 of sg_alloc_table, (b) any dereference/member access of the pointer.
- Require that the path from allocation to sink is not dominated by a guard that ensures non-NULL (e.g., KUNIT_ASSERT_NOT_ERR_OR_NULL or an aborting NULL-check).
- Treat reassignments that overwrite the variable with a non-NULL guaranteed value as stopping conditions.

5. Validation & Test Cases
- Positive: Function with struct kunit *test; sgt = kunit_kzalloc(...); ret = sg_alloc_table(sgt, ...); no prior check on sgt — expect a finding.
- Positive: sgt = kunit_kzalloc(...); sg_init_one(sgt->sgl, ...); no prior check — expect a finding.
- Negative: sgt = kunit_kzalloc(...); KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt); sg_alloc_table(sgt, ...); — expect no finding.
- Negative: sgt = kunit_kzalloc(...); if (!sgt) return; sg_alloc_table(sgt, ...); — expect no finding.
- Test harness notes: Include cases with simple aliases (e.g., tmp = sgt; sg_alloc_table(tmp, ...)) and ensure dominance analysis correctly recognizes guards preceding both sgt and its aliases.

6. Estimated Effort & Priority
Medium effort and medium priority; pattern is localized (single allocator and a small set of sinks) with straightforward path and dominance analysis.

7. Likely False-Positive Sources & Mitigations
- Guards not recognized due to complex control flow or macro-based assertions — mitigate by conservative dominance checks and explicitly recognizing KUNIT_ASSERT_NOT_ERR_OR_NULL as per the fix.
- Aliasing through multiple variables obscuring guards — mitigate with basic alias tracking from the allocation to sinks.
- Paths where the pointer is reassigned to a valid object before the sink — mitigate by terminating flows when a definite non-NULL assignment occurs.

8. Limitations & Assumptions
- Assumes sg_alloc_table dereferences its first argument, based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; other sinks are not enumerated.
- Focuses on kunit_kzalloc as the allocator implicated by [PATCH_DIFF]; other allocators are out of scope.
- Assumes KUNIT_ASSERT_NOT_ERR_OR_NULL aborts the test on failure as per [PATCH_DESCRIPTION]; other assertion semantics are not inferred.
- Interprocedural propagation beyond the current function is not guaranteed; deep aliasing or complex macros may require additional modeling.