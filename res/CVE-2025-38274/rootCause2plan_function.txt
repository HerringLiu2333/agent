1. Plan Summary
Detect KUnit test code that allocates a pointer with kunit_kzalloc and then uses it (e.g., passing to sg_alloc_table or dereferencing) without first asserting or checking against NULL, which can lead to a NULL pointer dereference.

2. Detection Steps
1) Step 1: Objective: find allocation sites returning a potentially NULL pointer. Signals: a variable assigned from a call to kunit_kzalloc(...) as shown in fpga_mgr_test_img_load_sgt (FUNCTION_CONTENT). FP mitigation: restrict to functions that use KUnit constructs (KUNIT_* macros or struct kunit * parameter) per FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS.

2) Step 2: Objective: identify the function context to focus on KUnit tests. Signals: the enclosing function takes struct kunit * as a parameter or contains KUNIT_ASSERT/KUNIT_EXPECT macros (FUNCTION_CONTENT). FP mitigation: exclude non-KUnit functions to align with the affected subsystem (ROOTCAUSE_ANALYSIS).

3) Step 3: Objective: track the pointer value from allocation to first use. Signals: the allocated variable (e.g., sgt) is used as an argument to sg_alloc_table(...) or is dereferenced via field access (sgt->...) (FUNCTION_CONTENT, PATCH_DESCRIPTION). FP mitigation: limit to intra-procedural paths and the immediate first use after allocation to reduce path explosion.

4) Step 4: Objective: determine if a NULL-check/assertion guards the pointer before use. Signals: presence of KUNIT_ASSERT_NOT_ERR_OR_NULL(test, var) or KUNIT_ASSERT_FALSE(test, IS_ERR_OR_NULL(var)) on the same variable before the first use (PATCH_DIFF, FUNCTION_CONTENT). FP mitigation: treat these assertions as sufficient guards; if present, do not flag.

5) Step 5: Objective: flag unguarded calls passing the allocated pointer to sg_alloc_table. Signals: sg_alloc_table(var, ...) where var originates from kunit_kzalloc and no prior NULL-check/assertion exists (FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS, PATCH_DESCRIPTION). FP mitigation: require the call to occur before any guard and within the same function block.

6) Step 6: Objective: flag unguarded dereferences of the allocated pointer. Signals: field access on the allocated variable (e.g., sgt->sgl) occurs before any NULL-check/assertion (FUNCTION_CONTENT). FP mitigation: exclude cases where a guard appears in control-flow predecessors (simple dominance analysis).

7) Step 7: Objective: avoid mistaking unrelated checks as guards. Signals: ignore checks/asserts on other variables (e.g., KUNIT_ASSERT_EQ(test, ret, 0) after sg_alloc_table) because they don't validate the allocated pointer itself (FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS). FP mitigation: confirm the check’s operand is the allocated variable, not a different variable like ret.

8) Step 8: Objective: strengthen confidence by type/context. Signals: the allocated variable is declared as struct sg_table * and used with sg_alloc_table or sg_init_one consistent with FUNCTION_CONTENT. FP mitigation: prioritize matches with this type to reduce generic-pointer false positives.

9) Step 9: Objective: confirm potential dereference by downstream semantics. Signals: calls to sg_alloc_table(...) on a potentially NULL sgt are known to forward to __sg_alloc_table and memset(), which dereferences sgt (PATCH_DESCRIPTION, ROOTCAUSE_ANALYSIS). FP mitigation: only apply this semantic risk to the specific callee sg_alloc_table as evidenced.

10) Step 10: Objective: report only when the dangerous use occurs immediately after allocation. Signals: the first use (call or deref) appears with no intervening guard statements between the allocation and the use (FUNCTION_CONTENT pre-patch ordering). FP mitigation: require proximity (e.g., within a few statements) to reduce noise.

3. Target Elements
- Function definitions that accept struct kunit * or use KUNIT_* macros.
- Call sites to kunit_kzalloc with assigned results.
- Variables of type struct sg_table * produced by kunit_kzalloc.
- Call sites to sg_alloc_table and sg_init_one using the allocated variable.
- Field dereferences of the allocated variable (e.g., var->member).
- Assertion/check macros: KUNIT_ASSERT_NOT_ERR_OR_NULL, KUNIT_ASSERT_FALSE with IS_ERR_OR_NULL, and IS_ERR_OR_NULL usage.

4. Dataflow / Taint Considerations
- Track the pointer value from the kunit_kzalloc assignment to its first use (argument passing or dereference) within the same function.
- Model guards as sanitizers: any prior assertion/check on the same variable (KUNIT_ASSERT_NOT_ERR_OR_NULL or IS_ERR_OR_NULL-based) stops the flow.
- Restrict to intra-procedural flow and immediate post-allocation paths to match the pre-patch flaw pattern.

5. Validation & Test Cases
- Positive: the pre-patch fpga_mgr_test_img_load_sgt where sgt = kunit_kzalloc(...); sg_alloc_table(sgt, ...) and sgt->sgl appear with no KUNIT_ASSERT_NOT_ERR_OR_NULL before use (FUNCTION_CONTENT).
- Negative: the patched version with KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt) immediately after allocation (PATCH_DIFF), then sg_alloc_table and sgt->sgl; should not be flagged.
- Negative: fpga_mgr_test_init where allocations are followed by KUNIT_ASSERT_NOT_ERR_OR_NULL or KUNIT_ASSERT_FALSE(IS_ERR_OR_NULL(...)) on the allocated objects (FUNCTION_CONTENT); should not be flagged.
- Test harness notes: run on KUnit test files containing kunit_kzalloc patterns and verify only the unguarded immediate-use cases are reported.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where custom guards exist not recognized as KUNIT_ASSERT_NOT_ERR_OR_NULL or IS_ERR_OR_NULL; mitigate by limiting recognized guards to those shown in FUNCTION_CONTENT.
- Aliasing where the pointer is validated through another alias; mitigate by focusing on the direct variable assigned from kunit_kzalloc and its immediate use.
- Functions other than sg_alloc_table that may or may not dereference the pointer; mitigate by only treating sg_alloc_table as dangerous per PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS.

8. Limitations & Assumptions
- The plan assumes kunit_kzalloc may return NULL (PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS); other allocators are not considered due to lack of evidence.
- Only sg_alloc_table is treated as a downstream dereferencer based on provided analysis; other callees’ semantics are not determinable from inputs.
- Guard recognition is limited to KUNIT_ASSERT_NOT_ERR_OR_NULL and IS_ERR_OR_NULL-based assertions seen in FUNCTION_CONTENT; other valid guard patterns may be missed.