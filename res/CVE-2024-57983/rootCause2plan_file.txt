1. Plan Summary
Detect array size vs loop-bound mismatches where a per-channel array is undersized (e.g., CHANS-1) but accessed across all channels (e.g., i < CHANS), leading to out-of-bounds writes/reads as in the TH1520 mailbox suspend/resume paths.

2. Detection Steps
1) Step 1: Objective — Identify candidate arrays sized by a channel-count constant. Signals — Array declarations whose size expression directly references a macro/constant like TH_1520_MBOX_CHANS, especially with a “- 1” adjustment (based on PATCH_DIFF/FILE_CONTENT). FP mitigation — Exclude arrays without a symbolic link to a single “count” constant or with non-constant size.

2) Step 2: Objective — Find loops that iterate over the full channel count. Signals — For-loops initializing an induction variable to 0 and comparing with a bound that directly references the same macro/constant (e.g., i < TH_1520_MBOX_CHANS) as shown in the suspend/resume functions (FILE_CONTENT). FP mitigation — Require monotonic increment (i++/+=1) and a strict less-than condition to conservatively infer the maximum index is bound-1.

3) Step 3: Objective — Match array uses within such loops. Signals — Array element access where the indexed array is the one from Step 1 and the index expression is the loop’s induction variable (exactly or plus/minus zero), e.g., ctx->intr_mask[i] (FILE_CONTENT). FP mitigation — Exclude accesses guarded by conditions that demonstrably prevent the final iteration from indexing the last element (e.g., i < CHANS-1 inside the loop).

4) Step 4: Objective — Determine size-vs-bound inconsistency. Signals — Symbolic/constant comparison showing the array declared length D equals CHANS - k (k ≥ 1) while the loop bound B equals CHANS; infer B-1 ≥ D, hence potential OOB when i = D (ROOTCAUSE_ANALYSIS). FP mitigation — Require that the same macro/constant drives both D and B (semantic equivalence, not just textual), to avoid coincidental matches.

5) Step 5: Objective — Confirm write semantics (higher severity for OOB write). Signals — Within the loop, a write to the array element (e.g., ctx->intr_mask[i] = ioread32(...)) as in th1520_mbox_suspend_noirq (FILE_CONTENT). FP mitigation — Prioritize/report only when a write occurs; optionally downgrade to warning if only reads are detected.

6) Step 6: Objective — Confirm read-after-write or write-from-array patterns that propagate corruption. Signals — In a sibling loop with the same bound, reading from the same array element and passing to MMIO write (e.g., iowrite32(ctx->intr_mask[i], ...)) as in th1520_mbox_resume_noirq (FILE_CONTENT/ROOTCAUSE_ANALYSIS). FP mitigation — If both save (write) and restore (read) loops exist, raise confidence; otherwise, keep as potential but note single-sided risk.

7) Step 7: Objective — Elevate likelihood for heap-based corruption. Signals — The array resides in a struct type allocated via kzalloc/devm_kzalloc (e.g., ctx from devm_kzalloc in th1520_mbox_init_generic) (FILE_CONTENT). FP mitigation — Require proven heap allocation for “heap OOB” classification; otherwise classify as “potential OOB”.

8) Step 8: Objective — Reduce false positives from arrays that intentionally exclude one channel. Signals — If the array is sized CHANS-1 but is not directly indexed by i; instead, it is indexed by a different variable with selective increments or guarded by conditions (e.g., remote_icu[remote_idx] with remote_idx incremented only when i != KERNEL_CPU0) (FILE_CONTENT). FP mitigation — Only flag when the loop’s induction variable drives the array index directly (or via trivial identity), not when an alternative index with compensating logic is used.

9) Step 9: Objective — Prioritize power-management context where impact is severe. Signals — Functions named in PM callbacks or within CONFIG_PM_SLEEP regions (e.g., th1520_mbox_suspend_noirq/th1520_mbox_resume_noirq referenced by dev_pm_ops) (FILE_CONTENT). FP mitigation — Use this as a ranking/priority signal, not a hard filter, to still catch the general class elsewhere.

10) Step 10: Objective — Aggregate evidence and report. Signals — Emit an alert when Steps 1–4 are satisfied, with higher confidence if Steps 5–7 apply and lower if only partial signals exist (ROOTCAUSE_ANALYSIS). FP mitigation — Suppress if proof shows max index < declared length, or if a prior guard ensures i never reaches the out-of-bounds index.

3. Target Elements
- Array declarations (especially struct fields) whose size uses a shared channel-count macro/constant.
- For-loops with canonical induction over the channel count.
- Array index expressions inside loop bodies.
- Memory allocation sites for the containing struct (e.g., kzalloc/devm_kzalloc).
- PM callback functions and regions under CONFIG_PM_SLEEP and dev_pm_ops hooks.

4. Dataflow / Taint Considerations
- Track symbolic equivalence between the array size macro and the loop bound macro to compare D vs B.
- Track the loop induction variable to the array index expression; allow only trivial identity mappings (i or i + 0).
- Track writes to and reads from the array within the loop to classify OOB write vs read.
- Track allocation flow to determine heap-based nature (struct allocated via kzalloc/devm_kzalloc).

5. Validation & Test Cases
- Positive: Array u32 intr_mask[TH_1520_MBOX_CHANS - 1]; loop for (i = 0; i < TH_1520_MBOX_CHANS; i++) { ctx->intr_mask[i] = ioread32(...); } and a counterpart restore loop reading intr_mask[i] into iowrite32 (as in FILE_CONTENT and ROOTCAUSE_ANALYSIS). Expect a high-confidence report.
- Negative: Array sized u32 arr[TH_1520_MBOX_CHANS - 1]; loop for (i = 0; i < TH_1520_MBOX_CHANS - 1; i++) arr[i] = ...; Expect no report.
- Negative: Array u32 remote_icu[TH_1520_MBOX_CHANS - 1]; loop over i < TH_1520_MBOX_CHANS but indexing remote_icu[remote_idx] with guarded increments when i != KERNEL_CPU0 (FILE_CONTENT). Expect no report due to non-identity index and compensating control flow.
- Test harness notes: Enable macro evaluation so TH_1520_MBOX_CHANS folds to a constant; ensure CONFIG_PM_SLEEP regions are parsed to pick up suspend/resume functions.

6. Estimated Effort & Priority
Medium — Requires AST matching with simple symbolic reasoning and loop bound/index analysis; high security impact per ROOTCAUSE_ANALYSIS.

7. Likely False-Positive Sources & Mitigations
- Non-canonical loops where guards effectively cap the index below the undersized boundary; mitigation: require proof of direct induction variable indexing without protective guards.
- Arrays intentionally smaller than the full set, using a remapped index variable; mitigation: require direct use of the loop variable as the index (identity mapping).
- Macros not resolvable in the analysis context; mitigation: degrade to low confidence or skip when constants cannot be compared.

8. Limitations & Assumptions
- Assumes the analyzer can resolve macro-based constants and perform simple arithmetic comparisons (E.g., CHANS vs CHANS-1) as seen in PATCH_DIFF/FILE_CONTENT.
- Does not handle complex index arithmetic or data-dependent loop bounds; focuses on canonical for-loops.
- Cannot prove runtime reachability of PM paths (CONFIG_PM_SLEEP); relies on syntactic presence (FILE_CONTENT).
- The plan is grounded in the specific pattern from ROOTCAUSE_ANALYSIS and may miss structurally dissimilar manifestations.