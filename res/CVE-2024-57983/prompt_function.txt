1. CVE Identifier
CVE-2024-57983

2. Vulnerability Type
Out-of-bounds write/read (buffer overflow) due to incorrect array size

3. Root Cause Summary
The driver’s suspend/resume context buffer was undersized by one element: struct th1520_mbox_context declared intr_mask[TH_1520_MBOX_CHANS - 1] while the code in th1520_mbox_suspend_noirq and th1520_mbox_resume_noirq saves/restores all TH_1520_MBOX_CHANS interrupt mask registers. This off-by-one sizing mismatch caused the last register access to go past the end of the array, corrupting adjacent memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Mailbox driver for T-head TH1520 (drivers/mailbox/mailbox-th1520.c), power-management suspend/resume context under CONFIG_PM_SLEEP.

2) Pre-Patch Flaw:
An array in the PM context struct was defined one element too small relative to the actual number of mask registers handled. Evidence: in mailbox-th1520.c, under CONFIG_PM_SLEEP, “u32 intr_mask[TH_1520_MBOX_CHANS - 1];” is used to store ICU0 interrupt mask registers, but the functions operate on all TH_1520_MBOX_CHANS (four) registers.

3) Trigger Condition:
During system-wide suspend/resume (noirq) when th1520_mbox_suspend_noirq saves and th1520_mbox_resume_noirq restores the interrupt mask registers for MBOX ICU0 with CONFIG_PM_SLEEP enabled.

4) Impact Mechanism:
Saving/restoring four registers into a three-element array results in an out-of-bounds write on suspend and a corresponding out-of-bounds read on resume, corrupting adjacent kernel memory within the driver’s context and potentially leading to crashes or undefined behavior.

5. Patch Analysis
1) Fix Approach:
Correct the buffer sizing to match the number of registers accessed, eliminating the off-by-one and preventing out-of-bounds accesses.

2) Key Code Changes:
In struct th1520_mbox_context, intr_mask size changed from “[TH_1520_MBOX_CHANS - 1]” to “[TH_1520_MBOX_CHANS]” (mailbox-th1520.c, around line 41 in the diff hunk).

3) Locking/Concurrency Impact:
No locking or ordering changes; the fix solely adjusts memory bounds and does not affect concurrency or synchronization.

6. Broader Kernel Security Implications
Off-by-one array sizing errors in low-level suspend/resume paths can silently corrupt kernel memory, risking system instability or denial of service during PM transitions. While exploitation specifics are hardware and layout-dependent, such memory corruption can, in principle, facilitate further exploitation if critical control data is overwritten. Ensuring buffer sizes align precisely with loop bounds and hardware register counts is essential for robust kernel driver security, particularly in PM contexts where diagnostics and recovery are limited.