1. Plan Summary
Detect off-by-one out-of-bounds read/write caused by arrays sized one element smaller than the number of elements accessed in suspend/resume paths, as exemplified by intr_mask[TH_1520_MBOX_CHANS - 1] being iterated over TH_1520_MBOX_CHANS elements.

2. Detection Steps
1) Step 1: Objective: Identify candidate undersized arrays. Signals: Array or struct-field declarations whose size is an expression of the form (C − 1) or otherwise one less than a count macro/constant C (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Prefer arrays declared within CONFIG_PM_SLEEP blocks or used in PM context (as in [PATCH_DIFF]).

2) Step 2: Objective: Link arrays to PM suspend/resume usage. Signals: References to these arrays inside functions whose names include “suspend” or “resume” (e.g., “_suspend_noirq”/“_resume_noirq” per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Require at least one access path within a suspend/resume-named function; deprioritize arrays never touched in such functions.

3) Step 3: Objective: Find loop-driven accesses that imply accessing C elements. Signals: For/while loops in those functions where the loop bound uses the same C macro/constant that appeared in the array size (but without the “− 1”), e.g., i from 0 up to C (exclusive) per [ROOTCAUSE_ANALYSIS] statement “saves/restores all TH_1520_MBOX_CHANS registers.” FP mitigation: Ensure the bound comparison is a standard increasing loop form (i = 0; i < C; i++), not an over-approximation; ignore non-monotonic loops.

4) Step 4: Objective: Confirm array element access is indexed by the loop iterator tied to C. Signals: Array[index] reads or writes where index is the loop variable from Step 3. FP mitigation: Exclude cases where the index is transformed by a clamp check comparing against the array length (e.g., an explicit guard using sizeof(array)/sizeof(array[0])).

5) Step 5: Objective: Compute and compare effective array length vs. maximum index used. Signals: Static evaluation that array length L equals (C − 1) while the loop guarantees an iteration that uses index C − 1, implying index == L (OOB) as per [ROOTCAUSE_ANALYSIS]. FP mitigation: Only flag when L and C can be resolved to related compile-time expressions (same macro identifier C appears in both).

6) Step 6: Objective: Distinguish write vs. read to prioritize memory corruption risks. Signals: Identify write accesses (e.g., assignment to array element) in suspend paths and read accesses in resume paths, matching the described “save and restore” pattern ([PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS]). FP mitigation: Elevate findings where both a write in a suspend-like function and a read in a resume-like function exist for the same array and index range.

7) Step 7: Objective: Tie accesses across both functions to the same array field/instance. Signals: Alias/field resolution that the array referenced in suspend and resume is the same struct field (as with struct th1520_mbox_context.intr_mask in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Require consistent field symbol identity; ignore accesses to unrelated arrays.

8) Step 8: Objective: Respect conditional compilation context aligning with PM. Signals: Ensure the array declaration or its use is within or reachable only under CONFIG_PM_SLEEP (per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: If preprocessor conditions cannot be resolved, retain but lower confidence unless function names clearly indicate PM paths.

9) Step 9: Objective: Exclude cases where array size equals C or loop bound equals the array length. Signals: Negative check that the array length is not exactly C and that the loop bound is not derived from array length (e.g., computed length macro). FP mitigation: Require that the loop bound strictly exceeds array length by at least 1 in the worst iteration.

10) Step 10: Objective: Reduce noise from dead/unreachable code. Signals: Basic reachability checks (no unconditional returns/breaks preventing final iteration) ensuring the iteration that hits index C − 1 is feasible. FP mitigation: Ignore loops with guards that provably terminate before reaching index C − 1.

3. Target Elements
- Array and struct-field declarations with compile-time sizes, especially under CONFIG_PM_SLEEP.
- Macros/constants used to define array sizes and loop bounds (e.g., TH_1520_MBOX_CHANS per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Functions whose names include “suspend” or “resume” (e.g., th1520_mbox_suspend_noirq and th1520_mbox_resume_noirq in [PATCH_DESCRIPTION]).
- For/while loops and their bound conditions.
- Array indexing expressions (reads and writes) using loop indices.
- Preprocessor conditionals guarding PM context (CONFIG_PM_SLEEP).

4. Dataflow / Taint Considerations
- Track the loop index variable from initialization to use in array indexing; confirm its bound is tied to macro C.
- Propagate constant/macro values symbolically to compare array length (C − 1) vs. loop bound C.
- Track field references to ensure suspend and resume functions operate on the same array field instance.
- Detect guarding conditions that cap the index to array length and use them to suppress reports.

5. Validation & Test Cases
- Positive: A struct under CONFIG_PM_SLEEP declares arr[C − 1]; a suspend_noirq function loops i = 0; i < C; i++ and writes arr[i]; a resume_noirq function loops over i < C and reads arr[i]. Expect a report indicating OOB at index C − 1 (based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
- Negative: Same code but arr sized as arr[C]; expect no report (matches [PATCH_DIFF] fix).
- Negative: Loop bound uses i < (sizeof(arr)/sizeof(arr[0])) or i < C − 1; expect no report.
- Negative: Array sized C − 1 but loop breaks before i reaches C − 1; expect no report.

- Test harness notes: Parameterize C as a macro to ensure the checker identifies shared macro usage across array size and loop bounds; include CONFIG_PM_SLEEP guards to verify conditional handling.

6. Estimated Effort & Priority
Medium. The pattern is well-scoped and high impact per [ROOTCAUSE_ANALYSIS], but requires careful constant/macro matching and basic reachability reasoning.

7. Likely False-Positive Sources & Mitigations
- Arrays intentionally sized smaller than a larger domain constant C but with internal guards: mitigate by requiring evidence of an actual access at index equal to array length.
- Unresolved macros/preprocessor paths: mitigate by correlating function names (suspend/resume) and requiring both write and read patterns.
- Aliasing to larger backing storage: mitigate by focusing on direct array field indexing rather than pointer arithmetic from unknown bases.

8. Limitations & Assumptions
- Assumes array size and loop bounds can be resolved to comparable forms (e.g., both reference the same macro C), as inferred from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].
- Lacks function bodies in [FUNCTION_CONTENT]; the plan presumes standard loop idioms (i from 0 to C) used in th1520_mbox_suspend_noirq/resume_noirq per [ROOTCAUSE_ANALYSIS].
- Does not verify domain semantics (e.g., “interrupt mask registers”) beyond function naming and CONFIG_PM_SLEEP context from [PATCH_DESCRIPTION]/[PATCH_DIFF].