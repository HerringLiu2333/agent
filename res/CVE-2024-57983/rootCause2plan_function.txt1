1. Plan Summary
Detect fixed-size arrays whose declared length is off-by-one smaller than the number of elements subsequently accessed (e.g., size uses CONST-1 while loops index up to CONST), leading to out-of-bounds read/write.

2. Detection Steps
1) Step 1: Identify candidate arrays — fixed-size arrays declared in structs where the dimension is a constant or macro expression (e.g., TH_1520_MBOX_CHANS or arithmetic with it). Record the array field, its dimension expression, and any referenced symbol(s) in that expression.
2) Step 2: Classify the dimension expression — determine whether it is exactly a named constant K or a stricter bound such as K-1 (or any expression provably less than K by simple algebra). Mark arrays whose size is K-1 as “suspect” with respect to K.
3) Step 3: Find array index uses — locate all occurrences of indexing into the candidate field (arr[idx]) or equivalent pointer arithmetic on that field. For each, collect the index expression and whether it is part of a write (assignment to arr[idx], passing arr[idx] as an out-parameter) or a read.
4) Step 4: Extract loop bounds — for each index use, identify the enclosing loop controlling idx and extract the loop’s upper bound form (e.g., idx < U, idx <= U-1, 0..U-1). Record U and the symbol(s) it references.
5) Step 5: Match symbols across size and use — check if the loop bound U references the same symbol K that appears in the array dimension. Prefer syntactic or simple algebraic matches (e.g., U == K or U-1 == K-1).
6) Step 6: Detect off-by-one mismatch — flag when: (a) the array size is K-1 (or otherwise provably < K), and (b) there exists a use where the loop iterates up to K elements (e.g., idx < K or idx <= K-1), implying idx can reach K-1 while the array only has 0..K-2 valid indices.
7) Step 7: Detect non-loop direct OOB indices — also flag if there is any direct index into the array using K-1 (or an expression ≥ K-1) while the declared size is K-1 (valid max index would be K-2). This complements loop-based detection.
8) Step 8: Track interprocedural struct field access — resolve ctx->field[index] patterns across functions to capture saves/restores in different functions (e.g., “suspend” vs “resume”) that both use the same array with K-bound indexing. Treat field access via pointers and member expressions to unify evidence.
9) Step 9: Prioritize PM context patterns (optional heuristic) — boost confidence if the struct/type name includes “context” and/or the accessing functions’ names include “suspend” or “resume”, indicating state save/restore paths as in the PM scenario. This reduces false positives while keeping generality.
10) Step 10: Report with precise evidence — for each finding, include: the array field and its declared size expression; the loop bound expression(s) or direct index that reach K-1; whether the access is a write (higher severity) or read; and locations for both declaration and offending use.

3. Limitations & Assumptions
- Assumes CodeQL can recover simple arithmetic relationships between dimension and loop bounds; complex macro expansions or non-literal includes may limit comparability.
- Does not guarantee detection when indexing arises through opaque pointer arithmetic, complex control flow, or data-dependent bounds.
- Preprocessor conditionals (e.g., CONFIG_PM_SLEEP) may hide declarations/uses from analysis; availability depends on the analyzed build configuration.
- Symbol matching relies on shared named constants between array dimension and loop bounds; if different constants alias the same value, purely syntactic matching may miss equivalence.
- Heuristics using function/type names (“suspend”, “resume”, “context”) are optional and may not generalize to all codebases.