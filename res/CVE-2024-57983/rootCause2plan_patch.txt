1. Plan Summary
Detect out-of-bounds array access due to off-by-one array sizing where a buffer is declared with one fewer element than the number of items actually saved/restored (e.g., TH_1520_MBOX_CHANS - 1 vs usage up to TH_1520_MBOX_CHANS), particularly in suspend/resume contexts.

2. Detection Steps
1) Step 1: Identify arrays declared with a length expression that subtracts 1 from a constant (e.g., X - 1). Signals: struct member arrays where the dimension is a compile-time expression “constant minus one”; maps to the root cause described in [ROOTCAUSE_ANALYSIS] and the pre-patch declaration in [PATCH_DIFF]. FP mitigation: restrict to arrays of scalar register-like types (e.g., u32) and prefer declarations in PM-related contexts (e.g., under CONFIG_PM_SLEEP).

2) Step 2: Resolve the “constant” used in the array dimension and find code that indexes the same array using bounds tied to that constant without subtraction (e.g., loop condition i < X or iterating over X items). Signals: loops, iterators, or repeated accesses where the upper bound references the same constant X; maps to saving/restoring “all four” registers per [ROOTCAUSE_ANALYSIS]. FP mitigation: require a clear syntactic/semantic link that the same constant symbol is used both for array sizing and for access bounds.

3) Step 3: Compute the valid maximum index from the array dimension (X - 2 when dimension is X - 1) and the maximum possible index from the loop/access (X - 1 when bound is i < X). Signals: range analysis tying loop variable to array index expression. Why: confirms an off-by-one write/read past the array’s end per [ROOTCAUSE_ANALYSIS]. FP mitigation: require at least one write or read where the index variable is not further constrained (e.g., no “break” before reaching X - 1 or no guard that clamps i).

4) Step 4: Prioritize functions associated with power management suspend/resume paths. Signals: function names containing “suspend” or “resume” and/or being compiled under CONFIG_PM_SLEEP as per [PATCH_DIFF]. Why: bug is triggered in th1520_mbox_suspend_noirq/th1520_mbox_resume_noirq per [ROOTCAUSE_ANALYSIS]. FP mitigation: only report when access occurs within such PM functions or when the array is declared under CONFIG_PM_SLEEP.

5) Step 5: Link the array to a PM context struct used to store hardware register state. Signals: arrays named suggestively like “intr_mask” or similar context buffers; struct scope near PM-related comments (e.g., “store MBOX context across system-wide suspend/resume” per [PATCH_DIFF]). Why: aligns with the intended design of saving/restoring interrupt mask registers. FP mitigation: optional name-based heuristics (“mask”, “context”) increase precision but should be non-mandatory.

6) Step 6: Confirm both save and restore paths access the array with the same off-by-one bound. Signals: identify separate functions (e.g., suspend and resume) both referencing the array with loop bounds tied to X. Why: validates consistent misuse that risks corruption during both suspend and resume per [ROOTCAUSE_ANALYSIS]. FP mitigation: if only one path is found, still flag but lower confidence; boost confidence when both are found.

7) Step 7: Prefer cases where the constant X denotes a fixed hardware count (e.g., TH_1520_MBOX_CHANS). Signals: macro constant that appears in a mailbox driver or hardware-related file as in [PATCH_DIFF] path drivers/mailbox/mailbox-th1520.c. Why: reduces FP by focusing on hardware enumeration contexts where off-by-one errors are common and critical. FP mitigation: require the array and accesses to reside in the same file/module with hardware-driver hints (e.g., drivers/mailbox).

8) Step 8: Detect direct out-of-bounds potential on the last iteration. Signals: presence of array[index] where index can equal X - 1 while array length is X - 1. Why: this is the precise overflow described in [ROOTCAUSE_ANALYSIS]. FP mitigation: exclude cases with guards like if (i < X - 1) before array access, or where the loop is actually bounded to i < X - 1.

9) Step 9: Elevate severity when the array element type matches register width (e.g., u32) and the code comments indicate saving/restoring registers. Signals: type u32 and nearby comments similar to [PATCH_DIFF] (“store MBOX context across system-wide suspend/resume”). Why: matches the exact faulty context that led to kernel memory corruption. FP mitigation: lower severity if types are non-scalar or unrelated to register snapshots.

10) Step 10: Cross-check for preprocessor guards that ensure the code is compiled only when CONFIG_PM_SLEEP is enabled. Signals: array declaration and usage wrapped by #ifdef CONFIG_PM_SLEEP as shown in [PATCH_DIFF]. Why: the trigger condition per [ROOTCAUSE_ANALYSIS] requires CONFIG_PM_SLEEP. FP mitigation: exclude code that cannot compile together (array or usage outside the same guard) to avoid mismatched analysis.

3. Target Elements
- Struct member array declarations and their dimension expressions.
- Macro constants used in dimensions and loop bounds (e.g., TH_1520_MBOX_CHANS).
- Loops and control-flow constructs driving array indices (for/while/foreach).
- Array indexing expressions and assignments (reads/writes).
- Function declarations and bodies named or annotated as suspend/resume.
- Preprocessor guards (e.g., CONFIG_PM_SLEEP) around declarations and code blocks.
- Comments indicating PM context saving/restoring.

4. Dataflow / Taint Considerations
- Track value-range of loop/index variables to determine possible index values reaching the array access.
- Relate constants used in array dimensions to constants used in loop bounds; treat them as semantically the same symbol.
- Model control-flow to verify the loop can reach the last iteration (i = X - 1) without guards preventing the out-of-bounds access.

5. Validation & Test Cases
- Positive: A struct under CONFIG_PM_SLEEP with u32 intr_mask[TH_1520_MBOX_CHANS - 1]; suspend/resume functions iterate for (i < TH_1520_MBOX_CHANS) and access intr_mask[i]; expect a report.
- Negative: Fixed code with u32 intr_mask[TH_1520_MBOX_CHANS]; same loop bound i < TH_1520_MBOX_CHANS; expect no report.
- Negative: Array sized [TH_1520_MBOX_CHANS - 1] but loops use i < (TH_1520_MBOX_CHANS - 1) for all accesses; expect no report.
- Test harness notes: Compile-time constants should be resolved; ensure analysis respects preprocessor guards (CONFIG_PM_SLEEP) so the declaration and usage co-exist.

6. Estimated Effort & Priority
Medium: requires constant expression resolution, range analysis for loop indices, and symbol equivalence between array dimension and loop bound.

7. Likely False-Positive Sources & Mitigations
- Intentional under-allocation to skip a reserved element; mitigate by requiring evidence that all X elements are accessed.
- Macros that change meaning across compilation units; mitigate by same-file symbol matching and preprocessor guard alignment.
- Loops with early breaks or guards narrowing the effective bound; mitigate by control-flow checks to confirm reachable index X - 1.
- Non-PM contexts where X - 1 is correct; mitigate by prioritizing CONFIG_PM_SLEEP regions and suspend/resume functions.

8. Limitations & Assumptions
- Exact loop bodies for th1520_mbox_suspend_noirq/th1520_mbox_resume_noirq are not provided; the checker assumes they iterate to TH_1520_MBOX_CHANS as stated in [ROOTCAUSE_ANALYSIS].
- The analysis assumes TH_1520_MBOX_CHANS is a resolvable compile-time constant; if not, precision drops.
- Hardware-specific intent (e.g., number of registers truly required) cannot be inferred beyond constants used in code; exploitability is not determinable per [ROOTCAUSE_ANALYSIS].