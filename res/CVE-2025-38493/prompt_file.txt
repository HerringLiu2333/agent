1. CVE Identifier
CVE-2025-38493

2. Vulnerability Type
Memory safety: incorrect length/metadata initialization causing FORTIFY_SOURCE bounds-check failure and kernel panic (denial of service)

3. Root Cause Summary
In __timerlat_dump_stack(), the code copied the saved stack into stack_entry->caller via memcpy before initializing entry->size. Since struct stack_entry->caller is annotated with __counted_by(size) (commit e7186af7fb26), FORTIFY’s bounds check uses entry->size to validate the memcpy length. The pre-patch entry->size contained uninitialized data from the ring buffer (often zero), causing FORTIFY to detect a write exceeding the recorded size and triggering __fortify_report and a kernel panic. The root cause is an order-of-operations bug: failing to set the counted-by length field prior to performing a size-checked memory copy.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Kernel tracing subsystem, osnoise/timerlat tracer (CONFIG_TIMERLAT_TRACER with CONFIG_STACKTRACE), specifically stack dump construction for TRACE_STACK events.

2) Pre-Patch Flaw:
In osnoise.c::__timerlat_dump_stack(), the sequence was:
- entry = ring_buffer_event_data(event);
- memcpy(&entry->caller, fstack->calls, size);
- entry->size = fstack->nr_entries;
Because caller is __counted_by(size), the memcpy invoked FORTIFY checks using an uninitialized entry->size, producing false overflow detection.

3) Trigger Condition:
Using timerlat with stack saving/dumping enabled (osnoise_data.print_stack > 0). Paths include:
- timerlat_irq and timerlat_main calling timerlat_dump_stack(), and
- user-space read via timerlat_fd_read calling timerlat_dump_stack.part.0.
Under these scenarios, the memcpy into entry->caller occurs while entry->size is still garbage (sometimes zero), leading to the observed panic: “memcpy: detected buffer overflow: 88 byte write of buffer size 0”.

4) Impact Mechanism:
FORTIFY_SOURCE sees entry->size == 0 for a nonzero memcpy length and calls __fortify_report, which triggers a WARN and panic, crashing the kernel (denial of service).

5. Patch Analysis
1) Fix Approach:
Initialize the counted-by field (entry->size) before performing the memcpy into the counted array (entry->caller), aligning with __ftrace_trace_stack() behavior.

2) Key Code Changes:
In __timerlat_dump_stack():
- Before: memcpy(&entry->caller, fstack->calls, size); entry->size = fstack->nr_entries;
- After: entry->size = fstack->nr_entries; memcpy(&entry->caller, fstack->calls, size);
This reordering ensures FORTIFY’s bounds check uses the correct size.

3) Locking/Concurrency Impact:
None. The change is purely an initialization order fix within the event construction; no locks or ordering primitives were added/modified.

6. Broader Kernel Security Implications
FORTIFY’s __counted_by requires correct initialization ordering of metadata fields prior to memory operations. Misordering can convert benign operations into kernel panics, yielding easy denial-of-service vectors when tracing is enabled. Similar counted-by annotated structures across the kernel must ensure size fields are set before copying into associated arrays, especially when using ring_buffer_event_data() buffers where fields start uninitialized. This fix reinforces the need for careful sequencing in trace event construction to avoid FORTIFY-triggered crashes.