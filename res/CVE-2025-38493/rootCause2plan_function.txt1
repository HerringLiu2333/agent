1. Plan Summary
Detect memcpy writes into a struct field annotated with __counted_by(<lenfield>) that occur before initializing the associated length field for the same instance.

2. Detection Steps
1) Step 1: Map counted-by relationships from struct declarations. Signals: a struct member marked with __counted_by(size_field); record the array/pointer field and its associated size_field name.

2) Step 2: Find memcpy calls whose destination refers to a counted-by field. Signals: memcpy(...) where the first argument takes the address of the counted-by field (e.g., &obj->field or &obj.field) or a pointer derived from that field.

3) Step 3: Resolve the struct instance used in the destination. Signals: extract the base object (obj) from the destination expression (the receiver of -> or .).

4) Step 4: In the same function, locate assignments to the associated size_field on that same instance. Signals: direct writes like obj->size_field = ... or obj.size_field = ....

5) Step 5: Determine statement order and dominance. Signals: the memcpy executes before any dominating assignment to obj->size_field (i.e., no prior write to size_field reaches the memcpy).

6) Step 6: Strengthen confidence when a write to obj->size_field exists after the memcpy in the same function. Signals: a post-copy assignment to obj->size_field (matching the pre-patch pattern).

7) Step 7: Identify “fresh/uninitialized” instances typical of this path. Signals: obj obtained from ring_buffer_event_data(event) (or via trace_buffer_lock_reserve followed by ring_buffer_event_data), suggesting its fields contain ring buffer data until explicitly set.

8) Step 8: Exclude cases where the size_field is known-initialized before the memcpy. Signals: earlier assignments to obj->size_field or whole-struct initialization dominating the memcpy (e.g., a prior memset or copy that sets size_field).

9) Step 9: Check the memcpy size argument is not trivially zero. Signals: third argument to memcpy is a nonzero constant or a variable (e.g., size), indicating a meaningful copy length.

10) Step 10: Report a finding when the destination is a counted-by field, the memcpy precedes initialization of its associated size_field for the same instance, and the instance appears fresh/uninitialized. Signals: conjunction of Steps 2–7 with Step 9 indicating potential out-of-bounds/DoS per FORTIFY.

3. Limitations & Assumptions
- Assumes CodeQL can recognize __counted_by annotations; if they are hidden behind macros, modeling may be incomplete.
- Does not confirm runtime sizes; relies on static ordering (memcpy before size_field initialization).
- “Fresh/uninitialized” inference from ring_buffer_event_data(event) is based on supplied context; other allocators or initializers are not modeled.
- Focuses on memcpy; similar issues via other memory-write APIs are not covered here due to lack of evidence in the materials.
- Analysis is intra-procedural; interprocedural initialization of size_field is not considered.