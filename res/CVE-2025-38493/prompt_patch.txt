1. CVE Identifier
CVE-2025-38493

2. Vulnerability Type
Out-of-bounds write attempt due to use of uninitialized size for a __counted_by-bound field, causing fortified memcpy overflow and kernel panic (Denial of Service)

3. Root Cause Summary
The pre-patch code in __timerlat_dump_stack() copied stack entries into entry->caller before initializing entry->size, even though caller is annotated with __counted_by(size). With FORTIFY_SOURCE, memcpy validates the destination bound using entry->size; since that field contained uninitialized ring-buffer data (often zero), the runtime check detected a write larger than the reported bound and triggered __fortify_report, panicking the kernel. The root cause is incorrect initialization order of the size field relative to the memcpy, introduced after commit e7186af7fb26 added __counted_by(size) to struct stack_entry.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
tracing/osnoise (timerlat stack saving and dumping via ftrace ring buffer)

2) Pre-Patch Flaw:
__timerlat_dump_stack() performed:
- "memcpy(&entry->caller, fstack->calls, size);"
- "entry->size = fstack->nr_entries;"
This writes to a __counted_by(size) field before initializing the count, causing FORTIFY to see an incorrect (garbage/zero) bound.

3) Trigger Condition:
Using timerlat with stack saving enabled when fstack->nr_entries > 0 and the ring buffer event’s entry->size was uninitialized (e.g., zero), leading to a memcpy whose length exceeds the FORTIFY-derived destination bound.

4) Impact Mechanism:
FORTIFY’s destination size checking (string_helpers.c) detects “88 byte write of buffer size 0” and calls __fortify_report/__fortify_panic, resulting in a kernel panic (Denial of Service). Without the check, the logic implies a possible out-of-bounds write into the ring buffer event payload, but the provided evidence confirms the panic rather than silent corruption.

5. Patch Analysis
1) Fix Approach:
Initialize the size field (entry->size = fstack->nr_entries) before performing the memcpy so FORTIFY uses the correct runtime bound for the __counted_by field.

2) Key Code Changes:
A simple reordering in __timerlat_dump_stack():
- Move "entry->size = fstack->nr_entries;" before "memcpy(&entry->caller, fstack->calls, size);"
This mirrors the safe ordering used in __ftrace_trace_stack().

3) Locking/Concurrency Impact:
None. No locks or ordering beyond the memcpy/assignment were changed; the fix addresses initialization order only and does not modify ring buffer locking semantics.

6. Broader Kernel Security Implications
This issue highlights the importance of correctly initializing __counted_by-bound fields before any memory operations that rely on them, especially under FORTIFY_SOURCE. Similar patterns elsewhere in tracing or other subsystems using variable-length event payloads must ensure size fields are set prior to memcpy to avoid false overflow detection or actual out-of-bounds writes. Consistent adherence to initialization-before-use prevents kernel panics and strengthens runtime bounds enforcement.