1. CVE Identifier
CVE-2025-38493

2. Vulnerability Type
Out-of-bounds write / unsafe memcpy due to uninitialized counted-by length field, resulting in kernel crash (DoS)

3. Root Cause Summary
The function __timerlat_dump_stack() performed memcpy into struct stack_entry->caller, which is annotated with __counted_by(size), before initializing entry->size. Because entry->size contained uninitialized data from the ring buffer (often zero), the FORTIFY_SOURCE bounds check interpreted the destination buffer length as 0 and triggered a kernel panic. The flawed logic was the incorrect initialization order: “memcpy(&entry->caller, fstack->calls, size); entry->size = fstack->nr_entries;” should have set entry->size before the memcpy. This is analogous to __ftrace_trace_stack(), which initializes the counted length prior to copying.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
tracing/osnoise (timerlat stack saving path)

2) Pre-Patch Flaw:
In __timerlat_dump_stack(), entry->size (the length driving __counted_by for entry->caller) was set after the memcpy, leaving FORTIFY to see a zero/garbage size during the copy and flag the write as out-of-bounds.

3) Trigger Condition:
Using timerlat with stack saving and reading from the timerlat fd (timerlat_fd_read path) when ring_buffer_event_data() returns an entry whose size field is still uninitialized at the time of memcpy; FORTIFY then computes the destination size as 0 while “size” > 0.

4) Impact Mechanism:
FORTIFY’s destination-bound check detects “88 byte write of buffer size 0” and calls __fortify_panic, causing a kernel WARN/panic (DoS). Without the check, the memcpy would write past the actual caller array bounds determined by nr_entries, risking memory corruption.

5. Patch Analysis
1) Fix Approach:
Initialize the counted-by length (entry->size) before performing the memcpy so the FORTIFY bounds check uses the correct destination size.

2) Key Code Changes:
In __timerlat_dump_stack():
- Pre-patch order:
  memcpy(&entry->caller, fstack->calls, size);
  entry->size = fstack->nr_entries;
- Post-patch order:
  entry->size = fstack->nr_entries;
  memcpy(&entry->caller, fstack->calls, size);
This reordering ensures entry->size is set prior to the copy.

3) Locking/Concurrency Impact:
No changes to locking or concurrency. The existing trace_buffer_lock_reserve() and trace_buffer_unlock_commit_nostack() usage remains unchanged; the fix strictly adjusts assignment order within the reserved event.

6. Broader Kernel Security Implications
This highlights the need to initialize __counted_by fields before any memory operations that rely on them, especially under FORTIFY_SOURCE. Similar patterns in tracing or other subsystems can lead to crashes or memory corruption if initialization order is wrong. Ensuring correct field initialization and copy ordering improves robustness against DoS and latent buffer overflows in kernel instrumentation paths.