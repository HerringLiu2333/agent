1. Plan Summary
Detect functions that accept an optional pointer output parameter and then dereference it along unguarded paths for internal traversal, leading to NULL pointer dereference, as exemplified by pre-patch eir_get_service_data.

2. Detection Steps
1) Step 1: Identify candidate functions with a pointer parameter used as an optional output (objective). Signals: a function parameter of pointer type (e.g., size_t*) that is conditionally checked for NULL (e.g., “if (len)”) and written via “*param = …” (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: require both a NULL-check of the parameter and at least one write to dereferenced parameter inside that guard.

2) Step 2: Within those candidates, locate any dereference of the same pointer parameter outside a dominating NULL-check (objective). Signals: uses of “*param” in arithmetic, indexing, or pointer arithmetic (e.g., “eir += *len; eir_len -= *len;”) on paths not guarded by “param != NULL” (FUNCTION_CONTENT lines evidencing “eir += *len; eir_len -= *len”). FP mitigation: path-sensitive analysis to ensure the dereference is reachable when the parameter may be NULL.

3) Step 3: Detect loop-based parsing that advances a buffer using the optional pointer parameter as traversal state (objective). Signals: a loop (while/for) calling a helper (e.g., eir_get_data) that takes the same pointer parameter, followed by advancing the buffer using “*param” (PATCH_DIFF and ROOTCAUSE_ANALYSIS show “while ((eir = eir_get_data(..., len))) ... eir += *len;”). FP mitigation: restrict to patterns where the parameter is passed to a helper and then used to adjust offsets/lengths in the same loop body.

4) Step 4: Flag conflation of optional output parameter with internal traversal length (objective). Signals: the parameter is both (a) passed to a helper as an out-argument and (b) used to control iteration (pointer increments/decrements), rather than storing the helper’s output in a local variable (ROOTCAUSE_ANALYSIS notes this conflation; PATCH_DIFF replaces “len” with local “dlen”). FP mitigation: suppress when a local variable is used for traversal and the parameter is only written under a NULL guard (post-patch pattern).

5) Step 5: Identify match/mismatch branch asymmetry indicating unsafe dereference on the mismatch path (objective). Signals: conditional branch checks a value (e.g., uuid == value) with guarded write “if (len) *len -= 2” on match, but unconditionally dereferences the parameter on the mismatch path to advance (FUNCTION_CONTENT shows this asymmetry). FP mitigation: ensure both a guarded write exists and an unguarded deref exists in a different branch/path.

6) Step 6: Confirm the parameter is documented optional by code cues (objective). Signals: the presence of “if (param)” before any write implies optionality; PATCH_DESCRIPTION states len can be NULL and must not be used for skipping. FP mitigation: increase confidence only when such cues exist; otherwise, lower severity to avoid flagging mandatory pointers.

7) Step 7: Exclude patched-safe patterns that decouple traversal from the optional pointer (objective). Signals: introduction of a local variable (e.g., “size_t dlen;”), passing its address to the helper, using the local variable for pointer arithmetic, and only assigning to “*param = dlen - const” under a NULL guard (PATCH_DIFF shows this exact pattern). FP mitigation: treat this decoupling as a strong negative signal.

8) Step 8: Report when all high-confidence signals co-occur (objective). Signals: optional pointer parameter, helper call with the parameter, loop-based parsing, unguarded deref for traversal, and guarded write on match path (aggregate of steps 1–5). FP mitigation: require at least three of the above signals to reduce incidental matches.

3. Target Elements
- Function definitions and parameters (pointer-type output parameters).
- Conditional checks against NULL for parameters.
- Loops (while/for) that parse buffers.
- Calls to helper functions using the parameter as an out-argument.
- Pointer arithmetic and length adjustments using dereferenced parameters.
- Branches in which the parameter is conditionally written versus unconditionally dereferenced.

4. Dataflow / Taint Considerations
- Track “may be NULL” state for the pointer parameter when there is no dominating non-NULL check.
- Model dominance/guarding: paths where “param != NULL” is not guaranteed should treat dereferences as unsafe.
- Track flow from helper calls that receive the parameter to subsequent dereferences used for traversal.
- Distinguish local traversal variables versus reuse of the optional parameter for iteration control.

5. Validation & Test Cases
- Positive: The pre-patch eir_get_service_data in FUNCTION_CONTENT should be flagged (unguarded “*len” in mismatch traversal, conditional “if (len)” write on match, and helper call passing len).
- Negative: The post-patch function in PATCH_DIFF should not be flagged (uses local dlen for traversal and only writes to *len under guard).
- Test harness notes: Analyze both versions to confirm the checker differentiates guarded-only writes plus local traversal (safe) from unguarded traversal with optional pointer (unsafe).

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Functions where the pointer parameter is guaranteed non-NULL by external contracts not visible to the analysis; mitigate by requiring in-function NULL-check cues to claim optionality.
- Helper calls that ensure the parameter becomes non-NULL; mitigate by insisting on explicit in-function guards before deref or decoupled traversal variables.
- Macros or inlined constructs obscuring guards; mitigate via control-flow-aware analysis to confirm guard dominance.

8. Limitations & Assumptions
- The checker assumes optionality from in-function NULL-checks; absence of such cues may hide true issues or produce false negatives.
- Semantics of helper functions (e.g., whether they guarantee non-NULL) are not inferable from provided materials.
- The plan is derived from Bluetooth EIR parsing patterns; other domains may require additional context to assert optionality and traversal semantics.