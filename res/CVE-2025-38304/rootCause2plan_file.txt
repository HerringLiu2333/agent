1. Plan Summary
Detect functions that accept an optional output pointer (e.g., size_t* len), write to it conditionally, but also dereference it unconditionally for internal control-flow (e.g., advancing parsing), which can cause a NULL pointer dereference when the caller passes NULL.

2. Detection Steps
1) Step 1: Identify candidate pointer parameters meant as optional outputs — signals: writes to *param guarded by “if (param)” or equivalent; mapping: mirrors “if (len) *len -= 2” in eir_get_service_data; FP mitigation: require at least one guarded write to the dereferenced parameter.
2) Step 2: Find unguarded dereferences of such parameters — signals: occurrences of *param (read context) or param used as an array base outside dominance of a non-NULL guard; mapping: the pre-patch “eir += *len; eir_len -= *len;” dereferenced len without checking; FP mitigation: require control-flow analysis showing no dominating check or early return on NULL along at least one path.
3) Step 3: Detect loop-based parser patterns using the optional output to advance — signals: while/for loops that call another function passing the optional pointer param as an argument, followed by arithmetic like “x += *param” or “x -= *param”; mapping: based on the loop using eir_get_data(..., len) then advancing by *len (ROOTCAUSE_ANALYSIS, PATCH_DIFF); FP mitigation: require both a call-with-param and a subsequent deref in the same loop body.
4) Step 4: Confirm mixed semantics (optional write but required read) — signals: both a guarded write to *param and an unguarded read of *param within the same function; mapping: reflects mixing optional output with internal control-flow (ROOTCAUSE_ANALYSIS); FP mitigation: suppress if all reads are also under non-NULL guards.
5) Step 5: Check for pointer normalization to a safe local before use — signals: patterns like “if (!param) param = &local;” or assignment to a guaranteed non-NULL alias dominating the read; mapping: analogous to fix introducing local dlen and not relying on param for iteration (PATCH_DIFF); FP mitigation: suppress when such normalization dominates all dereferences.
6) Step 6: Check for early NULL handling — signals: immediate return or error path when param is NULL before any deref; mapping: ensures deref cannot occur if NULL; FP mitigation: suppress when an early return on NULL dominates all deref paths.
7) Step 7: Corroborate optionality with call sites (when available) — signals: at least one call passing NULL for the argument; mapping: len “is considered optional so it can be NULL” (PATCH_DESCRIPTION); FP mitigation: raise severity when NULL actuals exist; otherwise lower confidence but still report due to internal optionality pattern.
8) Step 8: Prioritize arithmetic/pointer-advance contexts — signals: “+= *param”, “-= *param”, pointer increments by *param; mapping: directly matches “cannot be used for skipping to next entry” (PATCH_DESCRIPTION) and “eir += *len; eir_len -= *len;”; FP mitigation: require the advanced variable is part of loop progression or buffer traversal.
9) Step 9: Exclude pure output-only usage — signals: parameter only ever written (and only under guard) and never read; mapping: safe pattern; FP mitigation: do not report.
10) Step 10: Report at first unsafe use after a call that purportedly populates length — signals: first unguarded deref following a call where the param is passed; mapping: pinpoints the precise fault site as shown by the pre-patch line “eir += *len;” (FILE_CONTENT, PATCH_DIFF); FP mitigation: avoid duplicate findings within the same function.

3. Target Elements
- Function definitions and parameter lists.
- If-conditions guarding pointer parameters (null checks).
- Pointer dereference expressions and array indexing via dereferenced pointer.
- Loop constructs (while/for) involved in parsing/traversal.
- Call sites where the candidate parameter is passed to other functions (potential out-arg use).
- Statements performing arithmetic/pointer advancement using dereferenced optional parameters.
- Early-return or parameter normalization patterns.

4. Dataflow / Taint Considerations
- Track the candidate parameter’s potential nullness from function entry.
- Model dominance of null-checks and early returns to determine if dereferences occur on feasible NULL paths.
- Track assignments that rebind the parameter to a non-NULL local (normalization) and treat subsequent dereferences as safe.
- Treat a call passing the parameter as not proving non-NULL unless there’s an explicit check or normalization; the core issue is internal deref, not the call itself.

5. Validation & Test Cases
- Positive: Pre-patch eir_get_service_data body (FILE_CONTENT) where len is checked before write but later used unconditionally to advance (eir += *len; eir_len -= *len;); expect a finding pointing to the first unguarded deref.
- Negative: Post-patch version (PATCH_DIFF) using a local dlen for advancement and writing to *len only under “if (len)”; expect no findings.
- Negative: Function that does “if (!len) return;” before any deref; expect no findings. Function that does “size_t tmp; if (!len) len = &tmp; ... use *len” under dominance; expect no findings.
- Test harness notes: Include interprocedural check to detect calls passing NULL to corroborate optional semantics, but ensure intra-procedural analysis alone produces the positive result.

6. Estimated Effort & Priority
High: important kernel-safety pattern (ROOTCAUSE_ANALYSIS) with moderate implementation complexity (control-flow dominance + deref identification + optional call-site corroboration).

7. Likely False-Positive Sources & Mitigations
- Hidden preconditions or annotations guaranteeing non-NULL not visible to the analyzer; mitigate by requiring both guarded writes and unguarded reads.
- Macros/inlines obscuring guards; mitigate by analyzing expanded AST where possible.
- Aliasing where param is assigned a safe alias off-path; mitigate with dominance and dataflow checks.
- Cross-TU missing call sites; mitigate by not requiring call-site evidence, but downgrading severity when absent.

8. Limitations & Assumptions
- Assumes the pattern “if (param) write to *param” implies optionality; does not read external specs/comments except as design rationale (PATCH_DESCRIPTION, ROOTCAUSE_ANALYSIS).
- May miss cases where optional parameter flows through aliases or is normalized via macros not visible to the analysis.
- Cannot precisely model callee behavior (e.g., whether callee tolerates NULL); focus is on internal unguarded deref, as per the root cause.
- Whole-program call-site corroboration may be incomplete in partial builds.