1. Plan Summary
Detect functions that accept an optional pointer output parameter and then dereference it on unguarded paths (e.g., for buffer traversal or arithmetic), leading to a potential NULL pointer dereference like in eir_get_service_data.

2. Detection Steps
1) Step 1: Identify functions with a pointer parameter that is treated as optional by checking for a local null check before writing through it (e.g., if (param) { *param = ... }).
2) Step 2: For each such parameter, find all dereferences of the parameter (*param reads/writes) and classify those that occur outside the syntactic scope of a guarding null check (not dominated by “if (param)” or an equivalent non-null assertion).
3) Step 3: Determine whether any unguarded dereference of the parameter participates in arithmetic or pointer arithmetic (e.g., x += *param, x -= *param, arr[*param], pointer += *param), as seen in eir += *len; eir_len -= *len.
4) Step 4: Check reachability: ensure there is a path from function entry to the unguarded dereference with no dominating return or check that guarantees the parameter is non-NULL (no early “if (!param) return” covering all paths).
5) Step 5: Increase confidence by detecting that the unguarded dereference occurs within a loop body, and the computed value is used to advance parsing or iteration state (e.g., updating a buffer pointer and remaining length), mirroring the EIR traversal pattern.
6) Step 6: Flag cases where the same parameter is also used as an output argument to a callee (passed by address) and later used locally for traversal without guarding; this suggests conflation of an optional output parameter with internal traversal state, as in passing len to eir_get_data then using *len for iteration.
7) Step 7: Exclude safe patterns where all dereferences of the parameter are dominated by a proven non-NULL check or where the parameter is copied into a local non-NULL variable and only that local is dereferenced (e.g., replacing len with a local dlen).
8) Step 8: For each finding, report the unguarded dereference location, the optional-parameter evidence (the guarded write), and the arithmetic/pointer-update usage that could execute on mismatch paths (e.g., after a conditional fails inside the loop).

3. Limitations & Assumptions
- Assumes “if (param)” or similar checks indicate optionality; if code does not guard writes, optionality may be missed.
- Does not infer callee contracts; passing a parameter to a callee is only a heuristic for “output parameter” usage.
- Control-flow dominance and reachability are approximated; complex macros or inlined checks may affect precision.
- The plan targets the general class of unguarded dereferences of optional pointer outputs used in traversal; other NULL-deref causes outside this pattern are out of scope.