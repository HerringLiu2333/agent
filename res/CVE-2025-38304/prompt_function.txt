1. CVE Identifier
CVE-2025-38304

2. Vulnerability Type
NULL pointer dereference (improper handling of optional pointer parameter)

3. Root Cause Summary
The pre-patch implementation of eir_get_service_data used the caller-provided optional length pointer (len) both to advance parsing and for output without checking for NULL. Specifically, it unconditionally performed pointer arithmetic with “eir += *len; eir_len -= *len;” in the mismatch path, dereferencing len even when the caller passed NULL. The function also passed len directly to eir_get_data, conflating an optional output parameter with internal traversal state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth stack (EIR parsing within HCI), function eir_get_service_data

2) Pre-Patch Flaw:
Inside eir_get_service_data, the loop advanced using “*len” regardless of whether len was NULL, and len was also modified on match (“*len -= 2”) without isolating traversal state from the optional output parameter. Code lines evidencing the flaw:
- “while ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, len)))”
- “eir += *len;”
- “eir_len -= *len;”

3) Trigger Condition:
eir_get_service_data is called with len == NULL and at least one EIR_SERVICE_DATA element does not match the requested uuid, causing the mismatch path to execute and dereference the NULL len in “eir += *len; eir_len -= *len;”.

4) Impact Mechanism:
Dereferencing a NULL pointer in kernel space triggers an OOPS/BUG, leading to a kernel crash or denial of service in Bluetooth processing paths.

5. Patch Analysis
1) Fix Approach:
Decouple internal traversal length management from the optional output parameter by introducing a local variable (dlen) to always hold the current record length. Use dlen for iteration and only write to *len when non-NULL and a match is found.

2) Key Code Changes:
- Replace eir_get_data(..., len) with eir_get_data(..., &dlen) to ensure a non-NULL length sink for parsing.
- On match, set the optional output length explicitly: “*len = dlen - 2” (instead of “*len -= 2”).
- Use dlen for advancing the buffer: “eir += dlen; eir_len -= dlen” instead of dereferencing the possibly NULL len.

3) Locking/Concurrency Impact:
None. The changes are confined to local variable usage and pointer arithmetic within a parsing routine; no locks or ordering semantics are introduced or altered.

6. Broader Kernel Security Implications
This fix hardens the Bluetooth EIR parsing against crashes caused by optional output parameters, reinforcing a best practice to avoid using caller-supplied optional pointers for internal control flow. Similar patterns in other parsers or helpers should be audited to prevent kernel-level DoS from NULL dereferences and to ensure robust handling of optional arguments.