1. CVE Identifier
CVE-2025-38304

2. Vulnerability Type
NULL pointer dereference (kernel crash/denial-of-service)

3. Root Cause Summary
eir_get_service_data used the caller-provided size_t *len both to receive the length from eir_get_data and to advance iteration through EIR entries, but len is optional and may be NULL. The pre-patch loop unconditionally dereferenced *len to skip to the next entry (“eir += *len; eir_len -= *len;”), causing a NULL pointer dereference when len == NULL. The function thereby mixed an optional output parameter into internal control flow without guarding against NULL.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth HCI EIR (Extended Inquiry Response) and advertising data parsing

2) Pre-Patch Flaw:
In eir_get_service_data (eir.c), the loop called eir_get_data(eir, eir_len, EIR_SERVICE_DATA, len) and then used *len to advance parsing even if len was NULL. Although the code guarded the assignment when a UUID match was found (“if (len) *len -= 2;”), it did not guard the iteration step that dereferenced len.

3) Trigger Condition:
Any caller invoking eir_get_service_data with len == NULL and providing an EIR buffer containing at least one EIR_SERVICE_DATA element (so eir_get_data returns non-NULL) leads to dereferencing *len during the non-matching path or subsequent iterations.

4) Impact Mechanism:
Dereferencing a NULL pointer in kernel space causes an oops/panic, resulting in denial-of-service. No evidence of memory corruption beyond the crash is present.

5. Patch Analysis
1) Fix Approach:
Decouple internal iteration from the optional output parameter by introducing a local variable (dlen) to capture the length from eir_get_data, using dlen for buffer advancement, and only writing to *len when len is non-NULL.

2) Key Code Changes:
- Introduced local size_t dlen.
- Changed the call to eir_get_data to use &dlen instead of len: “eir = eir_get_data(..., &dlen)”.
- On UUID match, set *len = dlen - 2 only if len is non-NULL (previously “*len -= 2”).
- Replaced “eir += *len; eir_len -= *len;” with “eir += dlen; eir_len -= dlen;”.
These map directly to eliminating the unsafe dereference of an optional pointer.

3) Locking/Concurrency Impact:
None. The changes affect local parsing logic and do not introduce or modify synchronization, locking, or RCU semantics.

6. Broader Kernel Security Implications
This issue highlights the risk of using optional output parameters for internal control flow without NULL checks in kernel parsing routines. Similar patterns should be audited across networking and Bluetooth code where len parameters can be NULL (e.g., other uses of eir_get_data), to prevent kernel crashes from malformed or user-supplied advertising/EIR inputs. Strengthening parsing routines to rely on internal state rather than optional pointers reduces attack surface for denial-of-service.