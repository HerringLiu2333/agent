1. Plan Summary
Detect functions that treat a pointer output parameter as optional (guarded writes under if (param)) but also dereference it unguarded for internal control flow (e.g., loop advancement), creating a potential NULL pointer dereference.

2. Detection Steps
1) Step 1: Identify candidate pointer parameters that are treated as optional outputs — look for parameters of pointer-to-scalar types that are written under a conditional check like “if (param) ... *param = ...” — this maps to the optional len pattern noted in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; reduce false positives by requiring at least one guarded write of the form “if (p) *p = expr”.
2) Step 2: For each candidate, find unguarded dereferences of the same parameter — locate uses of “*param” in expressions outside any dominating non-null check — this directly matches the root cause where “eir += *len; eir_len -= *len;” executed without checking len (see [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]); mitigate by verifying there is no dominating check or reassignment that ensures non-NULL.
3) Step 3: Classify dereference context as internal control flow bookkeeping — flag when the dereferenced value is used to advance pointers/cursors or adjust lengths (e.g., X += *param, Y -= *param) rather than solely writing to *param — this mirrors “using len to skip to next entry” in [ROOTCAUSE_ANALYSIS]; reduce false positives by requiring the dereference result to modify variables other than the parameter itself.
4) Step 4: Detect loop-based scanning patterns — check whether the unguarded dereference occurs inside a loop body (while/for) to repeatedly advance parsing state — this reflects the EIR scanning loop in [PATCH_DIFF]; deprioritize findings outside loops unless corroborated by Step 5.
5) Step 5: Correlate with upstream call passing the same parameter — in the same function/loop, find a call that passes the candidate pointer as an argument before the unguarded deref — this matches “eir_get_data(..., len)” followed by using “*len” (see [PATCH_DIFF]); reduce false positives by requiring the deref to post-dominate such a call in at least one path.
6) Step 6: Ensure a possible NULL path exists — verify there is no function-wide precondition enforcing non-NULL (e.g., an early return if !param or reassignment of param to a local non-NULL buffer) dominating the deref — this ties to the trigger condition in [ROOTCAUSE_ANALYSIS]; filter out cases where param is normalized to a valid pointer prior to first deref.
7) Step 7: Cross-check mixed usage (guarded write + unguarded read) — confirm at least one guarded assignment “if (param) *param = ...” co-exists with at least one unguarded read “*param” used for control flow/bookkeeping — this captures the exact misuse fixed by introducing a local dlen in [PATCH_DIFF]; reduces noise by ensuring the API is truly treated as optional by the author.
8) Step 8: Prioritize when the deref is on the non-match/iteration path — within branch structure, prefer cases where the deref is reached when a match condition fails (e.g., after comparing a field and advancing) — this mirrors the “non-matching service-data element” trigger in [ROOTCAUSE_ANALYSIS]; use basic branch analysis to spot deref in the loop-continue path.
9) Step 9: De-emphasize benign cases — lower severity or suppress when all dereferences of the parameter occur within “if (param)” guarded regions or are preceded by a dominance-proven non-NULL assertion — reduces false positives by honoring correct optional-pointer patterns.

3. Target Elements
- Function definitions and their pointer parameters.
- If-conditions that check parameter non-NULL.
- Assignments writing through the parameter pointer (e.g., “*param = ...”).
- Dereference expressions of the parameter used in arithmetic/pointer arithmetic.
- Loop constructs (while/for) and their bodies.
- Call sites that pass the parameter as an argument.
- Control-flow/dominance relationships and post-dominance within loops/branches.

4. Dataflow / Taint Considerations
- Treat the candidate pointer parameter as “possibly NULL” unless dominated by a non-NULL guard or normalization to a non-NULL alias.
- Track control-flow to ensure that unguarded dereferences are reachable along a path without intervening non-NULL guarantees.
- Track simple aliasing: if the parameter is reassigned to a non-NULL local (e.g., set to the address of a local buffer) dominating the deref, consider it safe; otherwise, treat deref of the original parameter as risky.
- Correlate the temporal order: call(site) that uses the parameter as an argument followed by deref of the same parameter within the same loop/region.

5. Validation & Test Cases
- Positive: A function that takes a size_t* len, calls another helper with len inside a while loop, uses if (len) *len = expr on match, and in the non-match path advances a cursor with cursor += *len; remaining -= *len; (mirroring [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]); expect a finding.
- Negative: The same function pattern but introduces a local dlen, passes &dlen to the helper, uses dlen for loop advancement, and only writes to len under if (len); expect no finding (matches the fixed code in [PATCH_DIFF]).
- Negative: A function that returns early if len == NULL before any dereference; expect no finding.
- Negative: A function that normalizes len to a non-NULL local buffer (e.g., set to &local) before any dereference and then uses *len; expect no finding.
- Test harness notes: Run intra-procedural analysis with control-flow and dominance enabled; ensure loop and branch contexts are preserved for path feasibility checks.

6. Estimated Effort & Priority
Medium effort, High priority (kernel-level NULL deref leading to DoS as per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- APIs where the pointer parameter is not truly optional despite incidental “if (param)” usage; mitigate by requiring both guarded write and unguarded read patterns.
- Hidden preconditions enforced by callers (not visible intra-procedurally); mitigate by prioritizing only when guarded writes indicate optional semantics.
- Complex aliasing that normalizes the parameter to a safe pointer; mitigate by basic alias tracking and dominance checks.
- Macros obscuring dereferences; mitigate by relying on AST after preprocessing if available.

8. Limitations & Assumptions
- Assumes that the presence of “if (param) *param = ...” indicates the parameter may be NULL (as evidenced by [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]); external API contracts are not analyzed.
- Inter-procedural guarantees (e.g., callers never pass NULL) are not considered; analysis is intra-procedural with simple dominance/alias checks.
- Semantic intent of callees (e.g., whether they write to the pointer) is approximated by the call passing pattern; exact callee behavior is not modeled.