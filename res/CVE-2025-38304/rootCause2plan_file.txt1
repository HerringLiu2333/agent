1. Plan Summary
Detect cases where an optional output pointer parameter (e.g., size_t* len) is passed to a helper and later dereferenced without a dominating NULL check, causing a potential NULL pointer dereference similar to the pre-patch eir_get_service_data issue.

2. Detection Steps
1) Step 1: Identify candidate pointer variables within a function that may be optional — signals: the variable is a pointer (e.g., size_t*, u16*, u8*) and there exists at least one guarded dereference pattern like “if (ptr) { *ptr ... }”.
2) Step 2: Within the same function, locate unguarded dereferences of the same pointer (reads of *ptr in expressions or arithmetic) that are not control-dominated by a prior “ptr != NULL” check along all paths to the dereference.
3) Step 3: Increase confidence by requiring that the pointer is also passed as an argument to another function call before the unguarded dereference, indicating it is used as an output parameter (e.g., passed to eir_get_data or similar).
4) Step 4: Highlight unguarded dereferences used to advance parsing or control flow — signals: expressions like “x += *ptr;” or “x -= *ptr;” or array/pointer stepping where *ptr influences offsets.
5) Step 5: Exclude cases where the pointer is proven non-NULL on all paths to the dereference — signals: a dominating check “if (!ptr) return;”, or an assignment that sets the pointer to the address of a local or global (ptr = &local), or other proof of non-nullability along every path.
6) Step 6: Report when both patterns co-occur: (a) evidence the pointer is treated as optional (guarded assignment/use) and (b) an unguarded dereference of that same pointer exists, especially after a call passing it as an argument.
7) Step 7: Provide a specialized detection for the exact Bluetooth pattern: in functions that call eir_get_data with a length/output pointer argument, flag subsequent unguarded uses of “*len” (e.g., “eir += *len; eir_len -= *len;”) unless a dominating non-NULL check for len exists.
8) Step 8: Further increase priority if the unguarded dereference occurs on the non-matching path inside a loop over parsed entries (e.g., after a comparison fails and before the next iteration), matching the pre-patch control-flow structure of eir_get_service_data.

3. Limitations & Assumptions
- Assumes that “if (ptr)” or “if (ptr != NULL)” indicates optionality; absence of annotations may cause false positives or negatives.
- Does not infer true out-parameter semantics from callees; passing a pointer to a function is used as a heuristic for “output parameter.”
- Cannot conclusively prove non-nullability from external contracts or comments not present in code; relies on intra-procedural dominance and simple assignments (e.g., address-of) for non-null proof.
- Type specificity (e.g., size_t* len) is not strictly enforced; the checker targets general optional pointer misuse, potentially flagging similar patterns beyond Bluetooth EIR code.