1. Plan Summary
Detect functions that treat a pointer out-parameter as optional (guarded writes) but later read/dereference it unconditionally for loop iteration or buffer advancement, risking a NULL pointer dereference.

2. Detection Steps
1) Step 1: Identify candidate functions with pointer-to-scalar parameters intended as outputs. Signals: writes to *param occur under a guard like “if (param)” or a null-check, indicating the parameter is optional.

2) Step 2: Within these functions, locate any reads of the same parameter (uses of *param as a value) outside the dominance of a preceding null-check on that parameter. Signals: *param appears in arithmetic, indexing, or pointer arithmetic expressions not protected by “if (param)”.

3) Step 3: Focus on loop constructs that iterate over buffers/entries. Signals: in a while/for loop, a buffer pointer or remaining-length variable is updated by a value read from *param (e.g., “ptr += *param” or “len -= *param”).

4) Step 4: Detect the pattern where the optional parameter is passed to a helper that returns/locates a sub-element, followed by an unconditional read of *param. Signals: call like helper(..., param) then immediate use of *param to advance parsing, without a guarding null-check.

5) Step 5: Confirm the read of *param is used for internal control flow or iteration state rather than solely for returning data to the caller. Signals: *param drives cursor movement, loop continuation, or buffer slicing.

6) Step 6: Ensure path feasibility from function entry: there exists a path to the unguarded read where the parameter could be NULL. Signals: no prior unconditional requirement (assert, early return) that param is non-NULL; param originates from the caller unchanged.

7) Step 7: Prioritize cases where guarded writes coexist with unguarded reads in different branches (e.g., on-match writes under “if (param)”, off-match path uses *param to skip). Signals: conditional that writes to *param only on specific condition, but loop progression uses *param regardless.

8) Step 8: Exclude safe patterns where all reads of *param are strictly dominated by a null-check or are predicated on the same guard in all paths. Signals: every dereference of *param occurs only inside blocks proven to require param != NULL.

9) Step 9: Optionally rank findings higher when the parameter’s name or usage aligns with size/length semantics (e.g., len) and the read value is used to advance a buffer pointer and decrease a length variable within a loop. Signals: simultaneous pointer increment and length decrement using the same *param value.

3. Limitations & Assumptions
- The checker infers “optional” semantics from guarded writes; formal API documentation is not available.
- It cannot prove callers always pass non-NULL; thus, some findings may be false positives if external contracts guarantee non-NULL.
- It does not model callee behavior (e.g., whether helper functions validate or initialize the pointer); analysis focuses on local unguarded dereferences.
- The plan targets pointer-to-scalar out-parameters; complex aliasing or indirect propagation may reduce precision.