1. CVE Identifier
CVE-2025-38313

2. Vulnerability Type
Double-free (heap memory corruption)

3. Root Cause Summary
In fsl_mc_device_add(), when adding a DPRC device, mc_bus is allocated and mc_dev is set to point into that allocation (“mc_dev = &mc_bus->mc_dev;”). On the error path (error_cleanup_dev), the pre-patch code unconditionally called kfree(mc_bus); followed by kfree(mc_dev);. Since mc_dev aliases the already freed mc_bus allocation, this resulted in a double-free of the same memory. The patch corrects this by freeing only mc_bus when it is non-NULL, and freeing mc_dev otherwise.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Freescale Management Complex (MC) bus driver (drivers for bus type “fsl-mc”); function fsl_mc_device_add() in the MC bus core.

2) Pre-Patch Flaw:
In fsl_mc_device_add(), for DPRC objects, mc_bus is kzalloc’ed and mc_dev is assigned as a reference into mc_bus (“mc_dev = &mc_bus->mc_dev;”). At label error_cleanup_dev, the code executed:
- kfree(mc_dev->regions);
- kfree(mc_bus);
- kfree(mc_dev);
This unconditionally frees both mc_bus and mc_dev, even though mc_dev is embedded within mc_bus, causing a double-free.

3) Trigger Condition:
Any failure that jumps to error_cleanup_dev during creation of a DPRC device in fsl_mc_device_add(), such as unknown device type, get_dprc_icid() failure, MMIO region retrieval failure, or device_add() failure, with mc_bus allocated and mc_dev referencing mc_bus->mc_dev.

4) Impact Mechanism:
Double-free of kernel heap memory corrupts slab allocator metadata, which can lead to kernel crashes, undefined behavior, or potential exploitation avenues due to heap corruption.

5. Patch Analysis
1) Fix Approach:
Introduce conditional deallocation to avoid freeing the same underlying memory twice when mc_dev aliases mc_bus->mc_dev. Specifically, free mc_bus if it was allocated (DPRC case), otherwise free mc_dev (non-DPRC case).

2) Key Code Changes:
- Pre-patch (error_cleanup_dev): “kfree(mc_bus); kfree(mc_dev);”
- Post-patch (error_cleanup_dev): 
  - if (mc_bus) kfree(mc_bus);
  - else kfree(mc_dev);
This ensures only one free corresponding to the actual allocation is performed. The patch also leaves kfree(mc_dev->regions) intact, which is independent.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The fix is purely in error-path memory management and does not alter synchronization primitives or execution ordering.

6. Broader Kernel Security Implications
This issue highlights the risk of mixing embedded objects and separate allocations in error paths; aliases must be considered to prevent double-frees. Error handling should mirror release semantics (as fsl_mc_device_release() already correctly frees either the bus container or device depending on type). Static checks like “kfree(NULL) is safe” do not account for aliasing; conditional frees based on allocation provenance are necessary. Adopting consistent lifetime management patterns (and careful handling of embedded structures) reduces memory corruption risks across kernel subsystems.