1. Plan Summary
Detect functions that free both a heap-allocated “container” and a pointer alias to one of its embedded fields, causing double-free/invalid interior free in error cleanup paths.

2. Detection Steps
1) Step 1: Identify candidate “container” variables allocated with kmalloc/kzalloc (e.g., mc_bus) within a function. Signal: variable assigned from kmalloc/kzalloc and later used as a struct pointer.

2) Step 2: Identify “alias” variables assigned to the address of a field within the container (e.g., mc_dev = &mc_bus->mc_dev). Signal: assignment that uses the unary address-of operator applied to a member expression of the container.

3) Step 3: Track data flow to ensure the alias retains the “interior-pointer” definition at the cleanup site. Signal: no reassignment of the alias to another value (including NULL or a fresh kmalloc) along paths to the free calls.

4) Step 4: Optionally detect alternate allocation of the alias itself via kmalloc/kzalloc on a different branch. Signal: alias receives a kmalloc/kzalloc result in a distinct control-flow path, indicating conditional ownership versus embedding.

5) Step 5: Locate cleanup regions reachable from error paths (e.g., labeled blocks like error_cleanup_dev or common epilogues) that perform deallocation. Signal: a basic block or sequence containing kfree calls before returning an error.

6) Step 6: Within such a cleanup region, check for kfree(container) and kfree(alias) both present and reachable on the same path. Signal: two kfree calls whose arguments are respectively the container and the alias, with control flow allowing both to execute.

7) Step 7: Confirm ordering and path feasibility where kfree(container) can execute before kfree(alias) after the alias was derived from the container. Signal: path-sensitive analysis ensuring the alias assignment precedes both frees and no intervening alias redefinition.

8) Step 8: Exclude safe patterns that conditionally free one or the other based on mutually exclusive guards reflecting allocation choice. Signal: constructs like “if (container) kfree(container); else kfree(alias);” or equivalent exclusive checks that prevent both frees in the same execution.

9) Step 9: Flag also the invalid interior free case even without the container free, if the alias may be an interior pointer and kfree(alias) is reachable. Signal: alias dataflow from “&container->field” to a kfree call with no evidence alias was separately kmalloc’d on that path.

10) Step 10: Increase confidence by verifying the container passed to kfree matches the heap object originally allocated (same variable, no aliasing to fields). Signal: the kfree argument is the base pointer returned by kmalloc/kzalloc, not a member address.

11) Step 11: Suppress false positives where the alias is nulled before the cleanup (kfree(NULL) safe) or the container is unallocated on that path. Signal: check for alias = NULL or evidence that the container allocation site is not reachable on the flagged path.

12) Step 12: Produce a diagnostic that includes: the container allocation site, the alias-to-embedded-field assignment, and the cleanup region with both frees. Signal: path summary showing control-flow from allocation/aliasing to the dual kfree.

3. Limitations & Assumptions
- Only kmalloc/kzalloc/kfree patterns are considered; other custom allocators/frees are not modeled from the provided materials.
- Mutual exclusivity beyond simple if/else constructs may be hard to prove; complex predicates could lead to conservative reports.
- Interprocedural aliasing or pointer casts obscuring “&container->field” relationships are not fully handled based on the given inputs.
- Concurrency, lifetime across functions, and external side effects are out of scope; the checker focuses on intra-function error paths.