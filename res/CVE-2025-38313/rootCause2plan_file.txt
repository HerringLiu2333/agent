1. Plan Summary
Detect double-free caused by freeing both a heap-allocated container and an alias pointer to one of its embedded fields along the same error/cleanup path.

2. Detection Steps
1) Step 1: Identify functions that allocate a struct and then create an alias pointer to an embedded field via address-of. Signals: a heap allocation call (e.g., kzalloc) assigned to a variable, followed by “alias = &container->field” within the same function; based on [FILE_CONTENT] where mc_bus is allocated and mc_dev = &mc_bus->mc_dev. FP mitigation: require that the alias assignment post-dominates the allocation and that both variables are live thereafter.

2) Step 2: Locate error/cleanup blocks reachable via gotos or direct fall-through that perform deallocation. Signals: labels like error_cleanup_* or consecutive kfree calls in a cleanup section; based on [PATCH_DIFF] error_cleanup_dev block and [ROOTCAUSE_ANALYSIS] description. FP mitigation: only consider blocks reachable from the allocation path via control-flow edges.

3) Step 3: Confirm that the alias pointer refers inside the allocated container. Signals: alias pointer computed with address-of on the allocated pointer’s struct field (interior pointer); aligns with mc_dev = &mc_bus->mc_dev in [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS]. FP mitigation: exclude cases where alias is later reassigned or points to a different allocation via function calls.

4) Step 4: Check for unconditional freeing of both the container and the alias along a single path. Signals: two deallocator calls on the same path, one for the container (kfree(container)) and one for the alias (kfree(alias)), without mutually exclusive guards; based on pre-patch sequence in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: require that both calls are jointly reachable under the same branch/label without if/else separation.

5) Step 5: Verify absence of guards that prevent double-free. Signals: lack of a conditional that frees exactly one of the two pointers (e.g., if (container) kfree(container); else kfree(alias)); based on the fix in [PATCH_DIFF]. FP mitigation: do not flag when a guard ensures only one of the two frees happens.

6) Step 6: Ensure the alias pointer has not been separately allocated. Signals: no kmalloc/kzalloc assignment to the alias variable after the address-of assignment; aligns with mc_dev assignment pattern in [FILE_CONTENT]. FP mitigation: require dataflow showing alias derives only from the address-of expression on the container pointer.

7) Step 7: Confirm that the freed alias and container point to overlapping memory regions. Signals: alias is syntactically a field of the container type and the container is the base returned by the allocator; matches mc_dev embedded in mc_bus in [ROOTCAUSE_ANALYSIS]. FP mitigation: exclude cases where free of alias pertains to independently allocated subresources (e.g., mc_dev->regions), which are separate allocations in [FILE_CONTENT].

8) Step 8: Restrict to deallocation primitives consistent with the allocation. Signals: use of kfree for the alias and container that were obtained from kmalloc-family; per kernel patterns in [FILE_CONTENT] and [PATCH_DIFF]. FP mitigation: ignore other custom free routines unless paired with kmalloc-family patterns to avoid mismatched-free noise.

9) Step 9: Path sensitivity for error conditions. Signals: errors triggered before device_add success or when type-specific steps fail (unknown type, get_dprc_icid failure, MMIO region retrieval failure), as noted in [ROOTCAUSE_ANALYSIS]; verify the error path with both frees is reachable from those points. FP mitigation: require at least one explicit goto to the cleanup label from a failing call in the branch where alias was created.

10) Step 10: Report when all above conditions hold, attributing the double-free to aliasing of an embedded field of a freed container. Signals: presence of both kfree(container) and kfree(alias) in the same cleanup path with alias created via &container->field; directly maps to the double-free root cause in [ROOTCAUSE_ANALYSIS]. FP mitigation: include a summary explaining the aliasing provenance and the absence of guarding in the cleanup.

3. Target Elements
- Functions containing: heap allocation sites (kmalloc/kzalloc), address-of assignments to struct fields, error/cleanup labels with goto edges.
- Call sites to deallocators (kfree).
- Condition checks influencing allocation branch (e.g., “type == dprc” as context).
- Control-flow constructs leading to cleanup blocks (labels, goto, error returns).

4. Dataflow / Taint Considerations
- Track dataflow from the allocation result into an alias pointer created via address-of a field (&container->field).
- Track control-flow reachability from allocation and alias creation to the cleanup label executing both frees.
- Ensure the alias pointer is not tainted by subsequent reassignments to new allocations or external function returns.

5. Validation & Test Cases
- Positive: A function allocates “bus” via kzalloc, sets “dev = &bus->mc_dev”, then in error_cleanup executes kfree(bus); kfree(dev); — expect a report (mirrors pre-patch in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: Same setup but cleanup uses “if (bus) kfree(bus); else kfree(dev);” — expect no report (matches fixed logic in [PATCH_DIFF]).
- Negative: Two kfree calls on distinct independently allocated pointers without aliasing (e.g., kfree(buf1); kfree(buf2);) — expect no report.
- Test harness notes: Include path with goto to cleanup from a failing call after alias creation to verify path sensitivity.

6. Estimated Effort & Priority
High.

7. Likely False-Positive Sources & Mitigations
- Alias pointer reassigned later to a separate allocation; mitigation: require no reassignments after address-of.
- Custom allocation/free APIs masquerading as kfree; mitigation: restrict to kmalloc-family and kfree pairs.
- Cleanup code with implicit mutual exclusion not captured by simple guards; mitigation: require explicit if/else or dominance analysis proving exclusivity.
- Interior pointers that are legitimately freed via bespoke semantics; mitigation: limit to kernel kfree where freeing interior pointers is invalid.

8. Limitations & Assumptions
- Assumes deallocation via kfree for kmalloc-family allocations; other allocators are not covered due to lack of evidence in provided materials.
- Path feasibility beyond syntactic reachability may require advanced control-flow modeling not fully determinable here.
- Type checks (e.g., “dprc”) influence alias creation, but the checker generalizes the pattern without relying on specific type strings.
- Does not account for cross-function lifetime management or custom release callbacks beyond the in-function error path described.