1. CVE Identifier
CVE-2025-38313

2. Vulnerability Type
Double-free (memory corruption)

3. Root Cause Summary
In fsl_mc_device_add’s error path (label error_cleanup_dev), the pre-patch code unconditionally freed both mc_bus and mc_dev without accounting for the DPRC case where mc_dev is merely a reference to a field within the newly allocated mc_bus. As a result, freeing mc_bus followed by freeing mc_dev caused a double-free of the same underlying allocation. The patch corrects this by making deallocation ownership-aware: if mc_bus was allocated, only mc_bus is freed; otherwise mc_dev is freed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Freescale/NXP DPAA2 Management Complex bus (fsl-mc), function fsl_mc_device_add

2) Pre-Patch Flaw:
Unconditional deallocation of both mc_bus and mc_dev in the error_cleanup_dev path, despite mc_dev being an alias into mc_bus for DPRC devices.

3) Trigger Condition:
When adding an MC device that is a DPRC, mc_bus is allocated and mc_dev references a field within mc_bus; an error occurs earlier in fsl_mc_device_add, causing execution of error_cleanup_dev.

4) Impact Mechanism:
Freeing mc_bus and then mc_dev (“kfree(mc_bus); kfree(mc_dev);”) results in double-free of the same memory region, leading to slab metadata corruption and potential kernel crash or memory safety violations.

5. Patch Analysis
1) Fix Approach:
Introduce ownership-aware conditional deallocation to prevent freeing both pointers when they alias the same allocation.

2) Key Code Changes:
In fsl_mc_device_add at error_cleanup_dev:
- Replace
  “kfree(mc_bus);
   kfree(mc_dev);”
  with
  “if (mc_bus)
       kfree(mc_bus);
   else
       kfree(mc_dev);”
- Retain prior “kfree(mc_dev->regions);” before the conditional free.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is limited to error-path memory management and conditional freeing.

6. Broader Kernel Security Implications
Error-path double-frees in bus/device initialization can be triggered by probe failures or malformed device configurations, risking kernel memory corruption. Ensuring correct ownership and alias awareness in cleanup paths strengthens kernel robustness and reduces the attack surface for exploitation via error handling code.