1. Plan Summary
Detect cases where a pointer is assigned to an embedded field of a heap-allocated object and both the container and the embedded-field pointer are freed on the same error/cleanup path, causing a double-free/invalid free (as in mc_dev = &mc_bus->mc_dev followed by kfree(mc_bus); kfree(mc_dev)).

2. Detection Steps
1) Step 1: Objective: Identify heap allocation of a container object. Signals: Calls to kernel allocators (e.g., kzalloc/kmalloc) whose result is stored in a pointer variable (e.g., mc_bus). Why: Based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS, mc_bus is the allocated base object. FP mitigation: Exclude stack/const/global addresses and ensure the pointer is assigned the allocator return value.

2) Step 2: Objective: Detect aliasing where a second pointer refers to an embedded field of the allocated container. Signals: Assignments taking the address of a field of the allocated object (e.g., mc_dev = &mc_bus->mc_dev). Why: This aliasing is the root of the bug per FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS. FP mitigation: Require the address-of operation (&container->field) or equivalent direct field-address capture in the same function scope.

3) Step 3: Objective: Locate cleanup/error paths that free both the container and the alias pointer. Signals: Presence of kfree(container) and kfree(alias) reachable from a common label/block (e.g., error_cleanup_dev) without intervening return; as shown in PATCH_DIFF and FUNCTION_CONTENT. Why: ROOTCAUSE_ANALYSIS notes unconditional kfree(mc_bus); kfree(mc_dev) caused the defect. FP mitigation: Require both free calls to be on the same control-flow path with no guarding condition separating them.

4) Step 4: Objective: Ensure the path is feasible with the alias in effect. Signals: Control-flow path where the alias assignment precedes the cleanup block and neither the container nor the alias is reassigned/nullified before the frees. Why: Confirms the inner pointer still aliases the freed allocation (ROOTCAUSE_ANALYSIS). FP mitigation: Drop paths where alias is overwritten, set to NULL, or conditionally assigned in mutually exclusive branches not leading to the two frees.

5) Step 5: Objective: Distinguish safe conditional cleanup from unsafe unconditional double-free. Signals: If the code uses mutually exclusive conditions to free exactly one of the two (e.g., if (container) free(container); else free(alias)), treat as safe; this matches PATCH_DIFF’s fix. Why: PATCH_DIFF shows the intended correct pattern that avoids double-free. FP mitigation: Suppress findings when a clear else-if mutual exclusivity ensures only one free executes.

6) Step 6: Objective: Preferentially flag interior-pointer frees even if the container free is absent. Signals: kfree(alias) where alias is known to be &container->field derived from a heap allocation in the same function. Why: ROOTCAUSE_ANALYSIS frames this as invalid free of a non-kmalloc pointer; freeing an interior pointer is unsafe regardless. FP mitigation: Only flag when the container was allocated via kmalloc-family and alias derives from its field address (avoid generic pointers with unknown provenance).

7) Step 7: Objective: Account for null-safety checks to avoid spurious reports. Signals: Recognize that kfree(NULL) is safe (PATCH_DESCRIPTION), so the presence or absence of null-checks should not affect detection; instead, ensure at least one feasible path where allocation succeeded. Why: The bug triggers when allocation succeeds and later error occurs (ROOTCAUSE_ANALYSIS triggers). FP mitigation: Require a path with successful allocation (non-NULL result) and subsequent error-induced jump to cleanup.

8) Step 8: Objective: Exclude frees of distinct, separately allocated subfields. Signals: Skip frees of fields like kfree(obj->regions) when the field is independently allocated and not an alias variable representing the whole device (FUNCTION_CONTENT shows mc_dev->regions is separately freed). Why: This avoids conflating legitimate suballocation frees with the alias problem. FP mitigation: Limit detection to frees of the alias variable itself or its direct aliases, not unrelated member fields.

9) Step 9: Objective: Restrict scope to intra-procedural patterns where allocation, aliasing, and cleanup co-occur. Signals: All key events happen within the same function body (as in fsl_mc_device_add). Why: ROOTCAUSE_ANALYSIS and FUNCTION_CONTENT show the flaw is local to one function’s error path. FP mitigation: Avoid inter-procedural aliasing unless strong evidence is present to reduce FPs.

10) Step 10: Objective: Produce precise diagnostics tying cause and effect. Signals: Report the locations of (a) container allocation, (b) alias assignment (&container->field), and (c) both free calls in the same cleanup. Why: Aids triage by mapping exactly to the sequence that causes double/invalid free (ROOTCAUSE_ANALYSIS, PATCH_DIFF). FP mitigation: Only report when all three anchors are identified.

3. Target Elements
- Functions containing: heap allocation sites, address-of-field alias assignments, and error/cleanup labels or unified return blocks.
- Call sites to kfree (and similar kernel deallocators if modeled).
- Control-flow constructs leading to error labels (goto, if-conditions) and their dominance/ordering.
- Assignments and reassignments to the container and alias variables.
- Conditional constructs that enforce mutual exclusivity between frees.

4. Dataflow / Taint Considerations
- Track dataflow from allocator return to the container pointer.
- Track aliasing from the container to an interior pointer via address-of-field assignments; maintain may-alias relation.
- Path-sensitivity: ensure the aliasing assignment dominates the cleanup path where frees occur, with no intervening writes nullifying or reassigning.
- Control dependence: ensure both frees can execute on the same path and are not mutually exclusive (suppress when guarded by if/else as in PATCH_DIFF).

5. Validation & Test Cases
- Positive: Allocate container = kzalloc(...); alias = &container->inner; on error: kfree(container); kfree(alias); Expect a finding for double/invalid free (mirrors FUNCTION_CONTENT pre-patch and ROOTCAUSE_ANALYSIS).
- Positive: Allocate container = kzalloc(...); alias = &container->inner; on error: kfree(alias); Expect a finding for invalid free of interior pointer (Step 6).
- Negative: Allocate container; alias = &container->inner; on error: if (container) kfree(container); else kfree(alias); Expect no finding (matches PATCH_DIFF fix).
- Negative: container = NULL; alias allocated separately with kzalloc; on error: kfree(container); kfree(alias); Expect no finding (no interior alias relationship).
- Test harness notes: Include paths where allocation succeeds but later calls fail (e.g., after type check or device_add) to exercise feasible error labels as in FUNCTION_CONTENT.

6. Estimated Effort & Priority
Medium: Requires modeling of address-of-field aliasing and path-sensitive control-flow, but confined intra-procedurally with straightforward allocator/free matching.

7. Likely False-Positive Sources & Mitigations
- Alias lost or overwritten before cleanup: mitigate by requiring no intervening reassignment or nullification.
- Mutually exclusive frees not recognized due to complex conditions: mitigate by recognizing standard if/else, switch exclusivity; conservatively suppress when exclusivity is provable.
- Non-standard alloc/free wrappers: mitigate by limiting to known kernel allocators/frees per evidence (kzalloc/kfree).
- Inter-procedural aliasing (e.g., container_of patterns) not handled: limit to explicit &container->field cases to avoid speculation.

8. Limitations & Assumptions
- Assumes the deallocator of interest is kfree, as shown in PATCH_DIFF and FUNCTION_CONTENT; other APIs are not covered due to lack of evidence.
- Does not model string-based conditions (e.g., strcmp on types); treats aliasing paths as potentially feasible without resolving runtime strings (ROOTCAUSE_ANALYSIS lists triggers but not statically provable).
- Does not attempt cross-function alias modeling or container_of macro patterns, which are not evidenced in the provided code.