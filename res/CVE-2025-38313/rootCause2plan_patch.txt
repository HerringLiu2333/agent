1. Plan Summary
Detect error-path double-free bugs where two pointers that may alias the same underlying allocation (one being a subobject/field reference of the other) are unconditionally freed, as in the pre-patch fsl_mc_device_add case.

2. Detection Steps
1) Step 1: Objective: locate cleanup/error blocks with multiple deallocations. Signals: within a function, identify basic blocks or label-targeted cleanup paths (e.g., error labels) that make two or more calls to kfree-like deallocators in sequence (based on PATCH_DIFF showing consecutive kfree(mc_bus); kfree(mc_dev); at error_cleanup_dev). FP mitigation: restrict to pairs of frees executed on all paths through the block (no guarding condition between them).

2) Step 2: Objective: collect the pair(s) of freed pointer expressions in such blocks. Signals: extract the variables/expressions passed to kfree for each call; normalize through simple aliases (assignments, phi merges) to underlying variables. FP mitigation: ignore frees of the same variable twice (a different class) and focus on two distinct pointer variables as in the patch (mc_bus and mc_dev).

3) Step 3: Objective: determine if one freed pointer can be a subobject/field reference derived from the other. Signals: along any path reaching the cleanup, find assignments where the second pointer is set from the address-of a field of the first pointer’s pointee (e.g., p2 = &p1->field) or equivalent field-pointer derivations; this reflects “mc_dev is a reference to one of [mc_bus’s] fields” (ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION). FP mitigation: require that the field-derivation dominates or reaches the cleanup along at least one feasible path without being overwritten.

4) Step 4: Objective: confirm heap ownership for the “container” pointer. Signals: check that the container pointer (the one whose field was referenced) receives a value from a heap allocation API in the same function on a path to cleanup (e.g., kmalloc/kzalloc-style), matching “a new mc_bus is allocated” (PATCH_DESCRIPTION, ROOTCAUSE_ANALYSIS). FP mitigation: if the container pointer is never seen receiving a heap allocation in-function (or only receives stack/global addresses), do not flag.

5) Step 5: Objective: check for unconditional double-free risk. Signals: verify both frees are unguarded by mutual-exclusion conditions and occur in the same block/sequence (as in the pre-patch unconditional kfree(mc_bus); kfree(mc_dev); from PATCH_DIFF). FP mitigation: if an if/else enforces that only one of the two pointers is freed (e.g., “if (mc_bus) free(mc_bus); else free(mc_dev);” per PATCH_DIFF), suppress the alert.

6) Step 6: Objective: ensure path feasibility of the alias case reaching the cleanup. Signals: confirm there exists a control-flow path where (a) the container is allocated, (b) the subobject pointer is derived from it, and (c) execution reaches the cleanup with both frees executed; this mirrors the DPRC error path (ROOTCAUSE_ANALYSIS Trigger Condition). FP mitigation: exclude if conditions along the path conclusively prevent both frees when aliasing holds (e.g., prior early returns).

7) Step 7: Objective: detect order-sensitive freeing that implies double-free. Signals: when one freed pointer may be a subobject of the other’s allocation, and the container is freed first followed by the subobject pointer, flag due to freeing the same underlying allocation twice (ROOTCAUSE_ANALYSIS Impact Mechanism). FP mitigation: if the second free is guarded by a check that the alias does not hold (and that check dominates the free), suppress.

8) Step 8: Objective: rule out intentional ownership transfers or independent allocations. Signals: if the subobject-like pointer also has independent allocation sources that dominate cleanup on all paths (i.e., it always comes from its own kmalloc on paths to cleanup), consider it independent. FP mitigation: require evidence of subobject derivation on at least one path to the cleanup with no intervening reassignment to an independent allocation.

9) Step 9: Objective: account for nulling patterns that prevent a second free. Signals: check if either pointer is set to NULL between the two frees and the second free is guarded or null-checked; this indicates explicit prevention (PATCH_DESCRIPTION notes “kfree(NULL) is safe” guarding pattern). FP mitigation: if the second free is control-dependent on a NULL state that must hold, do not warn.

10) Step 10: Objective: focus on error/cleanup flows typical in kernel code. Signals: prioritize labels with names suggesting error cleanup and goto edges leading to them, as shown by label error_cleanup_dev (PATCH_DIFF). FP mitigation: de-prioritize normal-return paths where multiple frees are part of structured separate-object teardown.

3. Target Elements
- Functions with error labels/cleanup sections and goto-based unwinding.
- Calls to kfree-like deallocators.
- Heap allocation sites for container objects.
- Assignments deriving subobject pointers from container objects (address-of field, field pointer).
- Control-flow conditions guarding or selecting frees (if/else).
- Dominance and reachability relations between allocations, derivations, and frees.

4. Dataflow / Taint Considerations
- Track intra-procedural dataflow from allocation sites to container pointers.
- Track derivation flows creating subobject/field pointers from container pointers (address-of member or equivalent).
- Propagate aliases through assignments/phi nodes to the variables freed.
- Perform path feasibility checks ensuring an aliasing path reaches the cleanup where both frees occur unconditionally.

5. Validation & Test Cases
- Positive: Allocate A = kmalloc(...); set B = &A->field; goto error: kfree(A); kfree(B); Expect a report (matches PATCH_DIFF pre-fix and ROOTCAUSE_ANALYSIS).
- Positive: Path 1: A=kmalloc; B=&A->field; Path 2: B=kmalloc; Common error label does kfree(A); kfree(B); Expect a report due to feasible aliasing path.
- Negative: error label uses if (A) kfree(A); else kfree(B); Expect no report (matches PATCH_DIFF fix).
- Negative: Independently allocate A and B via kmalloc on all paths; error label kfree(A); kfree(B); Expect no report.
- Test harness notes: Include cases with and without intervening NULL checks, with goto-based cleanup, and with assignments that overwrite B before cleanup.

6. Estimated Effort & Priority
High — kernel memory corruption via double-free on error paths is severe, and patterns are well-scoped by alias and control-flow analysis.

7. Likely False-Positive Sources & Mitigations
- Imprecise aliasing when subobject derivation occurs interprocedurally; mitigate by limiting to intra-procedural derivations.
- Cases where field-like derivation is later overwritten by independent allocation; mitigate by requiring no dominating overwrite on the path to cleanup.
- Benign double-free lookalikes where mutual exclusion is enforced by non-obvious conditions; mitigate with dominance/control-dependence checks for guards.

8. Limitations & Assumptions
- Assumes recognition of heap allocation and kfree-like APIs; only kfree is evidenced (PATCH_DIFF), so other deallocators are not covered here.
- Analysis is intra-procedural; interprocedural aliasing (e.g., via helper functions) may be missed.
- Does not prove DPRC-specific semantics; relies on structural evidence that one pointer can be a subobject of another (ROOTCAUSE_ANALYSIS).
- Cannot fully prove runtime feasibility under complex conditions; uses conservative path-feasibility within the function.