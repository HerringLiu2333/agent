1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds read

3. Root Cause Summary
The function cs_dsp_mock_bin_add_name_or_info rounded the string length up to a multiple of 4 and then used that padded length as the memcpy source size, i.e., “memcpy(tmp, info, info_len)” after info_len had been increased. This caused memcpy to read past the end of the original source string when the original length was not a multiple of 4. The bug stems from using the destination’s padded size instead of preserving and using the original source length for the copy.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware test utilities for Cirrus Logic DSP (FW_CS_DSP_KUNIT_TEST_UTILS) within cs_dsp KUnit tests.

2) Pre-Patch Flaw:
In cs_dsp_mock_bin_add_name_or_info, info_len was set to strlen(info), then rounded up to a multiple of 4, and used directly in “memcpy(tmp, info, info_len)”, causing the copy to read beyond the true length of the source string.

3) Trigger Condition:
Any info string whose length is not divisible by 4 (info_len % 4 != 0), which activates the padding path and the incorrect memcpy length.

4) Impact Mechanism:
memcpy performs an out-of-bounds read from the source pointer (info), potentially accessing adjacent memory and triggering KASAN OOB read reports; in non-sanitized builds this could lead to information exposure or faults depending on memory layout.

5. Patch Analysis
1) Fix Approach:
Preserve the original string length separately and use it as the memcpy size, while keeping the padded destination size for allocation and payload length.

2) Key Code Changes:
- Introduced “size_t copy_len = info_len;” before rounding.
- Changed “memcpy(tmp, info, info_len);” to “memcpy(tmp, info, copy_len);”.
This ensures only the original string length is read from the source, and the extra padded bytes remain zero-initialized by kunit_kzalloc.

3) Locking/Concurrency Impact:
None; the change is purely in copy length logic within a test utility function and does not alter locking or ordering.

6. Broader Kernel Security Implications
This fix reinforces a common pattern for safe padding: round up only the destination allocation and payload length, but copy the exact source length. Avoiding OOB reads prevents subtle information leaks and sanitizer-detected faults, even within test code that can be reused or serve as reference for production paths. Similar string-padding/copy routines elsewhere should be audited to ensure source copy sizes are not derived from padded destination lengths.