1. Plan Summary
Detect cases where a length variable is rounded up for padding/alignment and then incorrectly reused as the copy size in memcpy/memmove, causing potential out-of-bounds read from the source buffer.

2. Detection Steps
1) Step 1: Identify memory copy operations — look for calls to memcpy/memmove and record destination, source, and the length/count argument — focus on these as the potential sink for oversized copies; reduce FPs by excluding memset-like functions and ensuring the third argument is a size/count.
2) Step 2: Track the length argument’s definition chain — find if it is assigned via a padding/alignment operation such as round_up(var, K) as shown in [PATCH_DIFF], especially if preceded by a modulo check (var % K) — this maps to the root cause where the size was increased for allocation ([ROOTCAUSE_ANALYSIS] 3 and 5); mitigate FPs by requiring dominance (the rounding dominates the memcpy) within the same function or block.
3) Step 3: Detect the modulo guard pattern — check if the rounding is inside a conditional that tests (len % C) or equivalent before assigning len = round_up(len, C) — this mirrors the trigger path where only misaligned lengths are padded ([PATCH_DIFF]); mitigate FPs by requiring the same variable appears in both the modulo test and the round_up call.
4) Step 4: Correlate destination allocation size — within the same block/branch, look for an allocation of the destination buffer using the padded length variable (e.g., kunit_kzalloc(test, len, …) as in [PATCH_DIFF]) — this indicates the padded value is meant for allocation, not for copy; reduce FPs by requiring the allocated pointer flows into the memcpy destination.
5) Step 5: Check for absence of preserved original length — ensure there is no separate variable capturing the pre-rounded length that is used as the memcpy size (contrast with the fix adding copy_len in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS] 5.1) — this strengthens confidence that the copy size is the padded length; mitigate FPs by ignoring cases where memcpy size is another variable/dataflow not equal to the rounded value.
6) Step 6: Assess monotonic increase — confirm that the rounding operation can only keep or increase the length (e.g., round_up) and that the branch requires misalignment (len % C != 0), implying the post-rounded value is strictly greater than the original ([ROOTCAUSE_ANALYSIS] 3) — this directly maps to potential OOB read from the source; mitigate FPs by requiring the modulo condition or an equivalent proof of strict increase along the path.
7) Step 7: Validate source pointer stability — ensure the source pointer to memcpy is not reallocated or resized within the same branch that performs rounding (i.e., only the destination is allocated with the padded length) — this matches the root cause where the source remains at original size ([ROOTCAUSE_ANALYSIS] 3); reduce FPs by requiring no allocation or resizing flows into the memcpy source in that region.
8) Step 8: Prefer string/data-length provenance — if available, detect that the length variable earlier represents a source data length (e.g., was assigned before rounding and used to reason about source content) — this strengthens the case that the original value was the correct copy size ([ROOTCAUSE_ANALYSIS] 3); mitigate FPs by treating this as a bonus signal, not a hard requirement.
9) Step 9: Scope and dominance — require the sequence (modulo check) → (round_up assignment) → (destination allocation using padded size) → (memcpy using same padded size) to occur within a single function and in a dominating order — this reduces interprocedural ambiguity and maps to the concrete flawed pattern in [PATCH_DIFF]; reduces FPs by constraining to localized patterns.
10) Step 10: Exempt fixed patterns — if a separate variable preserves the original length (e.g., size_t copy_len = len before rounding) and that preserved value is used as the memcpy size, do not report ([PATCH_DIFF] and [ROOTCAUSE_ANALYSIS] 5.1) — this avoids flagging corrected code paths.

3. Target Elements
- Calls to memcpy/memmove.
- Variable assignments to size/length variables, especially via round_up(len, K).
- Conditional checks testing len % K related to alignment.
- Allocation sites for the memcpy destination using the same (padded) length.
- Intra-procedural control-flow dominance relationships among the above statements.

4. Dataflow / Taint Considerations
- Track dataflow of the length variable from its original value to the rounded/padded value and into the memcpy length argument.
- Track dataflow from the padded length into the destination allocation size and the destination pointer into memcpy.
- Ensure the memcpy source pointer is not derived from an allocation using the padded size within the same region, indicating the source remains at original size.
- Recognize preservation of original length by checking for a variable assigned before rounding and used as memcpy size (treated as a safe pattern).

5. Validation & Test Cases
- Positive: Code where len is rounded up after if (len % 4) and memcpy(dst_allocated_with_len, src, len) uses the padded len as count, with no preserved original length variable (mirrors pre-patch snippet in [PATCH_DIFF]).
- Negative: Patched pattern where size_t copy_len = len precedes len = round_up(len, 4), destination is allocated with len, and memcpy uses copy_len as size ([PATCH_DIFF]).
- Test harness notes: Include variants where allocation is zero-initializing (as in kunit_kzalloc) and where the modulo guard is present; ensure control-flow dominance is respected within one function.

6. Estimated Effort & Priority
Medium effort; High priority due to memory safety implications and clear mapping to a common padding misuse ([ROOTCAUSE_ANALYSIS] 6).

7. Likely False-Positive Sources & Mitigations
- Source buffer is known (but not inferred) to be at least padded length: mitigate by requiring modulo guard and lack of source resizing within the branch.
- Custom alignment helpers or arithmetic not recognized as round_up: mitigate by anchoring on the modulo-guard + increase-and-reuse pattern; keep detection intra-procedural.
- Complex interprocedural flows where original/source length is updated elsewhere: mitigate by constraining to local, dominated sequences matching [PATCH_DIFF].

8. Limitations & Assumptions
- Assumes presence of a recognizable alignment function call like round_up as in [PATCH_DIFF]; other alignment idioms may be missed.
- Does not prove actual source buffer size; relies on the monotonic increase plus modulo-guard heuristic from [ROOTCAUSE_ANALYSIS] to infer risk.
- Focuses on memcpy/memmove; other copy APIs are not covered due to lack of evidence in the supplied materials.