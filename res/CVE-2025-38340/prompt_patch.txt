1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds memory read due to length miscalculation/padding

3. Root Cause Summary
In cs_dsp_mock_bin_add_name_or_info(), the code rounded the source string length (info_len) up to a 4-byte multiple and then used this padded length as the memcpy copy size. The original code “memcpy(tmp, info, info_len)” executed after “info_len = round_up(info_len, 4)”, causing memcpy to read past the end of the source buffer when the original length was not a multiple of 4. The flaw was a length misuse: failing to preserve and use the original source length for the copy, leading to OOB read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test code), function cs_dsp_mock_bin_add_name_or_info

2) Pre-Patch Flaw:
The function rounded info_len upward and reused the modified value as the memcpy count, instead of copying only the original length. This conflated allocation size (padded) with data length (actual), resulting in reading beyond the source buffer.

3) Trigger Condition:
Any input where info_len % 4 != 0 (i.e., source string length not a multiple of 4), triggering the padding logic and subsequent oversized memcpy.

4) Impact Mechanism:
memcpy reads beyond the bounds of the source buffer, leading to KASAN-reported OOB read. In kernel context—even KUnit—this can access unintended memory, potentially causing faults or information exposure.

5. Patch Analysis
1) Fix Approach:
Separate the original data length from the padded allocation length and use the original length for memcpy. Preserve info_len before rounding, allocate the padded size, and copy only the unpadded length; zero-initialization provides the padding content.

2) Key Code Changes:
- Introduced a new variable: “size_t copy_len = info_len;” before rounding.
- Changed memcpy to use the original length: from “memcpy(tmp, info, info_len)” to “memcpy(tmp, info, copy_len)”.
- Retained “info_len = round_up(info_len, 4);” solely for allocation size.

3) Locking/Concurrency Impact:
None. The change is confined to bounds handling; no locking or ordering modifications are involved.

6. Broader Kernel Security Implications
This fix reinforces the need to distinguish between logical data length and allocation/padding size, a common source of memory safety bugs in kernel code. Even within test code, OOB reads can mask real issues, destabilize tests, or indicate patterns that, if present in production paths, would lead to information disclosure or crashes. Adopting clear length management and zero-initialized padding avoids read-overruns and improves robustness against subtle memory errors detected by tools like KASAN.