1. Plan Summary
Detect memcpy/memmove calls that use a padded/aligned length (rounded up from strlen) as the copy size when the source is the original string, which can cause an out-of-bounds read.

2. Detection Steps
1) Step 1: Identify candidate copy sites â€” calls to memcpy or memmove. Signals: Third argument is a variable/expression N; second argument is a pointer S of type char const* or char*.

2) Step 2: Recover the original string length computation for the same source pointer S. Signals: A prior strlen(S) whose result flows to a variable Len0 dominating the copy site.

3) Step 3: Detect padding/alignment of the length before the copy. Signals: A transformation of Len0 into LenPad via either a call/macro named round_up(Len0, k) or an if-branch testing (Len0 % k) followed by assigning LenPad = round_up(Len0, k).

4) Step 4: Verify the copy size uses the padded length. Signals: Dataflow from LenPad to N (the size argument of memcpy/memmove) at the copy site; ensure N is not dataflow-equal to Len0.

5) Step 5: Correlate the destination allocation with the padded length to reduce false positives. Signals: A preceding allocation (e.g., kunit_kzalloc) whose size argument is LenPad and whose result is the destination pointer D used in the memcpy/memmove.

6) Step 6: Ensure the source of the copy is still the original pointer associated with strlen. Signals: The source argument S at memcpy/memmove aliases the argument to strlen and is not the newly allocated destination pointer D.

7) Step 7: Strengthen evidence that padding increased the size on this path. Signals: The copy is control-dependent on a check like (Len0 % k) != 0 (or equivalent), or the only available path is one in which LenPad is computed from Len0 by round_up; treat these as indicating LenPad >= Len0 and likely greater.

8) Step 8: Exclude safe-preservation patterns. Signals: If there exists a preserved variable CopyLen that is dataflow-equal to Len0 (pre-rounding) and the copy size N is dataflow-equal to CopyLen (not LenPad), do not flag.

9) Step 9: Exclude explicit bounding/min patterns. Signals: If N is syntactically or dataflow equivalent to a min-like expression that limits to Len0 (e.g., min(LenPad, Len0)) or the copy uses APIs that inherently cap by source length (not present here), do not flag.

10) Step 10: Report when a memcpy/memmove reads from S with N derived from LenPad (rounded-up from strlen(S)), especially under a (Len0 % k) path condition and with an allocation using LenPad for D, indicating potential OOB read from S.

3. Limitations & Assumptions
- The plan assumes the analyzer can resolve dataflow through macros like round_up; if treated purely as macros without flow modeling, detection may miss cases.
- Only round_up and modulo-check patterns are specified; other alignment idioms (bitmasking, arithmetic) are not covered by this plan due to lack of evidence in the materials.
- The plan assumes kunit_kzalloc is visible to the analyzer; other allocators are not enumerated here to avoid inventing facts beyond the inputs.
- Proving that LenPad > Len0 is path- and constant-dependent; without constant k or explicit (Len0 % k) guards, the checker may conservatively flag potential issues.