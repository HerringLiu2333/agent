1. Plan Summary
Detect memcpy/memmove calls that use a padded/rounded-up length derived from a string’s original length (e.g., strlen) for the copy size, causing potential out-of-bounds reads when padding is required (as in cs_dsp_mock_bin_add_name_or_info()).

2. Detection Steps
1) Step 1: Objective — Locate candidate memcpy/memmove calls where the third argument is a variable. Signals — Calls to memcpy/memmove with a non-constant size argument. FP mitigation — Exclude cases where the size argument flows from a known safe minimum (e.g., min of two lengths) or is directly the result of strlen/strnlen without intervening inflation.

2) Step 2: Objective — Identify “length inflation” via alignment/padding just before the copy. Signals — Assignments like len = round_up(len, K) or arithmetic aligning to a multiple-of-K, often under a predicate like if (len % K). FP mitigation — Require evidence that the new value can be greater than the prior value on the same path (e.g., a modulo check indicates non-multiple), per ROOTCAUSE_ANALYSIS trigger condition.

3) Step 3: Objective — Correlate the “original length” with a string measurement. Signals — A prior assignment len = strlen(src) or strnlen(src, …), where src is the same pointer later used as memcpy source. FP mitigation — Prefer cases where the source pointer remains unchanged between the strlen and memcpy and where no explicit bound/cap is applied after strlen.

4) Step 4: Objective — Detect use of the inflated length as the memcpy size. Signals — After len is rounded up, the same rounded variable is passed as the third argument to memcpy(dest, src, len). FP mitigation — Exclude cases where a separate variable preserves the pre-rounded length and is used for the copy (based on PATCH_DIFF introducing copy_len).

5) Step 5: Objective — Recognize the padding-allocation pattern indicating intent to pad the destination, not to read extra from the source. Signals — Allocation of the destination buffer using the rounded length (e.g., kzalloc/kunit_kzalloc with len after round_up) followed by memcpy into that buffer. FP mitigation — Confirm that the rounded length is used for allocation and that no explicit logic writes padding bytes after the memcpy (consistent with the pre-patch misuse per ROOTCAUSE_ANALYSIS).

6) Step 6: Objective — Establish that the path condition implies padding would occur. Signals — A control predicate such as if (orig_len % K) wrapping the rounding and the memcpy. FP mitigation — Require that the memcpy is control-dependent on this predicate to ensure feasibility of “len increased” on the copy path (PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS show this exact structure).

7) Step 7: Objective — Ensure the source’s available size is likely limited to the original string length. Signals — Source pointer typed as const char* or char*, measured via strlen, and not reallocated or extended; no accompanying known buffer size. FP mitigation — Exclude cases where the source is a heap/stack buffer with a known larger allocation size or where there is evidence of extra capacity initialization.

8) Step 8: Objective — Prioritize classical string-padding misuse patterns. Signals — Rounding to small constants (e.g., 2, 4, 8) and comments or variable names implying padding/alignment (as in “padded string” per FILE_CONTENT). FP mitigation — Lower severity or suppress if the copy uses safer string APIs (strlcpy/strscpy) or if subsequent code writes explicit zero padding.

9) Step 9: Objective — Highlight single-variable misuse. Signals — A single length variable is reused for both allocation size and memcpy length after being increased, without an intervening preservation of the original (contrasted with PATCH_DIFF adding copy_len). FP mitigation — Exclude if there exists a saved “original length” variable used for the copy size, matching the fix approach.

10) Step 10: Objective — Report when all key signals align with root cause. Signals — strlen-derived original length; conditional modulo check; round_up (or equivalent) inflating the same variable; memcpy using the inflated length from the original source pointer. FP mitigation — Require at least three converging indicators (string length measure, inflation, and use in memcpy) to reduce incidental arithmetic false positives.

3. Target Elements
- Calls to memcpy/memmove and similar raw memory copy APIs.
- Variables holding lengths derived from strlen/strnlen of a source pointer.
- Assignments performing alignment/padding (e.g., round_up, ALIGN-like arithmetic).
- Conditional checks on modulo (len % K) indicating non-aligned length.
- Allocation sites using the rounded/padded length for the destination buffer.
- Dataflow between source pointers measured by strlen and later used in memcpy.

4. Dataflow / Taint Considerations
- Track dataflow from strlen/strnlen result into a length variable (orig_len).
- Track transformations where orig_len is increased to a padded/rounded value (padded_len).
- Track that the memcpy source pointer is the same as the pointer measured by strlen and has not been re-materialized or bounded.
- Ensure control/data dependence that padded_len > orig_len is feasible (e.g., modulo predicate).
- Confirm memcpy third argument is padded_len rather than orig_len or a min(original, padded).

5. Validation & Test Cases
- Positive: Code that does len = strlen(src); if (len % 4) { len = round_up(len, 4); dest = kzalloc(len); memcpy(dest, src, len); }, mirroring the pre-patch cs_dsp_mock_bin_add_name_or_info() (ROOTCAUSE_ANALYSIS, FILE_CONTENT).
- Negative: Patched pattern with size_t copy_len = len; len = round_up(len, 4); dest = kzalloc(len); memcpy(dest, src, copy_len); (PATCH_DIFF fix), and variants using strlcpy/strscpy or memcpy with min(copy_len, len).
- Test harness notes: Include control-dependent paths (modulo branch) and paths without modulo branch (always-rounded) to ensure detection hinges on proven or plausible inflation of length.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Cases where the source buffer actually has capacity ≥ padded_len though not provable; mitigate by requiring strlen-based source-length origin and unchanged source pointer.
- Arithmetic that coincidentally increases a length unrelated to source bounds; mitigate by requiring explicit alignment patterns (round_up/modulo) and string-length provenance.
- Copies where later code zero-fills or otherwise safely manages padding; mitigate by detecting preserved original length usage or explicit capped copies.

8. Limitations & Assumptions
- Assumes availability of recognized alignment helpers (e.g., round_up) or detectable modulo/multiple-of-K arithmetic; other custom alignment idioms may be missed.
- Cannot always prove at compile time that the modulo predicate holds; the checker assumes feasibility when the branch guards the memcpy.
- Cannot always know the true allocation size of the source buffer; the heuristic relies on strlen provenance to suggest the source bound equals the original length.
- Focus is on out-of-bounds read from source during memcpy, not destination overflow, per ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION.