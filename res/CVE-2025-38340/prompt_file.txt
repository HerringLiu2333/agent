1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds read (length miscalculation during memcpy)

3. Root Cause Summary
In cs_dsp_mock_bin_add_name_or_info(), the code rounded the string length up to a 4-byte boundary for padding and then used this padded length as the memcpy() size from the original source string. This caused memcpy() to read past the end of the source buffer when padding was required (up to 3 extra bytes), leading to an out-of-bounds read detected by KASAN.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware: Cirrus Logic cs_dsp KUnit test utilities (linux/firmware/cirrus/cs_dsp_test_utils)

2) Pre-Patch Flaw:
- Function: cs_dsp_mock_bin_add_name_or_info()
- The variable info_len was updated to a padded value (round_up(info_len, 4)) and then used as the length in memcpy(tmp, info, info_len), causing the copy to read beyond the actual source string length.

3) Trigger Condition:
- Any call where strlen(info) % 4 != 0, i.e., when the input string length is not a multiple of 4 and padding is performed.

4) Impact Mechanism:
- memcpy() reads up to 3 bytes beyond the end of the source string pointer (info), resulting in an out-of-bounds read. This can trigger KASAN/OOB-read reports and potentially copy unintended adjacent kernel memory into the constructed test buffer.

5. Patch Analysis
1) Fix Approach:
- Separate the original string length from the padded length. Copy only the original length into a zero-initialized (kzalloc) padded buffer, leaving the padding bytes as zeros.

2) Key Code Changes:
- Added size_t copy_len = info_len; before rounding.
- Changed memcpy(tmp, info, info_len); to memcpy(tmp, info, copy_len); ensuring no over-read from the source.
- Evidence (diff hunk in cs_dsp_mock_bin_add_name_or_info()):
  - Introduces copy_len holding the pre-rounded length.
  - Uses copy_len as the memcpy length while keeping info_len for allocation and payload length.

3) Locking/Concurrency Impact:
- None. The issue is a pure length/logic error in test code; no locking or concurrency changes were made or needed.

6. Broader Kernel Security Implications
- Highlights a common pitfall: reusing a padded/aligned length for source-buffer memcpy leads to OOB reads. Similar patterns in production code (alignment/padding of payloads) can cause data leaks or crashes. Maintaining distinct variables for original vs. padded lengths and using zero-initialized buffers for padding are safer patterns that prevent OOB reads and inadvertent information disclosure.