1. Plan Summary
Detect out-of-bounds reads where a length derived from strlen is rounded up for padding and then incorrectly used as the memcpy source size instead of the original string length.

2. Detection Steps
1) Step 1: Objective: Identify candidate memory copy operations. Signals: Calls to memcpy (or equivalent raw byte copy) where the length argument is a variable/expression, not a literal. FP mitigation: Ignore cases where the length is a constant or directly tied to a compile-time known buffer size.

2) Step 2: Objective: Find copies whose length originates from a string-length function. Signals: Backward dataflow from memcpy’s length argument to a prior strlen(info) (or equivalent) producing a variable later reused as the copy size. FP mitigation: Require that the same source pointer used in memcpy’s second argument is also the argument of the strlen, per [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS].

3) Step 3: Objective: Detect padding/round-up transformations that can increase the length beyond the true string length. Signals: The strlen-derived variable is subsequently reassigned via round_up(len, K) or equivalent “multiple-of-K” adjustment, commonly guarded by a modulo check like (len % K). FP mitigation: Require evidence of increased length on the path (e.g., presence of modulo check and round_up as in [PATCH_DIFF]/[FUNCTION_CONTENT]).

4) Step 4: Objective: Verify the misuse in the copy operation. Signals: The memcpy uses the post-rounding length as its third argument (e.g., memcpy(tmp, info, info_len) where info_len was rounded up), matching [ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude cases where a separate preserved original length (e.g., copy_len = old info_len) is used for the memcpy, as shown fixed in [PATCH_DIFF].

5) Step 5: Objective: Corroborate that the rounding was for destination padding, not a justified source size. Signals: A heap allocation for the destination uses the rounded length (e.g., kunit_kzalloc(..., info_len)), consistent with [FUNCTION_CONTENT]. FP mitigation: Require that the rounded length variable flows to the allocation size and the same destination pointer flows to memcpy’s first argument.

6) Step 6: Objective: Ensure control-flow feasibility where the length actually increases. Signals: The memcpy call occurs under or after a branch where len % K != 0 is true and len is rounded up, as in [FUNCTION_CONTENT]. FP mitigation: Use path feasibility (i.e., along paths where modulo check passes) to reduce speculative matches.

7) Step 7: Objective: Avoid flagging already-fixed or safe variants. Signals: Presence of a distinct variable capturing the pre-rounded length (e.g., copy_len = info_len before round_up) that is used as the memcpy size, as in [PATCH_DIFF]. FP mitigation: Suppress alerts when memcpy size operand equals the preserved original length or an explicit min(original, padded).

8) Step 8: Objective: Generalize beyond the exact constant “4” while staying aligned with the root cause. Signals: Multiple-of-N padding via round_up(len, N) accompanied by a modulo check on the same N, per [ROOTCAUSE_ANALYSIS] pattern “round up to a multiple of 4.” FP mitigation: Require that N is a constant > 1 and appears consistently in both the modulo check and the rounding.

9) Step 9: Objective: Confirm string semantics of the source. Signals: The source pointer to memcpy is of character type and was previously passed to strlen (indicating NUL-terminated string intent). FP mitigation: Exclude cases where length is not derived from strlen or where the source is clearly non-string binary data without strlen involvement.

10) Step 10: Objective: Reduce aliasing false positives. Signals: Ensure that the variable rounded and used for allocation and memcpy length is the same SSA/dataflow identity (or tied through simple reassignments), as in [FUNCTION_CONTENT]. FP mitigation: Avoid flagging when there is intervening reassignment that replaces the length with another bounded value not proven to have increased.

3. Target Elements
- Calls to memcpy (and close equivalents performing raw copies).
- Variables receiving results from strlen.
- Arithmetic or macro-based round-up/padding operations (e.g., round_up(len, K); modulo checks on len % K).
- Allocation sites where the size is the rounded length (e.g., kunit_kzalloc/kzalloc).
- Control-flow conditions gating the padding path (len % K != 0).
- Assignments that preserve pre-rounded length (e.g., copy_len = len) for negative filtering.

4. Dataflow / Taint Considerations
- Track dataflow from strlen(source) into a length variable.
- Track transformations that increase the length via round_up/multiple-of-K logic and ensure the increased value flows into both allocation size and memcpy’s third argument.
- Track the source pointer identity: the argument to strlen must be the same (or an alias) as memcpy’s source argument.
- Track presence/absence of a preserved original length that flows into memcpy length; if present and used, do not flag.

5. Validation & Test Cases
- Positive: Pre-patch pattern from [FUNCTION_CONTENT]: info_len = strlen(info); if (info_len % 4) { info_len = round_up(info_len, 4); tmp = kunit_kzalloc(..., info_len); memcpy(tmp, info, info_len); } → should be flagged.
- Positive: Variant with different K (e.g., 8) and same pattern (strlen -> modulo -> round_up -> alloc with rounded -> memcpy with rounded) → should be flagged.
- Negative: Patched pattern from [PATCH_DIFF]: preserve copy_len before round_up and use copy_len in memcpy → should not be flagged.
- Negative: Copies where length is not derived from strlen or where memcpy size uses min(original_len, rounded_len) → should not be flagged.
- Test harness notes: Include control-flow paths where modulo check is false (no round_up) to ensure no false flags; include aliasing of the length variable through simple assignments to validate dataflow robustness.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Source buffer has extra valid bytes beyond strlen (string in a larger allocated region): mitigate by requiring strlen-origin and explicit round-up transformation plus path feasibility.
- Macro expansion/inline arithmetic patterns not recognized as “round up”: mitigate by anchoring on combined signals (modulo check plus increased assignment).
- Nonstandard memcpy-like wrappers: mitigate by initially targeting known memcpy and extensible to recognized equivalents cautiously.

8. Limitations & Assumptions
- Assumes availability of recognizable round-up constructs (e.g., round_up macro) and modulo checks; purely arithmetic alignments without clear signals may be missed.
- Cannot prove actual runtime buffer bounds of the source; relies on strlen usage as a proxy for string semantics.
- Kernel-specific helpers (kunit_kzalloc) are treated as generic allocations; the checker does not infer zero-initialization effects beyond confirming padding intent.
- Only evidence-based on the multiple-of-4 round-up pattern from [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]; broader patterns may require further domain knowledge.