1. Plan Summary
No checker can be accurately designed because [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] contain no usable content for CVE-2024-58099; the plan below documents the required steps once those artifacts are available and highlights current blockers.

2. Detection Steps
1) Step 1: Identify patched code regions — signals: enumerate changed files, functions, and conditions from [PATCH_DIFF] — FP mitigation: restrict analysis scope to affected symbols and nearby call chains only.
2) Step 2: Extract root-cause pattern from [ROOTCAUSE_ANALYSIS] — signals: precise vulnerability class (e.g., null-deref, OOB, UAF), preconditions, and sink/guard relationships — FP mitigation: require all documented preconditions to be simultaneously satisfied.
3) Step 3: Derive semantic invariants introduced by the patch — signals: new guards, return-value checks, bounds checks, ownership/lock operations, lifetime adjustments per [PATCH_DIFF] — FP mitigation: report only when the “before-patch” state lacks these invariants in equivalent contexts.
4) Step 4: Localize candidate sites — signals: find AST nodes matching pre-patch patterns (e.g., call sites to the same APIs, field accesses, pointer arithmetic) in functions analogous to those changed — FP mitigation: limit to same API usage patterns and data types as in the patched code.
5) Step 5: Model control/data dependencies that enforce the fix — signals: control-flow edges from checks to sinks; dataflow from parameters/returns to the vulnerable operations — FP mitigation: require that the path from source to sink bypasses all fix-like checks introduced in the patch.
6) Step 6: Check for missing/incorrect error handling — signals: unhandled error returns, ignored sentinel values, or early returns added by the patch — FP mitigation: only flag when the function’s contract (as implied by [PATCH_DIFF]) mandates handling.
7) Step 7: Validate resource/lifetime invariants — signals: allocation/free, init/use, lock/unlock sequences altered by the patch — FP mitigation: report only if a feasible path demonstrates the broken sequence that the patch enforces.
8) Step 8: Validate bounds/length invariants — signals: comparisons added around array/memory operations and their operands — FP mitigation: require that the same memory operation occurs without the newly added bounds check on feasible paths.
9) Step 9: Cross-function propagation — signals: preconditions moved to callers or callee contracts changed in [PATCH_DIFF] — FP mitigation: constrain to call chains observed in the patch and require consistent parameter flows.
10) Step 10: Suppress by equivalence — signals: alternative guards or equivalent invariants already present though different syntactically — FP mitigation: treat semantically equivalent checks (null, range, state) as satisfying the fix.
11) Step 11: Confirm exploitability — signals: feasibility of reaching the sink with violating state under realistic inputs as described in [ROOTCAUSE_ANALYSIS] — FP mitigation: require at least one feasible interprocedural path with unmet patch-introduced guard.
12) Step 12: Rank and de-duplicate — signals: prioritize findings most structurally similar to [PATCH_DIFF] contexts; collapse duplicates across overloads/templates — FP mitigation: use structural similarity to patched sites to raise precision.

3. Target Elements
- Functions modified or added in [PATCH_DIFF] and their immediate callers/callees.
- Call sites to APIs that appear in the patched hunks.
- Condition checks, especially new comparisons, null/state guards, and early returns introduced by the patch.
- Allocation/deallocation, init/use, and lock/unlock boundaries altered by the patch.
- Function return-value uses and error-handling branches affected by the patch.
- Memory/buffer operations (copy, read, write) wrapped by newly added checks.

4. Dataflow / Taint Considerations
- Track flow from function parameters, returns, and fields referenced in the patched conditions to the vulnerable operations.
- Model control dependencies: a guard introduced by the patch must dominate the sink to be considered protective.
- Track ownership/lifetime flows where the patch adds or reorders allocation/free or lock/unlock sequences.
- Track length/size variables and indices used in memory operations where the patch adds bounds checks.

5. Validation & Test Cases
- Positive: Pre-patch snippet mirroring [PATCH_DIFF] before-state (e.g., missing null/bounds/error check, improper lifetime/lock sequence) that reaches the same sink without the new guard; expect a finding.
- Negative: Post-patch snippet including the newly added guard/handling exactly as in [PATCH_DIFF]; expect no finding.
- Test harness notes: Include interprocedural cases reflecting caller/callee contract changes and paths with equivalent but differently written guards to test suppression.

6. Estimated Effort & Priority
High — Blocked until [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], or [ROOTCAUSE_ANALYSIS] provide the concrete vulnerability pattern and fix invariants.

7. Likely False-Positive Sources & Mitigations
- Alternative equivalent guards expressed differently; mitigate by semantic equivalence checks for null/range/state validations.
- Infeasible paths due to missed control dependencies; mitigate by requiring dominance/post-dominance relationships between guards and sinks.
- Context-mismatched API usage; mitigate by restricting to functions/files and call chains highlighted in [PATCH_DIFF].

8. Limitations & Assumptions
- All critical inputs are missing: [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] provide no actionable details; no vulnerability class, APIs, or fix patterns can be derived.
- The plan assumes that once artifacts are available, the checker will be anchored to patch-introduced guards and the root-cause description.
- Without these artifacts, specific signals, sinks, sources, and concrete examples cannot be defined, and no accurate detection is possible.