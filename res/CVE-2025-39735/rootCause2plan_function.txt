1. Plan Summary
Detect cases where a value is clamped or narrowed to a signed int using an upper bound from a wider/unsigned domain without validating it against INT_MAX, and the resulting int is then used as a size/length (size_t) in dump-like functions, enabling negative-to-large conversion and out-of-bounds reads (as in ea_get()).

2. Detection Steps
1) Step 1: Objective — Find clamping/min/max operations that explicitly use int as the destination type. Signals — Calls/macros like clamp_t with type argument int (or equivalent min_t/max_t with int) and an upper bound expression from an unsigned or wider integer domain (e.g., u32/size_t); based on PATCH_DIFF and ROOTCAUSE_ANALYSIS. FP mitigation — Exclude cases where the upper bound is a compile-time constant ≤ INT_MAX.

2) Step 2: Objective — Determine whether a safety guard exists for the oversized upper bound. Signals — In dominating control flow, search for a condition comparing the same upper bound expression to INT_MAX (e.g., upper > INT_MAX) with an early-return/logging path bypassing the clamp and sink, as shown in PATCH_DIFF. FP mitigation — If such a guard exists on all paths to the clamp, suppress the finding.

3) Step 3: Objective — Confirm the potentially lossy narrowing. Signals — The clamped result is stored in a signed int variable and the upper bound’s static type can hold values > INT_MAX (e.g., unsigned 32-bit or size_t), matching ROOTCAUSE_ANALYSIS. FP mitigation — Skip when the result variable is size_t/unsigned or when an explicit cast to a wider unsigned occurs before further use.

4) Step 4: Objective — Identify unsafe sink usage where a negative int can be reinterpreted as a large size_t. Signals — The int result flows as an argument to functions that take a size_t/unsigned length parameter, especially print_hex_dump as in FUNCTION_CONTENT and PATCH_DESCRIPTION. FP mitigation — Maintain a curated sink list initially limited to print_hex_dump (and optionally hex_dump_to_buffer if length is passed), to tightly match the described issue.

5) Step 5: Objective — Validate that the sink participates in an unbounded or large-iteration pattern. Signals — For print_hex_dump, len is used in a for-loop iterating up to len (as described in PATCH_DESCRIPTION), establishing that a huge len can cause out-of-bounds reads via downstream hex_dump_to_buffer. FP mitigation — Require that the called function is known to iterate up to len (from ROOTCAUSE_ANALYSIS/PATCH_DESCRIPTION), avoiding unrelated APIs.

6) Step 6: Objective — Check for compensating range checks on the clamped result before the sink. Signals — Look for comparisons ensuring the int length is non-negative and within a safe range (e.g., len >= 0 and len ≤ upper) prior to calling the sink; the pre-patch code lacks this, per FUNCTION_CONTENT. FP mitigation — If such checks reliably dominate the sink, suppress the alert.

7) Step 7: Objective — Detect equivalent patterns without clamp_t but with similar narrowing. Signals — int length derived from an unsigned/wider size source (e.g., EALIST_SIZE-like expression) via assignment/cast/min/max, then passed as size_t to print_hex_dump; aligns with broader implications in ROOTCAUSE_ANALYSIS. FP mitigation — Apply Steps 2 and 6 (guards and bounds checks) to reduce noise.

8) Step 8: Objective — Highlight mismatch between validation and usage paths. Signals — The code detects a size mismatch (e.g., EALIST_SIZE(...) != ea_size) and immediately dumps data using a derived int length without ensuring the upper bound is int-representable; exactly the pattern added by the if (upper > INT_MAX) guard in PATCH_DIFF. FP mitigation — Require both a mismatch condition and the absence of an INT_MAX guard on the upper bound.

9) Step 9: Objective — Prioritize findings where the upper bound’s source is on-disk or externally controlled metadata. Signals — Expressions resembling size macros from structures/buffers (e.g., EALIST_SIZE(ea_buf->xattr) as in PATCH_DESCRIPTION/FUNCTION_CONTENT) or function returns without local bounds; model as tainted/external length producers. FP mitigation — If provenance is purely local arithmetic with constants and types ≤ int, deprioritize or suppress.

10) Step 10: Objective — Ensure reporting only when all core risk factors align. Signals — Conjunction of: int-typed clamp/min narrowing from wider/unsigned upper bound, absence of INT_MAX guard, and dataflow of the int into a size_t length parameter of print_hex_dump (or equivalent). FP mitigation — Require this conjunction to reduce incidental integer type mismatches that are otherwise harmless.

3. Target Elements
- Macro/function-like calls to clamp_t, min_t, max_t, or equivalent clamps using int as the target type.
- Variable declarations/assignments where a length is stored in a signed int.
- Comparisons against INT_MAX for upper bounds and their dominance relative to usage.
- Call sites of print_hex_dump and hex_dump_to_buffer, focusing on the length argument type and source.
- Conditional branches indicating metadata mismatch checks (e.g., size_check-like conditions).
- Expressions producing lengths derived from buffer/metadata macros (e.g., EALIST_SIZE-like sources).

4. Dataflow / Taint Considerations
- Track dataflow from an unsigned/wider upper bound expression through clamping/min/max into a signed int variable.
- Propagate that int variable into calls where the corresponding parameter is size_t/unsigned.
- Model control-flow dominance to detect presence/absence of guards like upper > INT_MAX that bypass the clamp/sink path (per PATCH_DIFF).
- Optionally taint-mark size sources originating from on-disk/metadata helpers (like EALIST_SIZE) to raise priority.

5. Validation & Test Cases
- Positive: Code where int size = clamp_t(int, something, 0, u32_len); print_hex_dump(..., size, ...); with no prior check that u32_len ≤ INT_MAX, matching FUNCTION_CONTENT pre-patch.
- Negative: Same as above, but with an if (u32_len > INT_MAX) { log; skip dump; } else { clamp and dump; }, as in PATCH_DIFF.
- Negative: size_t size = clamp_t(size_t, ea_size, 0, u32_len); print_hex_dump(..., size, ...); (no narrowing to int).
- Test harness notes: Validate dominance analysis (guard must dominate the clamp and sink path); verify type-resolution recognizes size_t/unsigned parameters at the sink.

6. Estimated Effort & Priority
High priority; medium effort. Type analysis, dominance checks, and local dataflow to recognized sinks are straightforward but require careful macro/source type handling.

7. Likely False-Positive Sources & Mitigations
- Upper bounds that are provably ≤ INT_MAX via non-trivial invariants not expressed as explicit guards; mitigation: require explicit guard or conservative suppress if proof is not local.
- Alternate sinks that do not iterate up to len; mitigation: restrict sink set to print_hex_dump/hex_dump_to_buffer per PATCH_DESCRIPTION.
- Architectures where int and upper bound types have the same width; mitigation: still require absence of INT_MAX guard, but allow configuration to account for type sizes.

8. Limitations & Assumptions
- Assumes the analysis can resolve macro-like calls (clamp_t/min_t) and parameter types at sinks; macro expansion details are not provided.
- Cannot definitively prove at compile time that an unsigned upper bound exceeds INT_MAX; relies on type-based heuristics and absence of guards, per ROOTCAUSE_ANALYSIS.
- Assumes print_hex_dump and hex_dump_to_buffer behave as described in PATCH_DESCRIPTION; exact signatures are not included in the materials.