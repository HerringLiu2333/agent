1. CVE Identifier
CVE-2025-39735

2. Vulnerability Type
Integer overflow and signed/unsigned conversion leading to slab-out-of-bounds read

3. Root Cause Summary
In jfs’s ea_get(), the code used clamp_t(int, ...) with an upper bound of EALIST_SIZE(ea_buf->xattr) without validating that this upper bound fit in int. When EALIST_SIZE exceeded INT_MAX, the conversion to int overflowed, producing a negative “size” that was then passed to print_hex_dump(), where it was interpreted as a huge size_t and drove unbounded iteration. This caused print_hex_dump()/hex_dump_to_buffer() to read beyond the end of the xattr buffer, triggering a slab-out-of-bounds read. The root cause is missing validation of EALIST_SIZE(ea_buf->xattr) relative to INT_MAX before clamping and dumping.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem extended attribute handling (fs/jfs) in ea_get()

2) Pre-Patch Flaw:
In the size_check path of ea_get(), the code executed:
- “int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));”
- “print_hex_dump(... ea_buf->xattr, size, 1);”
This trusted EALIST_SIZE() as an int-capable upper bound and passed the potentially overflowed “size” to print_hex_dump() without bounds validation.

3) Trigger Condition:
EALIST_SIZE(ea_buf->xattr) returns a value greater than INT_MAX (e.g., 4110417968), and EALIST_SIZE(...) != ea_size, causing entry into the size_check label. The upper bound overflows when cast to int, making “size” negative; when converted to size_t in print_hex_dump(), it becomes a very large value.

4) Impact Mechanism:
print_hex_dump() treats the negative “size” as a huge unsigned len and iterates:
- for (i = 0; i < len; i += rowsize) { ... hex_dump_to_buffer(ptr + i, linelen, ...); }
Eventually ptr + i moves beyond the actual buffer. hex_dump_to_buffer() then reads past bounds in its loop over j < len, resulting in a slab-out-of-bounds read and potential kernel crash.

5. Patch Analysis
1) Fix Approach:
Add a preemptive validation to reject and log cases where EALIST_SIZE(ea_buf->xattr) exceeds INT_MAX before performing clamp_t or calling print_hex_dump(). If the size is too large, skip the dump and bail out with an error, preventing overflow and unsafe reads.

2) Key Code Changes:
- Introduced:
  if (unlikely(EALIST_SIZE(ea_buf->xattr) > INT_MAX)) {
      printk(... "extended attribute size too large: %u > INT_MAX\n", ...);
  } else {
      int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
      printk(... "invalid extended attribute\n");
      print_hex_dump(... ea_buf->xattr, size, 1);
  }
- This ensures the clamp upper bound is valid for int and prevents passing a corrupted (overflowed) “size” into print_hex_dump(). The rest of the path still releases and returns -EIO.

3) Locking/Concurrency Impact:
None. The change is purely input validation and logging within ea_get(); no locks or ordering were added or modified.

6. Broader Kernel Security Implications
The fix hardens xattr error handling against malformed filesystem data that could otherwise cause kernel memory safety violations during diagnostic dumping. It underscores the need to validate sizes before type-narrowing (e.g., to int) and before using them as iteration bounds in utility functions. Auditing similar clamp_t(int, ...) patterns and debug print paths across the kernel may prevent analogous signed/unsigned and overflow-induced OOB accesses. Preventing slab-out-of-bounds reads reduces risk of kernel crashes and potential information disclosure via unintended memory reads.