1. Plan Summary
Detect integer-overflow/underflow paths where a signed int length, computed using an unchecked large unsigned upper bound (e.g., from on-disk metadata), is passed to an API expecting an unsigned length (e.g., size_t), leading to out-of-bounds iteration as in the pre-patch ea_get() → print_hex_dump() flow.

2. Detection Steps
1) Step 1: Objective: Find calls to diagnostic dump routines that take a pointer and an unsigned length. Signals: Call sites of print_hex_dump (root-cause path per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]) and similar dump helpers where the length parameter is size_t or another unsigned type; capture the actual argument expression for len. FP mitigation: Restrict initially to print_hex_dump (explicitly implicated in [PATCH_DESCRIPTION]) to avoid broad generalization.

2) Step 2: Objective: Identify when the len argument at such calls is a signed int variable. Signals: The len argument is an lvalue or expression of integral type that is signed and narrower than or equal to 32 bits; especially variables declared as int. FP mitigation: Exclude cases where the variable is explicitly cast to an unsigned type after validated range checks.

3) Step 3: Objective: Trace backward to how this signed int length is computed. Signals: The variable is assigned from a clamp/min/max pattern that conceptually clamps an int using an upper bound expression; e.g., usage of clamp-like macros with a destination type int, or equivalent min(max(...)) idioms. FP mitigation: Require that the upper bound expression is not statically a small constant and originates from a non-constant value.

4) Step 4: Objective: Determine whether the upper bound to the clamp/min comes from a potentially large unsigned value derived from external/on-disk metadata. Signals: The upper bound expression has an unsigned type (e.g., u32/size_t) or is the result of endian-conversion/read macros on struct fields akin to EALIST_SIZE(ea_buf->xattr) (referenced in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: If there is a prior guard “if (upper > INT_MAX) { … skip dump … } else { … use upper … }” in control-dominant scope (as added in [PATCH_DIFF]), do not flag.

5) Step 5: Objective: Detect missing validation that upper <= INT_MAX before computing the signed int size. Signals: No dominating conditional that constrains the upper bound to be <= INT_MAX, and the computation assigns to an int without a range check. FP mitigation: Treat as validated if there is any dominating assertion/conditional ensuring the upper bound is <= INT_MAX (e.g., comparisons to INT_MAX or explicit cast with bounds check).

6) Step 6: Objective: Flag risky signed-to-unsigned length conversions at the call boundary. Signals: The int variable flows as the len argument to print_hex_dump (size_t) without an intervening non-trivial sanitization (e.g., if (len < 0) len = 0; or conversion to size_t after clamping with an unsigned-safe bound). FP mitigation: Suppress if there is an explicit non-negative check on the int variable dominating the call.

7) Step 7: Objective: Strengthen evidence of a dangerous iteration context downstream. Signals: The target function (print_hex_dump) is known to iterate up to len and do pointer arithmetic (as described in [PATCH_DESCRIPTION]); thus, any huge len risks OOB. FP mitigation: Limit to known iterating dump routines (print_hex_dump) to reduce speculative matches.

8) Step 8: Objective: Correlate with error/logging paths triggered by mismatched sizes. Signals: The computation occurs under a conditional like “if (EALIST_SIZE(...) != expected_size)” before logging plus hex dump (shown in [FILE_CONTENT] and [PATCH_DIFF]), indicating the path can be hit on corrupted metadata. FP mitigation: Prefer matches where a mismatch check precedes the dump call; lower confidence otherwise.

9) Step 9: Objective: Prefer sources tied to filesystem/on-disk structures. Signals: The upper bound is derived from expressions involving ea_buf->xattr or structs named jfs_ea_list, or macros like EALIST_SIZE (as in [FILE_CONTENT]/[PATCH_DIFF]). FP mitigation: Deprioritize if the upper bound is computed purely from local arithmetic without any struct/IO-derived value.

10) Step 10: Objective: Report when all three conditions co-occur: unsigned external size → clamped into int without INT_MAX guard → used as size_t in dump. Signals: Dataflow chain from upper bound to int size to len at print_hex_dump, with absence of INT_MAX guard and non-negative check. FP mitigation: Require clear SSA-like dominance of the assignment over the call, and no reassignment/sanitization in-between.

3. Target Elements
- Call sites to print_hex_dump (and optionally hex_dump_to_buffer wrappers if directly invoked).
- Variable declarations and assignments of signed int length variables used in such calls.
- Clamp/min/max idioms that set those length variables, including macro-style clamp_t with destination type int.
- Conditional guards comparing upper bounds to INT_MAX or checking len >= 0 before the call.
- Expressions sourcing upper bounds from on-disk metadata (e.g., EALIST_SIZE, fields of jfs_ea_list, or similar).

4. Dataflow / Taint Considerations
- Track flows from “upper bound” expressions with unsigned or potentially large type (e.g., values read from on-disk structures/macros like EALIST_SIZE) into int variables via clamping/min/max or direct assignment.
- Track subsequent flow from that int variable into the len parameter of print_hex_dump, noting the implicit signed-to-unsigned conversion.
- Model dominance: ensure no intervening sanitization (upper <= INT_MAX or len >= 0 checks) occurs along the path to the call site.

5. Validation & Test Cases
- Positive: The pre-patch snippet in ea_get(): int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr)); followed by print_hex_dump(..., size, ...); with no upper <= INT_MAX guard (from [FILE_CONTENT]). Expect a finding.
- Negative: The post-patch block with if (EALIST_SIZE(...) > INT_MAX) { printk... } else { int size = clamp_t(int,...); print_hex_dump(..., size, ...); } (from [PATCH_DIFF]). Expect no finding due to the dominating upper-bound guard.
- Negative: A variant where the length variable is size_t (not int) or where there is an explicit if (size < 0) size = 0; before print_hex_dump. Expect no finding.
- Test harness notes: Build small kernel-like stubs with print_hex_dump prototype and simulate EALIST_SIZE usage; verify control-flow dominance and dataflow tracking.

6. Estimated Effort & Priority
High: Requires interprocedural dataflow, type reasoning for signed/unsigned interactions, dominance analysis, and kernel API modeling for print_hex_dump.

7. Likely False-Positive Sources & Mitigations
- Paths where the upper bound is known (but not syntactically obvious) to be <= INT_MAX due to prior invariants: mitigate by requiring an explicit guard or by allowing suppression when upper is a constant or proven <= INT_MAX.
- Calls where the int length is sanitized via non-negative checks or bounded by buffer size: mitigate by recognizing dominating checks.
- Non-kernel contexts or custom dump functions with safe internals: mitigate by initially restricting to print_hex_dump as per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].

8. Limitations & Assumptions
- Assumes print_hex_dump’s len parameter is size_t and used for iteration as described in [PATCH_DESCRIPTION]; the checker will rely on known kernel API semantics.
- Cannot, from provided snippets, resolve the exact definition of EALIST_SIZE; assumes it returns an unsigned size derived from on-disk data (per [ROOTCAUSE_ANALYSIS]).
- May not perfectly identify all clamp/min idioms expressed via diverse macros; relies on conceptual pattern matching of “int destination clamped by unsigned upper bound” without macro expansion details.