1. Plan Summary
Detect cases where a value is clamped or narrowed to int using an unsigned/wider upper bound without validating it against INT_MAX, and the resulting int is later used as an unsigned/size_t length in iteration/dump routines (e.g., print_hex_dump), risking overflow and out-of-bounds reads.

2. Detection Steps
1) Step 1: Identify int-narrowing via clamping/casts — look for assignments to int from clamping constructs (e.g., clamp-like macros) or explicit/implicit casts where the upper bound expression is of unsigned or wider-than-int type — this matches the clamp_t(int, …, EALIST_SIZE(...)) pattern in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]; mitigate FPs by requiring the upper bound expression’s type width ≥ 32-bit unsigned or size_t.
2) Step 2: Confirm potential overflow at the upper bound — check if the upper bound expression may exceed INT_MAX (unsigned type, not a constant ≤ INT_MAX, or derived from size-like helpers) — this maps to EALIST_SIZE returning values like 4110417968 per [PATCH_DESCRIPTION]; reduce FPs by excluding cases where static bounds or assertions clearly limit it to ≤ INT_MAX.
3) Step 3: Require absence of a dominating INT_MAX guard — ensure there is no preceding/control-dominating check comparing the same upper bound to INT_MAX that logs/bails or branches away before the narrowing — aligns with the fix adding if (EALIST_SIZE(...) > INT_MAX) { ... } else { ... } in [PATCH_DIFF]; mitigate FPs by recognizing such guard patterns, including early returns or skipping the narrowing/sink call.
4) Step 4: Track the narrowed int into an unsigned/size_t sink — follow dataflow from the narrowed int to function parameters of type size_t/unsigned that represent lengths — this targets print_hex_dump “len” in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; reduce FPs by restricting sinks to known length parameters.
5) Step 5: Prioritize known risky sinks — flag flows into print_hex_dump length or into hex_dump_to_buffer length (directly or indirectly) — these are the exact loops that perform unbounded iteration in [PATCH_DESCRIPTION]; reduce FPs by focusing on these names/signatures first.
6) Step 6: Verify pointer-plus-length usage — at the sink, confirm the same call uses a pointer/buffer argument together with the length (e.g., ptr plus len in print_hex_dump) — this matches the ptr+i passed to hex_dump_to_buffer described in [PATCH_DESCRIPTION]; mitigate FPs by requiring the presence of a pointer argument paired with the suspect length.
7) Step 7: Exclude already-sanitized negatives — if there is a guard ensuring the narrowed int is non-negative and capped by a safe upper bound before the sink (e.g., min with rowsize using size_t after validation) — this avoids benign casts; reduce FPs by insisting validation occurs prior to the sink in all control-flow paths.
8) Step 8: Prefer error-path contexts — boost confidence when the pattern appears in error-handling/logging paths with printk followed by dump calls as in [PATCH_DIFF] — this context matches the pre-patch “invalid extended attribute” path; mitigate FPs by deprioritizing normal fast paths without such logging.
9) Step 9: Check inequality trigger — optionally recognize a condition that indicates malformed input (e.g., EALIST_SIZE(...) != ea_size) guarding the narrowing and sink call — this matches the “size_check” trigger in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; treat as a supporting signal, not a hard requirement.
10) Step 10: Report with path summary — include source upper bound expression, the narrowing site, absence of INT_MAX validation, and the sink call with the argument — mirrors the causal chain shown in [ROOTCAUSE_ANALYSIS]; this helps triage accuracy.

3. Target Elements
- Assignments/declarations of int variables derived from clamp-like constructs or casts.
- Macro/function invocations that conceptually clamp with an upper bound (clamp_t-like).
- Comparisons against INT_MAX and control-flow guards dominating the narrowing/sink.
- Calls to print_hex_dump and hex_dump_to_buffer, specifically their length parameters.
- Pointer-plus-length call sites used for diagnostic dumping or iteration.
- Error-handling/logging paths (e.g., printk) preceding dump calls.

4. Dataflow / Taint Considerations
- Track dataflow from an upper bound expression (e.g., EALIST_SIZE-like size providers) into a narrowed int via clamping or cast.
- Propagate this int into sinks where it is converted to size_t/unsigned length parameters (e.g., print_hex_dump len), including through intermediate assignments/variables.
- Model control-flow dominance to detect absence/presence of INT_MAX checks gating the narrowing/sink path.
- Optionally model pointer argument pairing with the length at the sink to confirm buffer-length semantics.

5. Validation & Test Cases
- Positive: int size = clamp_t(int, ea_size, 0, EALIST_SIZE(xattr)); print_hex_dump(..., xattr, size, 1); with no preceding if (EALIST_SIZE(xattr) > INT_MAX) guarding the path — expect a finding.
- Positive: int size = clamp_t(int, val, 0, big_unsigned); print_hex_dump(..., buf, size, 1); big_unsigned is size_t or unsigned non-constant — expect a finding.
- Negative: if (EALIST_SIZE(xattr) > INT_MAX) { log; bail; } else { int size = clamp_t(int, ea_size, 0, EALIST_SIZE(xattr)); print_hex_dump(..., xattr, size, 1); } — expect no finding.
- Negative: Upper bound is a constant ≤ INT_MAX (e.g., 4096); or additional checks ensure size ≥ 0 and ≤ safe_max before the sink — expect no finding.
- Test harness notes: Run intra-procedural and inter-procedural dataflow to capture variable propagation to sink; ensure dominance analysis recognizes guarding branches.

6. Estimated Effort & Priority
Medium: Requires type reasoning, dominance/guard recognition, and targeted dataflow to known sinks.

7. Likely False-Positive Sources & Mitigations
- Upper bound types that are unsigned but practically capped by prior logic not recognized — mitigate by requiring explicit INT_MAX or equivalent guard in dominating paths.
- Benign conversions where the int is later clamped to non-negative size_t before the sink — mitigate by checking for subsequent sanitization prior to sink.
- Sinks misidentified as length-iterating when they internally bound-check — mitigate by restricting to print_hex_dump/hex_dump_to_buffer as evidenced in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].

8. Limitations & Assumptions
- Assumes the analyzer can conceptually recognize clamp-like macros and type widths; macro expansion specifics are not provided.
- Cannot always prove that an unsigned upper bound can exceed INT_MAX without value-range info; uses type and absence-of-guard heuristics.
- Sink coverage is limited to print_hex_dump/hex_dump_to_buffer based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; other similar sinks are not enumerated here.
- Exact buffer size knowledge (e.g., true bounds of ea_buf->xattr) is not determinable from the inputs; detection focuses on the overflowed length propagation pattern.