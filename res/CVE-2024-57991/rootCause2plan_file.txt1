1. Plan Summary
Detect cases where code iterates a kernel list with a non-safe list_for_each_entry and, inside nested loops, structurally reorders the currently iterated node within the same list without exiting the outer iteration, which can cause soft lockup/livelock.

2. Detection Steps
1) Step 1: Identify outer list iteration constructs. Look for uses of list_for_each_entry-like macros (non-safe variant) that iterate a node variable over a specific list head with a given member field (e.g., list_for_each_entry(role, &mgnt->active_list, mgnt_entry)).

2) Step 2: Model the “current node” and “current list head.” For each such loop, bind: (a) the iterated element variable (e.g., role), (b) the list head expression (e.g., &mgnt->active_list), and (c) the member field (e.g., mgnt_entry).

3) Step 3: Find structural list mutations inside the outer loop body that affect the current node. Within the loop body, detect calls to list_del, list_add, list_add_tail, list_move, list_move_tail, list_replace, or equivalent, where the node argument refers to the iterated element’s member (e.g., &role->mgnt_entry).

4) Step 4: Check that the target of the mutation is the same list being iterated. For insertion/move calls, ensure the destination list head argument aliases or syntactically matches the outer loop’s list head (e.g., &mgnt->active_list).

5) Step 5: Recognize nested control constructs around the mutation. Determine if the mutation resides within an inner loop (e.g., a for/while loop or second list iteration) nested inside the outer list_for_each_entry.

6) Step 6: Detect unsafe continuation of the outer iteration. From the mutation site, compute control-flow to see if there exists a path that remains within the outer loop body and reaches the loop’s end/next iteration without an unconditional exit from the outer loop (i.e., without return, goto to a label after the outer loop, or otherwise abandoning the outer loop).

7) Step 7: Flag “break-only” from inner loops as insufficient exit. If the immediate post-mutation control-flow uses a break that targets only the innermost loop containing the mutation (and not the outer list_for_each_entry), treat it as a continuation of the outer iteration and mark as risky.

8) Step 8: Exempt cases that exit the outer loop immediately. Do not report when the only post-mutation paths reliably perform return, goto to a label located after the outer loop, or other constructs that terminate the outer iteration immediately.

9) Step 9: Exempt safe iteration idioms. Do not report when the outer iteration uses list_for_each_entry_safe (or an equivalent “safe” variant that stores the next pointer) and the mutation is limited to deletion of the current element without re-inserting it back into the same list in the same outer iteration.

10) Step 10: Prioritize reordering operations within the same list. Raise severity when the pattern deletes and re-adds/moves the current node into the same list (reorder), as this most strongly matches the root-cause scenario that led to a soft lockup in rtw89_entity_recalc_mgnt_roles().

11) Step 11: Report with precise context. For each finding, include the outer loop site, the mutation calls (e.g., list_del + list_add), the inner loop context, and the absence of an outer-loop exit after mutation, recommending either an immediate exit (e.g., goto to after-loop) or switching to a safe iteration strategy.

12) Step 12: Optional heuristic tightening. If available, increase confidence when the same node and same list head are involved in both list_del and list_add within the same branch, and the immediate control flow only uses break from the inner loop (as in the pre-patch behavior), matching the CVE’s root cause.

3. Limitations & Assumptions
- Assumes CodeQL can resolve macro-style list iteration and list APIs sufficiently to recognize list_for_each_entry and list mutation helpers; macro expansion may obscure some signals.
- Equivalence/alias of “same list head” is approximated via syntactic or simple dataflow matching; complex aliasing may reduce accuracy.
- The checker infers which loop a break targets based on nesting; deeply tangled control flow, conditional gotos, or macros may complicate this.
- The plan focuses on reordering/deletion of the currently iterated node; mutations of other nodes or other lists are not considered here.
- Determining that an exit goto targets a label “after the outer loop” relies on control-flow and location analysis; false negatives/positives may occur if label scopes are non-obvious.