1. Plan Summary
Detect kernel code that mutates the currently iterated element of a non-safe list_for_each_entry loop and then continues iterating, risking an infinite loop/soft lockup (CWE-835).

2. Detection Steps
1) Step 1: Identify outer loops that use the kernel traversal macro list_for_each_entry over a list head L, with iterator variable V and member link field M. Signals: macro-like iteration of V over L using M (e.g., list_for_each_entry(V, &L, M)).

2) Step 2: Confirm the iterator is the non-safe variant, not list_for_each_entry_safe. Signals: loop is constructed via list_for_each_entry and no *_safe variant is present.

3) Step 3: In the body of that outer loop, find calls that delete the current element from any list. Signals: a call to list_del whose argument is the address of V’s link field (&V->M).

4) Step 4: In the same loop body, find calls that add the current element back into a list, especially the same list head L. Signals: calls to list_add or list_add_tail where the first argument is &V->M and the second argument aliases the same list head L used by the outer loop.

5) Step 5: Correlate that the add/remove operations affect the same list being iterated. Signals: the list head argument in list_add/list_add_tail is the same L as the loop’s list head (or an alias to it).

6) Step 6: Determine whether the mutation occurs inside a nested inner loop or conditional block within the outer loop. Signals: presence of an inner for/while/loop construct or nested control-flow around the mutation site.

7) Step 7: Analyze control flow from the mutation site to see if the outer loop is terminated immediately after the mutation. Safe signals: a goto to a label placed after the outer loop, a return, or other control flow that exits the outer loop entirely.

8) Step 8: Flag as unsafe if, after mutation, control flow merely executes a break or continue that targets only the nearest inner loop/block, or falls through to the end of the outer loop body, allowing the outer loop to proceed to the next iteration. Signals: a break statement enclosed by an inner loop, no outer-loop exit on all reachable paths from the mutation.

9) Step 9: Increase confidence if the sequence is specifically list_del(&V->M) followed by list_add(&V->M, &L) within the same outer loop iteration, indicating a reordering of the current element during iteration. Signals: adjacent or sequential add/remove of the same V->M in the same block.

10) Step 10: Optionally, note subsequent re-iteration over the same list L later in the function, which can compound the risk. Signals: another list_for_each_entry over L after the outer loop.

11) Step 11: Exclude cases where the loop uses list_for_each_entry_safe or where all paths after mutation clearly exit the outer loop. Signals: explicit *_safe iteration or guaranteed exit (goto-after-loop or return).

12) Step 12: Report findings with the outer loop location, the mutation call sites, and the control-flow evidence that the outer loop continues after mutation. Signals: source ranges of loop header, list_del/list_add calls, and the non-exiting control-flow path.

3. Limitations & Assumptions
- Assumes standard Linux kernel list APIs and macro names (list_for_each_entry, list_for_each_entry_safe, list_del, list_add, list_add_tail); other list implementations are out of scope.
- Macro expansion details and aliasing of list heads may be imperfect; the checker relies on name/argument-based correlation to relate the loop’s list head to mutation calls.
- The analysis approximates control-flow; it may not prove an actual infinite loop, only the risky pattern of mutating a currently iterated node and continuing the non-safe traversal.
- Concurrency and runtime conditions (e.g., number of matching entries) are not evaluated; the checker focuses solely on static structural risks present pre-patch.