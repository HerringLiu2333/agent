1. Plan Summary
Detect kernel list iteration that mutates the same list (delete/re-add of the current node) without immediately exiting the outer traversal, which can cause livelock/soft lockup as seen in rtw89_entity_recalc_mgnt_roles().

2. Detection Steps
1) Step 1: Identify outer iterations over kernel intrusive lists — look for list_for_each_entry-like macros iterating a list head (e.g., &mgnt->active_list) and a node field (e.g., mgnt_entry) — focus on functions that hold a mutex per [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]. Mitigate FPs by only considering canonical Linux list macros and capturing the iteration variable, list head expression, and node field used.

2) Step 2: Within the body of the outer list iteration, find statements that call list_del/list_del_init on the current iteration element’s list node (e.g., &role->mgnt_entry) — this is the signal of mutating the list being iterated, per [ROOTCAUSE_ANALYSIS]. Reduce FPs by ensuring the operand of list_del is the same node field used in the iteration macro for that element.

3) Step 3: Detect re-insertion into the same list during that iteration — look for list_add/list_add_tail where the second argument equals the same list head expression being iterated (e.g., &mgnt->active_list) — this matches the re-ordering behavior described in [PATCH_DESCRIPTION]/[PATCH_DIFF]. Mitigate by requiring both delete and add within the same control-flow path (e.g., same conditional block).

4) Step 4: Exclude “safe” iteration patterns — if the outer loop uses list_for_each_entry_safe (or equivalent safe macros) that allow deletion during traversal, do not flag. This maps to reducing FPs because safe variants are designed for concurrent mutation.

5) Step 5: Analyze control flow immediately following the delete/add mutation to determine loop exit — look for return statements, a goto that jumps to a label after the outer loop (as in “goto fill” added in [PATCH_DIFF]), or a break targeting the outer loop. Suppress findings if an immediate outer-loop exit is guaranteed by control-flow.

6) Step 6: Detect nested loop contexts where a break/continue after mutation only exits the inner loop, leaving the outer list traversal ongoing — compute the syntactic loop nesting and the target of break/continue; if it applies to the inner loop only (as in pre-patch [ROOTCAUSE_ANALYSIS]), flag. This directly maps to the root cause by ensuring the traversal continues after structural changes.

7) Step 7: Check for continued outer iteration paths post-mutation — if control can reach further statements inside the outer loop body and proceed to the next iteration (no immediate jump beyond the loop), consider this unsafe. Mitigate FPs by allowing a reset/restart idiom only if the code rewinds the iterator explicitly (rare in macro-based loops; otherwise flag).

8) Step 8: Confirm the mutated list is the same concrete list head as the one iterated — perform alias/equality on the list head expression to avoid flagging cases that delete/add to a different list. This addresses FPs where a node is moved between unrelated lists.

9) Step 9: Elevate confidence when both list_del and list_add target the current element’s node and the same list head within a conditional block guarded by a match (e.g., link->chanctx_idx == RTW89_CHANCTX_0) — this mirrors the normalization pattern in [FILE_CONTENT]. Reduce FPs by requiring this combined pattern rather than a single delete.

10) Step 10: Optionally check for lock held (e.g., lockdep_assert_held(&rtwdev->mutex)) to prioritize findings in critical sections likely to cause soft lockup, per [FILE_CONTENT]. Use this only to prioritize, not to exclude.

11) Step 11: Exclude cases where the code subsequently replaces the loop with a new iteration over the modified list immediately (e.g., exits and starts a separate list_for_each_entry) — treat as safe if mutation is followed by explicit restart outside the original loop, as in “goto fill” in [PATCH_DIFF]. This reduces FPs by recognizing benign reordering followed by re-iteration.

12) Step 12: Report with context including the function name (e.g., rtw89_entity_recalc_mgnt_roles()), the mutated list head, and the absence of an immediate outer-loop exit, citing the risky pattern from [ROOTCAUSE_ANALYSIS]. This helps validate mapping to the root cause and triage.

3. Target Elements
- Functions containing list_for_each_entry-style macros over kernel intrusive lists.
- Calls to list_del/list_del_init, list_add/list_add_tail within loop bodies.
- Control-flow constructs: break/continue, goto labels, return statements.
- Nested loops and their syntactic scopes.
- Lock checks (e.g., lockdep_assert_held) to prioritize critical sections.

4. Dataflow / Taint Considerations
- Track the iteration variable’s node field as “current element” taint; ensure list_del targets this tainted node.
- Track the list head expression from the loop macro; ensure list_add re-inserts into the same head.
- Control-flow path from mutation site to detect whether execution exits the outer loop or continues.

5. Validation & Test Cases
- Positive: Outer list_for_each_entry over &mgnt->active_list, inside nested loop: on condition, list_del(&role->mgnt_entry); list_add(&role->mgnt_entry, &mgnt->active_list); break; (only inner loop), and outer loop continues; expect a finding (matches pre-patch in [ROOTCAUSE_ANALYSIS]/[FILE_CONTENT]).
- Negative: Same mutation but followed by goto label that is placed after the outer loop (as in [PATCH_DIFF] “goto fill”); expect no finding.
- Negative: Use list_for_each_entry_safe and perform list_del/list_add on the current element; expect no finding.
- Test harness notes: Ensure macro expansion is recognized; emulate minimal structs with mgnt->active_list and mgnt_entry fields and nested loops.

6. Estimated Effort & Priority
High — Denial-of-service via soft lockup in kernel driver path; pattern is common and impactful.

7. Likely False-Positive Sources & Mitigations
- Mutating a different list while iterating: mitigate by matching list head equivalence.
- Intentional restart patterns not using goto/return (e.g., manual re-initialization): hard to detect; mitigate by requiring an immediate exit or a clear restart outside the loop.
- Complex macro variants or custom list APIs: scope to canonical Linux list macros to reduce ambiguity.
- Cases where deletion does not affect traversal (e.g., operating on a copy): mitigate by requiring the node to belong to the current iteration variable.

8. Limitations & Assumptions
- Assumes recognition of Linux list macros and their parameters; custom wrappers may be missed.
- Cannot prove runtime soft lockup; checker flags risky structural mutation continuing traversal as per [ROOTCAUSE_ANALYSIS].
- Does not fully model iterator invalidation semantics; relies on syntactic patterns (delete/add of current node and continued iteration).
- Only evidence-based on rtw89_entity_recalc_mgnt_roles() and the pattern described in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]; broader generalization assumes similar kernel list usage.