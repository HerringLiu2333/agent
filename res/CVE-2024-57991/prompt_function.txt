1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
CWE-835: Loop with Unreachable Exit Condition (Infinite Loop) leading to soft lockup (Denial of Service)

3. Root Cause Summary
In rtw89_entity_recalc_mgnt_roles(), the code reorders mgnt->active_list when it finds a role/link with chanctx_idx == RTW89_CHANCTX_0, using list_del() followed by list_add() while iterating with list_for_each_entry(). The pre-patch code only broke out of the inner link loop and continued the outer list_for_each_entry traversal on the mutated list. This unsafe combination (modifying the current list element without using a *_safe iterator and then continuing iteration) can cause the traversal to revisit/misiterate nodes, producing a non-terminating loop and CPU soft lockup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 Wi-Fi driver, channel/entity management (drivers/net/wireless/realtek/rtw89/chan.c)

2) Pre-Patch Flaw:
Inside rtw89_entity_recalc_mgnt_roles(), upon finding a link with RTW89_CHANCTX_0, the code executes:
- list_del(&role->mgnt_entry);
- list_add(&role->mgnt_entry, &mgnt->active_list);
- break;
This break exits only the inner for-loop, not the outer list_for_each_entry over mgnt->active_list, resulting in continued iteration over a mutated list using a non-safe iterator.

3) Trigger Condition:
When a qualifying role/link is found during the first traversal and the list is reordered, especially in cases where the normalization changes list ordering (e.g., more than one candidate or non-head match), the outer list_for_each_entry continues iterating the modified list, causing the iteration to fail to make forward progress.

4) Impact Mechanism:
The outer traversal can repeatedly visit nodes or loop indefinitely due to iterator invalidation after list mutation, leading to a soft lockup (watchdog trigger) with CPU stuck in rtw89_entity_recalc_mgnt_roles(), as observed in kernel logs (e.g., wpa_supplicant invoking the path).

5. Patch Analysis
1) Fix Approach:
Terminate the outer list_for_each_entry immediately after performing the normalization/reordering to avoid iterating the modified list with a non-safe iterator.

2) Key Code Changes:
- Replace the inner “break;” with “goto fill;” to exit the outer list_for_each_entry loop.
- Introduce a “fill:” label placed immediately before the second list_for_each_entry that populates mgnt->active_roles and chanctx_tbl.
This ensures no further iteration occurs on the modified list in the first pass.

3) Locking/Concurrency Impact:
No changes to locking; the function still asserts rtwdev->mutex is held (lockdep_assert_held(&rtwdev->mutex)). The fix addresses control flow/iteration safety rather than a locking deficiency, preventing unsafe iteration after list mutation while under the existing mutex.

6. Broader Kernel Security Implications
The bug allows a reliable denial-of-service via soft lockup in the Wi-Fi management path, potentially triggerable by userspace network configuration tools (e.g., wpa_supplicant). While it does not indicate memory corruption or privilege escalation, it can stall a CPU and disrupt networking and overall system responsiveness. The fix reduces risk by ensuring proper loop termination semantics when reordering kernel lists during iteration.