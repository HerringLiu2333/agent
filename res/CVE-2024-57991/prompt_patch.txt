1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
Denial of Service (soft lockup) due to improper loop control during list mutation

3. Root Cause Summary
rtw89_entity_recalc_mgnt_roles() mutates mgnt->active_list while iterating it and intended to stop iterating once a target match is found. Pre-patch code used break inside an inner loop, which exited only the inner loop and allowed the outer list_for_each_entry to continue on a modified list. This incorrect loop termination on a mutating list could cause the traversal to fail to make progress in certain cases, leading to a CPU soft lockup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 Wi-Fi driver, channel/management role handling (drivers/net/wireless/realtek/rtw89/chan.c)

2) Pre-Patch Flaw:
- In rtw89_entity_recalc_mgnt_roles(), when a “target pattern” is found, the code reorders the list via list_del/list_add and then uses break, which only exits an inner loop.
- The outer list_for_each_entry continues iterating over mgnt->active_list after it has been reordered, violating safe iteration expectations and enabling a non-progressing traversal.
- Evidence: pre-patch snippet within the function shows “list_del(&role->mgnt_entry); list_add(&role->mgnt_entry, &mgnt->active_list); break;” and the commit message clarifies “break just aborted the inner for-loop. The outer list_for_each_entry still continues.”

3) Trigger Condition:
- “Special cases” where the normalization finds entries matching the target pattern beyond the first, or where reordering while iterating causes the cursor to revisit or loop over the same elements.
- Under these conditions, the continued outer iteration on a mutated list can cause an effective infinite loop, observed as a soft lockup. The log shows soft lockup in rtw89_entity_recalc (chan.c:392, chan.c:479).

4) Impact Mechanism:
- Busy-loop/soft lockup in kernel context (watchdog: BUG: soft lockup) with processes like wpa_supplicant stuck, resulting in denial-of-service of the Wi-Fi stack on the affected CPU.

5. Patch Analysis
1) Fix Approach:
- Ensure termination of the outer list_for_each_entry immediately after performing the reordering by jumping out of the outer loop.
- Replace the inner-loop break with a goto to a label placed after the outer list traversal, preventing further iteration on the modified list.

2) Key Code Changes:
- Changed “break;” to “goto fill;” after list_del/list_add in rtw89_entity_recalc_mgnt_roles().
- Introduced/placed “fill:” label just before the next list_for_each_entry that processes mgnt->active_list.
- This guarantees the function exits the outer traversal as intended once a match-driven reordering occurs.

3) Locking/Concurrency Impact:
- No locking primitives were added or changed.
- The fix addresses control-flow correctness during list mutation; it avoids iterating a list that has just been reordered, removing the non-progress condition without altering concurrency semantics.

6. Broader Kernel Security Implications
- Iterating and mutating kernel linked lists concurrently requires careful control flow. Exiting all relevant loops or using *_safe iteration macros is essential to prevent non-progress conditions and lockups.
- Similar logic/flow bugs in other drivers may lead to kernel hangs or soft lockups; audits should ensure that list mutations during traversal either use safe iteration patterns or terminate traversal immediately after mutation.