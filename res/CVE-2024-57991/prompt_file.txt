1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
Denial of Service (soft lockup/livelock) caused by incorrect loop control and list reordering during iteration.

3. Root Cause Summary
rtw89_entity_recalc_mgnt_roles() normalizes mgnt->active_list by moving the first role using RTW89_CHANCTX_0 to the list head. Upon finding such a role, it deletes and re-inserts the current list node (list_del/list_add) while still inside an outer list_for_each_entry iteration. The code then uses break, which exits only the inner for-loop over link instances, allowing the outer list_for_each_entry to continue traversing a list that was just structurally modified. This can lead to a livelock/soft lockup in certain list layouts (e.g., when the matching role is not the first element). The patch replaces break with a goto that exits the outer iteration immediately after reordering, preventing further traversal of the mutated list.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Realtek rtw89 Wi-Fi driver, channel/entity management (drivers/net/wireless/realtek/rtw89/chan.c), function rtw89_entity_recalc_mgnt_roles().

2) Pre-Patch Flaw:
- Inside rtw89_entity_recalc_mgnt_roles(), the normalization loop does:
  - list_del(&role->mgnt_entry); list_add(&role->mgnt_entry, &mgnt->active_list);
  - break; (only exits the inner link loop)
- This leaves the outer list_for_each_entry over mgnt->active_list continuing after the list was reordered, risking repeated visitation or cyclic traversal.
- Evidence (pre-patch snippet at the hunk): “list_del(...); list_add(...); break;”.

3) Trigger Condition:
- When mgnt->active_list contains any role whose link has link->chanctx_idx == RTW89_CHANCTX_0, causing the code to reorder the list entry during the outer list_for_each_entry iteration.
- Particularly problematic when the matching entry is not the first list element, so reordering changes traversal state mid-iteration.

4) Impact Mechanism:
- Continuing the outer list_for_each_entry after list reordering can cause a livelock/soft lockup, as the iterator traverses a mutated list in an unsafe manner.
- The function holds rtwdev->mutex (lockdep_assert_held), so the CPU spins in the critical section, blocking related operations; kernel log shows soft lockup in rtw89_entity_recalc (e.g., “soft lockup - CPU#1 stuck ... RIP: ... rtw89_entity_recalc ... chan.c:392 chan.c:479”).

5. Patch Analysis
1) Fix Approach:
- Ensure immediate exit from the outer list_for_each_entry once the target role is found and reordered, preventing further iteration over a modified list.
- Implemented by jumping to a label that starts the next phase of processing, rather than merely breaking the inner loop.

2) Key Code Changes:
- In rtw89_entity_recalc_mgnt_roles():
  - Replace “break;” with “goto fill;” after list_del/list_add on mgnt->active_list (patch hunk around line ~391).
  - Introduce label “fill:” immediately before the subsequent list_for_each_entry used to populate mgnt->active_roles and mgnt->chanctx_tbl.
- No other logic or data structure changes; strictly control-flow correction aligned with the intent documented in the comment.

3) Locking/Concurrency Impact:
- No changes to locking primitives; rtwdev->mutex is still held.
- The fix reduces time spent in the mutex-held region by avoiding livelock and ensures deterministic control flow when mutating a list during traversal.
- No RCU or atomicity changes; the change prevents unsafe continued iteration after list mutation.

6. Broader Kernel Security Implications
- Demonstrates the risk of mutating kernel lists during traversal without using safe iteration patterns or exiting the loop; such errors can cause CPU soft lockups and system unresponsiveness.
- While not a memory-safety flaw, it enables denial-of-service conditions via normal Wi-Fi management paths (e.g., triggered during interface/channel context changes).
- Highlights the need for careful control-flow and iteration discipline (e.g., breaking outer loops or using list_for_each_entry_safe) in driver subsystems that reorder lists.