1. Plan Summary
Detect unsafe modification and reordering of a Linux kernel list within a non-safe list_for_each_entry iteration where control does not exit the outer loop, risking infinite traversal and soft lockup (as in rtw89_entity_recalc_mgnt_roles).

2. Detection Steps
1) Step 1: Objective — find outer iterations using non-safe Linux list macros; Signals — occurrences of list_for_each_entry over a list head (e.g., &mgnt->active_list) with a loop variable; FP mitigation — exclude *_safe variants like list_for_each_entry_safe.
2) Step 2: Objective — locate list mutation inside the outer iteration; Signals — calls to list_del taking the current iterator’s list node (e.g., &role->mgnt_entry) within the loop body; FP mitigation — require the list_del operand to be derived from the outer loop variable.
3) Step 3: Objective — confirm reordering within the same list; Signals — a subsequent list_add (or equivalent add) that adds the same node to the same list head being iterated (e.g., &mgnt->active_list) after list_del; FP mitigation — ensure the list head passed to list_add syntactically matches the head used in list_for_each_entry.
4) Step 4: Objective — establish that control flow does not terminate the outer iteration after modification; Signals — post-mutation paths that only hit a break in an inner loop or fall-through, without return/goto/break exiting the outer loop; FP mitigation — exclude cases with an immediate goto/return/break that leaves the outer loop (as in the fix “goto fill” from [PATCH_DIFF]).
5) Step 5: Objective — identify nested inner loops around the modification; Signals — presence of an inner for/while and a break statement scoped to that inner loop where the list mutation occurs; FP mitigation — confirm the break targets the inner loop (lexical containment), not the outer iteration label/block.
6) Step 6: Objective — confirm the mutation applies to the currently iterated node; Signals — the address-of member taken from the outer loop variable (e.g., &role->mgnt_entry) in both list_del and list_add; FP mitigation — exclude if the mutated node is different from the outer iterator variable or is aliased from a different object.
7) Step 7: Objective — assess risk amplification when the function performs multiple passes over the same list; Signals — another list_for_each_entry over the same list head later in the function; FP mitigation — use this only for prioritization (do not flag on this alone).
8) Step 8: Objective — ensure the mutation’s condition can be met; Signals — a conditional branch guarding the mutation on attributes of the current item (e.g., a link field check akin to chanctx_idx == RTW89_CHANCTX_0) that can be true; FP mitigation — exclude paths provably never taken (constant-false guards), otherwise assume possible as per [FUNCTION_CONTENT].
9) Step 9: Objective — produce findings only when all core signals co-occur; Signals — combine Steps 1–6 to assert: non-safe list iteration, modification of the current element, re-add to the same head, and continuation of the outer loop; FP mitigation — require all signals to be present to reduce noise.

3. Target Elements
- Functions containing Linux kernel list_for_each_entry iterations.
- Loop bodies and nested loops within those iterations.
- Call sites to list_del and list_add (or equivalent list re-link helpers).
- Control-flow constructs (break, goto, return) that determine whether the outer loop is exited.
- The list head expressions used by both iteration and re-add operations.
- The iterator variable’s member used as the list node.

4. Dataflow / Taint Considerations
- Track the loop iterator variable through the loop body to uses in list_del/list_add to confirm that the mutated node originates from the current element.
- Track the list head expression from the iterator macro to the list_add call to confirm same-container modification.
- Control-flow reachability from the mutation site to outer loop continuation (no immediate exit) to ensure the unsafe continuation occurs.

5. Validation & Test Cases
- Positive: A function iterates with list_for_each_entry over &mgnt->active_list, performs list_del(&role->mgnt_entry) and list_add(&role->mgnt_entry, &mgnt->active_list) inside an inner loop, then only breaks the inner loop (as shown in [FUNCTION_CONTENT] pre-patch); expect a finding.
- Negative: Same function but replaces the inner “break” with a control transfer that exits the outer loop (e.g., goto fill as in [PATCH_DIFF]); expect no finding.
- Negative: Iteration uses list_for_each_entry_safe or modifies a different list head than the one iterated; expect no finding.
- Test harness notes: Validate control-flow analysis correctly distinguishes inner vs outer loop exits and matches list head identity across macros and calls.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Mutations that are immediately followed by restarting or reinitializing the iteration in ways not captured; mitigate by requiring explicit outer-loop exit or re-init detection signals.
- Macros or wrappers around list_del/list_add obscuring the direct calls; mitigate by modeling common wrappers only if evidenced.
- Paths that are unreachable at runtime; mitigate by basic guard analysis, but accept residual FP due to static limits.
- Cases where the list head aliasing causes misidentification; mitigate by strict equality of head expressions where feasible.

8. Limitations & Assumptions
- Based on [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION], the risk arises specifically from list_for_each_entry combined with list_del/list_add on the current element; other list APIs are not covered due to lack of evidence.
- Assumes the ability to resolve macro semantics for list_for_each_entry and identify inner vs outer loop breaks; macro expansion details are not provided.
- Does not prove an actual infinite loop at runtime; flags structural patterns that match the pre-patch flaw.
- Only the provided function and pattern are known; broader variations in the kernel codebase are not detailed in the inputs.