1. Plan Summary
Detect cases where code iterates a Linux kernel list (non-safe list_for_each_entry-style) and, upon finding a match, reorders/mutates the same list (e.g., list_del + list_add) but only breaks out of an inner loop, allowing the outer iteration to continue on a modified list and risk a soft lockup.

2. Detection Steps
1) Step 1: Identify outer list traversals — look for uses of non-safe Linux list iteration macros (e.g., list_for_each_entry) with a list head H and iterator V — based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS] noting list_for_each_entry over mgnt->active_list. FP mitigation: exclude *_safe variants (e.g., list_for_each_entry_safe).

2) Step 2: Capture the loop body structure — detect if the outer list traversal contains a nested loop or nested search-like control (e.g., inner for/while/another list_for_each_entry) — mapping to “inner for-loop” per [PATCH_DESCRIPTION]. FP mitigation: require actual nested loop constructs inside the outer loop.

3) Step 3: Detect in-loop list mutation — within the outer loop body, find paths calling list_del on a list node derived from the iterator V (e.g., &V->X where X is the embedded list node) and list_add (or list_add_tail) adding that same node back to a list head expression H' — per [PATCH_DIFF] list_del(&role->mgnt_entry); list_add(..., &mgnt->active_list). FP mitigation: require dataflow linking H' to the same head H as the outer loop and the deleted node to V (or clearly aliasing V).

4) Step 4: Confirm same-list reordering — verify that the list_add destination head H' aliases the outer loop’s head H, indicating reordering of the currently iterated list — root cause was reordering mgnt->active_list while iterating it ([ROOTCAUSE_ANALYSIS]). FP mitigation: require structural equivalence or straightforward alias (e.g., same field access chain) between H and H'.

5) Step 5: Identify improper loop termination — after the mutation path, detect a break statement whose nearest enclosing loop is the inner loop (not the outer) — per [PATCH_DESCRIPTION]: “break just aborted the inner for-loop; the outer list_for_each_entry still continues.” FP mitigation: confirm nesting depth so the break targets the inner loop, not the outer.

6) Step 6: Check for continued outer iteration — ensure that control flow after the inner break can re-enter/continue the outer loop body/next iteration (i.e., no immediate return, goto past the outer loop, or other unconditional outer-loop exit) — aligns with pre-patch behavior continuing the outer traversal ([PATCH_DESCRIPTION]/[PATCH_DIFF]). FP mitigation: treat an immediate return/goto to a label placed after the outer traversal (like “goto fill” in [PATCH_DIFF]) as safe and do not flag.

7) Step 7: Exclude safe exits — if the mutation path is followed by a control-transfer that provably exits the outer loop (e.g., goto to a label post-loop, function return), consider it non-issue — matches the fix approach ([PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: require postdominator or clear syntactic evidence of exiting the outer loop.

8) Step 8: Optional broadened mutation ops — include list_move/list_move_tail as reordering signals when applied to V’s node into H to catch similar patterns across code — supported by “re-ordering” concept in [ROOTCAUSE_ANALYSIS]. FP mitigation: keep the “same head H” and “iterator-derived node” requirements to avoid unrelated list operations.

9) Step 9: Filter on absence of compensating outer logic — if there is an explicit outer-loop break/exit immediately after the inner loop (e.g., a flag set on mutation followed by unconditional outer break before the next iteration), consider it safe — consistent with intent “should have aborted the list_for_each_entry” ([PATCH_DESCRIPTION]). FP mitigation: require the outer break to be unconditionally reachable along the mutation path.

10) Step 10: Prioritize risky patterns — rank higher when list_del and list_add occur on the same path segment immediately followed by the inner break (tight sequence as in [PATCH_DIFF]); these are most likely to reproduce the bug. FP mitigation: de-prioritize if mutations are guarded by complex conditions without a clear immediate break.

3. Target Elements
- Functions containing Linux list iteration macros (list_for_each_entry and relatives).
- Loop constructs (outer and nested) and break/continue/goto/return statements.
- Calls to list_del, list_add/list_add_tail, and optionally list_move/list_move_tail.
- Expressions referencing list heads (e.g., &mgnt->active_list) and iterator-embedded list nodes (e.g., &iter->node).
- Control-flow regions around loops and labels (to determine loop-exit behavior).

4. Dataflow / Taint Considerations
- Track aliasing between the outer loop’s list head H and the head used in list_add/list_move.
- Track the iterator variable V and its list-node field used in list_del/list_add to ensure the mutated node is the one being iterated.
- Determine whether control flows from the mutation site to an inner-only break and then continues the outer loop (absence of outer-loop exit).

5. Validation & Test Cases
- Positive: Outer list_for_each_entry over H; inner loop finds match, executes list_del(&V->node); list_add(&V->node, &H); break; no goto/return; outer continues — should be flagged.
- Positive: Same as above with list_move(&V->node, &H) and inner break — should be flagged.
- Negative: After mutation, immediate goto to a label after the outer loop (as in [PATCH_DIFF] “goto fill;” with label before next phase) — should not be flagged.
- Negative: Use of list_for_each_entry_safe with list_del of current V and no re-add, or re-add followed by immediate outer-loop exit — should not be flagged.
- Negative: Mutation of a different list head than the one being iterated — should not be flagged.
- Test harness notes: Ensure macro resolution allows recognizing list_for_each_entry contexts and distinguish inner vs outer loop nesting for break targets.

6. Estimated Effort & Priority
Medium — requires modeling Linux list macros, container aliasing, and intra-procedural control-flow to determine break target and loop exit semantics.

7. Likely False-Positive Sources & Mitigations
- Complex aliasing where the head H' is indirectly the same as H; mitigate by requiring straightforward equivalence or simple alias patterns.
- Patterns where an outer-loop exit occurs indirectly (e.g., flag set then break later); mitigate by detecting immediate, unconditional outer exit on the mutation path.
- Safe mutation patterns using _safe iterators; mitigate by explicitly excluding *_safe macros.
- Benign reordering with guaranteed single-iteration outer loop; mitigate by checking that the outer loop can proceed to next iteration on the mutation path.

8. Limitations & Assumptions
- Assumes static identification of list macros and their semantic roles; macro-heavy code may obscure loop structures.
- Does not prove actual non-progress or soft lockup; flags control-flow patterns that match the root cause described in [ROOTCAUSE_ANALYSIS].
- Generalizes to list_move/list_add_tail cautiously; evidence in [PATCH_DIFF] centers on list_del/list_add.
- Interprocedural effects (e.g., helper functions performing mutation) may be missed if not analyzed within the same function scope.