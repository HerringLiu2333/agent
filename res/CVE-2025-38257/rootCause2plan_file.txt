1. Plan Summary
Detect kernel sites where user-controlled element counts are multiplied by element size to compute a byte size for memdup_user, without overflow checks, instead of using memdup_array_user, leading to potential integer overflow and underallocation (as in CVE-2025-38257).

2. Detection Steps
1) Step 1: Objective — find candidate array-duplication calls. Signals — call sites of memdup_user where the size argument is a binary multiplication of a variable and sizeof(struct/type) (as seen in [FILE_CONTENT] pre-patch _copy_apqns_from_user and [ROOTCAUSE_ANALYSIS]). FP mitigation — exclude memdup_user calls whose size argument is a plain variable or constant without multiplication.

2) Step 2: Objective — confirm the multiplication models array copying. Signals — the other memdup_user argument is a user pointer variable (void __user *), and the sizeof operand denotes a struct/type consistent with the target pointer type assigned from the call (e.g., assigned to struct pkey_apqn* as in [FILE_CONTENT]). FP mitigation — require that the return value flows to a pointer of the same element type used in sizeof, or is immediately cast/assigned to that type.

3) Step 3: Objective — establish user control over the count. Signals — dataflow/taint from copy_from_user-loaded fields or ioctl struct fields into the count variable (e.g., kgs.apqn_entries → nr_apqns in callers per [ROOTCAUSE_ANALYSIS] and [FILE_CONTENT] uses in pkey_ioctl_genseck2/…); also allow taint via function parameters arriving from such ioctl handlers. FP mitigation — if the count is a compile-time constant or provably bounded by a small constant upper limit that makes overflow impossible given sizeof(T), suppress.

4) Step 4: Objective — detect missing overflow protection. Signals — absence in the same function or dominating path of checks equivalent to count <= SIZE_MAX / sizeof(T) and absence of safer helper usage (memdup_array_user), per the fix in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation — if an overflow guard exists before the call or the code uses memdup_array_user already, do not flag.

5) Step 5: Objective — confirm that the count governs subsequent array semantics, increasing risk. Signals — the same count variable (or an alias) is passed alongside the returned pointer to downstream functions that expect an array length (e.g., pkey_handler_* with apqns, nr_apqns seen in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]) or used in loops/indexing over that pointer. FP mitigation — if the count is not used after duplication for indexing/length (e.g., data treated as raw bytes), deprioritize or suppress.

6) Step 6: Objective — detect helper wrappers that hide the pattern. Signals — functions that return void* or T* and internally call memdup_user with size computed as count*sizeof(T) (e.g., _copy_apqns_from_user in [FILE_CONTENT]), and are invoked by ioctl handlers with user-derived counts. FP mitigation — require at least one call site where the wrapper’s count parameter is tainted by copy_from_user/struct fields to flag the helper.

7) Step 7: Objective — recognize zero-entry checks that don’t mitigate overflow. Signals — preceding conditions like (nr_apqns == 0) returns that do not include any overflow-aware guard, per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]. FP mitigation — do not treat zero checks alone as sufficient; keep the finding unless a real overflow guard or memdup_array_user is used.

8) Step 8: Objective — avoid flagging safe allocation patterns. Signals — use of kmalloc_array(n, sizeof(T), …) or memdup_array_user(uaddr, n, sizeof(T)) as seen elsewhere in [FILE_CONTENT] and in [PATCH_DIFF]. FP mitigation — explicitly whitelist these safe APIs.

9) Step 9: Objective — capture cross-function propagation typical for ioctl paths. Signals — ioctl handlers that copy user structs (copy_from_user into local structs) and pass fields (e.g., apqn_entries) down to helpers that eventually reach memdup_user multiplication sites, per [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation — require a feasible interprocedural flow from the ioctl arg through helper parameters to the memdup_user site.

10) Step 10: Objective — prioritize findings with clear element-type consistency. Signals — sizeof operand refers to the same struct as the array element type used later (struct pkey_apqn in [FILE_CONTENT]); mismatches increase probability of a real array copy. FP mitigation — downgrade or suppress if sizeof uses an unrelated type not matching the array pointer’s base type.

3. Target Elements
- Call sites of memdup_user and memdup_array_user.
- Binary multiplication expressions used as size arguments.
- Function parameters and local variables representing counts (e.g., nr_apqns).
- copy_from_user call sites populating ioctl structs and their fields.
- Assignments of memdup_user results to typed pointers (e.g., struct pkey_apqn*).
- Calls to downstream handlers using (pointer, count) pairs (e.g., pkey_handler_*).
- Conditional checks preceding allocations (overflow guards vs. zero checks).

4. Dataflow / Taint Considerations
- Taint sources: fields loaded from copy_from_user of ioctl/user-space structures; ioctl function parameters; void __user* pointers.
- Propagation: through assignments, parameter passing into helpers (e.g., _copy_apqns_from_user), and simple arithmetic/comparisons.
- Sinks: memdup_user size argument formed by count*sizeof(T).
- Validation flow: the same tainted count reaching downstream uses (loops or function calls expecting array lengths).

5. Validation & Test Cases
- Positive: Pre-patch _copy_apqns_from_user returning memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn)) with nr_apqns tainted from ioctl fields; report with path to ioctl callers (pkey_ioctl_genseck2, pkey_ioctl_clr2seck2, pkey_ioctl_kblob2protk2, pkey_ioctl_kblob2protk3) as per [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS].
- Negative: Post-patch version using memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn)) as in [PATCH_DIFF]; no report.
- Negative: Allocations using kmalloc_array(nr_apqns, sizeof(struct pkey_apqn), …) in pkey_ioctl_apqns4k/apqns4kt from [FILE_CONTENT]; no report.
- Test harness notes: Build minimal kernel-like stubs for memdup_user/memdup_array_user and copy_from_user to exercise taint; ensure interprocedural flow from ioctl handler into helper is captured.

6. Estimated Effort & Priority
High: interprocedural taint and expression-shape analysis are needed, but the AST patterns and kernel APIs are well-defined.

7. Likely False-Positive Sources & Mitigations
- Count variables that are fully validated against safe upper bounds not recognized by the checker; mitigate by pattern-matching common overflow guards (count <= SIZE_MAX/sizeof(T), count * sizeof(T) <= MAX).
- Non-user-controlled counts (e.g., derived from trusted kernel data); mitigate via taint requirement from copy_from_user/ioctl fields.
- Multiplications not representing array sizes (mismatched sizeof type); mitigate by requiring type consistency between sizeof(T) and the target pointer’s base type.

8. Limitations & Assumptions
- Assumes availability of kernel-specific API recognition (memdup_user, memdup_array_user, copy_from_user) as per [FILE_CONTENT] and [PATCH_DIFF]; other allocators are not covered due to lack of evidence.
- Range-analysis precision is limited; the checker may not fully prove safety when custom overflow checks are written in non-standard forms.
- Architecture-dependent size_t widths are not modeled; the checker approximates overflow risk based on generic SIZE_MAX-style reasoning.
- Does not verify actual downstream OOB access; relies on pointer/count pair usage as a proxy for risk per [ROOTCAUSE_ANALYSIS].