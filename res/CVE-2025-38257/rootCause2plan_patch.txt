1. Plan Summary
Detect kernel call sites where a user-controlled element count is multiplied by an element size to form a byte size passed to memdup_user without an overflow-safe check, risking allocation-size underflow/overflow and subsequent out-of-bounds access.

2. Detection Steps
1) Step 1: Objective: Find candidate allocations from user memory. Signals: Call expressions to memdup_user where the second argument is the requested byte size; this maps to the pre-patch flaw replaced in [PATCH_DIFF]. FP mitigation: Ignore non-memdup_user calls and memdup_array_user which is the patched safe helper.

2) Step 2: Objective: Identify array-size multiplication patterns. Signals: The memdup_user size argument is a multiplication of a “count-like” value and sizeof(struct T) (or conceptually an element-size constant); this matches the nr_apqns * sizeof(struct pkey_apqn) pattern in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: Require that one operand is a sizeof(…) expression (or a constant equal to an element size) to distinguish from unrelated multiplications.

3) Step 3: Objective: Determine if the count operand is user-controlled via ioctl. Signals: The count value dataflows from ioctl-provided inputs (e.g., function parameters of an ioctl handler or fields populated via copy_from_user/get_user) as stated in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; treat variables tied to user pointers/structs as tainted. FP mitigation: Only flag when taint from user space (ioctl path) reaches the count; exclude counts proven to be constant or derived solely from kernel-internal, trusted values.

4) Step 4: Objective: Check for absence of overflow-safe size computation. Signals: No use of memdup_array_user (the fix in [PATCH_DIFF]) and no use of overflow-safe helpers like array_size mentioned in [ROOTCAUSE_ANALYSIS §6]; no preceding explicit overflow check before the multiplication. FP mitigation: Suppress if size is computed through memdup_array_user or array_size, or if there is a clear prior overflow guard that limits count to SIZE_MAX / sizeof(T) (conceptually equivalent).

5) Step 5: Objective: Avoid being misled by zero-count checks. Signals: Presence of a guard like nr_apqns == 0 leading to early return, as in [PATCH_DIFF]; this does not address overflow. FP mitigation: Do not treat zero-count checks as sufficient mitigation; keep the alert if other risky signals are present.

6) Step 6: Objective: Corroborate risk by checking downstream array semantics (for prioritization). Signals: The returned pointer is treated as an array of the element type and later accesses/loops are bounded by the same count (e.g., iterating up to nr_apqns), consistent with [ROOTCAUSE_ANALYSIS] “Subsequent code paths treat the buffer as containing nr_apqns entries.” FP mitigation: Use this only to raise confidence/severity; do not require it to flag, to avoid missing simpler vulnerable patterns.

7) Step 7: Objective: Exclude cases where the count is clearly bounded to prevent overflow. Signals: Prior comparisons that clamp count to a maximum consistent with preventing overflow (e.g., count <= SIZE_MAX / sizeof(T) or a tight compile-time maximum smaller than that product threshold). FP mitigation: Suppress when such a bound is present and dominates all paths to the memdup_user call.

8) Step 8: Objective: Finalize issue reporting and guidance. Signals: All of Steps 1–4 satisfied (and Step 6 optional for severity), indicating a user-controlled count × sizeof(T) passed to memdup_user without overflow protection, exactly the root cause in [ROOTCAUSE_ANALYSIS]. FP mitigation: Include context (the count source and the exact size expression) to assist triage and suggest replacing with memdup_array_user per [PATCH_DIFF]/[PATCH_DESCRIPTION].

3. Target Elements
- Function call sites: memdup_user (and distinction from memdup_array_user).
- Arithmetic expressions used as allocation/copy sizes, especially count × sizeof(T).
- Variables representing counts/lengths derived from user input via ioctl.
- Control-flow guards surrounding the call (zero-checks, upper-bound checks).
- Downstream uses of the returned pointer (loops/indexing up to count) for severity.

4. Dataflow / Taint Considerations
- Treat ioctl arguments and user-provided struct fields populated via copy_from_user/get_user as user-controlled taint sources (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
- Propagate taint through assignments, simple arithmetic, and parameter passing to identify when the count in the size multiplication originates from user input.
- Stop taint when strong sanitization occurs (e.g., explicit upper-bound comparison against SIZE_MAX / sizeof(T) or use of array_size/memdup_array_user).

5. Validation & Test Cases
- Positive: A function taking an ioctl-provided nr (from copy_from_user) that returns memdup_user(buf, nr * sizeof(struct item)); no overflow checks present. Expect a report.
- Positive: Same as above with an early “if (!buf || nr == 0) return NULL;” guard. Expect a report (zero-check not a mitigation).
- Negative: A function returning memdup_array_user(buf, nr, sizeof(struct item)). Expect no report.
- Negative: memdup_user(buf, array_size(nr, sizeof(struct item))) or memdup_user after an explicit check that nr <= SIZE_MAX / sizeof(struct item). Expect no report.
- Test harness notes: Run on a small kernel-like module with mocked __user annotations and ioctl-like handlers to exercise taint from user inputs through to the memdup_user size expression.

6. Estimated Effort & Priority
High: The pattern is precise, security-impacting, and common in ioctl/user-buffer handling per [ROOTCAUSE_ANALYSIS §6].

7. Likely False-Positive Sources & Mitigations
- Counts that appear user-controlled but are actually sanitized by non-obvious checks: mitigate by recognizing clear upper-bound guards.
- Multiplications that are not element-size based: mitigate by requiring a sizeof(T) (or clear element-size constant) operand.
- Non-ioctl contexts where memdup_user is used with trusted counts: mitigate via taint requirement from user input sources.

8. Limitations & Assumptions
- Assumes availability of kernel-specific user/taint sources (ioctl handlers, copy_from_user/get_user), inferred from [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; other user-input mechanisms are not enumerated here.
- Focuses on memdup_user; other alloc/copy APIs with similar risks are not covered unless they map to the same size-multiplication pattern and taint sources (mentioned broadly in [ROOTCAUSE_ANALYSIS §6] but not detailed).
- Detection of sophisticated overflow checks beyond simple upper-bound comparisons may be incomplete due to lack of explicit patterns in the provided materials.