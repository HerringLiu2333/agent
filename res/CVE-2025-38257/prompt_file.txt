1. CVE Identifier
CVE-2025-38257

2. Vulnerability Type
Integer overflow leading to underallocation and subsequent out-of-bounds kernel memory access (heap OOB read).

3. Root Cause Summary
The helper _copy_apqns_from_user() multiplied a user-controlled count (nr_apqns) by sizeof(struct pkey_apqn) without checking for integer overflow and passed the result to memdup_user(). If nr_apqns was large enough to overflow the product, the allocated buffer was smaller than required, while the original (overflowed) count was still used by callers, enabling later out-of-bounds access of the APQN array.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
s390 cryptographic pkey driver (drivers integrating zcrypt/pkey_base handlers for APQN selection and key operations).

2) Pre-Patch Flaw:
In _copy_apqns_from_user(void __user *uapqns, size_t nr_apqns), the code returned memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn)) with no overflow check on the multiplication. This permitted a size_t wrap-around on the size argument to memdup_user() for attacker-supplied nr_apqns.

3) Trigger Condition:
Any ioctl path that uses _copy_apqns_from_user() with a non-NULL user pointer and a maliciously large apqn_entries value:
- pkey_ioctl_genseck2 (kgs.apqns, kgs.apqn_entries)
- pkey_ioctl_clr2seck2 (kcs.apqns, kcs.apqn_entries)
- pkey_ioctl_kblob2protk2 (ktp.apqns, ktp.apqn_entries)
- pkey_ioctl_kblob2protk3 (ktp.apqns, ktp.apqn_entries)

4) Impact Mechanism:
- memdup_user() allocates/copies too few bytes due to overflow; the returned kernel buffer holds fewer struct pkey_apqn entries than requested.
- Callers continue to pass the original nr_apqns to pkey_handler_* functions, which iterate over the purported array length, causing out-of-bounds reads past the allocated buffer.
- This can lead to kernel crashes or unpredictable behavior by consuming adjacent kernel memory as bogus APQN entries (card/domain pairs), with potential misdirected hardware operations.

5. Patch Analysis
1) Fix Approach:
Replace the unsafe size calculation and raw memdup_user() with memdup_array_user(), which internally validates the product of count and element size and returns an error on overflow. This ensures allocation size matches the logical array length.

2) Key Code Changes:
- In _copy_apqns_from_user():
  - Pre-patch: return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));
  - Post-patch: return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));
This directly addresses the overflow in size calculation and provides error signaling if an overflow is detected.

3) Locking/Concurrency Impact:
None. The change is confined to safe user-memory duplication and overflow checking; no locking or ordering semantics are altered.

6. Broader Kernel Security Implications
- Using memdup_array_user() for user-controlled array copies standardizes overflow protection and prevents widespread underallocation/OOB bugs in ioctl handlers.
- The pattern of user-supplied element counts should consistently use array-aware helpers; failing to do so risks similar vulnerabilities in other subsystems.
- This fix reduces the attack surface for kernel memory exposure/crashes caused by integer overflows in size calculations tied to user input.