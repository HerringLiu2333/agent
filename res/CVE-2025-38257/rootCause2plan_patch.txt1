1. Plan Summary
Detect calls that pass a multiplied byte-size (count * element_size) into memdup_user where the count may be user-controlled (e.g., via ioctl), and where no overflow-safe helper (memdup_array_user/array_size) or explicit overflow guard is present.

2. Detection Steps
1) Step 1: Locate candidate sinks — calls to memdup_user and capture their size argument. Objective: focus analysis on allocations/copies from userspace that take a raw byte-size.

2) Step 2: Identify array-size computations in the size argument. Signals: the size argument is (or simplifies to) a multiplication involving sizeof(...) or a constant element-size and an integral “count” variable (possibly with minor arithmetic like additions/casts).

3) Step 3: Extract the “count” operand from the multiplication for further analysis. Signals: the non-sizeof operand is a variable/expression representing a number of elements (e.g., nr_*).

4) Step 4: Infer potential user control of the count. Signals: the count is a function parameter or value derived from parameters/fields in code that implements or is called by an ioctl handler (e.g., presence of ioctl-related function naming/arguments) or otherwise documented as set “via an ioctl call”.

5) Step 5: Track local dataflow to see if the count flows from an ioctl-exposed input within the function or its immediate callers. Signals: assignments/propagation from ioctl arguments to the count variable before the memdup_user call.

6) Step 6: Suppress if an overflow-safe helper is used instead. Signals: replace/compute size via memdup_array_user(uaddr, count, elem_size) or via an overflow-safe array_size helper; do not flag such cases.

7) Step 7: Suppress if there is an explicit precondition that rules out overflow for the specific multiplication. Signals: checks equivalent to ensuring count <= MAX_SIZE/elem_size (or otherwise proving the product fits in size_t) immediately dominating the call.

8) Step 8: Do not treat a mere zero-count check as a mitigation. Signals: conditions like “if (!uaddr || count == 0) return …” should not prevent a finding if the call still uses memdup_user with a product when count != 0.

9) Step 9: Increase confidence if subsequent logic treats the returned pointer as an array of the element type with the same count. Signals: loops or accesses that iterate up to the count and index into the returned buffer as an array of that element type.

10) Step 10: Report a potential overflow issue when a user-influenced count multiplies an element size to form the memdup_user size without a safe helper or explicit overflow guard. Include the count variable, the element size expression, and note that memdup_array_user should be used.

3. Limitations & Assumptions
- Determining whether a function is an ioctl handler or reachable from one may be approximate; lack of full driver registration context can reduce taint precision.
- Proving user control of the count is best-effort; the plan assumes counts passed/derived in ioctl-related code are user-influenced, which may yield false positives if validated earlier.
- Recognizing explicit overflow checks is limited to straightforward dominance patterns; complex validations may be missed.
- The plan targets memdup_user specifically; similar issues in other allocation/copy APIs are not covered unless they are explicitly using overflow-safe helpers noted here.
- Architectural size_t limits and exact element sizes are not modeled precisely; the checker infers element sizes from sizeof(...) patterns.