1. Plan Summary
Detect kernel code paths that call memdup_user with a size computed as count * element_size where the count is user-controlled, without an overflow-safe check/helper, risking integer overflow and undersized allocation.

2. Detection Steps
1) Step 1: Identify calls to memdup_user; signal is any call expression whose callee is memdup_user and takes a size argument.
2) Step 2: For each such call, inspect the size argument; signal is a multiplicative expression (X * Y), especially where Y is a sizeof(Type) (e.g., sizeof(struct pkey_apqn)) or a constant element size.
3) Step 3: Determine whether the non-sizeof operand represents a number-of-elements; signals include variables named like count/len/nr_* (e.g., nr_apqns) or parameters/locals used as array lengths.
4) Step 4: Assess user-control of the count operand; signals include dataflow from ioctl-controlled inputs, copy_from_user/get_user, or parameters sourced from userspace (as noted for nr_apqns via ioctl).
5) Step 5: Check for absence of overflow-safe helpers; signal is that the code uses memdup_user rather than memdup_array_user for array duplication from userspace.
6) Step 6: Check for absence of explicit overflow guards before the call; signals include no prior validation such as “count <= SIZE_MAX / element_size” or use of a checked-multiplication helper before passing the computed size.
7) Step 7: Exclude benign cases where the size is not a product of a variable count and element size; signals include pure sizeof(...) or constant sizes not influenced by user-controlled values.

3. Limitations & Assumptions
- Inferring “user-controlled via ioctl” relies on general kernel patterns (e.g., copy_from_user/get_user) and may miss custom pathways; exact taint sources are not fully enumerated in the supplied materials.
- The plan targets memdup_user; similar risks in other alloc/copy helpers (e.g., kmalloc + copy_from_user) are outside scope based on provided evidence.
- The checker does not verify subsequent use of the returned buffer as nr_apqns elements; it flags the hazardous allocation pattern itself.
- Zero-length semantics (“nr_apqns == 0” valid) are noted but not used to suppress findings; the checker focuses on overflow risk, not zero-handling correctness.