1. CVE Identifier
CVE-2025-38257

2. Vulnerability Type
Integer overflow in user-controlled allocation size leading to potential out-of-bounds access/memory corruption.

3. Root Cause Summary
The function _copy_apqns_from_user computed the byte size for memdup_user using nr_apqns * sizeof(struct pkey_apqn) without checking for integer overflow. Because nr_apqns is user-controlled via an ioctl, the multiplication could wrap, causing a too-small allocation while the logic later still treats the buffer as containing nr_apqns entries. This mismatch between the allocated size and the logical element count can lead to out-of-bounds accesses and unpredictable behavior in subsequent pkey handlers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
s390/pkey (s390 CCA AES key support and APQN list handling)

2) Pre-Patch Flaw:
In _copy_apqns_from_user(void __user *uapqns, size_t nr_apqns), the code passed nr_apqns * sizeof(struct pkey_apqn) to memdup_user without overflow protection. Specifically: “return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));”.

3) Trigger Condition:
A userspace process issues the relevant ioctl and supplies a large nr_apqns such that the product nr_apqns * sizeof(struct pkey_apqn) overflows size_t, with uapqns non-NULL and nr_apqns != 0.

4) Impact Mechanism:
The overflow results in a smaller-than-required allocation and copy. Subsequent code paths treat the buffer as containing nr_apqns entries, which can cause out-of-bounds reads/writes or other undefined behavior when iterating/accessing beyond the allocated memory.

5. Patch Analysis
1) Fix Approach:
Replace memdup_user with memdup_array_user to perform array-size multiplication with overflow detection and fail safely on overflow, differentiating that overflow is an error while a zero nr_apqns remains a valid case to be handled later.

2) Key Code Changes:
In _copy_apqns_from_user:
- Before: “return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));”
- After: “return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));”
The existing NULL/zero check “if (!uapqns || nr_apqns == 0) return NULL;” remains unchanged.

3) Locking/Concurrency Impact:
None. The change is confined to safe size computation and allocation-from-user; no locking or ordering adjustments were introduced.

6. Broader Kernel Security Implications
This fix reinforces the need to guard all user-controlled array length computations with overflow-safe helpers (e.g., memdup_array_user, array_size) to prevent allocation-size mismatches that can lead to memory corruption. Similar patterns across ioctl and user buffer handling are common; adopting these helpers systematically reduces the risk of integer overflow-driven vulnerabilities.