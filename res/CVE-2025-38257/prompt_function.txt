1. CVE Identifier
CVE-2025-38257

2. Vulnerability Type
Integer overflow in size calculation leading to undersized allocation and potential out-of-bounds access (heap buffer overflow/overread)

3. Root Cause Summary
The function _copy_apqns_from_user() computed the allocation size as nr_apqns * sizeof(struct pkey_apqn) without checking for overflow before passing it to memdup_user(). Because nr_apqns is user-controlled via ioctl, the multiplication could wrap, causing memdup_user() to allocate a buffer smaller than required for nr_apqns elements. Subsequent code that treats the returned buffer as an array of nr_apqns entries could perform out-of-bounds reads/writes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
s390 crypto key (pkey) driver

2) Pre-Patch Flaw:
- In _copy_apqns_from_user(void __user *uapqns, size_t nr_apqns), the code used:
  "memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn))"
- No validation of the product for overflow, despite nr_apqns being controlled by userspace via ioctl.

3) Trigger Condition:
- Userspace passes a large nr_apqns such that nr_apqns * sizeof(struct pkey_apqn) overflows size_t, while uapqns is non-NULL and nr_apqns != 0.

4) Impact Mechanism:
- memdup_user() allocates and copies only the wrapped (undersized) number of bytes.
- Kernel code that iterates over or indexes nr_apqns elements in the returned buffer may read or write beyond the allocated memory, leading to memory corruption, information disclosure, or kernel crashes.

5. Patch Analysis
1) Fix Approach:
- Replace raw multiplication and memdup_user() with memdup_array_user(), which performs checked array size calculation and fails on overflow.

2) Key Code Changes:
- Before: return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));
- After:  return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));
- The new helper detects multiplication overflow and returns an error rather than allocating an undersized buffer. The early return for nr_apqns == 0 remains unchanged, preserving the “zero is valid” semantics noted in the patch description.

3) Locking/Concurrency Impact:
- None. The change is purely about safe size calculation and copying from userspace; no locking semantics were introduced or modified.

6. Broader Kernel Security Implications
- Using memdup_array_user() eliminates a common class of integer overflow bugs in array allocations from userspace. This prevents heap mis-sizing that can lead to OOB accesses and potential privilege escalation. The fix aligns with kernel-wide best practices for safe user-controlled array length handling in ioctl paths.