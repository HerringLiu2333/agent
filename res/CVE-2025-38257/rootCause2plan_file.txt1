1. Plan Summary
Detect kernel cases where a user-controlled element count is multiplied by an element size to form a memdup_user() size, without overflow-safe handling, leading to potential underallocation and out-of-bounds array access.

2. Detection Steps
1) Step 1: Identify functions that ingest user data via copy_from_user() into a struct or local variables. Signal: assignments or struct initializations populated by copy_from_user() calls.

2) Step 2: From those copy_from_user() targets, track dataflow of fields representing counts (e.g., apqn_entries) into subsequent computations or function parameters. Signal: variables/fields read from the copied struct flowing into other variables or passed as size_t parameters to helpers.

3) Step 3: Locate calls to memdup_user() and inspect their size argument. Signal: size argument is a multiplication expression of a count and an element size (sizeof(struct …) or a constant corresponding to a struct size).

4) Step 4: Determine whether the count operand in the multiplication is user-controlled. Signal: dataflow from the copy_from_user()-populated field or a function parameter originating from such a field (e.g., helper parameter nr_apqns) reaches the memdup_user() size computation.

5) Step 5: Exclude cases that already use overflow-safe array duplication. Signal: if the code uses memdup_array_user() instead of memdup_user(), do not flag.

6) Step 6: Check for absence of explicit overflow guards around the multiplication feeding memdup_user(). Signal: no preceding checks that constrain count relative to element size (e.g., division by sizeof, upper bounds on count), and only trivial checks like “count == 0” or pointer NULL checks are present.

7) Step 7: Confirm array semantics to strengthen confidence. Signal: the pointer returned by memdup_user() flows into a variable typed as pointer to the same struct used in sizeof, or is returned from a helper and then assigned to such a pointer (e.g., struct pkey_apqn *apqns).

8) Step 8: Check that the original count is used later to process the array, indicating potential OOB if underallocated. Signal: the same count flows into loops or is passed together with the duplicated pointer to downstream functions (e.g., pkey_handler_* calls that take both apqns and nr_apqns).

9) Step 9: Prioritize findings where the helper function serves as a bridge between ioctl paths and memdup_user(). Signal: helper parameters (e.g., nr_apqns) are computed directly from user-populated structs in ioctl handlers and then used in memdup_user() size multiplication.

10) Step 10: Emit a warning at the memdup_user() call site when Steps 3–8 hold. Signal: message should highlight “user-controlled count × element size passed to memdup_user() without overflow-safe handling; use memdup_array_user().”

3. Limitations & Assumptions
- Assumes user-controlledness is inferred via dataflow from copy_from_user(); other validation not visible in the provided snippets may exist elsewhere and is not considered.
- Does not prove an actual overflow or OOB use; flags based on risky pattern (count × sizeof passed to memdup_user) and subsequent array use.
- Element size constants equivalent to sizeof(struct …) may be hard to match if defined indirectly; the plan assumes recognizable sizeof or literal constants.
- The checker cannot verify kernel helper internals; it relies on the patch’s indication that memdup_array_user() performs overflow checks while memdup_user() does not.