1. Plan Summary
Detect misuse of ERR_PTR-style error handling on APIs that return NULL on failure, specifically of_find_device_by_node(), leading to unchecked NULL pointer usage and potential dereference.

2. Detection Steps
1) Step 1: Identify call sites where a variable is assigned the result of of_find_device_by_node(node). Signals: assignment of a pointer-typed variable from of_find_device_by_node; this matches the exact API in the flaw (based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
2) Step 2: Find error checks that use IS_ERR(var) or return PTR_ERR(var) on that variable. Signals: condition with IS_ERR on the variable and/or return statements invoking PTR_ERR(variable); this maps to the root cause of assuming ERR_PTR semantics (based on [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]); mitigate FPs by requiring the check to be in the same function block as the call.
3) Step 3: Confirm absence of a NULL check (!var or var == NULL) on the same variable along the path before its next use. Signals: no explicit NULL check in the basic block or immediate successor blocks; this ensures the problematic path persists (based on [PATCH_DIFF]).
4) Step 4: Detect subsequent uses of the variable that imply dereference or member access. Signals: member access var->field or address-of member &var->field; this ties to the crash mechanism (based on “video->ece.reset = devm_reset_control_get(&ece_pdev->dev, NULL)” in [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]); reduce FPs by requiring such uses post the faulty check.
5) Step 5: Detect passing the variable to functions likely to dereference it (e.g., devm_platform_ioremap_resource(var, ...)). Signals: variable used as the first argument in calls that operate on a platform_device; this strengthens evidence of a potential NULL deref (based on [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]).
6) Step 6: Correlate the incorrect IS_ERR/PTR_ERR handling with the known NULL-returning API. Signals: the callee is of_find_device_by_node and the handler uses ERR_PTR idioms; this directly maps to the root cause (based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]); reduce FPs by scoping to this API.
7) Step 7: Check that the code path is reachable under a feature/enable condition. Signals: variable usage guarded by a flag like video->ece.enable, with the call/handling inside that block; this mirrors the real trigger condition (based on [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]); avoid over-pruning by not requiring runtime feasibility, only structural containment.
8) Step 8: Flag cases returning PTR_ERR(var) when var came from of_find_device_by_node. Signals: return statements using PTR_ERR(variable) sourced from the API; this is a strong indicator of mistaken error translation (based on [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]); mitigate FPs by excluding cases where a prior explicit NULL-to-error translation occurs.

3. Target Elements
- Functions containing calls to of_find_device_by_node.
- Call sites assigning its return to local variables.
- Condition checks using IS_ERR on the returned variable.
- Return-value uses invoking PTR_ERR on the variable.
- Subsequent dereferences/member accesses of the variable.
- Call arguments where the variable is passed to functions that operate on platform_device or device structures.

4. Dataflow / Taint Considerations
- Track dataflow from the of_find_device_by_node return to: error checks (IS_ERR/PTR_ERR), subsequent dereferences, and calls using the variable.
- Model control-flow to confirm the absence of a NULL check on the variable before its dereference or use.
- Confine the flow to paths within the same function and within the same basic region to reduce cross-function ambiguities.

5. Validation & Test Cases
- Positive: Pre-patch npcm_video_ece_init where of_find_device_by_node assigns to ece_pdev, error check uses IS_ERR(ece_pdev)/PTR_ERR(ece_pdev), and ece_pdev is later dereferenced (based on [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]).
- Negative: Patched version where the check is “if (!ece_pdev) return -ENODEV;” and subsequent uses occur only after the NULL check (based on [PATCH_DIFF]).
- Test harness notes: Run the checker on drivers/media/platform/nuvoton/npcm-video.c and verify it flags only the pre-patch variant and not the patched one.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where additional, non-local NULL checks exist: mitigate by requiring a pre-use NULL check in the same or immediate successor blocks.
- Wrapper macros obscuring NULL checks: mitigate by resolving simple macro expansions or requiring explicit !var patterns.
- Functions other than of_find_device_by_node: mitigate by scoping to the specific API named in the provided materials.

8. Limitations & Assumptions
- Assumes of_find_device_by_node returns NULL on failure; broader generalization to other APIs is out of scope without additional API models (based on [PATCH_DESCRIPTION]).
- Does not prove runtime reachability (e.g., whether video->ece.enable is true); it assumes structural paths are potentially executable (based on [ROOTCAUSE_ANALYSIS]).
- Knowledge of whether called functions dereference the pointer is inferred from usage patterns in the provided function; broader dereference modeling may need kernel API specifications.