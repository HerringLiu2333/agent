1. Plan Summary
Detect kernel driver call sites where a function that returns NULL on failure (of_find_device_by_node) are incorrectly treated as ERR_PTR (checked with IS_ERR or used with PTR_ERR), allowing NULL to bypass error handling and be dereferenced.

2. Detection Steps
1) Step 1: Objective: Identify return values from of_find_device_by_node. Signals: Calls to of_find_device_by_node whose result is stored into a variable; capture def-use of that variable. FP mitigation: Restrict to the exact API name and kernel build contexts to avoid matching unrelated functions (based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS).

2) Step 2: Objective: Find incompatible error checks that assume ERR_PTR. Signals: Conditional checks using IS_ERR(var) on the variable from Step 1 without a concurrent or subsequent explicit NULL check for the same variable in the same control region. FP mitigation: Require that no dominating null-check (e.g., !var) exists before any dereference or use; confirm check is in the same function (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS).

3) Step 3: Objective: Find incorrect error propagation via PTR_ERR on a value that can be NULL but not ERR_PTR. Signals: Uses of PTR_ERR(var) where var originates from of_find_device_by_node. FP mitigation: Exempt cases that first reassign var from a known ERR_PTR-returning API before PTR_ERR; require that the most recent reaching definition is from of_find_device_by_node (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS).

4) Step 4: Objective: Confirm potential NULL dereference due to missed NULL handling. Signals: Any dereference of var (member access, passing as non-null parameter, or implicit deref) along a path where the only guard is IS_ERR(var) (which evaluates false for NULL). FP mitigation: Use path-sensitivity to ensure no intervening NULL check dominates the dereference (based on ROOTCAUSE_ANALYSIS “failure path was never taken” and “continued assuming ece_pdev was valid”).

5) Step 5: Objective: Flag the specific pre-patch flawed pattern. Signals: Sequence “var = of_find_device_by_node(...); if (IS_ERR(var)) { … return PTR_ERR(var); } … deref(var)”. FP mitigation: Require both IS_ERR and PTR_ERR usage or a deref after only IS_ERR; this mirrors the exact flawed pattern (based on PATCH_DIFF).

6) Step 6: Objective: Recognize corrected pattern to avoid false positives. Signals: Checks of the form “if (!var) … return -ENODEV;” for the of_find_device_by_node return, possibly followed by safe use. FP mitigation: Suppress any alert if a dominating !var check exists and the returned constant is a negative errno (based on PATCH_DIFF and PATCH_DESCRIPTION).

7) Step 7: Objective: Handle mixed guards to avoid under/over-reporting. Signals: If code uses IS_ERR_OR_NULL(var) then returns -ENODEV (or another fixed negative errno) and no PTR_ERR(var) use, treat as safe; but if it uses PTR_ERR(var) in that branch, flag as incorrect error propagation. FP mitigation: Only flag the latter because API does not return ERR_PTR (based on ROOTCAUSE_ANALYSIS).

8) Step 8: Objective: Ensure reports are actionable by pointing to both misuse and consequence. Signals: For each finding, pair the incompatible check/return (IS_ERR/PTR_ERR) with the nearest subsequent dereference or use that assumes non-NULL. FP mitigation: If no dereference exists and function immediately returns a fixed errno on NULL, suppress to reduce noise (based on ROOTCAUSE_ANALYSIS impact mechanism).

3. Target Elements
- Function call sites to of_find_device_by_node and their assigned variables.
- Condition checks using IS_ERR, IS_ERR_OR_NULL, and explicit NULL checks on those variables.
- Uses of PTR_ERR on those variables.
- Pointer dereferences, member accesses, and function calls that consume those variables.
- Return statements that propagate errors from those variables.

4. Dataflow / Taint Considerations
- Track the dataflow from the of_find_device_by_node call result to all uses, including conditionals and returns.
- Perform path/dominance analysis: determine whether a NULL check dominates all dereferences; if only IS_ERR guards exist, NULL is unguarded.
- Track reassignments to ensure the value used in PTR_ERR or deref is still the one from of_find_device_by_node.
- Model that of_find_device_by_node can yield NULL but not ERR_PTR (from PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS).

5. Validation & Test Cases
- Positive: var = of_find_device_by_node(n); if (IS_ERR(var)) return PTR_ERR(var); foo(var->dev); Expected: report misuse and potential NULL deref.
- Positive: var = of_find_device_by_node(n); if (IS_ERR(var)) handle(); /* no null check */ use(var); Expected: report missed NULL handling before use.
- Positive: var = of_find_device_by_node(n); if (IS_ERR_OR_NULL(var)) return PTR_ERR(var); Expected: report incorrect PTR_ERR on NULL-returning API.
- Negative: var = of_find_device_by_node(n); if (!var) return -ENODEV; use(var); Expected: no report.
- Negative: var = of_find_device_by_node(n); if (IS_ERR_OR_NULL(var)) return -ENODEV; Expected: no report.
- Test harness notes: Run on drivers/media/platform/nuvoton/npcm-video.c pre- and post-patch; pre-patch should be flagged, post-patch should be clean.

6. Estimated Effort & Priority
Medium: Requires API modeling, control-flow dominance, and simple path-sensitivity; high value for kernel stability per ROOTCAUSE_ANALYSIS.

7. Likely False-Positive Sources & Mitigations
- Functions shadowing or wrapping of_find_device_by_node with different semantics; mitigate by matching the canonical kernel API symbol.
- Variables reassigned after the call; mitigate by ensuring the reaching definition at use sites is still the API return.
- Defensive code using IS_ERR_OR_NULL with constant errno returns; avoid flagging unless PTR_ERR is used.

8. Limitations & Assumptions
- Assumes accurate modeling that of_find_device_by_node never returns ERR_PTR, only NULL on failure (from PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS); the checker does not generalize to other APIs without additional ground truth.
- The plan cannot infer the exact errno to recommend (-ENODEV) beyond flagging misuse; it only checks for safe handling patterns indicated by the patch.