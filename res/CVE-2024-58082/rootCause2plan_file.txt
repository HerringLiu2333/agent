1. Plan Summary
Detect misuse of IS_ERR/PTR_ERR on the result of of_find_device_by_node(), which returns NULL on failure, leading to unchecked NULL dereferences.

2. Detection Steps
1) Step 1: Objective: Find call sites of of_find_device_by_node() and capture the variable receiving its return. Signals: Function call expression bound to a platform_device pointer variable. FP mitigation: Restrict to direct assignments from of_find_device_by_node() calls.
2) Step 2: Objective: Identify incorrect error handling that assumes ERR_PTR. Signals: Conditional checks using IS_ERR(var) or returns using PTR_ERR(var) on the aforementioned variable. FP mitigation: Require that the IS_ERR/PTR_ERR use is in the same function as the call and refers to the same variable without intervening reassignment.
3) Step 3: Objective: Confirm absence of a proper NULL check. Signals: No path that tests “!var” (or equivalent NULL comparison) with an early return or guard before later uses. FP mitigation: Perform control-flow guard analysis to see if any NULL-check dominates subsequent dereferences.
4) Step 4: Objective: Detect hazardous subsequent uses likely to dereference the platform_device. Signals: Passing var to devm_platform_ioremap_resource(var, …) or accessing &var->dev for devm_reset_control_get, or direct member access var->field. FP mitigation: Ensure these uses are reachable from the call site without a prior explicit NULL-return path.
5) Step 5: Objective: Validate path feasibility from the call to the dereference. Signals: A path exists in the CFG where only IS_ERR-based handling occurs and execution continues to dereference/use var. FP mitigation: Exclude paths gated by a correct NULL check that returns or prevents use.
6) Step 6: Objective: Correlate the misuse with the documented API contract. Signals: The specific function name of_find_device_by_node() is known to return NULL on failure per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]. FP mitigation: Limit to this function to avoid assumptions about other APIs.
7) Step 7: Objective: Flag cases where PTR_ERR(var) is returned for of_find_device_by_node()’s result. Signals: Return statements using PTR_ERR(var) tied to the var from Step 1. FP mitigation: Only report if a dereference/use of var exists later in the same function or the function continues after the return check in alternative paths.
8) Step 8: Objective: Ensure reporting focuses on actionable locations. Signals: Prefer reporting at the incorrect IS_ERR/PTR_ERR check site, with evidence of downstream dereference sites. FP mitigation: Aggregate both signals to reduce noise.

3. Target Elements
- Function call sites: of_find_device_by_node().
- Variable assignments capturing the call’s return value.
- Condition checks: IS_ERR(var) and comparisons against NULL.
- Return statements using PTR_ERR(var).
- Function argument uses and member accesses that dereference platform_device (e.g., devm_platform_ioremap_resource(var, …), &var->dev for devm_reset_control_get).
- Control-flow boundaries and dominance of guards.

4. Dataflow / Taint Considerations
- Track the return value from of_find_device_by_node() to the assigned variable.
- Propagate through aliases and direct uses to dereference sites and function calls that imply dereference.
- Model guard conditions: a NULL-check that returns or prevents use should sanitize the flow; IS_ERR checks do not sanitize NULL for this API.
- Path sensitivity: consider feasible paths where execution proceeds past the IS_ERR check to a dereference without a prior NULL guard.

5. Validation & Test Cases
- Positive: Code doing ece_pdev = of_find_device_by_node(node); if (IS_ERR(ece_pdev)) return PTR_ERR(ece_pdev); … devm_platform_ioremap_resource(ece_pdev, 0); Expect a finding indicating misuse and potential NULL deref.
- Negative: Code doing ece_pdev = of_find_device_by_node(node); if (!ece_pdev) return -ENODEV; … devm_platform_ioremap_resource(ece_pdev, 0); Expect no finding.
- Test harness notes: Run on drivers/media/platform/nuvoton/npcm-video.c; pre-patch should be flagged, patched code should be clean (based on [PATCH_DIFF]).

6. Estimated Effort & Priority
High: Kernel initialization path stability issues and the pattern is critical per [ROOTCAUSE_ANALYSIS]; limited scope makes implementation tractable.

7. Likely False-Positive Sources & Mitigations
- Wrapper functions or alternate APIs that convert NULL to ERR_PTR: mitigate by limiting to of_find_device_by_node().
- Complex reassignment of the variable before dereference: mitigate by tracking reassignments and only considering paths using the original returned value.
- Defensive code that includes both IS_ERR and NULL checks: mitigate by requiring absence of a dominating NULL guard before use.

8. Limitations & Assumptions
- Assumes of_find_device_by_node() returns NULL on failure; generalized lists of similar APIs are not provided, so detection is scoped to this function.
- Assumes calls like devm_platform_ioremap_resource and devm_reset_control_get dereference the platform_device pointer, based on [ROOTCAUSE_ANALYSIS]; the checker infers hazard from member accesses and typical usage patterns.
- Does not model interprocedural flows beyond the current function due to limited context in provided materials.