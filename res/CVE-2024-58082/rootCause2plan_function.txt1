1. Plan Summary
Detect incorrect error handling where of_find_device_by_node() failures (NULL) are checked using IS_ERR/PTR_ERR, allowing a NULL platform_device pointer to be dereferenced.

2. Detection Steps
1) Step 1: Identify functions that call of_find_device_by_node(...) and assign its result to a variable (e.g., a struct platform_device*).
   - Signal: An assignment whose RHS is a call to of_find_device_by_node.

2) Step 2: Immediately after that assignment, look for an error check using IS_ERR(var) on the assigned variable.
   - Signal: A condition if (IS_ERR(var)) guarding an error path.

3) Step 3: Within the IS_ERR(var) branch, check whether the code returns or propagates PTR_ERR(var).
   - Signal: Return statement or error propagation using PTR_ERR on the same variable.

4) Step 4: Confirm there is no explicit NULL check for the variable after the of_find_device_by_node call and before its first use (e.g., no if (!var) or equivalent guarding return).
   - Signal: Absence of a null-check condition on the variable along the forward control flow.

5) Step 5: Locate subsequent dereferences or uses of the variable that require it to be non-NULL.
   - Signals: Field access (var->...), address-of a field (&var->dev), or passing the variable to APIs that expect a valid device (e.g., devm_platform_ioremap_resource(var, ...), devm_reset_control_get(&var->dev, ...)).

6) Step 6: Ensure the dereference site is reachable on a path where the IS_ERR(var) branch is not taken (i.e., the normal path continues without a NULL guard).
   - Signal: Control-flow path from assignment through the IS_ERR check’s else/fallthrough to the dereference.

7) Step 7: Report a finding when all conditions hold: of_find_device_by_node result checked with IS_ERR/PTR_ERR, no intervening NULL check, and a subsequent dereference/use of the potentially NULL pointer.
   - Signal: Aggregate match of steps 1–6 within the same function.

8) Step 8: Optionally raise confidence when the IS_ERR branch logs an error (e.g., dev_err(...)) and returns based on PTR_ERR(var), matching the pre-patch pattern.
   - Signal: Logging followed by PTR_ERR-based return in the IS_ERR branch.

3. Limitations & Assumptions
- Assumes of_find_device_by_node() returns NULL on failure (as stated); the checker does not generalize to other APIs without similar documented behavior.
- Path feasibility may be conservative; some flagged paths might be safe due to external invariants not visible to static analysis.
- The checker focuses on dereference patterns conceptually (field access or passing to APIs); it does not verify the exact semantics of every callee beyond clear pointer dereference indicators.