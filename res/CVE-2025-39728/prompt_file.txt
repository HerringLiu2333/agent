1. CVE Identifier
CVE-2025-39728

2. Vulnerability Type
Improper initialization/order of flexible-array bounds metadata leading to sanitizer-detected array out-of-bounds and kernel panic (Denial of Service under UBSAN).

3. Root Cause Summary
In samsung_clk_init(), the code accessed and initialized entries of the flexible array ctx->clk_data.hws[] before setting the associated count field ctx->clk_data.num. Because struct clk_hw_onecell_data’s hws[] is checked against num (via __counted_by/UBSAN), num being 0 during the loop caused UBSAN_ARRAY_BOUNDS to flag every access as out-of-bounds and panic. The patch fixes the initialization order by assigning ctx->clk_data.num = nr_clks before any hws[] dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Samsung Common Clock Framework (clk: samsung), specifically samsung_clk_init().

2) Pre-Patch Flaw:
samsung_clk_init() iterated over ctx->clk_data.hws[i] prior to setting ctx->clk_data.num. Pre-patch code shows:
- for (i = 0; i < nr_clks; ++i) ctx->clk_data.hws[i] = ERR_PTR(-ENOENT);
- ctx->clk_data.num = nr_clks; (set after the loop)
With UBSAN bounds checking tied to num, hws[] was treated as length 0 during the loop.

3) Trigger Condition:
- Kernel built with UBSAN_ARRAY_BOUNDS=y.
- samsung_clk_init() invoked with nr_clks > 0 (normal during Exynos/Samsung CMU registration).
- Any access to hws[i] before num is set triggers UBSAN. The provided call trace shows the fault during platform clock init: samsung_clk_init -> samsung_cmu_register_one -> exynos_arm64_register_cmu.

4) Impact Mechanism:
UBSAN reports array index out of bounds on hws[] and panics the kernel, causing a boot-time denial of service on affected configurations. Without UBSAN, memory corruption does not occur because the allocation size is correct; the issue is the sanitizer’s bounds check tied to an uninitialized count.

5. Patch Analysis
1) Fix Approach:
Correct the initialization order to establish valid bounds metadata before any array access. Specifically, set ctx->clk_data.num = nr_clks before writing to ctx->clk_data.hws[].

2) Key Code Changes:
- Moved assignment:
  - From after the loop:
    ctx->clk_data.num = nr_clks;
  - To before the loop:
    ctx->clk_data.num = nr_clks;
- The loop that initializes hws[i] = ERR_PTR(-ENOENT) remains unchanged, but now executes with a valid num, satisfying UBSAN’s array bounds instrumentation.

3) Locking/Concurrency Impact:
None. The change is limited to initialization order within samsung_clk_init(); no locks were added/removed and no ordering of concurrent operations changed.

6. Broader Kernel Security Implications
This highlights a recurring pitfall with flexible arrays annotated by __counted_by: the count field must be set before any access to the array to satisfy runtime bounds instrumentation (UBSAN/KASAN). Similar initialization-order bugs elsewhere can cause sanitizer-induced panics and system unavailability in debug/sanitized builds. Ensuring correct ordering when initializing flexible-array containers reduces false-positive OOB reports and avoids DoS conditions in development or hardened configurations.