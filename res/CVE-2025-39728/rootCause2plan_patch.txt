1. Plan Summary
Detect cases where code indexes a struct’s array/flexible-array member before initializing the corresponding “count/num” field that defines its bounds, mirroring the samsung_clk_init() initialization-order bug.

2. Detection Steps
1) Step 1: Objective: Find candidate functions performing struct initialization where a member array is indexed. Signals: In a single function, identify member-indexing expressions like obj->A[i] (or obj.A[i]) on a common receiver object (e.g., ctx->clk_data.hws[i]) [based on PATCH_DIFF/ROOTCAUSE_ANALYSIS]. FP mitigation: Require at least one write to the array (store) rather than only reads.

2) Step 2: Objective: Detect a loop that controls the indexing. Signals: For- or while-loops where the loop variable i is used as the array index and the loop condition is i < N (or equivalent), with N being a single expression (e.g., nr_clks) [based on ROOTCAUSE_ANALYSIS describing for (i = 0; i < nr_clks; ++i) hws[i] = …]. FP mitigation: Ensure the index is syntactically the same variable that appears in the loop condition.

3) Step 3: Objective: Identify a later assignment to a scalar “bound” field of the same object. Signals: An assignment obj->B = N (or obj.B = N) occurring after the loop/indexing, where the receiver object is the same as for the array, and the RHS is the same N found in the loop bound (e.g., ctx->clk_data.num = nr_clks) [based on PATCH_DIFF moving num = nr_clks above the loop]. FP mitigation: Require same receiver base (same object path up to the field) and syntactic equality between the RHS and the loop bound.

4) Step 4: Objective: Establish incorrect temporal ordering. Signals: Program order shows that all array index writes occur before the first assignment to the “bound” field; dominance check that no prior assignment to the bound field reaches the loop header [based on ROOTCAUSE_ANALYSIS “indexed … before initializing … num”]. FP mitigation: If there exists any dominating earlier assignment to the bound field on all paths, suppress.

5) Step 5: Objective: Prioritize flexible-array-like members. Signals: The array member is declared as a flexible array or unsized/zero-length array, or is a pointer member used with indexing (typical kernel flexible-array idiom, e.g., hws[]) [based on ROOTCAUSE_ANALYSIS “flexible array member hws[]”]. FP mitigation: If the member is a fixed-size array with compile-time constant bounds and the index is provably within bounds, suppress.

6) Step 6: Objective: Strengthen evidence that the bound field is intended as the size. Signals: The bound field name suggests a size/count (e.g., “num”), or is referenced by sanitizer/bounds logic patterns; at minimum, the same N value flows to both the loop upper bound and the bound field assignment [based on PATCH_DIFF/ROOTCAUSE_ANALYSIS “clk_data.num” set to “nr_clks”]. FP mitigation: If the RHS assigned to the bound field is unrelated to the loop bound (no syntactic or dataflow equivalence), downgrade severity or suppress.

7) Step 7: Objective: Capture freshly allocated/initialized object contexts to increase confidence. Signals: The object (e.g., ctx) is allocated or zero-initialized in the same function before use (e.g., followed by a null-check “if (!ctx)” as in the snippet) [based on PATCH_DIFF/patch description mentioning allocation]. FP mitigation: If the object may have been previously initialized elsewhere (not freshly allocated), lower confidence.

8) Step 8: Objective: Exclude cases already safe by earlier bound initialization. Signals: Any assignment to the bound field appearing before the first array index access (even with a different RHS N’) implies correct order [based on ROOTCAUSE_ANALYSIS fix being to assign before loop]. FP mitigation: Require absence of any earlier write to the bound field on the relevant path.

9) Step 9: Objective: Identify multiple array accesses before bound initialization. Signals: If multiple array index operations on the same member occur prior to any bound assignment, aggregate them into one report to avoid noise. FP mitigation: Report once per function/object pair.

10) Step 10: Objective: Differentiate non-array member accesses. Signals: Exclude pointer dereferences not involving an index (e.g., obj->p = …) and scalar fields; only flag member[index] patterns for arrays or pointer-to-element. FP mitigation: This avoids conflating unrelated initialization ordering.

3. Target Elements
- Functions that initialize or set up provider/context structures.
- Member array or pointer indexing expressions (obj->field[index]).
- For-/while-loops controlling such indexing.
- Assignments to scalar “bound” fields on the same object (e.g., obj->num = …).
- Allocation/initialization sites for the object (e.g., new allocation followed by null-check).
- Control-flow/dominance to compare ordering between array accesses and bound-field assignment.

4. Dataflow / Taint Considerations
- Track the expression N used as the loop upper bound and confirm it flows (syntactically or via simple aliases) to the RHS assigned to the bound field later.
- Track the receiver object path (e.g., ctx->clk_data) to ensure the array field and bound field are on the same base object.
- Simple equivalence of loop bound and assignment RHS is sufficient; deep interprocedural taint is not necessary here.

5. Validation & Test Cases
- Positive: Function with for (i = 0; i < nr; ++i) ctx->data.hws[i] = …; later ctx->data.num = nr; Expect a finding (matches PATCH_DIFF pre-fix and ROOTCAUSE_ANALYSIS).
- Positive: ctx allocated in function; hws[i] writes precede any write to num; num assigned to same nr afterward; Expect a finding (amplifies confidence as in PATCH_DESCRIPTION).
- Negative: ctx->data.num = nr; for (i = 0; i < nr; ++i) ctx->data.hws[i] = …; Expect no finding (matches the fix in PATCH_DIFF).
- Negative: Array member is fixed-size and index proven within bounds; Expect no finding.
- Test harness notes: Include variations where the bound assignment appears in conditional branches; validate dominance analysis ensures only paths with “index-before-bound” are flagged.

6. Estimated Effort & Priority
Medium: Requires intra-procedural control/dataflow, member-receiver unification, and loop-bound equivalence checks.

7. Likely False-Positive Sources & Mitigations
- Bound field semantically unrelated to the array: mitigate by requiring same RHS as loop bound and same receiver object.
- Bound field already initialized by a prior call: mitigate by boosting confidence only when object is freshly allocated in the function.
- Arrays not used with sanitizer/bounds checks: mitigate by prioritizing fields named like “num” and flexible-array-like members.

8. Limitations & Assumptions
- The analysis assumes a relation between the array member and the “num” field inferred by shared RHS (N) and common receiver, as exemplified by clk_data.hws[] and clk_data.num [based on PATCH_DIFF/ROOTCAUSE_ANALYSIS].
- It cannot prove UBSAN configuration or runtime bounds semantics; it flags ordering patterns that would trigger sanitizer issues as described [based on PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS].
- Flexible-array detection may be approximate when only pointer members are used; exact declaration forms may not always be known from local context.