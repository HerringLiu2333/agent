1. Plan Summary
Detect cases where a flexible-array field is accessed before its associated count field is initialized, causing sanitizer-triggered array-bounds violations (e.g., hws[] used before num is set in samsung_clk_init).

2. Detection Steps
1) Step 1: Identify candidate objects allocated with a flexible-array size parameter. Signals: allocation using a sized helper (e.g., struct_size(ctx, <container>.<arrayField>, sizeVar)) or equivalent, capturing the object (ctx), the array field path (e.g., clk_data.hws), and the size variable (e.g., nr_clks).

2) Step 2: Locate the associated count field assignment within the same function. Signals: an assignment to a scalar field on the same container as the array (e.g., ctx->clk_data.num = sizeVar or an expression derived from sizeVar).

3) Step 3: Find any element access to the flexible array before the count field is set. Signals: reads/writes like ctx->clk_data.hws[index], including in loops and standalone statements, and verify control-flow order precedes the first assignment to the count field from Step 2.

4) Step 4: Strengthen by recognizing initialization loops tied to the size variable. Signals: a loop with a bound referencing the size variable (e.g., for (i = 0; i < sizeVar; i++)) where the loop body writes to ctx->clk_data.hws[i] (e.g., setting ERR_PTR(-ENOENT)).

5) Step 5: Ensure object identity and container match. Signals: the array access and the count-field assignment must reference the same object instance (ctx) and the same container path (clk_data).

6) Step 6: Exclude safe cases where the count field is set early. Signals: if any assignment to the count field for the same object/container occurs on all paths before any array access, do not flag; consider control-flow (e.g., early returns or panics) to ensure the array access is reachable without a prior count assignment.

7) Step 7: Report a violation when array accesses (Step 3/4) occur before the first count-field assignment (Step 2). Signals: highlight the earliest array access location and the later count-field assignment, and include the associated size variable to indicate intended bounds.

3. Limitations & Assumptions
- The checker assumes the count field resides in the same container as the flexible array (e.g., clk_data.hws with clk_data.num); other naming patterns or locations may be missed.
- The presence of __counted_by instrumentation is inferred from behavior described, not from explicit annotations in code; the checker uses structural heuristics rather than annotations.
- It assumes the size variable used in allocation/loop is the intended bound for the count field; if a different variable initializes the count, correlations may be imperfect.
- Interprocedural initialization of the count field (e.g., via helper functions or constructors) is not handled; analysis is limited to the current functionâ€™s control flow.