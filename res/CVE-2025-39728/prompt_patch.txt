1. CVE Identifier
CVE-2025-39728

2. Vulnerability Type
Out-of-bounds array access due to improper initialization order (flexible array bounds not set before indexing), leading to UBSAN-triggered panic.

3. Root Cause Summary
In samsung_clk_init(), the driver indexed the flexible array member ctx->clk_data.hws[i] before initializing the corresponding bound field ctx->clk_data.num. With UBSAN_ARRAY_BOUNDS enabled, sanitization relies on clk_data.num to validate hws[] indexing; since num was set only after the loop, accesses appeared out-of-bounds and triggered a panic. The patch fixes the initialization order by assigning ctx->clk_data.num = nr_clks before the loop that writes to hws[].

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Common Clock Framework (CCF), Samsung clock provider (clk: samsung), function samsung_clk_init().

2) Pre-Patch Flaw:
The code executed:
- for (i = 0; i < nr_clks; ++i) ctx->clk_data.hws[i] = ERR_PTR(-ENOENT);
while ctx->clk_data.num was assigned only afterward. This left the runtime “num” bound unset during first access to the flexible array hws[], conflicting with UBSAN’s bounds expectations.

3) Trigger Condition:
Building the kernel with UBSAN_ARRAY_BOUNDS=y and invoking samsung_clk_init() for a Samsung CMU (e.g., via samsung_cmu_register_one → exynos_arm64_register_cmu) causes the loop to dereference hws[i] before num is initialized.

4) Impact Mechanism:
UBSAN detects an array index out-of-bounds on ctx->clk_data.hws[i] because clk_data.num is zero/uninitialized at the time of access, resulting in a kernel panic during early clock initialization.

5. Patch Analysis
1) Fix Approach:
Reorder initialization so that clk_data.num is set to nr_clks before any indexed access to clk_data.hws[], ensuring sanitizer-visible bounds are established prior to use.

2) Key Code Changes:
- Moved “ctx->clk_data.num = nr_clks;” above the for-loop that initializes hws[] entries.
- Removed the later, now redundant, assignment after setting dev/reg_base.
This change is confined to samsung_clk_init().

3) Locking/Concurrency Impact:
None. The change is purely an initialization order fix with no alterations to locking, RCU, or concurrency; spin_lock_init() remains unchanged and is unrelated to the bug.

6. Broader Kernel Security Implications
Ensuring fields that define flexible array bounds (e.g., “num”) are initialized before any indexing prevents sanitizer-triggered crashes and enforces correct memory safety semantics. This pattern is common in structures with flexible array members; similar ordering issues elsewhere could lead to latent crashes under sanitizers or hard-to-debug memory safety violations. The fix improves robustness during early driver initialization and supports safer runtime verification by sanitizers.