1. CVE Identifier
CVE-2025-38485

2. Vulnerability Type
Race condition leading to use-after-free/NULL pointer dereference in IRQ-threaded FIFO flush

3. Root Cause Summary
fxls8962af_fifo_flush() iterates active channels via iio_for_each_active_channel(indio_dev, bit), which dereferences indio_dev->active_scan_mask. The driver’s buffer shutdown path (fxls8962af_buffer_predisable) disables buffered mode without synchronizing with an in-flight threaded interrupt that may be running fxls8962af_interrupt → fxls8962af_fifo_flush. As a result, indio_dev may exit buffer mode and tear down active_scan_mask while the IRQ-thread is still flushing, leading to dereferencing a freed/NULL mask. The crash trace shows _find_first_bit_le from fxls8962af_fifo_flush, consistent with iio_for_each_active_channel operating on an invalid mask. The patch adds synchronize_irq(data->irq) during buffer shutdown to ensure no interrupt handler is running when buffered mode is disabled.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) accelerometer driver for NXP FXLS8962AF/FXLS8964AF (drivers using kfifo buffer and threaded IRQ handling)

2) Pre-Patch Flaw:
fxls8962af_buffer_predisable() disables the device’s buffer interrupt and FIFO mode while failing to synchronize with the driver’s threaded IRQ handler. Specifically, it performs regmap_clear_bits(FXLS8962AF_INT_EN, BUF_EN) followed by __fxls8962af_fifo_set_mode(data, false) without waiting for fxls8962af_interrupt/fxls8962af_fifo_flush to complete.

3) Trigger Condition:
A buffered-mode disable (via buffer teardown) races with an in-flight interrupt that triggers a FIFO flush. If the interrupt fires or is executing while buffered mode is being disabled, indio_dev->active_scan_mask can be freed/NULLed while fxls8962af_fifo_flush still iterates it.

4) Impact Mechanism:
fxls8962af_fifo_flush uses iio_for_each_active_channel, which relies on active_scan_mask and calls find_first_bit/_find_first_bit_le; when the mask is NULL or freed, it causes a kernel NULL pointer dereference/use-after-free, leading to an oops. Patch description and the stack trace confirm the fault in fxls8962af_fifo_flush and find_first_bit on an invalid mask.

5. Patch Analysis
1) Fix Approach:
Introduce explicit interrupt synchronization during buffer shutdown to eliminate the race. By calling synchronize_irq(data->irq) before disabling FIFO mode, the driver ensures any currently running interrupt handler (including the threaded IRQ path) completes before buffer teardown proceeds.

2) Key Code Changes:
In fxls8962af_buffer_predisable():
- After disabling the buffer interrupt (regmap_clear_bits INT_EN BUF_EN), add:
  synchronize_irq(data->irq);
- Then proceed to __fxls8962af_fifo_set_mode(data, false).
This maps directly to preventing concurrent execution of fxls8962af_fifo_flush while buffer mode is being disabled.

3) Locking/Concurrency Impact:
The change introduces IRQ-level serialization, closing the race window between the IRQ-threaded handler (fxls8962af_interrupt → fxls8962af_fifo_flush) and buffer teardown. No spinlock/mutex alterations were made; instead, synchronize_irq ensures no handler for data->irq is active, and with IRQF_ONESHOT threading, the line remains masked until the thread completes, making the shutdown safe with respect to active_scan_mask usage.

6. Broader Kernel Security Implications
Drivers that interact with IIO buffered mode and use threaded IRQ handlers must synchronize interrupts when tearing down buffer-related state to avoid UAF/NULL deref on core-managed structures like active_scan_mask. Failure to do so can lead to kernel crashes and stability issues, and in some scenarios could be a vector for memory corruption if freed memory is accessed. The pattern of adding synchronize_irq during mode transitions is applicable across similar sensor drivers and helps enforce safe ordering between ISR paths and buffer teardown.