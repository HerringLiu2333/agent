1. CVE Identifier
CVE-2025-38485

2. Vulnerability Type
Race condition leading to use-after-free/NULL dereference in interrupt handler

3. Root Cause Summary
The driver exited buffer mode without synchronizing with the device IRQ thread, allowing fxls8962af_interrupt() to run fxls8962af_fifo_flush() concurrently while indio_dev->active_scan_mask was being torn down. fxls8962af_fifo_flush() iterates channels via iio_for_each_active_channel(), which dereferences indio_dev->active_scan_mask and calls _find_first_bit_le. Without synchronization, active_scan_mask could become NULL or invalid (freed) during buffer teardown, causing a NULL pointer dereference/use-after-free. The missing step was to wait for any in-flight IRQ handlers to complete before disabling FIFO mode and changing buffer state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) accelerometer driver: fxls8962af (NXP FXLS8962AF)

2) Pre-Patch Flaw:
fxls8962af_buffer_predisable() disabled buffer interrupts and FIFO mode without ensuring no IRQ handler was currently executing (no synchronize_irq). The interrupt path fxls8962af_interrupt() could call fxls8962af_fifo_flush() which uses indio_dev->active_scan_mask, racing with buffer teardown that invalidates this mask.

3) Trigger Condition:
Disabling buffer mode while an IRQ is pending or the irq thread is running, so fxls8962af_fifo_flush() executes after indio_dev->active_scan_mask has been cleared/freed by the buffer disable path.

4) Impact Mechanism:
iio_for_each_active_channel() dereferences indio_dev->active_scan_mask inside fxls8962af_fifo_flush(); with the race, this pointer becomes NULL/invalid, leading to a NULL pointer dereference in _find_first_bit_le and potentially use-after-free, crashing the kernel (as reflected in the stack trace).

5. Patch Analysis
1) Fix Approach:
Serialize buffer teardown with the IRQ handler by calling synchronize_irq(data->irq) during predisable, ensuring no interrupt is currently running before disabling FIFO mode and finalizing buffer exit.

2) Key Code Changes:
Inserted synchronize_irq(data->irq) in fxls8962af_buffer_predisable() after clearing the device’s buffer interrupt enable bit and before calling __fxls8962af_fifo_set_mode(data, false):
- Before: cleared FXLS8962AF_INT_EN_BUF_EN and immediately set FIFO mode false.
- After: cleared FXLS8962AF_INT_EN_BUF_EN, then synchronize_irq(data->irq), then set FIFO mode false.

3) Locking/Concurrency Impact:
Adding synchronize_irq enforces ordering and mutual exclusion between the IRQ thread (fxls8962af_interrupt → fxls8962af_fifo_flush) and the buffer disable path. It closes the race window where the interrupt could access active_scan_mask while buffer mode is being torn down, preventing UAF/NULL deref.

6. Broader Kernel Security Implications
Driver transitions that affect buffer state and shared structures must synchronize with interrupt handlers to prevent lifetime violations, UAF, and kernel crashes. This fix exemplifies the need to pair interrupt disablement with synchronize_irq (or equivalent) during mode changes. Similar patterns across IIO and other subsystems should be audited to ensure object lifetimes remain valid under concurrent IRQ/thread execution.