1. Plan Summary
Detect IIO drivers that tear down buffered mode while a threaded IRQ handler can concurrently run a FIFO flush that iterates active channels, without synchronizing interrupts, leading to a race and potential use-after-free/NULL dereference.

2. Detection Steps
1) Step 1: Identify drivers that register a threaded IRQ handler and a kfifo buffer with a .predisable callback (signals: devm_request_threaded_irq called with a non-NULL thread function; devm_iio_kfifo_buffer_setup using buffer setup ops containing a preddisable function) — reduces FPs by focusing on IIO buffered drivers with threaded IRQ paths as in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS].
2) Step 2: Establish a shared device context between the IRQ thread function and the buffer predDisable using iio_dev parameters and iio_priv to the private data struct (signals: functions taking struct iio_dev*, calling iio_priv(indio_dev), and accessing the same data fields) — reduces FPs by requiring both paths operate on the same device instance, per [FILE_CONTENT].
3) Step 3: Within or reachable from the IRQ thread function, detect a FIFO flush routine that iterates active channels (signals: call to fxls8962af_fifo_flush or equivalent containing iio_for_each_active_channel(indio_dev, bit)) — maps to active_scan_mask dereference per [ROOTCAUSE_ANALYSIS] and [FILE_CONTENT]; reduces FPs by requiring explicit use of iio_for_each_active_channel.
4) Step 4: Confirm the flush routine demuxes and pushes samples to IIO buffers (signals: iio_push_to_buffers_with_ts invoked after iio_for_each_active_channel) — ties the code to buffered-mode usage as in [FILE_CONTENT]; reduces FPs by ensuring the flush is part of buffer processing.
5) Step 5: Verify the IRQ thread path invokes the flush routine when a buffer interrupt is reported (signals: in IRQ thread function, reading FXLS8962AF_INT_STATUS and branching on FXLS8962AF_INT_STATUS_SRC_BUF to call the flush) — establishes the interrupt-driven timing described in [ROOTCAUSE_ANALYSIS]; reduces FPs by requiring the exact interrupt-to-flush linkage.
6) Step 6: In the buffer predDisable function, detect teardown of buffered mode (signals: clearing buffer interrupt enable and/or disabling FIFO mode, e.g., regmap_clear_bits(..., FXLS8962AF_INT_EN_BUF_EN) and __fxls8962af_fifo_set_mode(..., false)) — maps to the race window creation per [ROOTCAUSE_ANALYSIS]; reduces FPs by requiring concrete teardown operations.
7) Step 7: Confirm the private data struct holds the IRQ number used in request_threaded_irq (signals: data->irq field set from the probe argument and passed to devm_request_threaded_irq) — provides a synchronization target per [FILE_CONTENT]; reduces FPs by asserting the IRQ identity.
8) Step 8: Check for absence of synchronize_irq with the device IRQ in the buffer predDisable before or around buffer teardown (signals: no call to synchronize_irq(data->irq) preceding disabling interrupts/FIFO mode) — directly maps to the fix in [PATCH_DIFF] and root cause in [PATCH_DESCRIPTION]; reduces FPs by requiring the missing call.
9) Step 9: Optionally detect IRQF_ONESHOT/threaded behavior to heighten concurrency risk (signals: IRQF_ONESHOT flag and non-NULL thread function in request_threaded_irq) — supports the threaded handler scenario in [FILE_CONTENT]; reduces FPs by avoiding non-threaded handlers.
10) Step 10: Report findings only when steps 3–8 all match, indicating an IRQ-threaded flush that depends on active_scan_mask can run concurrently with buffer teardown lacking synchronize_irq — aligns with the crash trace and fix rationale in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]; reduces FPs by requiring the full pattern.

3. Target Elements
- Functions: IRQ thread function, FIFO flush function, buffer predDisable callback, probe/setup functions.
- Call sites: devm_request_threaded_irq, devm_iio_kfifo_buffer_setup, iio_for_each_active_channel, iio_push_to_buffers_with_ts, regmap_clear_bits/regmap_update_bits for buffer interrupt and mode.
- Fields/variables: device private data struct pointer from iio_priv, data->irq, indio_dev->active_scan_mask (accessed indirectly via iio_for_each_active_channel).
- Condition checks: INT_STATUS handling gating calls to fifo_flush.
- Lock/synchronization boundaries: presence/absence of synchronize_irq around buffer teardown.

4. Dataflow / Taint Considerations
- Track the device context from struct iio_dev* to the private data via iio_priv, and link functions operating on the same data instance.
- Propagate the IRQ number from probe (irq argument) into data->irq and into request_threaded_irq to confirm identity.
- Follow call flow from the IRQ thread to the FIFO flush function using call graph edges.

5. Validation & Test Cases
- Positive: Pre-patch fxls8962af_buffer_predisable that clears FXLS8962AF_INT_EN_BUF_EN and disables FIFO mode, while fxls8962af_interrupt calls fxls8962af_fifo_flush using iio_for_each_active_channel; no synchronize_irq(data->irq) present — expect a finding (based on [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]).
- Negative: Patched predDisable that calls synchronize_irq(data->irq) before disabling FIFO mode — expect no finding (based on [PATCH_DIFF]).
- Negative: A driver with threaded IRQ that does not use iio_for_each_active_channel in its flush, or without kfifo buffer predDisable teardown — expect no finding.
- Test harness notes: Run on the pre-patch file to flag, and on the patched diff to ensure suppression; include a synthetic driver variant without IRQ threading to confirm non-flag.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Drivers using alternative safe synchronization (e.g., disable_irq plus explicit thread quiescence) not detected as such; mitigate by looking for any synchronization calls before teardown, if identifiable.
- Non-IIO contexts using iio_for_each_active_channel-like patterns without buffer teardown; mitigate by requiring presence of iio_buffer_setup_ops predDisable and request_threaded_irq linkage.
- Teardown functions that are not actually used as predDisable ops; mitigate by verifying they are referenced in devm_iio_kfifo_buffer_setup.

8. Limitations & Assumptions
- Assumes iio_for_each_active_channel implies dereferencing active_scan_mask; derived from [ROOTCAUSE_ANALYSIS], but the exact internal implementation isn’t shown.
- Assumes synchronize_irq is the required synchronization primitive; based on [PATCH_DIFF] and [PATCH_DESCRIPTION], other safe patterns may exist but are not modeled.
- Does not prove that active_scan_mask is freed/NULLed at teardown; relies on race reasoning in [ROOTCAUSE_ANALYSIS].
- Device-specific register operations are used as signals for buffer teardown; the checker may need adaptation for other drivers with different register names.