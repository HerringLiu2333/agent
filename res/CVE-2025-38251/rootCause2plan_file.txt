1. Plan Summary
Detect functions that accept a struct sk_buff* and dereference it before validating it against NULL, especially when a later NULL-handling branch exists, indicating incorrect check ordering that can cause a NULL dereference.

2. Detection Steps
1) Step 1: Objective: find candidate functions that can receive NULL sk_buff pointers. Signals: functions with a parameter of type struct sk_buff* and an explicit in-function check like if (!skb) { ... } (seen in clip_push in [FILE_CONTENT]). FP mitigation: restrict to functions that contain an if (!skb) branch, evidencing NULL is a valid input path (per [ROOTCAUSE_ANALYSIS]).

2) Step 2: Objective: identify pre-guard dereferences of skb. Signals: reads of skb fields (e.g., skb->truesize) or passing such fields to functions before reaching the if (!skb) branch; e.g., atm_return(vcc, skb->truesize) placed before the NULL check in [PATCH_DIFF]/pre-patch logic described in [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure the dereference occurs on paths not dominated by an earlier if (skb) or equivalent non-NULL assertion.

3) Step 3: Objective: detect early-return branches triggered by conditions unrelated to skb that still dereference skb. Signals: top-of-function conditionals like if (!clip_devs) { ... } containing skb->... accesses and returning, positioned before the if (!skb) block (pre-patch per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: confirm the condition controlling the branch does not reference skb, making the dereference independent of skb’s NULLness.

4) Step 4: Objective: highlight ordering bugs where a later branch handles NULL skb but earlier paths already dereference it. Signals: control-flow structure in which any path reaching a dereference (e.g., skb->truesize) can occur prior to the if (!skb) handler; use dominance/order analysis within the function (clip_push example in [FILE_CONTENT]). FP mitigation: exclude cases where the function has an early guard if (!skb) that dominates all uses of skb.

5) Step 5: Objective: specifically flag uses of atm_return(vcc, skb->truesize) prior to NULL validation. Signals: calls where the second argument syntactically references skb->truesize, matching the exact problematic dereference cited in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]. FP mitigation: only report when such calls precede any if (!skb) guard and occur in branches that can execute regardless of skb’s value.

6) Step 6: Objective: detect dereferences in cleanup/early-exit code blocks that free skb and return without first ensuring non-NULL. Signals: patterns like kfree_skb(skb) coupled with a field access (e.g., skb->truesize) before the function's NULL guard; this mirrors the pre-patch logic in [PATCH_DIFF]. FP mitigation: verify the block is reachable without an earlier check guaranteeing skb is non-NULL.

7) Step 7: Objective: strengthen confidence by recognizing callback contexts known to pass NULL. Signals: functions assigned to vcc->push or vcc->pop (clip_push set in clip_mkip in [FILE_CONTENT]) and containing an if (!skb) path, aligning with the teardown behavior described in [PATCH_DESCRIPTION]. FP mitigation: require both callback assignment and presence of if (!skb) to avoid flagging unrelated functions.

8) Step 8: Objective: detect dereferences occurring “just before” NULL-handling accounting calls. Signals: presence of accounting or return calls that use skb->truesize before the NULL guard, then a later reorder placing atm_return after validating skb (as fixed in [PATCH_DIFF]). FP mitigation: ensure the checker compares call order relative to the if (!skb) block to avoid misreporting post-fix patterns.

9) Step 9: Objective: confirm the existence of a global-state branch that should not precede NULL validation. Signals: checks against global/device state like clip_devs (static global in [FILE_CONTENT]) positioned ahead of NULL handling and containing dereferences; this matches the root cause in [ROOTCAUSE_ANALYSIS]. FP mitigation: restrict to globals or fields not derived from skb to ensure the branch’s gating condition does not imply non-NULL.

10) Step 10: Objective: avoid duplicates and noise. Signals: group multiple pre-guard dereferences within the same function into a single report pointing to the earliest dereference site. FP mitigation: suppress secondary reports in the same function once one ordering violation is confirmed.

3. Target Elements
- Function definitions that take a struct sk_buff* parameter (e.g., clip_push).
- Intra-function condition checks (if (!skb), if (!clip_devs)).
- Member accesses of skb (e.g., skb->truesize, skb->dev, skb->len).
- Function calls that use skb fields (e.g., atm_return(vcc, skb->truesize), kfree_skb(skb)).
- Callback assignments indicating push/pop handlers (e.g., vcc->push = clip_push).
- Early-return code blocks and their control-flow position relative to NULL checks.

4. Dataflow / Taint Considerations
- Track control-flow dominance: whether an if (!skb) check dominates all dereferences of skb within the function.
- Identify dereference flows of skb (member access, macro expansions leading to deref) that occur before a non-NULL guard.
- Treat conditions independent of skb (e.g., global clip_devs) as not proving non-NULL and thus risky when combined with dereferences.

5. Validation & Test Cases
- Positive: A function with signature (struct atm_vcc*, struct sk_buff*) that begins with if (!global) { atm_return(vcc, skb->truesize); kfree_skb(skb); return; } followed later by if (!skb) { ... } — should be flagged (pre-patch clip_push per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: The fixed version where the function first checks if (!skb) and only then calls atm_return(vcc, skb->truesize) and handles !clip_devs without dereferencing skb when NULL — should not be flagged (post-patch clip_push per [PATCH_DIFF]).
- Test harness notes: Run on net/atm/clip.c as provided to assert one finding for the pre-patch pattern and no findings for the patched pattern; include synthetic functions without if (!skb) to confirm they are not flagged.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Functions that syntactically check !skb later but have an earlier dominating if (skb) guard: mitigate via dominance analysis.
- Macros or helper functions that implicitly check skb before deref: limit to direct member access or ensure inlining/expansion analysis confirms no prior guard.
- Contexts where NULL is impossible by contract: mitigate by requiring presence of an explicit if (!skb) branch as evidence of NULL-accepting API.

8. Limitations & Assumptions
- The checker infers potential NULL calls from in-function if (!skb) presence; it cannot prove callers pass NULL beyond the statement in [PATCH_DESCRIPTION].
- Macro-induced dereferences (e.g., ATM_SKB(skb)) may be harder to resolve precisely; plan focuses on clear member accesses like skb->truesize shown in [PATCH_DIFF]/[FILE_CONTENT].
- The approach assumes that global-state checks (e.g., !clip_devs) do not imply skb non-NULL, as evidenced by the bug described in [ROOTCAUSE_ANALYSIS].