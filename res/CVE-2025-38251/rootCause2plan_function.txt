1. Plan Summary
Detect misordered NULL-checks where a pointer parameter is dereferenced on some path before it is validated, while the function contains a later explicit NULL-handling branch, as in the pre-patch clip_push() bug causing a NULL dereference when skb is NULL.

2. Detection Steps
1) Step 1: Objective—identify candidate pointers that are intended to be nullable. Signals—function parameters or local variables that are later tested with an explicit NULL-check (e.g., if (!p) …). FP mitigation—only consider pointers with at least one explicit NULL-check within the same function to indicate developer intent that NULL is possible (based on ROOTCAUSE_ANALYSIS 3 and 4).
2) Step 2: Objective—find unsafe dereferences before validation. Signals—any member/field access (p->field), array indexing (p[i]), pointer dereference (*p), or passing p to APIs that read fields immediately (conceptually like accessing skb->truesize) that is reachable from function entry without first passing through a condition ensuring p != NULL. FP mitigation—require control-flow reachability from entry to the dereference without dominance by a p != NULL check (matches pre-patch order in PATCH_DIFF).
3) Step 3: Objective—confirm mismatch between dereference and later NULL-handling. Signals—presence of a later branch handling p == NULL (e.g., if (!p) { … return; }) after the unsafe dereference. FP mitigation—require the later branch to be reachable from entry on a path that does not go through a return in the dereference’s enclosing branch (mirrors the “later !skb branch” in ROOTCAUSE_ANALYSIS 2 and PATCH_DIFF).
4) Step 4: Objective—prioritize misordered early-return branches guarded by unrelated conditions. Signals—dereference occurs inside a conditional whose predicate does not mention p (e.g., if (!clip_devs) { use p->field; return; }), while a later if (!p) exists. FP mitigation—exclude dereferences guarded by predicates that syntactically imply p is non-NULL (e.g., if (p) { … }).
5) Step 5: Objective—strengthen by detecting “use-then-free” of p under the unrelated condition. Signals—dereference (p->field) followed by freeing p or otherwise consuming it in the same branch, then early return, while a later p==NULL handler exists. FP mitigation—treat this as higher confidence but not required (based on PATCH_DIFF showing atm_return(vcc, skb->truesize); kfree_skb(skb); return;).
6) Step 6: Objective—use post-condition reasoning to rule out safe cases. Signals—earlier explicit checks or assertions that guarantee p is non-NULL along all paths reaching the dereference (e.g., immediate if (!p) return; precedes the dereference). FP mitigation—suppress if the dereference is control-flow dominated by a p != NULL check or an unconditional return on p == NULL.
7) Step 7: Objective—optional interprocedural corroboration of “nullable at callsite.” Signals—any call site that passes NULL or a maybe-NULL value to the function (e.g., analogous to vcc_destroy_socket() calling clip_push(vcc, NULL) per ROOTCAUSE_ANALYSIS 3). FP mitigation—use as a confidence boost; do not require when in-function NULL-check exists.
8) Step 8: Step 8: Objective—prioritize dereferences used to compute values then returned/consumed before null-check (pattern in bug). Signals—dereference of p->field used as an argument before any p NULL-check (e.g., atm_return(vcc, p->field) preceding if (!p)). FP mitigation—rank these higher severity as they mirror the root cause (ROOTCAUSE_ANALYSIS 3 and PATCH_DIFF).

3. Target Elements
- Functions and their parameters/local pointer variables.
- If-conditions and branches, including early returns.
- Member/field access expressions and pointer dereferences.
- Calls that consume pointer fields (arguments derived from p->field).
- Global variable checks or unrelated conditionals guarding dereferences.
- Return statements and control-flow dominance relationships.

4. Dataflow / Taint Considerations
- Track control-flow from function entry to each pointer dereference to ensure no prior non-NULL validation of that pointer occurs on that path.
- Track whether a dereference is control-flow dominated by a predicate implying p != NULL versus guarded by unrelated predicates (no mention of p).
- Optionally, interprocedural flow from call sites passing NULL/maybe-NULL into the callee parameter.
- Model reachability of later if (p == NULL) handlers to confirm “intended nullable” semantics.

5. Validation & Test Cases
- Positive: Function with early if (!G) { use p->field; return; } … later if (!p) { … return; } (mirrors PATCH_DIFF pre-patch ordering causing skb->truesize deref before !skb).
- Positive: Unconditional use of p->field at entry, with a later if (!p) handler (intended nullable pointer but dereferenced too early).
- Negative: if (!p) return; … p->field; (safe ordering; dereference dominated by NULL-check).
- Negative: if (p) { p->field; } else { … } (dereference is guarded by non-NULL predicate).
- Test harness notes: Include a case where the dereference is under if (!G) and p is freed/returned afterward, plus a later !p branch; and a case with known caller passing NULL to corroborate high confidence.

6. Estimated Effort & Priority
High: Requires control-flow dominance analysis, dereference identification, and optional interprocedural corroboration; bug class leads to kernel NULL deref DoS (ROOTCAUSE_ANALYSIS 2–4).

7. Likely False-Positive Sources & Mitigations
- Redundant/unreachable NULL-checks placed after dereferences (mitigate by requiring reachability and dominance analysis).
- Preconditions or invariants guaranteeing non-NULL not visible to the analyzer (mitigate by requiring explicit in-function NULL-check or nullable callsites to raise confidence).
- Complex aliasing where p is validated via an alias (mitigate by conservative alias tracking or restrict to direct uses of p).
- Macros/inlined helpers hiding validations (mitigate by recognizing common equality predicates and assertions when resolvable).

8. Limitations & Assumptions
- Assumes explicit in-function NULL-check is a proxy for “pointer may be NULL”; absence of such checks may hide true bugs or reduce recall.
- Optional caller evidence may be incomplete if call graph is partial; results should not depend solely on interprocedural proof (ROOTCAUSE_ANALYSIS mentions vcc_destroy_socket() but code is not provided).
- Does not model concurrency or runtime environment (e.g., global state like clip_devs) beyond syntactic checks; unrelated conditions are treated as not implying p non-NULL unless they reference p.
- Cannot infer API contracts that guarantee non-NULL unless explicitly checked in the code.