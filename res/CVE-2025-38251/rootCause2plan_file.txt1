1. Plan Summary
Detect dereferences of a function pointer parameter before the code verifies it is non-NULL, especially when the function later contains an explicit NULL-handling branch for that parameter (incorrect check ordering leading to NULL deref).

2. Detection Steps
1) Step 1: Identify candidate functions that take at least one pointer parameter and contain an explicit NULL-handling branch for that parameter. Signals: presence of a test like “if (!P)” or “if (P == NULL)” anywhere in the function body, where P is a function parameter.

2) Step 2: For each such parameter P, collect all syntactic and semantic dereferences of P. Signals: member access via P->field, pointer dereference *P, array indexing P[i], or using P to access subfields/lengths (e.g., P->truesize).

3) Step 3: Compute control-flow reachability from function entry to each dereference and determine whether any “P is non-NULL” guard dominates that dereference. Signals: dominating checks include “if (!P) { return/goto/... }” before the deref or deref located strictly within an “if (P)”/“if (P != NULL)” branch that dominates it.

4) Step 4: Flag dereferences of P that are reachable on some path without passing through any dominating non-NULL guarantee for P. Objective: find potential deref-before-check instances.

5) Step 5: Strengthen confidence by requiring that the function also contains a reachable explicit NULL-handling block for P after the flagged dereference. Signals: a post-dereference branch “if (!P) { ... }” or equivalent reachable later in control flow.

6) Step 6: Further prioritize cases where the unsafe dereference is nested under a condition that does not reference P (e.g., a global state check). Signals: the enclosing if/switch condition’s AST has no use of P and references non-local/global variables (e.g., a static/global pointer like clip_devs).

7) Step 7: Optionally enhance prioritization when the unsafe block both dereferences P and then frees P or returns immediately. Signals: sequence in the same block of P->field usage followed by a deallocation/free-like call with P and an early return, indicating likely misordered cleanup.

8) Step 8: Exclude dereferences that are unambiguously safe due to local reasoning. Signals: deref is within the “then” arm of an “if (P)” that dominates the deref, or within a block post-dominated by an earlier exit on “!P”.

9) Step 9: Report each issue with the dereference location, the first subsequent NULL-check location, and the unrelated guard (if any) that encloses the dereference. Objective: make the incorrect check ordering explicit and actionable.

3. Limitations & Assumptions
- The plan assumes the analyzer can perform intra-procedural control-flow and dominance analysis; inter-procedural proof that a caller passes NULL (e.g., vcc_destroy_socket) is not required.
- It assumes the presence of an explicit NULL-handling block implies the parameter may legally be NULL; functions lacking such a block are not considered.
- Distinguishing global vs. local conditions is heuristic; some “unrelated” guards may still imply non-NULL via complex invariants not visible intra-procedurally.
- Macros and inlined helpers may obscure dereferences; accurate modeling depends on the analyzer’s C preprocessor and AST construction fidelity.
- The plan does not model concurrency or lifetime beyond the function scope; it targets deref-before-check ordering within a single function body.