1. Plan Summary
Detect functions that dereference a pointer parameter (e.g., skb) before confirming it is non-NULL, especially within early-return/error branches gated by unrelated state, while evidence exists that the parameter can be NULL.

2. Detection Steps
1) Step 1: Identify functions that take a pointer parameter P and collect all uses of P inside the function; focus on member/field access (P->field), pointer dereference (*P), or array indexing via P.
2) Step 2: Gather evidence that P may be NULL by locating explicit null checks within the function (e.g., if (!P) or P == NULL) and/or call sites that invoke the function with a literal NULL for P.
3) Step 3: For each dereference of P, determine the control-flow path from function entry to that dereference and check whether any prior guard on that path verifies P is non-NULL; if none exists, treat the dereference as unguarded.
4) Step 4: Detect unguarded dereferences of P that occur inside a conditional branch whose condition does not mention P (e.g., checking a different variable/global like clip_devs), indicating ordering that prioritizes unrelated state over P’s null safety.
5) Step 5: Highlight cases where the unguarded dereference of P is followed by an immediate free/cleanup or return in the same branch (early-return/error path), matching teardown/cleanup flows where ordering mistakes are common.
6) Step 6: Confirm that elsewhere in the function there is a block handling P == NULL (e.g., logging, cleanup, and return upon !P), which strengthens the conclusion that P can be NULL and the earlier dereference is unsafe.
7) Step 7: Exclude dereferences that are syntactically guarded by the same conditional (e.g., the condition tests !P or ensures P is non-NULL before P is used) to reduce false positives.
8) Step 8: Raise the strongest alert when the sequence is: branch on unrelated state (e.g., !clip_devs) → dereference P (e.g., access P->field) → free/return, and a separate later block explicitly checks !P, demonstrating the precise pre-patch ordering flaw.
9) Step 9: Optionally rank findings higher if the dereference uses P’s fields as arguments to accounting/cleanup calls (e.g., passing P->field to a function) since this matches the pattern of using P before null-check in early-return paths.

3. Limitations & Assumptions
- The checker relies on explicit null checks or observed call sites passing NULL; if neither exists, it cannot confirm P may be NULL and may miss issues.
- It does not infer semantic guarantees from external APIs (e.g., whether a callee dereferences P); only direct member/field accesses or pointer dereferences are considered.
- Path feasibility and dominance are approximated via control-flow; complex macro expansions or inlined guards may reduce accuracy.
- The approach may flag false positives where invariants guarantee P non-NULL but are not syntactically visible.
- Concurrency, locking, and ordering effects beyond local control flow are not analyzed.