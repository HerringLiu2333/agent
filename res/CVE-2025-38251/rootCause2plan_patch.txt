1. Plan Summary
Detect functions that dereference a pointer parameter before checking it for NULL when an early-return branch is taken due to an unrelated condition, mirroring the pre-patch clip_push() ordering bug.

2. Detection Steps
1) Step 1: Objective: Find candidate functions where a pointer parameter may be NULL. Signals: Function body contains an explicit NULL-check on that parameter (e.g., if (!skb)) as in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: Ignore functions without any explicit NULL-check on the parameter.

2) Step 2: Objective: Locate dereferences of that parameter that occur prior to the parameter’s NULL-check. Signals: Any field access, array indexing, or use of the parameter (e.g., skb->truesize) that is reachable from function entry on a path that does not pass through the parameter NULL-check. FP mitigation: Require control-flow evidence that the NULL-check does not dominate the dereference.

3) Step 3: Objective: Prioritize dereferences that happen under an unrelated guard leading to early return. Signals: A conditional on some other variable (e.g., if (!clip_devs)) guarding a block that both dereferences the parameter and returns from the function, matching [PATCH_DIFF]. FP mitigation: Require that the guard condition does not test the parameter or its fields.

4) Step 4: Objective: Confirm the early-return semantics to match the cleanup/teardown pattern. Signals: The guarded block contains cleanup calls and a return (e.g., kfree_skb(skb); return;), as seen in [PATCH_DIFF]. FP mitigation: If no early return is present, deprioritize or suppress unless there is a clear dereference-before-NULL-check reachable path.

5) Step 5: Objective: Ensure the dereference is a real risky access. Signals: Identify dereference forms like parameter->field (e.g., skb->truesize) or passing such a field to another function (e.g., atm_return(vcc, skb->truesize)) per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude uses in constant-folded contexts or guaranteed-safe intrinsics; focus on genuine memory access semantics.

6) Step 6: Objective: Validate that no earlier check ensures non-NULL on the dereference path. Signals: No dominating if (param) condition, no explicit assertion equivalent, and no reassignment guaranteeing non-NULL before the dereference. FP mitigation: Use dominance/path reasoning to exclude paths post-dominated by a non-NULL assumption.

7) Step 7: Objective: Strengthen evidence with call-site corroboration. Signals: Find any call site that passes NULL to the parameter (e.g., vcc_destroy_socket() invoking clip_push() with NULL per [ROOTCAUSE_ANALYSIS]). FP mitigation: If no such call site is found, keep as a warning; if found, escalate to a likely defect.

8) Step 8: Objective: Highlight guards on potentially NULL globals used before the parameter NULL-check. Signals: Conditionals like if (!clip_devs) are evidence that the code anticipates NULL global state (per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]) and yet dereferences the parameter. FP mitigation: Require the unrelated guard to precede the parameter NULL-check and the dereference to occur within that guard.

9) Step 9: Objective: Prefer patterns where the fix is a reordering of checks as in the patch. Signals: The function contains both the unrelated guard and a separate explicit parameter NULL-check later, and the dereference is moved after the NULL-check in a fixed version (as described in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Suppress cases where the dereference already follows the parameter NULL-check on all paths.

10) Step 10: Objective: Produce actionable reports with path context. Signals: Show the path: function entry → unrelated guard true → dereference of parameter → cleanup/return, and separately show the later if (!param) block, mapping exactly to the root cause sequence in [ROOTCAUSE_ANALYSIS]. FP mitigation: Only report when both the pre-check dereference path and the later NULL-check exist.

3. Target Elements
- Functions with pointer parameters.
- Explicit NULL-check conditionals on those parameters.
- Conditionals on unrelated variables (e.g., globals like clip_devs).
- Field/member accesses of the pointer parameter.
- Function calls using the parameter or its fields (e.g., accounting routines).
- Cleanup/free calls (e.g., kfree_skb) followed by returns.
- Return statements and early-return blocks.
- Call sites that pass NULL to the function.

4. Dataflow / Taint Considerations
- Track control-flow reachability to ensure dereference occurs on a path before the parameter NULL-check (dominance analysis).
- Model dereference operations conceptually (member access, array indexing, passing to callees).
- Interprocedural flow from call sites to detect explicit NULL arguments or variables known to be NULL.
- Exclude paths where the parameter is proven non-NULL via prior checks or assignments.

5. Validation & Test Cases
- Positive: Function clip_push-like body with if (!clip_devs) { use skb->truesize; kfree_skb(skb); return; } and a later if (!skb) { ...; return; } — should be flagged as per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
- Negative: Reordered version where if (!skb) return; then use skb->truesize; then if (!clip_devs) { kfree_skb(skb); return; } — should not be flagged (matches the fix in [PATCH_DIFF]).
- Test harness notes: Include a cross-file call site passing NULL to confirm escalation; also include a variant without such a call site to remain a warning.

6. Estimated Effort & Priority
High (kernel crash potential per [ROOTCAUSE_ANALYSIS]; requires path/dominance and some interprocedural call-site analysis).

7. Likely False-Positive Sources & Mitigations
- Defensive NULL-checks for parameters that are never actually NULL at runtime; mitigate by requiring explicit later NULL-check and, if available, corroborating call sites.
- Complex control flow or macros obscuring dominance; mitigate by requiring clear early-return blocks and direct dereference patterns.
- Cleanup code that uses safe wrappers around NULL (not evident here); mitigate by focusing on clear dereference forms like param->field as in [PATCH_DIFF].

8. Limitations & Assumptions
- Assumes the presence of an explicit later NULL-check indicates the parameter may be NULL; this may be defensive only.
- Availability of interprocedural call graph to find NULL-passing call sites may be limited; absence reduces confidence.
- Does not model concurrency or dynamic environment state (e.g., whether a global is actually NULL); relies on the presence of guards as evidence (per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Free/cleanup routine recognition is based on structural patterns (cleanup + return) with kfree_skb as an example from [PATCH_DIFF]; other frees may not be captured without broader knowledge.