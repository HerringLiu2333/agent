1. CVE Identifier
CVE-2024-58055

2. Vulnerability Type
Double free leading to potential use-after-free and memory corruption

3. Root Cause Summary
In the USB gadget target function (f_tcm), the error path for unsupported SCSI opcodes freed the SCSI command structure (se_cmd) twice. Specifically, usbg_cmd_work() and bot_cmd_work() called transport_send_check_condition_and_sense() and then immediately transport_generic_free_cmd(&cmd->se_cmd, 0), while downstream completion handlers (e.g., bot_status_complete(), uasp_status_data_cmpl()) also perform transport_generic_free_cmd() after queuing and completing status responses. This duplicated free of the same se_cmd object can result in double free and subsequent use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
USB Gadget (drivers/usb/gadget/function/f_tcm.c), Target-based USB gadget implementing UAS/BOT SCSI transport and target core interaction.

2) Pre-Patch Flaw:
The pre-patch logic in usbg_cmd_work() and bot_cmd_work() freed cmd->se_cmd immediately on the “unsupported SCSI opcode” path after transport_send_check_condition_and_sense(), despite the asynchronous completion path also freeing it. Example (pre-patch): in usbg_cmd_work() out: "transport_send_check_condition_and_sense(...); transport_generic_free_cmd(&cmd->se_cmd, 0);" and similarly in bot_cmd_work().

3) Trigger Condition:
Receiving a SCSI CDB whose opcode maps to an invalid direction (get_cmd_dir() returns < 0), causing the work functions to take the error path that sends check condition and sense and then prematurely free se_cmd, while the completion handlers later free the same se_cmd again.

4) Impact Mechanism:
The duplicated transport_generic_free_cmd() causes a double free of se_cmd. Subsequent asynchronous callbacks (e.g., bot_status_complete(), uasp_status_data_cmpl()) may operate on freed memory, leading to use-after-free, memory corruption, or kernel crashes.

5. Patch Analysis
1) Fix Approach:
Remove the premature frees in the work functions so that the se_cmd lifecycle is managed only by the established completion paths that free the command after the status response has been handled.

2) Key Code Changes:
- In usbg_cmd_work() “out:” block, deletion of "transport_generic_free_cmd(&cmd->se_cmd, 0);".
- In bot_cmd_work() “out:” block, deletion of "transport_generic_free_cmd(&cmd->se_cmd, 0);".
These changes ensure that freeing occurs in bot_status_complete() and uasp_status_data_cmpl(), not twice.

3) Locking/Concurrency Impact:
No explicit locking changes. The fix addresses an asynchronous lifetime management issue by centralizing command freeing in completion callbacks, thereby eliminating race-prone double free/UAF scenarios inherent in mixed immediate and deferred frees.

6. Broader Kernel Security Implications
Incorrect lifetime management in asynchronous subsystems (USB gadget, SCSI target core) can lead to severe memory safety issues. Centralizing resource ownership and freeing in completion callbacks reduces risk of double free/UAF. Similar patterns should be audited in other error paths to ensure that transport_send_check_condition_and_sense() and completion handling do not both free the same command, preserving kernel stability and security.