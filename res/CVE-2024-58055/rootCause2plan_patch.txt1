1. Plan Summary
Detect XDP transmit paths that compute a DMA start address using a fixed headroom constant instead of the dynamic offset from the current xdp data pointer, risking packet corruption.

2. Detection Steps
1) Step 1: Identify XDP TX preparation contexts — functions that take a struct xdp_frame* or struct xdp_buff* and prepare/transmit data to the NIC (e.g., call dma_sync_single_for_device with DMA_TO_DEVICE). Signals: presence of XDP types (xdpf/xdp) and NIC transmit descriptor setup in drivers (especially networking drivers).

2) Step 2: Find code deriving a page from the XDP data pointer. Signals: calls like virt_to_page(xdpf->data) or virt_to_page(xdp->data) and storing the result into a local page variable.

3) Step 3: Find computation of a base DMA address from a page_pool API. Signals: calls to page_pool_get_dma_addr(page) with that page and assignment into a variable/field that looks like a TX descriptor DMA address (e.g., tbi->dma_addr or similar).

4) Step 4: Detect fixed-offset DMA address calculation. Signals: the DMA address variable/field is assigned as “base_dma + <constant or macro>” where the addend is a literal or a named constant (e.g., VMXNET3_XDP_HEADROOM), and the expression does not reference xdpf->data, xdp->data, or any pointer difference.

5) Step 5: Confirm that the data length is dynamic (consistent with XDP frame length), which heightens the mismatch risk. Signals: the size argument to dma_sync_single_for_device (or equivalent) is xdpf->len (or derived from it), or otherwise reflects the current XDP frame length rather than a fixed buffer size.

6) Step 6: Verify that the page used for base DMA came from the XDP data pointer (not an unrelated buffer). Signals: dataflow from xdpf->data/xdp->data into virt_to_page, then into page_pool_get_dma_addr used to compute the DMA start.

7) Step 7: Exclude cases where the DMA offset is correctly dynamic. Signals: presence of an offset expression derived from pointer arithmetic like (xdpf->data - (void*)xdpf) or (xdp->data - xdp->data_hard_start), or clearly equivalent pointer-difference computations feeding into the DMA address.

8) Step 8: Exclude cases where the added offset is a variable proven to be computed from the current xdp data pointer position. Signals: upstream dataflow showing the addend originates from xdpf->data/xdp->data minus a base/hard_start or an equivalent per-packet headroom calculation.

9) Step 9: Report a potential issue when Steps 2–6 match and Steps 7–8 do not, i.e., the DMA start address depends on a fixed headroom while the buffer length is dynamic and sourced from an XDP frame. Include contextual evidence: the constant addend, the base obtained via page_pool_get_dma_addr, and the dynamic length source.

3. Limitations & Assumptions
- This plan assumes that page_pool_get_dma_addr(page) with page derived from xdpf->data/xdp->data is the base for DMA; alternative base computations (e.g., other mapping APIs) are not covered by the signals above.
- The plan cannot prove at analysis time that an XDP program adjusted xdp->data; it flags the unsafe assumption of fixed headroom when dynamic adjustment is possible.
- Naming of fields (e.g., tbi->dma_addr) and macros (e.g., VMXNET3_XDP_HEADROOM) may vary across drivers; the checker relies on conceptual patterns rather than specific names.
- Some drivers may maintain invariants that xdp->data is fixed; without whole-driver proofs, the checker may conservatively flag such cases.