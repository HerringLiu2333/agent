1. Plan Summary
Detect incorrect DMA address calculations in XDP transmit paths where the DMA start address uses a fixed headroom instead of the dynamic offset derived from the current XDP data pointer, leading to packet corruption.

2. Detection Steps
1) Step 1: Objective — locate XDP TX setup code. Signals — functions that manipulate struct xdp_frame or xdp_buff, reference fields like data and len, and are part of an XDP transmit path (e.g., vmxnet3_xdp_xmit_frame invoked via vmxnet3_run_xdp/vmxnet3_xdp_xmit_back per PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS). FP mitigation — restrict to networking drivers and functions creating TX descriptors or preparing DMA.

2) Step 2: Objective — identify base DMA address derivation from a page-pool. Signals — a page derived from virt_to_page(xdpf->data) followed by page_pool_get_dma_addr(page) as the base DMA address (from PATCH_DESCRIPTION). FP mitigation — require that the page source traces back to the XDP data pointer.

3) Step 3: Objective — find the computed DMA start address used for TX. Signals — an assignment to a TX descriptor field (e.g., tbi->dma_addr) or equivalent, computed as base_dma + offset. FP mitigation — ensure the assigned address is later used in a DMA sync or TX ring programming.

4) Step 4: Objective — classify the offset expression. Signals — risky if the offset is a fixed constant or macro (e.g., VMXNET3_XDP_HEADROOM) not data-dependent on xdpf->data; safe if it’s a difference such as xdpf->data - (void *)xdpf or xdp->data - xdp->data_hard_start (per PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS). FP mitigation — perform dataflow dependence check to see if the offset syntactically or semantically depends on the current XDP data pointer.

5) Step 5: Objective — correlate DMA start with length usage. Signals — a dma_sync_single_for_device (or equivalent DMA sync) using the computed dma_addr and a length that is xdpf->len (from PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS). FP mitigation — require that the length or buffer size is directly or transitively derived from xdpf->len to confirm packet-length semantics.

6) Step 6: Objective — detect the mismatch pattern that causes corruption. Signals — presence of the risky fixed-offset DMA start paired with correct length from xdpf->len (exact flaw described in ROOTCAUSE_ANALYSIS). FP mitigation — only flag when both signals co-occur within the same TX preparation block.

7) Step 7: Objective — strengthen XDP-context confidence. Signals — function or call-chain names including run_xdp/xdp_xmit and/or use of XDP TX-specific helpers in the driver (as noted in PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS). FP mitigation — deprioritize or suppress findings outside XDP paths or without XDP-typed structures.

8) Step 8: Objective — catch macro-based headroom misuse. Signals — offset expression includes a macro named with XDP and HEADROOM semantics (e.g., VMXNET3_XDP_HEADROOM from PATCH_DESCRIPTION); treat as strong evidence of fixed headroom assumption. FP mitigation — require simultaneous presence of XDP data pointer handling and page_pool_get_dma_addr base.

9) Step 9: Objective — avoid flagging already-correct implementations. Signals — compute-and-use of offset equal to xdpf->data - (void *)xdpf or xdp->data - xdp->data_hard_start (the fix described in PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS). FP mitigation — explicitly whitelist when the offset depends on data minus frame base/hard_start.

10) Step 10: Objective — produce actionable findings. Signals — include context: the fixed offset expression, the base_dma computation chain, and the length source (xdpf->len) to allow manual review. FP mitigation — suppress if any alternative path in the same function correctly recomputes dma_addr with a dynamic offset before DMA sync.

3. Target Elements
- Functions in networking drivers that implement XDP transmit paths (e.g., vmxnet3_xdp_xmit_frame as per PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS).
- Assignments to TX descriptor DMA address fields (e.g., tbi->dma_addr) or equivalent.
- Calls to page_pool_get_dma_addr and virt_to_page related to XDP data pointers.
- Calls to dma_sync_single_for_device (or equivalent) that pair the computed DMA address with a length.
- Expressions and macros used as offsets in DMA address calculations (e.g., VMXNET3_XDP_HEADROOM per PATCH_DESCRIPTION).
- Uses of xdp_frame/xdp_buff fields: data, len, and references to frame base/hard_start concepts.

4. Dataflow / Taint Considerations
- Track dataflow from xdpf->data (or xdp->data) to:
  - The page via virt_to_page.
  - The base DMA address via page_pool_get_dma_addr.
  - The offset expression; mark safe if depends on (data - base_frame_ptr) semantics.
- Track derivation of buf_size/length from xdpf->len into the DMA sync call and descriptor length fields.
- Ensure the final dma_addr used in DMA sync originates from base_dma plus offset; flag when offset lacks dependency on the XDP data pointer.

5. Validation & Test Cases
- Positive: Code that computes tbi->dma_addr = page_pool_get_dma_addr(virt_to_page(xdpf->data)) + VMXNET3_XDP_HEADROOM; then calls dma_sync_single_for_device with that dma_addr and xdpf->len (matches PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS flaw).
- Negative: Code that computes dma_addr = page_pool_get_dma_addr(page) + (xdpf->data - (void *)xdpf) or xdp->data - xdp->data_hard_start, and syncs with xdpf->len (the fixed pattern in PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS).
- Negative: Non-XDP paths or DMA setups not involving xdp_frame/xdp_buff or not deriving base from virt_to_page(xdpf->data) and page_pool_get_dma_addr.
- Test harness notes: Run on vmxnet3 pre-fix and post-fix revisions; confirm a finding before the fix and no finding after.

6. Estimated Effort & Priority
High: The pattern is well-scoped, impacts packet integrity (ROOTCAUSE_ANALYSIS), and likely recurs across drivers with XDP TX paths.

7. Likely False-Positive Sources & Mitigations
- Drivers where XDP data pointer is guaranteed not to move: mitigate by requiring explicit XDP data pointer handling and length from xdpf->len.
- Code that later rewrites dma_addr with a dynamic offset: mitigate by ensuring the reported dma_addr is the one passed to DMA sync/TX.
- Non-XDP DMA code using similar patterns: mitigate by requiring involvement of xdp_frame/xdp_buff fields.

8. Limitations & Assumptions
- The provided PATCH_DIFF is unrelated to the described issue, so no direct diff cues are available for patterning; plan relies on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS.
- Field/type names may vary across drivers; detection assumes recognizable use of xdp_frame/xdp_buff, data, len, virt_to_page, page_pool_get_dma_addr, and dma_sync_single_for_device as seen in PATCH_DESCRIPTION.
- Static analysis cannot prove whether an XDP program will adjust xdp->data at runtime; the checker flags patterns that would be incorrect if xdp->data moves, per ROOTCAUSE_ANALYSIS.