1. Plan Summary
Detect cases where a function uses the unchecked result of a “finder” function that can return NULL, especially when a previously validated pointer to the same object is already stored in a reachable data structure and should be reused.

2. Detection Steps
1) Step 1: Objective—identify candidate “finder” functions that can return NULL. Signals—functions with pointer return types whose body contains an explicit return NULL path (e.g., avs_dai_find_path_template in [FILE_CONTENT]). FP mitigation—only consider functions with at least one explicit NULL return in any control-flow path.

2) Step 2: Objective—find call sites where the result of such a finder is directly used without a prior null-check. Signals—an assignment from the finder’s return to a local pointer variable immediately flowing as an argument to another function or being dereferenced (e.g., template passed to avs_path_set_constraint in [FILE_CONTENT] pre-patch). FP mitigation—require that there is no intervening check of the variable against NULL in the same basic block or dominating control flow.

3) Step 3: Objective—confirm that the unchecked use is “immediate” and likely unsafe. Signals—data flow from the finder’s return to a call argument in the same function without control-flow guards (no if (!ptr) or error-return handling before use). FP mitigation—exclude cases where the callee is trivially checked for NULL within the same statement context (not present here per [ROOTCAUSE_ANALYSIS]).

4) Step 4: Objective—detect presence of a prior validated retrieval of the same object earlier in the startup path. Signals—in another function, a call to the same finder is followed by an explicit NULL check and error return, and then stored into a struct field (e.g., template validated and stored into data->template in avs_dai_startup, [FILE_CONTENT]). FP mitigation—require an explicit conditional that rejects NULL (return -EINVAL or equivalent) before the store.

5) Step 5: Objective—establish the control-flow/call relationship between the prior validated function and the current function with unchecked use. Signals—the validated function calls the current function after storing the validated pointer (e.g., avs_dai_startup returns avs_hw_constraints_init, [FILE_CONTENT]). FP mitigation—prefer cases where a direct call edge exists (A calls B) to reduce speculative ordering.

6) Step 6: Objective—verify that the current function has access to the struct field containing the validated pointer. Signals—lookup of the same per-stream/per-dai context struct (e.g., snd_soc_dai_get_dma_data(...) into data, and data->template field of type matching the finder’s return, [FILE_CONTENT]). FP mitigation—require matching pointer types between finder’s return type and the struct field.

7) Step 7: Objective—detect redundant re-lookup when a validated field is accessible. Signals—current function both (a) obtains the context struct and (b) calls the finder again and (c) uses the new result without check, instead of using the stored field (pre-patch avs_hw_constraints_init versus post-patch change in [PATCH_DIFF]). FP mitigation—only flag if both signals (context access and re-lookup) co-occur, indicating a concrete alternative exists.

8) Step 8: Objective—prioritize cases where the unchecked value is passed to a function likely to dereference it. Signals—callee name or role indicates constraint/initialization or path configuration (e.g., avs_path_set_constraint as per [ROOTCAUSE_ANALYSIS] description of dereference), and the argument position corresponds to the finder’s object type. FP mitigation—if multiple callsites exist where NULL is explicitly allowed (not shown here), suppress unless there is supporting evidence of dereference risk (NULL path in finder + lack of check + prior validated field pattern).

9) Step 9: Objective—exclude safe patterns. Signals—cases where the finder’s result is immediately checked or sanitized before use, or where the stored field is not present/accessible in scope, or where the current function cannot reach the validated store via a call edge. FP mitigation—require all three risky conditions (nullable finder + missing check + available validated field) to hold.

10) Step 10: Objective—report with remediation hint grounded in the patch. Signals—suggest reusing the validated field instead of redundant lookup (as in [PATCH_DIFF] switching from local template to data->template). FP mitigation—only emit this hint if a matching field exists and types align.

3. Target Elements
- Functions that return pointers and contain explicit return NULL paths.
- Call sites assigning such results to local variables and using them as arguments or via dereference.
- Conditional checks guarding against NULL and error-return paths.
- Struct fields storing validated pointers (e.g., avs_dma_data.template).
- Interprocedural relationships: a function that validates and stores a pointer, then calls another function that re-fetches and uses without check.
- Getter calls that provide access to the context struct holding the stored pointer (e.g., snd_soc_dai_get_dma_data).

4. Dataflow / Taint Considerations
- Track data flow from the finder’s return value to:
  - A function call argument, or
  - A dereference expression.
- Track whether a NULL-check dominates the use site (absence indicates risk).
- Track storage of the validated finder result into a struct field and its reachability: function A stores it; function B, called by A, can access the same object via a known getter pattern and field access.
- Track type consistency: finder return type should match the struct field type and the callee argument type.

5. Validation & Test Cases
- Positive: Pre-patch avs_hw_constraints_init pattern—assign template = avs_dai_find_path_template(...); directly pass template to avs_path_set_constraint(...) with no NULL check, while avs_dai_startup previously validated and stored data->template ([FILE_CONTENT], [ROOTCAUSE_ANALYSIS]).
- Negative: Post-patch avs_hw_constraints_init—uses data->template instead of re-finding and thus does not use an unchecked possibly-NULL value ([PATCH_DIFF]).
- Negative: A function that calls a “find” function, checks if (!ptr) return -EINVAL;, and only uses ptr afterward; should not be flagged (mirrors avs_dai_startup validated store in [FILE_CONTENT]).
- Test harness notes: Run on the file containing these functions; ensure the checker identifies the pre-patch hunk and is silent on the post-patch version.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- The callee function may handle NULL safely: mitigate by requiring a finder with explicit NULL returns and absence of caller-side checks, plus the existence of a validated stored field suggesting NULL is not acceptable.
- The prior validated function may not actually precede the unchecked use at runtime: mitigate by requiring a direct call edge (A calls B) as seen in [FILE_CONTENT].
- Multiple different “finder” functions or unrelated pointer types: mitigate by enforcing pointer type matching between finder return, struct field, and callee parameter.

8. Limitations & Assumptions
- Assumes the analysis can resolve call edges to confirm that the validating function invokes the unchecked-using function (as in avs_dai_startup calling avs_hw_constraints_init, [FILE_CONTENT]).
- Does not prove the callee dereferences the argument; relies on [ROOTCAUSE_ANALYSIS] stating avs_path_set_constraint dereferences the template.
- Assumes availability of the context struct via a recognizable getter and field (e.g., snd_soc_dai_get_dma_data returning a struct with the validated field); patterns outside this may be missed.