1. Plan Summary
Detect uses of a pointer returned by a “finder” helper without a preceding NULL check, especially when the pointer is then dereferenced directly or passed into a function that dereferences it, as in the pre-patch avs_dai_find_path_template result flowing unchecked into avs_path_set_constraint (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS).

2. Detection Steps
1) Step 1: Objective — Identify candidate source functions that may return NULL; Signals — functions with pointer return type that contain a return of NULL in their body; FP mitigation — require a visible definition showing an explicit NULL return.
2) Step 2: Objective — Find call sites where the result of a candidate source is produced; Signals — assignment of the call result to a pointer variable or direct use as an argument/expression; FP mitigation — ensure the variable’s static type is a pointer and matches the source function’s return type.
3) Step 3: Objective — Identify unsafe sink uses in the same function where the result is consumed; Signals — (a) member access via -> or * on the variable, or (b) the variable passed as an argument to another function parameter that is subsequently dereferenced in that callee’s body; FP mitigation — for (b), require interprocedural evidence that the callee dereferences the corresponding parameter.
4) Step 4: Objective — Establish absence of guarding NULL checks between source and sink; Signals — no dominating condition like if (!ptr) { return/... } or if (ptr) guarding all paths to the sink; FP mitigation — use control-flow dominance: only report when the sink is reachable on a path not strictly dominated by a non-NULL guard on the pointer.
5) Step 5: Objective — Handle immediate-use patterns; Signals — direct passing of the call expression from the source function into a sink call without any intervening check; FP mitigation — same interprocedural dereference evidence for the sink as Step 3.
6) Step 6: Objective — Capture the exact CVE pattern for prioritization; Signals — in avs_hw_constraints_init, result of avs_dai_find_path_template used as the template argument to avs_path_set_constraint without a prior NULL check (per PATCH_DIFF/ROOTCAUSE_ANALYSIS); FP mitigation — restrict to this function pair when present to yield high-confidence alerts.
7) Step 7: Objective — Exclude safe alternatives introduced by the patch; Signals — uses of prevalidated data->template (or other known-good state) in place of the search result; FP mitigation — if the sink uses a different variable than the finder’s result and that variable is not dataflow-equal to the finder result, suppress the alert.
8) Step 8: Objective — Avoid false positives where non-NULL is ensured by earlier logic; Signals — assignments that overwrite the pointer with a known-good value before the sink, or assertions that imply non-NULL; FP mitigation — if there is any dominating assignment from a non-null-constructor or explicit check/assertion guaranteeing non-NULL, do not report.
9) Step 9: Objective — Prefer issues in initialization/setup paths where DoS impact is higher; Signals — functions that match initialization semantics (e.g., “init” in name like avs_hw_constraints_init from PATCH_DIFF); FP mitigation — treat such contexts as higher priority but still require the core missing-check pattern.

3. Target Elements
- Functions and their bodies (for NULL-return identification and dereference use).
- Call sites and assignments capturing pointer-returning call results.
- Conditional checks comparing a pointer to NULL or used in boolean context.
- Member access and unary dereference expressions.
- Interprocedural parameter-to-argument mappings to find dereferences of passed pointers in callees.

4. Dataflow / Taint Considerations
- Track dataflow from the source call result to its uses through local variables, assignments, and argument passing.
- Model control-flow guards: a path-sensitive check that the pointer is tested for NULL and that the sink is dominated by a non-NULL condition.
- Interprocedural flow from call argument to callee parameter, then to any dereference of that parameter.
- Consider immediate uses (source call directly used as sink argument) with no intervening variable.

5. Validation & Test Cases
- Positive: In avs_hw_constraints_init, template = avs_dai_find_path_template(...); ret = avs_path_set_constraint(..., template, ...); with no intervening NULL check — should be reported (as per ROOTCAUSE_ANALYSIS and PATCH_DIFF pre-patch).
- Negative: Same as above but with if (!template) return -EINVAL; before calling avs_path_set_constraint — should not be reported.
- Negative: Code using ret = avs_path_set_constraint(..., data->template, ...); without any lookup — should not be reported (matches PATCH_DIFF fix).
- Test harness notes: Include a callee body for avs_path_set_constraint that dereferences its template parameter to validate interprocedural deref detection; also include a variant where the callee body is unavailable to observe reduced-confidence or suppressed reporting.

6. Estimated Effort & Priority
Medium: requires interprocedural dataflow and dominance reasoning, but the patterns are common and well-supported by CodeQL libraries.

7. Likely False-Positive Sources & Mitigations
- Callees that do not dereference the pointer argument: mitigate by requiring evidence of dereference in callee.
- Helper functions that cannot return NULL in a given build/config: mitigate by requiring a visible NULL return in the helper’s definition.
- Non-explicit guarantees of non-NULL (e.g., documented invariants): unavoidable; provide suppression when a prior dominating check or assertion exists.
- Missing callee definitions causing uncertainty: default to not reporting unless a direct dereference occurs in the same function.

8. Limitations & Assumptions
- Assumes visibility of helper function bodies to confirm potential NULL returns; otherwise, the checker may miss cases or reduce confidence.
- Assumes callee bodies are available to prove dereference; if not, the checker won’t flag argument-passing sinks unless a direct dereference occurs locally.
- Does not infer semantic guarantees from external contracts; only explicit code checks/returns are considered.
- Based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS, the primary known instance is avs_dai_find_path_template flowing into avs_path_set_constraint; broader generalization relies on the same explicit signals.