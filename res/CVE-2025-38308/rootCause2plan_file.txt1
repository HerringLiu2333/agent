1. Plan Summary
Detect unchecked use of a pointer returned by a “finder” function that can return NULL, especially when a previously validated instance is already stored in per-stream context and should be reused.

2. Detection Steps
1) Step 1: Identify candidate finder functions that may return NULL. Signals: functions returning pointer types that contain explicit return NULL paths (e.g., avs_dai_find_path_template returns NULL on missing path).

2) Step 2: Collect all call sites where the finder’s return value is assigned to a local pointer variable. Signals: assignment of the call result to a pointer (e.g., template = avs_dai_find_path_template(...)).

3) Step 3: Determine whether the assigned pointer is validated before any use. Signals: absence of dominating null-check patterns (e.g., if (!template) { error/return; }) on all control-flow paths reaching its first use.

4) Step 4: Locate unsafe uses of the unvalidated pointer. Signals: the pointer is dereferenced (field access, array indexing) or passed as an argument to another function before any intervening null-check (e.g., ret = avs_path_set_constraint(..., template, ...)).

5) Step 5: Identify the per-stream context object available at the call site. Signals: local variable obtained via snd_soc_dai_get_dma_data(dai, substream) and its struct type members (e.g., struct avs_dma_data).

6) Step 6: Check for an equivalent validated pointer already stored in the context. Signals: a struct member with compatible type and role (e.g., data->template of type struct avs_tplg_path_template *) accessible in the same function.

7) Step 7: Cross-function validation source discovery. Signals: in another function (e.g., avs_dai_startup), find a pattern “ptr = finder(...); if (!ptr) return error; ctx->field = ptr;” establishing that ctx->field is a validated instance.

8) Step 8: Correlate arguments to ensure the re-lookup is redundant. Signals: finder is called with parameters derived from the same inputs used to populate the context (e.g., dai, rtd->dai_link->no_pcm, substream->stream) indicating semantic equivalence.

9) Step 9: Prioritize/report cases where a validated context field exists but is ignored in favor of an unchecked fresh lookup. Signals: within the same function, both the context (data) is available and data->template exists, yet the code calls the finder and uses its result without a null-check.

10) Step 10: Raise the alert when Steps 3–4 (unchecked use) and Steps 6–9 (validated reusable pointer present) are all satisfied. Signals: produce a path showing source (finder return), lack of null-check, and sink (first use), plus evidence of the validated context field.

11) Step 11: De-emphasize or suppress when a proper null-check protects all uses. Signals: a dominating if (!ptr) return/handle; guarding every path to use.

12) Step 12: Optional sink strengthening for confidence. Signals: callee names indicating likely dereference (e.g., avs_path_set_constraint) or immediate field access on the finder result.

3. Limitations & Assumptions
- Assumes the analyzer can recognize null-check dominance and basic dataflow across function bodies; complex path-sensitive reasoning may miss some cases.
- The plan infers equivalence of finder calls by argument similarity (e.g., dai, substream, rtd->dai_link->no_pcm); precise semantic equivalence cannot be fully guaranteed.
- Bodies of downstream functions like avs_path_set_constraint are not provided; we treat passing an unchecked pointer as risky even without confirming dereference inside.
- The detection of a “validated stored pointer” relies on finding a null-check followed by assignment into a context field elsewhere (e.g., in avs_dai_startup); if such evidence is in other files, cross-file analysis must be enabled.