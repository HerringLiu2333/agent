1. Plan Summary
Detect integer-overflow-prone allocation size calculations where a user-influenced length is added to header sizes using plain arithmetic before alloc_skb, without overflow-safe helpers, potentially causing undersized skb allocations on 32-bit builds.

2. Detection Steps
1) Step 1: Objective: find candidate allocation sites. Signals: calls to alloc_skb capturing the size argument expression (based on PATCH_DIFF showing alloc_skb use). FP mitigation: ignore trivial constant-only sizes.
2) Step 2: Objective: identify overflow-prone arithmetic in the size argument. Signals: the size argument is a sum where a non-constant variable is added to one or more sizeof(...) terms, optionally followed by a subtraction like “- pktshift” (mirrors ROOTCAUSE_ANALYSIS and PATCH_DIFF). FP mitigation: require at least one sizeof(...) literal in the addition to match the “headers + payload” pattern.
3) Step 3: Objective: confirm lack of overflow-safe arithmetic. Signals: absence of size_add (or similar overflow helper) in the addition, i.e., plain + combining the variable and header sizes (PATCH_DIFF shows size_add as the fix). FP mitigation: suppress if size_add wraps the variable-plus-headers part as in the patch.
4) Step 4: Objective: approximate the 32-bit risk context. Signals: code compiled in kernel sources where size_t may be 32-bit; treat as potentially affected when no explicit width guards are present (ROOTCAUSE_ANALYSIS emphasizes 32-bit overflow). FP mitigation: downgrade or suppress if the addition is performed via an overflow-safe helper; otherwise include a note that impact is specific to 32-bit builds.
5) Step 5: Objective: assess user influence on the variable term. Signals: the variable comes from a struct/parameter field analogous to gl->tot_len or similar length fields read from input paths (ROOTCAUSE_ANALYSIS: gl->tot_len is user-controlled via process_responses()). FP mitigation: prioritize when the variable is a struct field read (e.g., X->tot_len) not assigned locally within the function and used without prior clamping.
6) Step 6: Objective: detect lack of explicit overflow bounds checks. Signals: no preceding condition guarding the sum, such as checking the variable against SIZE_MAX minus the header constants before the alloc_skb call (ROOTCAUSE_ANALYSIS: “lacked overflow-safe arithmetic”). FP mitigation: suppress when a clear bounds check on the sum or on the variable against the additive constant is present immediately before the allocation.
7) Step 7: Objective: correlate allocation size with subsequent writes to confirm potential overflow impact. Signals: after the allocation, presence of copy/put operations that use the same variable (e.g., gl->tot_len) and/or the header sizes to populate the skb, indicating intent to store payload + headers (ROOTCAUSE_ANALYSIS: “subsequent packet/header data copying into the skb would then overrun”). FP mitigation: prioritize findings where such writes exist on the allocated skb along the same path.
8) Step 8: Objective: avoid noise from safe refactors. Signals: if the size calculation has been re-expressed exactly as size_add(variable, headers) with the subtract outside (as in PATCH_DIFF), consider safe. FP mitigation: suppress those cases and treat them as fixed instances of the pattern.

3. Target Elements
- Calls to alloc_skb and their size arguments.
- Arithmetic expressions computing allocation sizes, especially sums of a variable plus sizeof(...) terms and optional subtracts.
- Struct field reads representing lengths (e.g., gl->tot_len) used in allocation arithmetic.
- Control-flow guards preceding allocations that perform overflow checks.
- Subsequent use sites of the allocated skb where data of size variable and header constants is written or appended.

4. Dataflow / Taint Considerations
- Track dataflow from length-like struct fields or parameters (e.g., gl->tot_len) into the alloc_skb size expression to model user influence (per ROOTCAUSE_ANALYSIS: user-controlled via process_responses()).
- Correlate that same value’s flow into subsequent copy/append operations to the allocated skb to strengthen the evidence of potential overrun.
- Treat values not re-assigned or clamped in-function as more likely tainted; down-rank cases where the value is constrained prior to use.

5. Validation & Test Cases
- Positive: Pre-patch pattern: alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift, GFP_ATOMIC); with no prior bounds check; expect a finding.
- Negative: Patched pattern: alloc_skb(size_add(gl->tot_len, sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header)) - pktshift, GFP_ATOMIC); expect no finding.
- Negative: Allocation preceded by explicit check that gl->tot_len <= SIZE_MAX - (sizeof(header1)+sizeof(header2)); and then plain addition; expect no finding.
- Test harness notes: Run on drivers/infiniband/hw/cxgb4/device.c and verify the checker flags only the pre-patch call and clears on the patch commit.

6. Estimated Effort & Priority
Medium: requires expression pattern matching, light dataflow to associate the length variable, and simple guard detection.

7. Likely False-Positive Sources & Mitigations
- 64-bit-only builds where overflow cannot occur at practical sizes; mitigate by annotating risk as 32-bit specific and by requiring user-influenced variable evidence.
- Cases with non-obvious prior clamping or sanitization; mitigate by scanning for range checks on the variable or the sum before allocation.
- Benign arithmetic that mimics the pattern but writes less data than allocated; mitigate by correlating subsequent copy lengths to the variable-plus-headers intent.

8. Limitations & Assumptions
- Build-time architecture (32-bit vs 64-bit) may not be derivable from the database; the checker assumes potential 32-bit compilation as per ROOTCAUSE_ANALYSIS.
- Precise identification of “user-controlled” sources is limited; the plan infers taint from unmodified length fields analogous to gl->tot_len.
- The checker focuses on alloc_skb as per PATCH_DIFF; other allocators are out of scope unless similarly patterned.