1. CVE Identifier
CVE-2024-57973

2. Vulnerability Type
Integer overflow leading to heap-based buffer overflow (undersized allocation followed by out-of-bounds write)

3. Root Cause Summary
The function copy_gl_to_skb_pkt computed the skb allocation size using plain 32-bit arithmetic on a user-controlled length (gl->tot_len) without overflow checks. On 32-bit systems, the expression gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift could wrap, producing a much smaller allocation than needed. Subsequent __skb_put and data copy operations used the intended (potentially overflowing) total length, causing writes beyond the allocated buffer. The patch addresses this by using size_add() to perform overflow-safe size calculations for the allocation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
RDMA cxgb4 (Chelsio T4/T5/T6) driver in drivers/infiniband/hw/cxgb4

2) Pre-Patch Flaw:
- In copy_gl_to_skb_pkt, alloc_skb was called with a size computed by naive addition of gl->tot_len and header sizes: “gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift”.
- gl->tot_len originates from process_responses() and is user-controlled; on 32-bit, the addition could overflow and wrap to a smaller value.
- No validation or overflow-aware arithmetic was performed before allocation.

3) Trigger Condition:
- A crafted or large gl->tot_len on a 32-bit system such that gl->tot_len + sizeof(headers) exceeds UINT_MAX, causing integer wraparound in the allocation size computation.

4) Impact Mechanism:
- Integer wrap produces an undersized skb via alloc_skb.
- The function then calls __skb_put with the intended (potentially overflowing) total length and copies header plus gl payload into the skb, resulting in out-of-bounds writes and heap memory corruption (potential crash or exploitation).

5. Patch Analysis
1) Fix Approach:
- Introduce overflow-safe size calculation using size_add() for the allocation size to prevent integer wrap on 32-bit.

2) Key Code Changes:
- Replaced:
  “alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift, GFP_ATOMIC);”
  with:
  “alloc_skb(size_add(gl->tot_len, sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header)) - pktshift, GFP_ATOMIC);”
- This ensures the sum of gl->tot_len and header sizes cannot silently wrap; on overflow, the allocation request becomes large and fails rather than undersized.

3) Locking/Concurrency Impact:
- None. The change is purely arithmetic validation; no locking or ordering modifications.

6. Broader Kernel Security Implications
- User-controlled lengths must be handled with overflow-aware helpers (size_add/size_mul) to avoid undersized allocations and subsequent OOB writes.
- This class of bugs can lead to kernel heap corruption and potential privilege escalation; adopting systematic use of checked arithmetic in allocation size calculations reduces such risks across the kernel.