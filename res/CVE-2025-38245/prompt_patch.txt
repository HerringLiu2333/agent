1. CVE Identifier
CVE-2025-38245

2. Vulnerability Type
Race condition causing inconsistent device/procfs state and duplicate procfs entry registration

3. Root Cause Summary
atm_dev_deregister() released atm_dev_mutex immediately after list_del(&dev->dev_list) while procfs/sysfs for the device were still present, creating a race with atm_dev_register() which performs __atm_dev_lookup() under the same mutex and then creates procfs. This premature unlock allowed registration to see the device absent from the list and proceed to create a new procfs entry while the old entry had not yet been removed, triggering “proc_dir_entry already registered” WARN. The flaw is incorrect lock holding duration leading to non-atomic updates of related shared state (device list vs procfs/sysfs lifetime).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ATM networking subsystem (net/atm), device registration/deregistration paths involving procfs/sysfs (resources.c, proc.c)

2) Pre-Patch Flaw:
In atm_dev_deregister(), the code sequence was:
- mutex_lock(&atm_dev_mutex);
- list_del(&dev->dev_list);
- mutex_unlock(&atm_dev_mutex);
followed by atm_dev_release_vccs(dev), atm_unregister_sysfs(dev), and atm_proc_dev_deregister(dev). This unlocked the global device mutex before procfs/sysfs teardown, leaving a window where the device was absent from the list but its procfs/sysfs entries still existed.

3) Trigger Condition:
Concurrent atm_dev_register() for the same device name while atm_dev_deregister() is in progress. Registration does __atm_dev_lookup() under atm_dev_mutex and, finding no duplicate in the list due to early list_del, proceeds to create procfs entries while deregistration has not yet removed the existing procfs entries.

4) Impact Mechanism:
Duplicate procfs registration attempt triggers a WARN in proc_register (“proc_dir_entry 'atm/...' already registered”) and indicates inconsistent global state. This can lead to kernel warnings (“splat”), potential instability, and in configurations with panic_on_warn, a denial-of-service.

5. Patch Analysis
1) Fix Approach:
Hold atm_dev_mutex across the teardown of sysfs/procfs in atm_dev_deregister(), releasing the mutex only after atm_unregister_sysfs() and atm_proc_dev_deregister() complete. This makes removal of the device list entry and its procfs/sysfs entries effectively atomic with respect to concurrent registration.

2) Key Code Changes:
- Removed the immediate mutex_unlock(&atm_dev_mutex) after list_del(&dev->dev_list).
- Deferred mutex release until after:
  - atm_dev_release_vccs(dev);
  - atm_unregister_sysfs(dev);
  - atm_proc_dev_deregister(dev);
Evidence (hunk): the pre-patch unlock was removed after list_del; the description states “Release atm_dev_mutex after removing procfs/sysfs.”

3) Locking/Concurrency Impact:
By extending the critical section protected by atm_dev_mutex to include procfs/sysfs removal, the patch eliminates the race window where __atm_dev_lookup() sees the device absent while its procfs/sysfs still exist. This serializes device list updates with procfs/sysfs lifetime changes, ensuring consistent state observation by concurrent registration and preventing duplicate procfs entry creation.

6. Broader Kernel Security Implications
This fix highlights the necessity of holding global device-level locks across all related state transitions (list membership and associated filesystem artifacts) to avoid TOCTOU races. Similar patterns in other subsystems that update in-kernel registries alongside procfs/sysfs exposure must ensure atomicity under appropriate locks to prevent inconsistent states, warnings, or potential denial-of-service via panic-on-warn configurations. Consistent lifetime management reduces risk of resource duplication, stale entries, and broader integrity issues in kernel-exposed namespaces.