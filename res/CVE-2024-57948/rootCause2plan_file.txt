1. Plan Summary
Detect kernel list corruption risks where a node is deleted from an intrusive list without checking membership/emptiness, while another teardown path also deletes the same node, leading to double list removal under concurrent/unordered teardown.

2. Detection Steps
1) Step 1: Objective: Map list node fields to their container lists. Signals: Identify list_add* calls (e.g., list_add_tail_rcu(&X->field, &Y->container)) to establish the pair (node field, container head) and the owning types/expressions; why: needed to correlate delete sites to the same data structure; FP mitigation: only consider pairs that appear in at least one add-site in the codebase (based on FILE_CONTENT list_add_tail_rcu(&sdata->list, &local->interfaces)).

2) Step 2: Objective: Collect all deletion sites for each (node field, container) pair. Signals: Calls to list_del_rcu, list_del, or list_del_init on &Var->field inside functions; why: these are potential double deletions (based on FILE_CONTENT ieee802154_if_remove and ieee802154_remove_interfaces); FP mitigation: limit to deletions performed while holding a mutex associated with the container (see Step 3).

3) Step 3: Objective: Identify the lock guarding the container. Signals: mutex_lock/unlock around operations on the same container (e.g., &local->iflist_mtx surrounding operations on &local->interfaces); why: shared lock indicates shared critical section and potential sequencing issue (based on FILE_CONTENT both functions use local->iflist_mtx); FP mitigation: require that the same lock protects both add and delete sites for the pair.

4) Step 4: Objective: Detect “global removal” functions that remove all entries from the container. Signals: list_for_each_entry*_over container head with body doing list_del(&entry->field), often followed by a teardown like unregister_netdevice; why: models the hardware unregister path that removes all nodes (based on FILE_CONTENT ieee802154_remove_interfaces); FP mitigation: require both the loop and a deletion on the node field within it.

5) Step 5: Objective: Detect “single-node removal” functions that delete one node directly. Signals: Function with a parameter whose type owns the node field, performing list_del_rcu/list_del on &Param->field not inside a loop over the container; why: models the netlink path removing a single interface (based on FILE_CONTENT ieee802154_if_remove); FP mitigation: ensure the deletion is under the container’s lock from Step 3.

6) Step 6: Objective: Check for missing membership/emptiness guards before single-node deletion. Signals: Absence of a dominating conditional that checks list_empty on the container (e.g., list_empty(&Obj->container)) or equivalent membership guard before list_del_rcu/list_del; why: maps to the root cause where ieee802154_if_remove unconditionally deleted, fixed by adding a list_empty container check (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS); FP mitigation: if such a check exists, do not report.

7) Step 7: Objective: Cross-validate presence of both global and single-node removal for the same (node field, container) under the same lock. Signals: The function pair from Steps 4 and 5 reference the same field and container and acquire the same mutex; why: indicates two teardown paths that can run in different orders and double-delete (based on ROOTCAUSE_ANALYSIS); FP mitigation: if no matching pair exists, skip reporting.

8) Step 8: Objective: Boost confidence when deletion primitives differ between paths (RCU vs non-RCU). Signals: Single-node path uses list_del_rcu while global path uses list_del; why: this mismatch reflected in the failure trace and increases risk if membership isn’t checked (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS); FP mitigation: treat as a severity booster, not a hard condition.

9) Step 9: Objective: Recognize teardown context that supports the race scenario. Signals: Presence of synchronize_rcu or unregister_netdevice in proximity to deletion in either path; why: mirrors the teardown/unregister interleaving described (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS); FP mitigation: if neither teardown indicator exists in either path, lower confidence.

10) Step 10: Objective: Exclude cases where the node deletion safely reinitializes or guards membership. Signals: Use of list_del_init on the node field or a guard that checks node membership explicitly; why: these patterns reduce risk of deleting an already unlinked node; FP mitigation: do not report when such safeguards are present.

11) Step 11: Objective: Ensure the single-node deletion uses the same container as the add site. Signals: Dataflow from parameter->local (or equivalent) to the container head expression used in add and guard; why: ties the node to the correct container (based on FILE_CONTENT sdata->local->interfaces); FP mitigation: if the container head cannot be resolved consistently, skip.

12) Step 12: Objective: Emit a finding when all above conditions indicate risk. Signals: Single-node unguarded deletion under lock + existence of a global removal under the same lock on same (field, container); why: this matches the double list removal root cause (based on ROOTCAUSE_ANALYSIS); FP mitigation: include both function locations and suggest adding a container emptiness/membership check as per PATCH_DIFF.

3. Target Elements
- Macro/function calls: list_add*_rcu, list_del_rcu, list_del, list_del_init, list_for_each_entry*_loops, list_empty, synchronize_rcu, unregister_netdevice.
- Function definitions and their parameters for node types.
- Mutex lock/unlock calls associated with the container (e.g., iflist_mtx).
- Member expressions that identify the node field and container head (e.g., sdata->list, local->interfaces).
- Control-flow dominance of guards over deletion calls.

4. Dataflow / Taint Considerations
- Track the association between a node parameter (e.g., sdata) and its node field (sdata->list) and container (sdata->local->interfaces) via member access.
- Propagate through aliases to ensure the same container head expression is recognized across functions operating on the same structure (e.g., local resolved from sdata->local).
- Track lock variable identity through member access (e.g., sdata->local->iflist_mtx) to confirm same lock protects both paths.

5. Validation & Test Cases
- Positive: One function adds nodes to container; a global removal function loops over container with list_del and unregister; a single-node removal function calls list_del_rcu on &param->node under the same lock without any list_empty or membership check; expect a finding.
- Negative: Same as positive but single-node removal first checks list_empty(&param->local->container) and returns early; expect no finding (aligned with PATCH_DIFF).
- Negative: Only one deletion site exists for the node field/container; expect no finding.
- Test harness notes: Validate lock identity and container resolution across functions; include variants using list_for_each_entry_safe.

6. Estimated Effort & Priority
Medium — Requires cross-function correlation of list add/remove sites, lock matching, and control-flow guard dominance.

7. Likely False-Positive Sources & Mitigations
- Alternate membership guarantees not expressed via list_empty (mitigation: allow configurable alternative guards; lower severity if absent).
- Functions that are mutually exclusive by higher-level lifecycle not visible to static analysis (mitigation: require same-lock and presence of a global removal path).
- Containers that can be non-empty while specific node is already removed (mitigation: optionally search for node-specific membership checks and do not report if present).

8. Limitations & Assumptions
- Assumes container emptiness or an explicit membership guard is needed prior to deletion, following the fix pattern (based on PATCH_DIFF); node-specific membership checks not in the provided patch may exist elsewhere.
- Does not prove runtime interleaving; relies on structural presence of both removal paths under the same lock (as per ROOTCAUSE_ANALYSIS).
- RCU semantics and grace period ordering are not modeled precisely; synchronize_rcu presence is used only as a contextual signal.