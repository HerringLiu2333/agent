1. Plan Summary
Detect kernel list unlink operations that remove a node unconditionally under a lock while another teardown path can remove the same node(s) or empty the list under the same lock, risking double list deletion and list corruption.

2. Detection Steps
1) Step 1: Identify protected list structures — conceptual signals
- Find list heads H that are targets of list_add* calls (e.g., list_add_tail_rcu(node->list, H)).
- Record the mutex M used in close proximity to protect H (mutex_lock(M) … list_add … mutex_unlock(M)) and the node field L being linked (e.g., node->list).

2) Step 2: Find bulk teardown paths for H — conceptual signals
- Locate functions that, under the same mutex M, iterate H using list_for_each_entry(_safe) over H and call list_del(&entry->L) on each entry.
- Record these functions as “bulk remove” for pair (H, M), and note they empty H (fully or partially) while holding M.

3) Step 3: Find single-item removal functions for the same list — conceptual signals
- Locate functions that, under the same mutex M, call list_del_rcu(&X->L) or list_del(&X->L) on a parameter-derived or field-derived node X, not inside a loop over H.
- Record these functions as “single remove” for L under pair (H, M).

4) Step 4: Check for absence of membership/emptiness guards in single remove — conceptual signals
- Within each “single remove” function, check the control-flow path to list_del/list_del_rcu for a guard that ensures safety:
  - No preceding conditional that checks list_empty(H) (or equivalent global state indicating H was torn down) and exits/returns before deletion.
  - No check that confirms the node is currently linked to H (e.g., any presence check on H or X that would prevent a second unlink).
- If such guards are absent, mark as risky.

5) Step 5: Correlate with bulk teardown existence — conceptual signals
- For each risky “single remove,” confirm that a “bulk remove” for the same (H, M) exists in the codebase (same file or module).
- If both exist, escalate the finding: single-remove unlinks a node unconditionally while another path can unlink all nodes, creating a double-delete hazard.

6) Step 6: Flag mixing of list_del_rcu vs list_del across paths — conceptual signals
- If “single remove” uses list_del_rcu and “bulk remove” uses list_del (or vice versa) for the same node field L under the same (H, M), add a diagnostic note that mixed unlink APIs amplify the corruption risk in concurrent teardown.

7) Step 7: Validate lock consistency and atomicity of checks — conceptual signals
- Ensure both the guard (if present) and the list_del call are executed while holding the same mutex M.
- If a guard exists but is outside M’s critical section, treat it as ineffective and flag as missing/insufficient.

8) Step 8: Heuristic confirmation of removal semantics — conceptual signals
- In “single remove,” look for follow-up teardown such as synchronize_rcu() and unregister_netdevice() that indicate the function is a removal path; this raises confidence the unlink is final and should be idempotent/guarded.
- Use this as a severity boost, not a hard requirement.

9) Step 9: Report pattern akin to the CVE — conceptual signals
- Emit a result when:
  - A “single remove” unconditionally calls list_del/list_del_rcu on node field L under M,
  - There is a “bulk remove” that unlinks all entries from H under M,
  - And no membership/emptiness guard prevents the single remove when H has been (or may have been) emptied.
- Attach dataflow snippets: the head H expression, mutex M, node field L, and both function names.

3. Limitations & Assumptions
- The checker infers the protecting mutex by proximity; if locking is abstracted or uses different but equivalent locks, it may miss or misattribute protection.
- It assumes list membership checks are expressed via list_empty(H) or clearly equivalent guards; custom state flags or helper wrappers may evade detection.
- It does not prove concurrency; it flags structural risk when both paths exist for the same list under the same lock.
- It cannot verify that the node X is definitely part of H at runtime; it relies on structural association (same node field L and head H).
- The analysis focuses on Linux list APIs reflected in the provided materials; other container APIs are out of scope.