1. CVE Identifier
CVE-2024-57948

2. Vulnerability Type
Race condition leading to double list unlink and list corruption (kernel BUG/DoS)

3. Root Cause Summary
ieee802154_if_remove() unconditionally executed list_del_rcu(&sdata->list) even when the IEEE 802.15.4 hardware unregister path had already removed all interfaces (including sdata) from local->interfaces. This caused a double unlink of sdata->list: one via ieee802154_remove_interfaces() (list_del) and a second via ieee802154_if_remove() (list_del_rcu). The absence of a membership/emptiness check and coordination with the unregister sequence led to list corruption detected by __list_del_entry_valid_or_report(), triggering a kernel BUG.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IEEE 802.15.4 (mac802154) networking stack, interface management (net/mac802154/iface.c)

2) Pre-Patch Flaw:
ieee802154_if_remove() performed list_del_rcu(&sdata->list) under iflist_mtx without verifying that local->interfaces still contained any entries or that sdata remained linked. This unconditional deletion allowed a second unlink of sdata after ieee802154_remove_interfaces() had already done list_del(&sdata->list) during hardware unregistration.

3) Trigger Condition:
Concurrent interface deletion via generic netlink (CPU0: genl_family_rcv_msg_doit → ieee802154_del_iface → rdev_del_virtual_intf_deprecated → ieee802154_if_remove → list_del_rcu) and hardware device unregister (CPU1: ieee802154_unregister_hw → ieee802154_remove_interfaces → list_del(&sdata->list)). With the interfaces list already cleared, the subsequent list_del_rcu on an entry no longer in a list tripped list_debug assertions.

4) Impact Mechanism:
Double unlink corrupts the kernel’s list pointers, causing __list_del_entry_valid_or_report() to BUG (invalid prev/next invariants), leading to an immediate kernel crash (DoS). Given the use of RCU, improper unlinking could also expose readers to inconsistent state, but the observed impact is a hard BUG/oops.

5. Patch Analysis
1) Fix Approach:
Introduce a guard to avoid unlinking when the local interface list has already been emptied by the unregister path. This prevents double deletion of sdata->list.

2) Key Code Changes:
In ieee802154_if_remove():
- Added:
  if (list_empty(&sdata->local->interfaces)) {
    mutex_unlock(&sdata->local->iflist_mtx);
    return;
  }
- Retained the existing list_del_rcu(&sdata->list) only when the interfaces list is non-empty.

3) Locking/Concurrency Impact:
The patch keeps the existing mutex (iflist_mtx) but adds an early return under the lock, ensuring atomic check-and-decide behavior. It does not alter lock ordering; instead, it gates the unsafe operation based on container state, reducing the race window where a post-unregister list could be manipulated. It also implicitly harmonizes the RCU and non-RCU unlink paths by ensuring ieee802154_if_remove() does not perform list_del_rcu after ieee802154_remove_interfaces() has done list_del.

6. Broader Kernel Security Implications
This fix underscores the necessity of validating object/container state before performing unlink/free operations, especially when multiple teardown paths (netlink-driven interface removal vs. hardware unregister) can interact. Proper guarding prevents list corruption and kernel crashes, improving robustness against race conditions in subsystem teardown. The change also highlights careful coordination between RCU list operations and conventional list operations to avoid double unlinks and lifetime violations during concurrent removal.