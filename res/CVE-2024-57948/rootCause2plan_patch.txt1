1. Plan Summary
Detect unconditional kernel list unlinks of an interface node that can be concurrently unlinked on another teardown path, due to missing container/membership checks before list_del/list_del_rcu.

2. Detection Steps
1) Step 1: Identify candidate unlink sites — calls to list_del or list_del_rcu where the argument is a struct field address like &X->list (a per-element list_head). Signals: function calls to list_del(_rcu) taking a unary-address-of of a field named "list" or equivalent node member.

2) Step 2: For each candidate unlink site, identify the enclosing function and the node’s enclosing object and container. Signals: same function references to X->local and particularly a list head like X->local->interfaces, or code patterns suggesting that the node belongs to that container.

3) Step 3: Determine whether the function acquires the container’s protecting lock before unlinking (e.g., mutex_lock(&X->local->iflist_mtx)). Signals: lock/unlock calls on a field under X->local that brackets the unlink.

4) Step 4: Check if the function performs any guard ensuring the node is still linked or the container is non-empty before unlinking. Signals: a conditional using list_empty (or equivalent) on the container head (e.g., X->local->interfaces) leading to an early return or skipping the unlink; absence of such checks indicates risk.

5) Step 5: In the same module/file, search for other functions that also unlink the same node type from the same container. Signals: additional list_del or list_del_rcu calls on &Y->list where Y has the same struct type and the function references Y->local->interfaces (suggesting shared container).

6) Step 6: Correlate pairs of unlink functions that can act on the same nodes without explicit coordination. Signals: both functions touch X/Y->local->interfaces, both unlink &X/Y->list, and there is no shared serialization beyond per-function locking (e.g., same mutex) that would prevent concurrent removal across different call paths.

7) Step 7: Prioritize pairs where one function appears to be a device unregister/teardown path and the other a user-triggered interface delete path. Signals: function names containing unregister/remove and del/remove (e.g., ieee802154_unregister_hw/ieee802154_remove_interfaces versus ieee802154_if_remove/ieee802154_del_iface).

8) Step 8: Elevate severity if the two paths use different unlink primitives (list_del in one and list_del_rcu in the other), indicating potential mismatch in expectations and higher risk of double unlink. Signals: differing API names across the correlated pair.

9) Step 9: For each unguarded unlink site from Step 4 that has a correlated sibling unlink site from Step 5, emit a finding. Report the unguarded unlink location, the missing precondition (no container/member check under the lock), and the sibling unlink site(s) that can clear the same container, leading to potential double unlink.

10) Step 10: Suppress findings where the unguarded unlink site is immediately dominated by a proven membership/emptiness check of the relevant container under the same lock (e.g., list_empty(&X->local->interfaces) with early return), matching the patched pattern.

3. Limitations & Assumptions
- The checker infers container membership by textual/semantic proximity (e.g., references to X->local->interfaces); if the container is referenced indirectly or via helpers, it may be missed.
- It cannot prove runtime concurrency or RCU grace-period ordering; findings rely on the presence of multiple unlink sites without strong synchronization, which can yield false positives.
- It assumes that list_empty checks on the container head are the intended guard; alternative membership checks (e.g., per-node link-state invariants) may not be recognized.
- Function-role heuristics (names containing unregister/remove/del) are best-effort and may not generalize beyond the observed patterns.