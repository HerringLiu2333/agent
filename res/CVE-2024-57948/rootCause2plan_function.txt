1. Plan Summary
Detect functions that delete a list node unconditionally while another function can bulk-delete all nodes of the same list under the same lock, without a state check, leading to potential double deletion and list corruption (as in CVE-2024-57948).

2. Detection Steps
1) Step 1: Identify list topology — find where a node field is linked to a specific list head. Signals: calls to list_add* (e.g., list_add_tail_rcu) that take &X->list and &Y->interfaces, establishing the (node-field, head-field) pair (based on FUNCTION_CONTENT). FP mitigation: restrict to canonical Linux list APIs and record the exact field access chain (e.g., X->local->interfaces).

2) Step 2: Extract the protecting lock for that list — determine the mutex/lock consistently used for mutations. Signals: mutex_lock/unlock around list_add*, list_del*, or iteration on the same head (e.g., local->iflist_mtx in both functions per FUNCTION_CONTENT). FP mitigation: require the same lock expression (same field path/type) to be present around the operations.

3) Step 3: Locate bulk-removal functions that can empty the list. Signals: a function that iterates with list_for_each_entry_safe over the identified head and calls list_del (or list_del_rcu) on each element within the same lock (see ieee802154_remove_interfaces in FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: require the iteration head to be exactly the recorded head-field and the deletion to be inside the locked region.

4) Step 4: Locate per-node removal functions for the same list. Signals: a function that, under the same lock, deletes a single node via list_del_rcu(&X->list) (see ieee802154_if_remove in FUNCTION_CONTENT). FP mitigation: ensure the node field matches the earlier list_add* mapping and the lock matches Step 2.

5) Step 5: Verify absence of a guard that prevents unsafe deletion after bulk teardown. Signals: immediately before the per-node list_del*, no conditional that checks list_empty(&X->local->interfaces) with an early return/unlock (per PATCH_DIFF the fix adds this guard). FP mitigation: consider the guard present only if it dominates the deletion along all paths; otherwise flag.

6) Step 6: Confirm that the bulk-removal function fully empties the list. Signals: loop covers entire list head and there is no early exit before deleting each encountered node; deletion uses list_del (see FUNCTION_CONTENT). FP mitigation: require the loop to be the top-level iteration directly over the head and deletion unconditionally applied to loop variable.

7) Step 7: Correlate head and lock across functions to demonstrate a race-prone pair. Signals: both per-node and bulk-removal functions operate on the same head-field (e.g., local->interfaces) and same lock (e.g., local->iflist_mtx) as per ROOTCAUSE_ANALYSIS. FP mitigation: require structural equivalence of the field access chains and the same struct types for local and sdata.

8) Step 8: Boost confidence if life-cycle teardown semantics are present. Signals: per-node removal followed by synchronize_rcu and/or unregister_netdevice (see FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: treat this as a confidence signal, not a strict requirement, to avoid missing minimal reproductions.

9) Step 9: Exclude cases where the per-node remover is only called inside the bulk-removal loop. Signals: call graph showing the per-node deletion site is not invoked exclusively from within the bulk-removal iterator. FP mitigation: if the only callers are within the bulk loop, do not flag.

10) Step 10: Report a finding when Steps 1–7 hold and Step 5 fails. Signals: point the alert at the per-node list_del* call site and reference the paired bulk-removal function that empties the same head (mapping to the missing state validation root cause in ROOTCAUSE_ANALYSIS). FP mitigation: include the evidence set (head, lock, add-site, bulk-remover) to help manual triage.

3. Target Elements
- Functions that call Linux list primitives: list_add*, list_del*, list_del_rcu, list_for_each_entry_safe.
- Lock acquisition/release sites around list operations (e.g., mutex_lock/unlock on a specific field like local->iflist_mtx).
- Field access chains establishing node-to-head relationships (e.g., &sdata->list with &local->interfaces).
- Condition checks guarding deletions (e.g., list_empty(&head) with early return).
- Calls to lifecycle/teardown APIs (e.g., synchronize_rcu, unregister_netdevice) as confidence signals.

4. Dataflow / Taint Considerations
- Track the association between node fields and list heads via list_add* to form (node-field, head-field) pairs.
- Propagate the base object relationship (e.g., X->local and Y) to unify expressions across functions (sdata->local->interfaces vs local->interfaces).
- Track the lock variable/path used around list operations to ensure both functions share the same mutual exclusion.
- Dominance/path analysis to verify absence/presence of guard condition before deletion.

5. Validation & Test Cases
- Positive: Pre-patch ieee802154_if_remove that unconditionally calls list_del_rcu(&sdata->list) under local->iflist_mtx, combined with ieee802154_remove_interfaces that iterates &local->interfaces and list_del’s each entry (FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS). Expect a finding.
- Negative: Post-patch ieee802154_if_remove with the added if (list_empty(&sdata->local->interfaces)) { unlock; return; } before list_del_rcu (PATCH_DIFF). Expect no finding.
- Negative: A per-node removal under a different lock or acting on a different head than the bulk-remover. Expect no finding.
- Test harness notes: Ensure the analyzer recognizes Linux list macros and field-access equivalence across parameter names (e.g., sdata->local vs local).

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where external invariants ensure the per-node remover cannot race with bulk removal; mitigate by requiring same lock and explicit bulk-empties-list evidence.
- Alternative guards not using list_empty(&head); mitigate by acknowledging only the specific guard seen in PATCH_DIFF and documenting limitations.
- Complex aliasing of head/lock expressions; mitigate by requiring structurally identical field paths and types.

8. Limitations & Assumptions
- Assumes Linux list APIs and locking patterns; other container types are out of scope.
- Cannot conclusively prove runtime concurrency; relies on presence of a bulk remover that empties the list under the same lock (ROOTCAUSE_ANALYSIS).
- Only the specific state guard (list_empty(&head) + early return) is recognized from PATCH_DIFF; other safe patterns (if any) are not captured due to lack of evidence.
- Does not verify RCU correctness beyond recognizing synchronize_rcu/unregister_netdevice as confidence signals.