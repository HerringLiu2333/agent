1. Plan Summary
Detect kernel list unlink operations that can race with a concurrent teardown path, where a function unconditionally calls list_del or list_del_rcu on an element without first verifying container/list membership (e.g., list_empty on the container), leading to double unlink and list corruption as in CVE-2024-57948.

2. Detection Steps
1) Step 1: Identify candidate unlink sites — find call sites of list_del or list_del_rcu whose argument is a list node field of a struct (e.g., &obj->list) within a function. This captures the unsafe primitive highlighted in [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]; reduce FPs by restricting to Linux kernel list APIs only.

2) Step 2: Record the node and its enclosing function — extract the base variable (e.g., sdata) and the specific list member being unlinked (e.g., .list) plus the function name. This ties the unlink to a concrete node/context to correlate with other paths that may unlink the same element ([ROOTCAUSE_ANALYSIS]).

3) Step 3: Detect presence of a guarding emptiness/membership check — within the same function and before the unlink, look for a conditional that checks list_empty on a relevant container list head (e.g., obj->owner->interfaces) and gates/returns before unlink, as added in [PATCH_DIFF]. This maps directly to the fix; if the guard is missing, it suggests the pre-patch flaw.

4) Step 4: Check locking scope around the unlink — verify the unlink occurs while a mutex protecting the list (e.g., iflist_mtx) is held, and that any emptiness check (if present) is inside the same critical section ([PATCH_DIFF]). Flag higher risk when the unlink is under a lock but lacks the guard, since the patch does exactly that; ignore cases where no locking is used only if a clear membership check exists to avoid removing non-linked nodes.

5) Step 5: Corroborate a second removal path — in the same file/module, search for another function that either iterates the same container list and calls list_del on entries or directly unlinks the same node field type (e.g., ieee802154_remove_interfaces doing list_del on sdata->list, per [ROOTCAUSE_ANALYSIS]). This supports the “double unlink” risk and reduces FPs by requiring at least two unlink sites affecting the same list.

6) Step 6: Relate unlink sites to a common container — for the candidate function, derive the container head expression reachable from the node (e.g., obj->local->interfaces), and check that the corroborating function accesses/unlinks entries from the same container head. This enforces that both sites can target the same list ([ROOTCAUSE_ANALYSIS]).

7) Step 7: Assess path semantics by naming and call relationships — boost confidence if one function name indicates interface removal via netlink (e.g., contains “if_remove”/“del_iface”) and the other indicates hardware unregister/bulk removal (e.g., “remove_interfaces”/“unregister”), as shown in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]. Use these name heuristics to prioritize/report issues and suppress cases lacking any remove/unregister semantics.

8) Step 8: Check for alternative membership guards — consider it guarded (and do not flag) if the function tests for membership of the node or safe-to-unlink state before unlink (e.g., explicit list_empty on the container head, or an early return when container is empty as in [PATCH_DIFF]). This directly reflects the fix’s intent to prevent unlink when the container is already empty.

9) Step 9: Prefer RCU-sensitive cases — prioritize unlink sites using list_del_rcu when another path uses list_del on the same list, reflecting the mismatch seen in [ROOTCAUSE_ANALYSIS] that aggravated list corruption. This reduces noise by focusing on patterns with higher risk.

10) Step 10: Exclude single-owner/single-unlink patterns — if static analysis shows the node is only ever unlinked in one function in the module and no other function iterates/removes from the same container, do not flag. This mitigates FPs where double unlink is structurally impossible.

11) Step 11: Report when all risk signals align — raise an alert when an unconditional unlink is found without a container/membership guard under lock, and a second function exists that removes from the same container list. Explain that an emptiness/membership check (as added in [PATCH_DIFF]) is missing and may lead to double unlink/race per [ROOTCAUSE_ANALYSIS].

12) Step 12: Optional severity boost — increase severity if a debug list assertion or BUG trace is referenced in comments or strings near the code (list_debug), matching the crash evidence in [PATCH_DESCRIPTION]; otherwise keep default severity.

3. Target Elements
- Functions performing list operations (list_del, list_del_rcu) on struct list_head members.
- Conditional checks involving list_empty on container list heads.
- Locking boundaries (mutex_lock/mutex_unlock) around list operations.
- Functions that iterate container lists and bulk-remove entries.
- Function names indicating remove/unregister semantics.
- Call sites and intra-file function relationships to correlate shared containers.

4. Dataflow / Taint Considerations
- Track the base node variable used in list_del/list_del_rcu to its owning struct and up to the container list head expression (e.g., obj -> obj->local -> obj->local->interfaces).
- Correlate unlink sites by matching node member field access patterns and/or shared container head expressions across functions.
- Scope checks and operations within the same critical section to ensure the guard protects the unlink.

5. Validation & Test Cases
- Positive: A function like ieee802154_if_remove that takes sdata, locks iflist_mtx, unconditionally calls list_del_rcu(&sdata->list) without any preceding list_empty(&sdata->local->interfaces) or equivalent guard; another function in the same file (ieee802154_remove_interfaces) iterates local->interfaces and calls list_del on entries.
- Negative: The patched variant of ieee802154_if_remove that locks iflist_mtx, checks list_empty(&sdata->local->interfaces) and returns early before list_del_rcu when empty, then unlinks otherwise.
- Negative: A module where only one function ever unlinks a specific node field and no other function touches or iterates the same container list.
- Test harness notes: Run on pre- and post-patch versions of net/mac802154/iface.c to confirm one true positive pre-patch and no findings post-patch.

6. Estimated Effort & Priority
Medium effort, high priority due to kernel BUG/DoS impact per [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION].

7. Likely False-Positive Sources & Mitigations
- Cases where invariants guarantee membership but are not syntactically visible; mitigate by requiring corroborating bulk-remove/second unlink path.
- Code that uses different membership checks (flags) instead of list_empty; mitigate by allowing alternative guards when clearly gating unlink.
- Unrelated lists with same field name “list”; mitigate by matching container head expression shared across functions.
- Functions holding global serialization that precludes races; mitigate by prioritizing RCU/list_del_rcu mixes and remove/unregister naming signals.

8. Limitations & Assumptions
- Concurrency and RCU grace-period ordering cannot be proven statically; the checker infers risk from structural patterns.
- Precise mapping from node to container head may fail if computed via complex indirections not visible intra-procedurally.
- The plan assumes Linux kernel list APIs (list_del, list_del_rcu, list_empty) as in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; other custom list APIs are out of scope.
- Membership checks other than list_empty may be missed unless syntactically apparent near the unlink.