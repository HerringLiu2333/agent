1. CVE Identifier
CVE-2025-38298

2. Vulnerability Type
Out-of-bounds array access due to stale/lifecycle state (missing counter reset)

3. Root Cause Summary
The skx_edac_common module failed to reset the global ADXL component counter (adxl_component_count) on module teardown. When i10nm_edac was unloaded (leaving skx_edac_common loaded) and then reloaded, the ADXL component discovery incremented the already non-zero counter, doubling it relative to the actual array size. Subsequent decoding paths (e.g., skx_adxl_decode) used this inflated count to index the ADXL component arrays, causing out-of-bounds access and a general protection fault.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
EDAC (Error Detection And Correction) for Intel server platforms (skx_edac_common with i10nm_edac)

2) Pre-Patch Flaw:
In skx_adxl_put(), the code freed ADXL buffers but did not reset adxl_component_count; the function contained only “kfree(adxl_values);” and “kfree(adxl_msg);” with no counter reset. Because skx_edac_common remained loaded across i10nm_edac unload/reload, the stale non-zero counter accumulated on each reload.

3) Trigger Condition:
Unload only i10nm_edac (skx_edac_common stays loaded), then reload i10nm_edac and perform error injection tests. The counter is incremented again during ADXL component enumeration, producing a count larger than the actual number of components.

4) Impact Mechanism:
The inflated adxl_component_count drives loops/indices in skx_adxl_decode, leading to out-of-bounds references to the ADXL component arrays (adxl_values/adxl_msg). This invalid access surfaces during string formatting (string/vsnprintf/snprintf) in the decode path, causing a general protection fault in the mce_gen_pool_process workqueue, as shown in the stack trace.

5. Patch Analysis
1) Fix Approach:
Reset the global ADXL component counter during teardown to ensure a clean state for subsequent reloads.

2) Key Code Changes:
In skx_adxl_put(), the patch adds “adxl_component_count = 0;” before freeing adxl_values and adxl_msg:
- skx_adxl_put(): added a counter reset to zero, preserving correct bounds on re-init.

3) Locking/Concurrency Impact:
No locking or ordering changes were introduced. The change is a simple state reset during module teardown, which aligns with the module unload lifecycle and avoids stale global state; concurrency aspects remain unchanged.

6. Broader Kernel Security Implications
Failing to reset global state across module reloads can yield out-of-bounds accesses, leading to kernel crashes and potential memory corruption. EDAC paths often execute in workqueues and under error-handling contexts, so robustness against lifecycle issues is critical. This fix highlights the need to systematically reset counters and sizes in shared/common EDAC modules and to consider defensive bounds checks in decode paths to mitigate similar state-related bugs.