1. CVE Identifier
CVE-2025-38298

2. Vulnerability Type
Out-of-bounds access (OOB read) due to stale global state not reset on module teardown

3. Root Cause Summary
A global counter adxl_component_count in skx_edac_common was not reset during teardown (skx_adxl_put). After unloading only i10nm_edac and reloading it, the initialization path incremented adxl_component_count again, making it larger than the actual number of ADXL components. skx_adxl_decode later used this inflated count to iterate over ADXL component arrays (e.g., adxl_values/adxl_msg), indexing past their valid bounds. This out-of-bounds access led to a general protection fault during string formatting (vsnprintf/string) in the machine check processing path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
EDAC (Skylake/Xeon common EDAC code shared by i10nm_edac and skx_edac_common)

2) Pre-Patch Flaw:
The teardown function skx_adxl_put failed to reset the global ADXL component counter; it only freed adxl_values and adxl_msg. As a result, on subsequent module reload, adxl_component_count accumulated (double-counted) components, desynchronizing the counter from the actual array sizes and contents used by skx_adxl_decode.

3) Trigger Condition:
Unload only the i10nm_edac module (which auto-loads skx_edac_common), then reload i10nm_edac and perform EDAC error injection testing. The workqueue mce_gen_pool_process processes MCE events, invoking skx_mce_check_error â†’ skx_adxl_decode, which uses the stale doubled adxl_component_count.

4) Impact Mechanism:
skx_adxl_decode iterates up to adxl_component_count and accesses ADXL component arrays beyond their valid bounds. The out-of-bounds reference causes vsnprintf/string to operate on invalid memory, resulting in a general protection fault and kernel oops (DoS).

5. Patch Analysis
1) Fix Approach:
Reset the global state during teardown by setting adxl_component_count = 0 in skx_adxl_put so that subsequent reloads start from a clean state and the counter matches the actual number of components.

2) Key Code Changes:
In skx_adxl_put:
- Added a one-line state reset: adxl_component_count = 0;
- This is placed before freeing adxl_values and adxl_msg, ensuring no stale count remains after unload.
Patch hunk:
+ adxl_component_count = 0;
  kfree(adxl_values);
  kfree(adxl_msg);

3) Locking/Concurrency Impact:
No locking changes introduced. The fix operates in the module teardown path, resetting a global variable to eliminate stale state across unload/reload cycles; any additional concurrency considerations are unknown/not determinable from the provided diff.

6. Broader Kernel Security Implications
Failing to reset global/module state during teardown can lead to desynchronized counters and arrays, causing OOB accesses, crashes, or potential info leaks. EDAC paths are exercised by asynchronous workqueues (e.g., MCE handling), magnifying the impact of stale state when modules are reloaded. While exploitation requires privileged control over module load/unload and error injection, the bug leads to kernel DoS and highlights the need for robust teardown/reset of shared common-code state in modular subsystems. Ensuring counters and buffers are consistently reinitialized prevents similar lifetime/state bugs across reloads.