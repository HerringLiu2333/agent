1. CVE Identifier
CVE-2025-38298

2. Vulnerability Type
Out-of-bounds read due to stale global state (module unload/reload lifecycle bug)

3. Root Cause Summary
The global counter adxl_component_count in skx_edac_common was not reset on module unload. On reload, skx_adxl_get() incremented the already non-zero counter again (via while (*names++) adxl_component_count++;), making it larger than the actual number of ADXL components. Subsequent iterations in skx_adxl_decode() used this inflated bound to index adxl_component_names[i] and adxl_values[i], causing an out-of-bounds read and a general protection fault in snprintf().

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- EDAC (Error Detection and Correction) for Intel server processors, shared code skx_common (used by skx_edac and i10nm_edac), specifically ADXL decode support.

2) Pre-Patch Flaw:
- skx_adxl_put() freed adxl_values and adxl_msg but did not reset adxl_component_count to 0.
- skx_adxl_get() relies on adxl_component_count being zeroed before counting: while (*names++) adxl_component_count++; (FILE_CONTENT).
- skx_adxl_decode() iterates up to adxl_component_count and prints component names/values: len += snprintf(..., " %s:0x%llx", adxl_component_names[i], adxl_values[i]); (FILE_CONTENT).

3) Trigger Condition:
- Load i10nm_edac (which brings in skx_edac_common), unload only i10nm_edac, then reload i10nm_edac, and trigger error decoding (e.g., via MCE handling/error injection). On reload, adxl_component_count is double-counted.

4) Impact Mechanism:
- The doubled adxl_component_count causes skx_adxl_decode() to index past the actual end of adxl_component_names (and beyond valid adxl_values), resulting in an invalid pointer passed to snprintf(), leading to a general protection fault (as seen in call trace: string/vsnprintf/snprintf â†’ skx_adxl_decode).

5. Patch Analysis
1) Fix Approach:
- Reset the global counter during teardown to restore a clean state for subsequent reloads, preventing over-counting.

2) Key Code Changes:
- In skx_adxl_put():
  - Added: adxl_component_count = 0; (PATCH_DIFF).
  - This ensures that the next skx_adxl_get() recomputes the component count from zero and that later loops in skx_adxl_decode() stay within bounds.

3) Locking/Concurrency Impact:
- No locking changes. The fix is a simple state reset in the module unload path; no concurrency primitives were introduced or modified.

6. Broader Kernel Security Implications
- Highlights the risk of stale global state in common code shared by loadable modules; improper teardown can lead to memory safety issues on reload.
- While primarily a reliability/DoS issue (kernel oops) under module management operations, it underscores the need to comprehensively reset all global state during module removal to prevent OOB accesses and potential exploitation paths in other subsystems with similar patterns.