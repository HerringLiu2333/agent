1. Plan Summary
Detect missing resets of global size/counter variables during teardown that are used as array bounds elsewhere, leading to out-of-bounds accesses after module reload/lifecycle reuse.

2. Detection Steps
1) Step 1: Objective — find global scalar counters used to bound iteration over global buffers. Signals — a global integral variable appears in loop bounds/conditions that control indexing into a global pointer/array (e.g., i < count; array[i]). FP mitigation — restrict to cases where the same function reads both the counter and the array to form an index, as in the decode path described in [ROOTCAUSE_ANALYSIS 4].

2) Step 2: Objective — associate counters with specific arrays. Signals — identify pairs (C, A) where C is used as the upper bound and A is indexed by a loop variable constrained by C in at least one function. FP mitigation — require at least one non-teardown function that accesses both C and A, reflecting decode-like behavior per [ROOTCAUSE_ANALYSIS 4].

3) Step 3: Objective — locate teardown/free functions for those arrays. Signals — functions that call kfree (or equivalent deallocation) on the associated global arrays (e.g., adxl_values, adxl_msg in skx_adxl_put per [FUNCTION_CONTENT]). FP mitigation — prefer functions that free more than one related array or have “put”/teardown naming or are paired with an exported “get” (see [FUNCTION_CONTENT], [PATCH_DESCRIPTION]).

4) Step 4: Objective — detect absence of counter reset in teardown. Signals — in the teardown function, there is no assignment that sets the associated counter C to a baseline value (e.g., zero); pre-patch skx_adxl_put lacked “adxl_component_count = 0” per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS 5]. FP mitigation — consider an assignment equivalent to reset only if it is unconditional along all exit paths of teardown.

5) Step 5: Objective — strengthen confidence by finding accumulation-style updates in init/discovery paths. Signals — writes to C that depend on its prior value (C++, C += x, C = C + x) in functions that allocate or enumerate components; matches “incremented again” in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS 3]. FP mitigation — require that at least one such self-referential update exists outside teardown; ignore single plain assignment C = K (constant) as that suggests reinitialization.

6) Step 6: Objective — confirm lifecycle pairing (get/put) patterns. Signals — presence of a “get” or init function exported/public (e.g., EXPORT_SYMBOL_GPL(skx_adxl_get) in [FUNCTION_CONTENT]) and a similarly named “put” that frees arrays; suggests module reload/teardown context per [PATCH_DESCRIPTION]. FP mitigation — if no lifecycle pair is evident, lower priority of the alert.

7) Step 7: Objective — verify that the counter influences array access beyond teardown. Signals — identify any function (e.g., decode-like) that indexes A in a loop bounded by C and performs operations that could fault if OOB (e.g., string formatting chains as seen in [PATCH_DESCRIPTION] call trace). FP mitigation — require that the loop performs at least one dereference of A[i] or pointer arithmetic based on the loop variable.

8) Step 8: Objective — exclude safe cases where init reliably resets the counter before accumulation. Signals — within an init/get path that allocates/populates A, a dominating assignment C = 0 occurs before any self-referential updates to C on all paths. FP mitigation — only suppress the alert if the reset is clearly unconditional and textually/control-flow dominates increments in the same init phase.

9) Step 9: Objective — handle multiple arrays sharing one counter. Signals — the same counter C bounds access to multiple arrays that are freed in teardown (e.g., adxl_values and adxl_msg per [FUNCTION_CONTENT]); treat them as a single association group. FP mitigation — require at least one of the arrays in the group to be freed in teardown and referenced under C-bound loops.

10) Step 10: Objective — produce a consolidated finding. Signals — report when a (C, A-group) has: C used as bounds for A’s indexing; teardown frees A without resetting C; and at least one accumulation-style update of C exists. FP mitigation — include contextual evidence: names of get/put functions, presence/absence of C reset, locations of C-increment and A-index use, echoing the pattern fixed in [PATCH_DIFF] and explained in [ROOTCAUSE_ANALYSIS 3–5].

3. Target Elements
- Global variables: integral counters/size trackers and global pointers/arrays.
- Functions: teardown/free functions (e.g., “put”), init/get/discovery functions, decode/consumer functions.
- Call sites: kfree/deallocation calls on globals; EXPORT annotations indicating public lifecycle functions (per [FUNCTION_CONTENT]).
- Loop constructs and array indexing expressions that use counters as bounds.
- Assignments/updates to counters (increments, +=, self-referential assignments).

4. Dataflow / Taint Considerations
- Track dataflow from a counter variable to loop bounds/conditions controlling indices used to access associated arrays.
- Track writes to counters to distinguish resets (assignment from constant zero) from accumulative updates (depend on previous value) across functions.
- Track the association between arrays freed in teardown and arrays indexed elsewhere under the counter’s bound.
- Optional: track reachability between get/init and decode functions to strengthen lifecycle linkage, without requiring precise module unload semantics.

5. Validation & Test Cases
- Positive: A global array A and counter C; a decode() loops for i < C and accesses A[i]; get() allocates A and does C += discovered; put() frees A but does not set C = 0. Expect a finding highlighting missing reset in put() and accumulation in get().
- Positive: Two arrays A1, A2 bounded by the same C; teardown frees both without resetting C; decode uses C to index A1; get increments C. Expect a finding.
- Negative: Teardown frees A and sets C = 0 (as in [PATCH_DIFF]). Expect no finding.
- Negative: Init/get assigns C = 0 before any increments in all paths, even if teardown doesn’t reset; decode uses C to index A. Expect no finding due to dominating reset.
- Test harness notes: Include variants with different naming (not only “get/put”) and ensure the checker tolerates additional code in teardown while still detecting absence of reset.

6. Estimated Effort & Priority
High — security impact includes out-of-bounds kernel access per [PATCH_DESCRIPTION], and analysis requires interprocedural association and update classification.

7. Likely False-Positive Sources & Mitigations
- Counters that bound arrays but are always reset in init: mitigate via dominating-reset check (Step 8).
- Unrelated free functions: mitigate by requiring (C, A) association via joint usage and accumulation evidence (Steps 1–2, 5).
- Counters used for statistics rather than sizing: mitigate by requiring actual array indexing under the counter-bound loop (Step 7).
- Teardown that conditionally resets: mitigate by requiring unconditional reset along all teardown paths (Step 4).

8. Limitations & Assumptions
- Assumes availability of global variable resolution and interprocedural control-flow to infer dominating resets; exact module unload/reload sequencing is not derivable from the provided materials.
- Cannot prove runtime reload behavior; relies on static lifecycle heuristics (get/put naming and exports) informed by [FUNCTION_CONTENT] and [PATCH_DESCRIPTION].
- Does not model concurrency or locking; [ROOTCAUSE_ANALYSIS 5] states no locking changes, but the checker does not verify races.
- The presence of string formatting in the call trace is not explicitly leveraged beyond confirming decode-like consumers; the checker focuses on array-bound misuse per [ROOTCAUSE_ANALYSIS 4].