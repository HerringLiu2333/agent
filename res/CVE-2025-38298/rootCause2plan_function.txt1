1. Plan Summary
Detect teardown functions that free global component arrays but fail to reset an associated global counter used to bound indexing, which can cause out-of-bounds accesses after re-initialization.

2. Detection Steps
1) Step 1: Identify teardown-like functions that free global buffers. Signals: functions that call kfree on global pointers (e.g., adxl_values, adxl_msg), especially those named with “put” and co-located with a corresponding “get” export.
2) Step 2: For each freed global pointer, find an associated global counter/size variable. Signals: integer global with “count/num” naming (e.g., adxl_component_count) referenced in the same file and used with the freed arrays.
3) Step 3: Confirm the counter is used to bound iteration or indexing into the arrays. Signals: the counter appears in loop conditions or as a limit when accessing array elements or formatting messages based on those arrays (e.g., decode paths).
4) Step 4: Establish that the counter is incremented during initialization/discovery rather than being constant. Signals: updates via ++, +=, or additive assignments in “get”/init/enumeration functions (e.g., skx_adxl_get or discovery routines).
5) Step 5: In the teardown function, check whether the counter is reset to zero. Signals: presence or absence of an assignment setting the identified counter to 0 in the same function that calls kfree.
6) Step 6: Flag a finding when all of the following hold: the teardown frees arrays, the counter controls array indexing elsewhere, the counter is incremented during init, and the teardown does not reset the counter. Signals: conjunction of Steps 1–5 on the same set of globals/functions.
7) Step 7: Prioritize findings where the counter flows into string formatting or decode paths. Signals: the counter is used inside functions that call string/vsnprintf/snprintf while indexing the freed arrays (as seen in skx_adxl_decode).

3. Limitations & Assumptions
- Assumes naming and structural conventions (e.g., “get/put” pairing, “count” naming) to associate counters with buffers; mismatches may reduce accuracy.
- Static analysis cannot confirm module unload/reload sequences; it infers risk from lifecycle patterns (free without reset plus increment-on-init).
- The exact decode/access sites (e.g., skx_adxl_decode) are not provided; the checker must infer indexing/loop bounds from general usage of the counter with the freed arrays.
- Concurrency, locking, and cross-module call contexts are not analyzed; the checker focuses solely on state-reset omissions in teardown functions.