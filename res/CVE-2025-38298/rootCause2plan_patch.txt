1. Plan Summary
Detect global counters/length variables used to bound iteration over global arrays that are freed in a teardown function but where the counters are not reset on teardown and are incrementally updated during initialization, leading to stale, inflated counts and potential out-of-bounds access after module reload (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).

2. Detection Steps
1) Step 1: Identify teardown functions — look for functions that free global/module-scope buffers (e.g., kfree on file-scope pointers) and have teardown-like naming or lifecycle roles (names containing put/exit/teardown or referenced by module exit paths) — to cut noise, require ≥1 kfree of a global pointer or being an exported/entry teardown routine (from PATCH_DIFF adding reset in skx_adxl_put).
2) Step 2: Collect freed arrays/pointers in teardown — record the global variables freed (e.g., adxl_values, adxl_msg) — only keep globals (file-scope or static) to match module-lifetime state (from PATCH_DIFF).
3) Step 3: Find associated global counters — search for global variables used as loop bounds or size-like parameters in functions that index into those freed arrays (e.g., loops with index < counter accessing array[index]) — require direct or obvious derived use to associate the counter with the arrays (from ROOTCAUSE_ANALYSIS: counter bounds ADXL arrays).
4) Step 4: Check teardown does not reset associated counters — in the teardown function identified, verify that the associated counter lacks an assignment to a reset value (e.g., 0) — this mirrors the pre-patch flaw of missing adxl_component_count reset (from PATCH_DIFF and ROOTCAUSE_ANALYSIS).
5) Step 5: Identify initialization paths updating the counter — locate functions that allocate or (re)initialize the freed arrays and also modify the counter via accumulation (e.g., ++, +=, or adding discovered counts) — this matches the double-counting mechanism described (from ROOTCAUSE_ANALYSIS).
6) Step 6: Confirm absence of dominating reset in initialization — ensure there is no unconditional assignment that resets the counter to a baseline (e.g., zero) at the start of the initialization path before increments — this distinguishes safe reinit from accumulation across reloads (from ROOTCAUSE_ANALYSIS on accumulation).
7) Step 7: Verify counter-driven iteration on arrays — find places (non-init/teardown) where a loop condition uses the counter to control iteration and the loop body indexes into one of the freed arrays — this ties the stale counter to possible OOB in processing paths (from ROOTCAUSE_ANALYSIS: skx_adxl_decode iterates to counter and accesses arrays).
8) Step 8: Strengthen association via allocation sizing (optional) — if detectable, note where arrays are allocated with sizes not directly derived from the counter that later bounds iteration, suggesting a desynchronization risk — use as a confidence booster, not a requirement (from ROOTCAUSE_ANALYSIS on desynchronization).
9) Step 9: Exclude locals and per-call state — filter out counters or arrays with automatic storage or confined to a single function to avoid non-persistent state issues — the bug concerns module-global state surviving unload/reload (from ROOTCAUSE_ANALYSIS).
10) Step 10: Report when all key signals align — flag cases where: a teardown frees global arrays but does not reset an associated global counter; the counter is incrementally updated in init without a dominating reset; and the counter bounds iteration indexing into those arrays elsewhere — this pattern matches the pre-patch flaw causing OOB after reload (from PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS).
11) Step 11: Reduce false positives by lifecycle linkage — prefer cases where teardown and init are within the same module/translation unit and where teardown is called on unload (e.g., via naming/exports) — deprioritize warnings lacking evidence of both init and teardown in the same component (from Kernel subsystem lifecycle described in ROOTCAUSE_ANALYSIS).
12) Step 12: Rank severity — increase severity if the bounded iteration feeds into string formatting or other memory-sensitive operations in asynchronous paths (e.g., workqueue handlers), as indicated in the call trace; otherwise keep as medium severity — this mirrors the observed general protection fault path (from PATCH_DESCRIPTION).

3. Target Elements
- Functions: teardown/put/exit functions, init/setup functions, decode/processing functions using the arrays.
- Call sites: kfree calls on global pointers; allocation sites for arrays (kmalloc/kzalloc) in init.
- Variables: file-scope/static global counters used as loop bounds; global arrays/pointers freed in teardown and indexed elsewhere.
- Control structures: loops whose bounds use global counters and bodies index into associated arrays.
- Assignments/updates: counter updates (++, +=) vs. resets (assignment to 0).

4. Dataflow / Taint Considerations
- Track dataflow from global counters into loop conditions and into expressions used to index associated arrays.
- Track association between arrays freed in teardown and their uses where indexing is governed by the counter.
- Track counter updates across init paths to distinguish accumulation (increment/add) from reset (assignment to zero).
- Optional: track allocation size expressions to see whether they are or are not derived from the same counter used in iteration.

5. Validation & Test Cases
- Positive: A module with global int component_count; arrays global pointers freed in put(); init() enumerates components and does component_count += found; decode() loops i < component_count and accesses arrays[i]; put() frees arrays but does not set component_count = 0 — expect a warning.
- Negative: Same as positive but put() assigns component_count = 0 before frees — expect no warning.
- Negative: init() begins with component_count = 0; subsequent increments occur, and put() frees arrays — expect no warning due to dominating reset in init.
- Test harness notes: Compile unit-level C files modeling module init/exit, with globals, kmalloc/kfree calls, and loops using the counter; verify that association logic links the counter to arrays used in loops.

6. Estimated Effort & Priority
Medium — requires interprocedural analysis to associate counters with arrays and to recognize init/teardown semantics, but patterns are well-scoped and frequent in kernel code.

7. Likely False-Positive Sources & Mitigations
- Counters intentionally persistent across unload/reload or used for diagnostics only — mitigate by requiring array-indexing use governed by the counter.
- Teardown that is never actually invoked on unload — mitigate by preferring functions with teardown-like naming or module exit linkage.
- Arrays not actually bounded by the counter despite co-occurrence — mitigate by requiring loop index < counter and array[index] within the same loop.
- Macros/inline wrappers around kfree/kmalloc obscuring signals — mitigate by recognizing common kernel alloc/free wrappers where possible.

8. Limitations & Assumptions
- Cannot conclusively determine module unload/reload event ordering; relies on heuristics (naming/exports) to identify teardown.
- Exact allocation sizes vs. actual component count derivations may be opaque; the checker infers association via use patterns, not exact sizes.
- Concurrency and asynchronous execution context (e.g., workqueues) are not modeled; impact severity is inferred from usage sites.
- This plan assumes C code patterns similar to those in the kernel (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS) and may need adaptation for other environments.