1. Plan Summary
Detect stale global counters used as loop bounds across module init/teardown that are not reset on teardown, leading to out-of-bounds reads on arrays during later use.

2. Detection Steps
1) Step 1: Objective: find file-scope global integer counters whose value persists across calls. Signals: static/global int-like variables read/written in multiple functions (e.g., adxl_component_count in [FILE_CONTENT]). FP mitigation: exclude locals and non-static globals passed by pointer to avoid per-instance counters.

2) Step 2: Objective: identify “init/get” functions that populate such counters by accumulation instead of assignment. Signals: functions where the counter is incremented in a loop based on traversing a list/sentinel-terminated array (e.g., while (*names++) adxl_component_count++; in skx_adxl_get() from [FILE_CONTENT]) and with no assignment to zero before the loop. FP mitigation: require absence of any dominating write setting the counter to a constant (especially 0) within the function.

3) Step 3: Objective: detect allocations sized from the counter within the same init/get function. Signals: allocation calls (e.g., kcalloc) whose element count argument is the counter, assigning to a global pointer (e.g., adxl_values = kcalloc(adxl_component_count, ...) in [FILE_CONTENT]). FP mitigation: ensure the allocation happens after the accumulation loop, indicating reliance on the counter’s current value.

4) Step 4: Objective: detect a “teardown/put/remove” function corresponding to the init/get that frees memory but does not reset the counter. Signals: functions that kfree the pointers allocated in Step 3 (e.g., skx_adxl_put() frees adxl_values/adxl_msg in [FILE_CONTENT]) and contain no write setting the counter to zero (pre-patch scenario). FP mitigation: tie teardown to init by shared globals; ignore miscellaneous frees not linked to the counter.

5) Step 5: Objective: confirm later use of the counter as a loop bound to index arrays. Signals: loops with bounds i < counter that dereference arrays by index i (e.g., for (i = 0; i < adxl_component_count; i++) { adxl_values[i]; adxl_component_names[i]; } in skx_adxl_decode() from [FILE_CONTENT]). FP mitigation: require at least one dereference of an array/pointer not definitively allocated to length “counter” within the same init (e.g., adxl_component_names originates from adxl_get_component_names(), a non-allocation in [FILE_CONTENT]).

6) Step 6: Objective: assess cross-array indexing risk under the shared counter. Signals: within the loop, index two distinct arrays/pointers with i where only one was allocated using the counter (e.g., adxl_values vs adxl_component_names in [FILE_CONTENT]). FP mitigation: require evidence that the second array’s size is unknown or derived from an external provider (function return, global const), increasing risk of mismatch on stale counter.

7) Step 7: Objective: identify sink usage that magnifies impact (OOB read into formatted output). Signals: arguments to snprintf/vsnprintf or similar using the indexed pointer as a string argument (e.g., adxl_component_names[i] passed to snprintf in [FILE_CONTENT]). FP mitigation: optional; do not require a sink to flag, but raise severity if present to match [ROOTCAUSE_ANALYSIS] crash path.

8) Step 8: Objective: detect absence of counter reset on teardown as the specific lifecycle flaw. Signals: in the teardown function from Step 4, no store setting counter to 0 (contrast with [PATCH_DIFF] which adds adxl_component_count = 0;). FP mitigation: exclude cases where teardown writes zero, or another function in the unload path resets the counter.

9) Step 9: Objective: ensure the counter gates decode/execution paths that persist across reloads. Signals: uses of the counter as a guard before calling the decode function (e.g., adxl_component_count && skx_adxl_decode(...) in skx_mce_check_error() from [FILE_CONTENT]). FP mitigation: this presence strengthens confidence; absence should not suppress alerts.

10) Step 10: Objective: correlate init/get, decode/use, and teardown functions to the same module/shared file to strengthen path validity. Signals: functions in the same translation unit exporting symbols (EXPORT_SYMBOL_GPL) and sharing the same global state (e.g., skx_adxl_get/put/decode in [FILE_CONTENT]). FP mitigation: restrict to globals and functions within the same file or module to avoid cross-module aliasing uncertainty.

11) Step 11: Objective: flag when all three conditions hold: accumulation-without-reset in init, indexing loop using the counter on multiple arrays, and teardown missing reset. Signals: conjunction of Steps 2, 5–6, and 4–8. FP mitigation: require at least one free of an allocation sized by the counter in teardown to confirm lifecycle pairing.

12) Step 12: Objective: produce actionable report focusing on the missing reset. Signals: highlight the teardown function and the exact counter write that is missing (compare with [PATCH_DIFF] showing the intended fix). FP mitigation: suggest precise remediation (set counter to 0 in teardown) without speculating beyond provided evidence.

3. Target Elements
- File-scope static/global integer variables used as counters.
- Functions resembling init/get and teardown/put/remove that manipulate shared globals.
- Allocation sites using the counter for array sizes.
- Loops bounded by the counter that index arrays/pointers.
- Free/deallocation sites for arrays allocated from the counter.
- Calls to printf-like sinks that consume indexed pointers.

4. Dataflow / Taint Considerations
- Track writes to the counter within init/get: increments vs resets (no dominating zero assignment).
- Track allocation size expressions that use the counter and the pointers receiving them.
- Track teardown frees of those pointers and absence of counter resets afterward.
- Track array/pointer provenance: whether an indexed pointer was allocated based on the counter vs obtained from external APIs (e.g., adxl_get_component_names()).
- Track usage of the counter as a loop bound and the corresponding indexed dereferences.

5. Validation & Test Cases
- Positive: A global counter incremented in init via while (*p++) count++; used to size an allocation; teardown frees the allocation but does not set count=0; another function loops i < count indexing both the allocated array and an external names array and prints names[i] via snprintf.
- Negative: Same as positive but teardown sets count=0 (as in [PATCH_DIFF]); or init starts with count=0 assignment before counting; or loop bound is the actual length of the names array computed locally each time.
- Test harness notes: Run on the provided [FILE_CONTENT] pre-patch scenario to expect a finding; ensure no finding after applying [PATCH_DIFF] (addition of adxl_component_count = 0 in skx_adxl_put()).

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Intended persistent counters (accumulators): mitigate by requiring the allocation/free lifecycle pairing and cross-array indexing risk.
- Counters reset in a different teardown path: mitigate by scanning all functions that free the related allocations and checking for any reset.
- Arrays with guaranteed external size equal to the counter (not inferable): mitigate by raising severity only when one indexed pointer comes from an external provider function rather than an allocation sized by the counter.

8. Limitations & Assumptions
- Assumes init/get and teardown/put/remove semantics based on naming and shared globals; actual module unload paths are not statically provable.
- Cannot prove the true length of externally provided arrays (e.g., from firmware) or runtime call ordering.
- Concurrency/locking effects are not modeled (per [ROOTCAUSE_ANALYSIS], no locking changes were involved).
- The checker infers risk from structural patterns observed in [FILE_CONTENT]; it does not execute code paths nor observe real reload behavior.