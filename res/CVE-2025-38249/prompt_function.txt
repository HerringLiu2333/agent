1. CVE Identifier
CVE-2025-38249

2. Vulnerability Type
Out-of-bounds read (insufficient length validation of device-controlled data)

3. Root Cause Summary
snd_usb_get_audioformat_uac3() trusted the device-provided length hc_header.wLength when allocating and interpreting a uac3_cluster_header_descriptor. It allocated wLength bytes and immediately accessed fields (e.g., cluster->bNrChannels) without ensuring wLength >= sizeof(struct uac3_cluster_header_descriptor). If a malicious or buggy USB device reported a smaller wLength, the code read past the end of the allocated buffer, causing an out-of-bounds read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA USB audio (UAC3 descriptor parsing)

2) Pre-Patch Flaw:
- Device-controlled wLength from hc_header was used directly for allocation and struct interpretation:
  - “wLength = le16_to_cpu(hc_header.wLength);”
  - “cluster = kzalloc(wLength, GFP_KERNEL);”
  - “num_channels = cluster->bNrChannels;”
- There was no lower-bound check to ensure wLength >= sizeof(*cluster) before dereferencing cluster.

3) Trigger Condition:
A USB audio device returns a High Capability header with wLength smaller than sizeof(struct uac3_cluster_header_descriptor) and the subsequent descriptor request returns exactly that short length.

4) Impact Mechanism:
Dereferencing fields of an undersized buffer (e.g., cluster->bNrChannels) and passing the undersized buffer to convert_chmap_v3(cluster) causes out-of-bounds reads from kernel heap memory, risking kernel crashes or undefined behavior.

5. Patch Analysis
1) Fix Approach:
Introduce a lower-bound validation of the device-provided length before allocation and dereference, rejecting descriptors smaller than the required header size.

2) Key Code Changes:
- Added:
  - if (wLength < sizeof(*cluster)) return NULL;
- This check is inserted immediately after:
  - wLength = le16_to_cpu(hc_header.wLength);
- Prevents allocating too-small buffers that would be interpreted as uac3_cluster_header_descriptor.

3) Locking/Concurrency Impact:
None. The patch only adds input-length validation; no locking or ordering changes.

6. Broader Kernel Security Implications
This fix addresses a common class of USB descriptor parsing issues where device-controlled lengths are trusted without minimum-size checks. Ensuring lower-bound validation before casting buffers to protocol structures reduces the attack surface from malicious USB devices. Similar validations should be systematically reviewed across other USB audio/UAC descriptor paths to prevent analogous OOB reads.