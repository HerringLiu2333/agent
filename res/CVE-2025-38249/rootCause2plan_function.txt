1. Plan Summary
Detect cases where a device-controlled length is used to allocate a buffer that is then interpreted as a fixed-size descriptor struct and dereferenced without a prior check ensuring length >= sizeof(struct), leading to potential out-of-bounds reads.

2. Detection Steps
1) Step 1: Objective: Identify device-controlled descriptor headers. Signals: Calls that read from a device into a local buffer (e.g., a descriptor header) via an IN control transfer, as evidenced by snd_usb_ctl_msg filling hc_header in [FUNCTION_CONTENT]; Why: This locates the untrusted source of length values per [ROOTCAUSE_ANALYSIS]; FP mitigation: Require the call direction to be IN and the buffer to be subsequently read in the same function.
2) Step 2: Objective: Find extraction of a length field from that header. Signals: Assignment where a variable is derived from a field of the device-filled header (e.g., wLength = le16_to_cpu(hc_header.wLength) in [FUNCTION_CONTENT]); Why: This maps to the untrusted wLength per [ROOTCAUSE_ANALYSIS]; FP mitigation: Ensure the field read occurs after the device read and is not overwritten by a constant afterward.
3) Step 3: Objective: Locate allocations sized by that untrusted length. Signals: Memory allocation sites (e.g., kzalloc) whose size argument flows from the extracted length (cluster = kzalloc(wLength, ...), [FUNCTION_CONTENT]); Why: Allocation directly controlled by untrusted length is the first half of the root cause; FP mitigation: Exclude cases where the size is min-bounded by another validated value known to be >= sizeof(target struct).
4) Step 4: Objective: Detect interpretation of the allocated buffer as a fixed descriptor struct. Signals: The allocated pointer is typed or cast to a concrete struct type and used as such (e.g., struct uac3_cluster_header_descriptor *cluster), followed by field access or passing as that type ([FUNCTION_CONTENT], uses cluster->bNrChannels and convert_chmap_v3(cluster)); Why: This indicates the code assumes at least sizeof(struct) bytes; FP mitigation: Require at least one field dereference or a call-site use where the callee expects the struct type without an explicit size parameter.
5) Step 5: Objective: Check for the presence or absence of a minimal-size guard. Signals: A conditional comparing the untrusted length against sizeof(the interpreted struct) immediately before allocation or dereference (e.g., the patchâ€™s if (wLength < sizeof(*cluster)) return NULL in [PATCH_DIFF]); Why: The fix specifically adds this check per [PATCH_DESCRIPTION]/[PATCH_DIFF]; FP mitigation: If such a check is present and dominates all dereferences, do not flag.
6) Step 6: Objective: Ensure equality checks against the requested transfer size do not suppress findings. Signals: Conditions like err != wLength (present in [FUNCTION_CONTENT]) that validate transport completeness but not structural minimum size; Why: [ROOTCAUSE_ANALYSIS] notes this equality check is insufficient to prevent OOB; FP mitigation: These checks should not clear the alert unless combined with a lower bound against sizeof(struct).
7) Step 7: Objective: Prioritize findings where the allocated buffer is populated from the device using the same untrusted length. Signals: A second device read into the allocated buffer with the size argument set to the same untrusted length (as in the second snd_usb_ctl_msg into cluster, [FUNCTION_CONTENT]); Why: This matches the exact trigger path described in [ROOTCAUSE_ANALYSIS]; FP mitigation: Use this as a ranking signal rather than a hard requirement to avoid missing variants.
8) Step 8: Objective: Confirm dereference or use happens before any adequate bounds check. Signals: Control-flow ordering where field access or function call with the struct pointer occurs without an earlier dominating condition ensuring length >= sizeof(struct); Why: The read of cluster->bNrChannels and passing to convert_chmap_v3 occurs without the added guard pre-patch ([FUNCTION_CONTENT]); FP mitigation: Use dominance/guard analysis; if a correct guard exists on all paths to the deref, suppress.
9) Step 9: Objective: Reduce FPs in variable-length or header-with-tail patterns. Signals: Cases where code only accesses the first byte(s) and contains a check guaranteeing those specific offsets are within the length (e.g., analogous to as->bLength check in [FUNCTION_CONTENT]); Why: Accessing only the first byte when len >= 1 may be safe; FP mitigation: If the only derefs are to fields provably within a guard-checked prefix smaller than sizeof(struct), deprioritize or suppress.
10) Step 10: Objective: Flag passing the struct pointer to helper functions without an accompanying size parameter and without prior size check. Signals: Calls like convert_chmap_v3(cluster) where no size is provided ([FUNCTION_CONTENT]); Why: This implies the callee may read beyond a short length, aligning with [ROOTCAUSE_ANALYSIS] impact; FP mitigation: Suppress if there is a dominating sizeof-guard or if the callee is known (via summary) to read only a guarded prefix (if such knowledge is available).

3. Target Elements
- Function bodies that perform device reads of descriptor headers (e.g., snd_usb_ctl_msg with IN direction).
- Assignments extracting length fields from device-filled headers.
- Allocation sites where allocation size flows from such lengths.
- Pointer casts/initializations where the allocated buffer is treated as a specific struct type.
- Field dereferences on that struct pointer and call sites where the pointer is passed as that struct without explicit size.
- Condition checks comparing the untrusted length to sizeof(struct) or to constants.
- Control-flow/dominance between checks and dereferences.

4. Dataflow / Taint Considerations
- Track taint from buffers populated by IN device reads into their fields, especially length fields.
- Propagate taint from the length field into variables used as allocation sizes and I/O request sizes.
- Model the link between the tainted size and the allocated pointer as a pair (size, buffer).
- Guard analysis: identify conditions asserting size >= sizeof(struct) dominating dereferences.
- Prioritization: if the same tainted size is used to fill the allocated buffer from the device, raise severity.

5. Validation & Test Cases
- Positive: A function reads a device header, extracts header->wLength, allocates buf = kzalloc(wLength), fills it with a device read of wLength, dereferences buf as struct X without checking wLength >= sizeof(struct X); Expected: flagged.
- Negative: Same as above but with a guard if (wLength < sizeof(*buf_as_X)) return error; Expected: not flagged.
- Negative: Code extracts length, allocates buffer of that length, but only reads a first-byte field with a guard ensuring length >= 1; Expected: not flagged or low-priority.
- Positive: Code passes the struct-typed pointer to a helper without a size argument and without size guard (e.g., convert_chmap_v3-like usage); Expected: flagged.
- Test harness notes: Include cases where an equality check (received == requested) is present to confirm it does not suppress the alert; include the exact pre-patch snippet from [FUNCTION_CONTENT] as a golden positive.

6. Estimated Effort & Priority
Medium-high: Requires interprocedural taint tracking from device reads, size-to-allocation pairing, and dominance analysis for guards.

7. Likely False-Positive Sources & Mitigations
- Variable-length structs or headers with valid short prefixes: mitigate by checking if only guarded prefix fields are accessed.
- Guards using constants equivalent to sizeof(struct) but not written with sizeof: may be missed as valid; document as limitation or permit configurable constant mappings.
- Callee behavior unknown: passing struct pointer to helper without size might be benign; mitigate by prioritizing but not requiring such cases unless no guard exists.

8. Limitations & Assumptions
- Assumes device reads like snd_usb_ctl_msg with IN direction produce untrusted data (based on [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]); other I/O APIs are not enumerated here.
- Cannot definitively know callee memory access patterns (e.g., convert_chmap_v3) without summaries; risk of both FPs and FNs.
- Does not compute precise field offset vs. length bounds; relies on presence/absence of sizeof(struct)-style guards highlighted in [PATCH_DIFF]/[PATCH_DESCRIPTION].
- Assumes sizeof information is available for the struct types in question.