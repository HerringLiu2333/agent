1. CVE Identifier
CVE-2025-38249

2. Vulnerability Type
Out-of-bounds read (insufficient length validation of device-controlled buffer)

3. Root Cause Summary
snd_usb_get_audioformat_uac3() used a USB device–controlled length (wLength from the UAC3 High Capability header) directly for kzalloc and then immediately cast the buffer to struct uac3_cluster_header_descriptor and accessed its fields without ensuring the buffer is large enough for that header. If the device reports a wLength smaller than sizeof(struct uac3_cluster_header_descriptor), subsequent reads like cluster->bNrChannels and cluster->wLength access beyond the allocated memory, causing an out-of-bounds read. The patch adds a minimal length check (wLength >= sizeof(*cluster)) before allocation, preventing the unsafe cast and dereference on too-small buffers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA USB audio (sound/usb audio parsing for UAC3)

2) Pre-Patch Flaw:
In snd_usb_get_audioformat_uac3(), the code performed:
- “wLength = le16_to_cpu(hc_header.wLength);”
- “cluster = kzalloc(wLength, GFP_KERNEL);”
and then dereferenced the buffer as “struct uac3_cluster_header_descriptor” (e.g., “num_channels = cluster->bNrChannels;” and passing it to convert_chmap_v3()) without verifying that wLength is at least the size of the header struct. This uses an undersized, device-controlled allocation for a fixed-size header access.

3) Trigger Condition:
A malicious or non-compliant USB UAC3 audio device that returns a High Capability header with wLength < sizeof(struct uac3_cluster_header_descriptor) in the initial snd_usb_ctl_msg() response. The driver then allocates a buffer of that smaller size and reads header fields from it.

4) Impact Mechanism:
Reading cluster->bNrChannels and cluster->wLength on a buffer smaller than the header leads to out-of-bounds reads from kernel heap memory. Additionally, convert_chmap_v3() uses cluster->wLength to drive further parsing, which can amplify the OOB read if the header fields are read from insufficiently sized memory, potentially causing information disclosure or kernel faults.

5. Patch Analysis
1) Fix Approach:
Introduce defensive length validation before allocation: ensure the device-provided wLength is at least the size of the uac3_cluster_header_descriptor. If not, abort the parsing path early.

2) Key Code Changes:
In snd_usb_get_audioformat_uac3():
- After “wLength = le16_to_cpu(hc_header.wLength);”
- Add:
  “if (wLength < sizeof(*cluster))
      return NULL;”
This prevents allocating an undersized buffer and subsequent unsafe dereferences.

3) Locking/Concurrency Impact:
None. The change is a simple bounds check with early return; no locking, ordering, or concurrency primitives were modified.

6. Broader Kernel Security Implications
USB descriptors are fully device-controlled, and casting variable-length buffers to fixed-size structures without validating minimum lengths is a recurring risk in USB class drivers. This fix hardens the UAC3 path against malformed descriptors that could trigger kernel heap OOB reads, reducing the attack surface from rogue or compromised USB peripherals. Similar validations should be audited wherever device-supplied lengths govern allocations and subsequent structured accesses.