1. Plan Summary
Detect call sites where the pointer returned by smu_atom_get_data_table is dereferenced without a dominating NULL check, as in the pre-patch atomctrl_initialize_mc_reg_table{,_v2_2} functions that caused a kernel NULL pointer dereference.

2. Detection Steps
1) Step 1: Objective — find candidate sources. Signals — locate assignments where a variable of pointer type is assigned the return value of smu_atom_get_data_table (possibly via a cast), as shown in the function bodies and [PATCH_DIFF]. FP mitigation — restrict to the specific callee name smu_atom_get_data_table because [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS] confirm it may return NULL.

2) Step 2: Objective — track uses of the returned pointer. Signals — from each assignment, flow-sensitively track the variable (including through casts and simple aliases) to its first dereference: member access (->), unary *, array indexing through the pointer, or pointer-based address arithmetic used to read fields (e.g., vram_info->usMemClkPatchTblOffset), as illustrated in [FUNCTION_CONTENT]. FP mitigation — ignore uses that are only stored or compared but not dereferenced.

3) Step 3: Objective — identify guarding NULL checks. Signals — search control predicates dominating each dereference that test the pointer’s non-NULL-ness (e.g., if (!ptr) { return/err; } or if (ptr) { ... deref ... }), including early returns as in the added patch block in [PATCH_DIFF]. FP mitigation — require that the dereference is syntactically or control-flow dominated by the positive arm (ptr) or post a negative-arm early-exit; exclude unrelated conditions (e.g., checks on result) that do not mention the pointer, per [FUNCTION_CONTENT].

4) Step 4: Objective — detect unguarded dereferences. Signals — report when at least one dereference is reachable on a path not dominated by any explicit pointer NULL-check identified in Step 3, e.g., immediate uses like module_index >= vram_info->ucNumOfVRAMModule seen in [FUNCTION_CONTENT]. FP mitigation — demand existence of a feasible path from the call to the dereference without intervening dominating guard; treat gotos/returns conservatively.

5) Step 5: Objective — account for multiple dereferences and compounding risk. Signals — after the first unguarded dereference is found, optionally collect subsequent dereferences (e.g., vram_info->sHeader.ucTableFormatRevision and the offset-based access) to provide context, as described in [ROOTCAUSE_ANALYSIS]. FP mitigation — still report a single finding per call site unless a later guard appears; stop collection once a proper guard is encountered.

6) Step 6: Objective — avoid false guards. Signals — ignore checks on unrelated variables (e.g., if (0 == result)) because they do not assert non-NULL for the pointer, matching the pattern in [FUNCTION_CONTENT]. FP mitigation — only consider guards whose condition directly references the pointer variable.

7) Step 7: Objective — handle reassignments. Signals — if the pointer variable is reassigned before the dereference, restart the analysis from the new assignment; otherwise treat the dereference as using the original returned value. FP mitigation — if reassignment comes from a function other than smu_atom_get_data_table, do not assume that new value can be NULL unless it is also from the same API; conservatively stop reporting on the original source if control-flow proves the dereference uses the new value.

8) Step 8: Objective — prioritize the most dangerous cases. Signals — rank warnings higher when dereference occurs in the same basic block or immediately after the call, as in the pre-patch code, per [FUNCTION_CONTENT]. FP mitigation — optionally suppress low-severity cases where a non-NULL assumption is enforced by an assert-like macro (if identifiable) before deref.

9) Step 9: Objective — verify early-exit correctness. Signals — consider a guard valid only if the NULL case leads to a control-flow exit from the function or a path that cannot reach the dereference (e.g., return, goto out, or unconditional error label), consistent with [PATCH_DIFF] early return -EINVAL. FP mitigation — ignore guards that merely set a flag or variable (e.g., result = -1) without preventing the dereference on some path.

10) Step 10: Objective — detect pointer arithmetic that implicitly dereferences. Signals — flag cases where pointer value is used as base to compute a new pointer that is later dereferenced using fields from the original pointer (e.g., le16_to_cpu(vram_info->usMemClkPatchTblOffset) and then cast/offset), as in [FUNCTION_CONTENT]. FP mitigation — only report if the base pointer’s fields are read or the computed pointer is dereferenced without a dominating NULL-check.

3. Target Elements
- Function call sites to smu_atom_get_data_table.
- Assignments receiving the call’s return into pointer-typed variables (with or without casts/typedefs).
- Field/member accesses (->), unary dereference (*), array/indexing via the pointer, and pointer-based offset computations using the pointer’s fields.
- Conditional statements and assertions involving the pointer (NULL/non-NULL checks).
- Early-exit constructs (return/goto/break) used in error handling after NULL checks.

4. Dataflow / Taint Considerations
- Source: the value returned by smu_atom_get_data_table assigned to a pointer variable.
- Sinks: dereference operations on that variable (member access, *ptr, ptr[idx], or using ptr’s fields to compute addresses).
- Guards: control-flow predicates that test the pointer for NULL or non-NULL and that dominate the dereference; require that the NULL arm blocks reachability of the dereference.
- Flow sensitivity: track the specific variable instance along paths until reassignment; treat casts as transparent; handle dominance and reachability to find unguarded paths.

5. Validation & Test Cases
- Positive: Pre-patch atomctrl_initialize_mc_reg_table and atomctrl_initialize_mc_reg_table_v2_2 where vram_info is dereferenced (ucNumOfVRAMModule, sHeader.ucTableFormatRevision, usMemClkPatchTblOffset) without a prior NULL check ([FUNCTION_CONTENT]); expect findings at the first such dereference.
- Negative: Patched versions with if (!vram_info) { pr_err(...); return -EINVAL; } immediately after the call ([PATCH_DIFF]); expect no findings because dereferences are dominated by the guard.
- Negative: A synthetic variant where if (vram_info) { use fields } else { return -EINVAL; }; expect no findings since dereferences are in the (vram_info) branch only.
- Positive: A variant that sets result = -1 on error but does not exit before dereferences (mirroring [FUNCTION_CONTENT]); expect a finding because result checks do not guard the pointer.

- Test harness notes: Run on kernel C sources with preprocessing enabled to preserve control-flow and macro-expanded conditions; ensure the API name smu_atom_get_data_table is resolved.

6. Estimated Effort & Priority
High — The pattern is well-scoped and impactful (kernel NULL deref/DoS per [ROOTCAUSE_ANALYSIS]), but requires path-sensitivity and dominance analysis to minimize false positives.

7. Likely False-Positive Sources & Mitigations
- Cases where upstream code guarantees non-NULL by contract but no local check exists; mitigate by restricting to smu_atom_get_data_table which [PATCH_DESCRIPTION] confirms may return NULL.
- Guards implemented via non-standard macros not recognized as NULL checks; mitigate by recognizing common forms (ptr, !ptr) and early exits.
- Complex control-flow where the analysis fails to model dominance accurately; mitigate by requiring a clear, direct null-check dominance to suppress, otherwise report with lower confidence.

8. Limitations & Assumptions
- Assumes smu_atom_get_data_table can return NULL, based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; the checker focuses on this API specifically.
- Does not infer global contracts or interprocedural guarantees that might ensure non-NULL; evaluates only local function context.
- Cannot fully reason about macro-based assertions without expanded form; results may vary depending on preprocessing.