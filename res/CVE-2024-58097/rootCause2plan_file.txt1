1. Plan Summary
Design a CodeQL checker framework that, guided by patch-introduced safeguards, flags pre-patch code paths where attacker-controlled data reaches sensitive operations without the added validation, bounds checks, or guards.

2. Detection Steps
1) Step 1: Scope identification — locate symbols (functions, methods, classes, files) changed in the patch and use them as anchors for analysis of pre-patch implementations.
2) Step 2: Guard inference — compare pre- vs post-patch code to enumerate newly added validations (e.g., null/length checks, authorization checks, type checks) and defensive calls (e.g., sanitizers).
3) Step 3: Sink discovery — catalog sensitive operations that the patch newly guards or wraps (e.g., resource access, memory writes, parsing/deserialize, command/file/network operations) as sinks to protect.
4) Step 4: Source modeling — infer attacker-controlled inputs relevant to the patched code (e.g., request parameters, environment/config, file contents, user-provided strings) from the context of the edited functions and their call sites.
5) Step 5: Required-check modeling — represent the specific predicates/calls introduced by the patch as “required guards” (e.g., specific conditionals, validation helpers, capability checks) that must precede reaching the sink.
6) Step 6: Data/control flow linking — compute flows from modeled sources to the identified sinks within the anchored functions and their callers, preserving control-flow to ensure the guard must be on-path.
7) Step 7: Missing-guard detection — flag any source-to-sink path where the inferred required guard is absent, bypassed, or unreachable before the sink is invoked.
8) Step 8: Context constraints — restrict findings to the module/package/file regions affected by the patch and to calls with argument shapes/types matching those guarded post-patch.
9) Step 9: Validation equivalence — treat alternative guards as acceptable if they are semantically equivalent to the patch (e.g., same predicate or same sanitizer function), and report only when no equivalent guard is present.
10) Step 10: Reachability check — ensure the flagged path is feasible (entry points reachable and sink callable) using call graph reachability from externally invokable functions indicated by the patch context.
11) Step 11: Result explanation — include path evidence showing source, missing guard location, and sink, emphasizing the exact checks added by the patch that are absent pre-patch.
12) Step 12: Deduplication — merge multiple reports that share the same sink and missing guard within the same function to avoid noisy duplicates.

3. Limitations & Assumptions
- No PATCH_DESCRIPTION, PATCH_DIFF, FILE_CONTENT, or ROOTCAUSE_ANALYSIS were provided, so the vulnerability class, exact sources, sinks, and guards cannot be instantiated.
- The plan assumes patch artifacts exist to derive guards and sinks; without them, the checker cannot be concretely parameterized.
- Specific APIs, languages, frameworks, and validation helpers are unknown; modeling of sources/sinks and guard semantics must be supplied from the missing materials.