1. Plan Summary
Detect platform driver probe functions that can call a cleanup/remove routine which reads drvdata (via platform_get_drvdata) before the probe has called platform_set_drvdata, leading to a NULL dereference on error paths.

2. Detection Steps
1) Step 1: Identify candidate probe functions — functions returning int with a parameter of type struct platform_device* (e.g., arm_ni_probe from [FUNCTION_CONTENT]) and name indicating probe — because the flaw arises in platform driver probe routines (per [ROOTCAUSE_ANALYSIS]).
2) Step 2: Within each probe, locate allocation/initialization of a driver private state pointer — look for devm_kzalloc (or similar) assigned to a local pointer and subsequent field initializations (e.g., ni and ni->fields in [FUNCTION_CONTENT]) — as this indicates there is state expected to be stored in drvdata (per [ROOTCAUSE_ANALYSIS]).
3) Step 3: Record any calls to platform_set_drvdata(pdev, X) and their control-flow positions — this is the required association fix (added in [PATCH_DIFF]) — to later verify if it occurs before any hazardous cleanup call.
4) Step 4: Find calls in probe to a callee that takes the same pdev and is used as an error-path cleanup (e.g., arm_ni_remove(pdev) in [FUNCTION_CONTENT]) — signal includes being on a branch when an initialization call returns error (ret != 0) and followed by return — which maps to the trigger condition (per [ROOTCAUSE_ANALYSIS] 3).
5) Step 5: For each such callee, analyze its body to check for platform_get_drvdata(pdev) and dereference of the result (member access, array index, or passing to a function expecting a non-NULL struct) — this confirms the impact mechanism (per [ROOTCAUSE_ANALYSIS] 4) and reduces false alarms when callee doesn’t use drvdata.
6) Step 6: Perform path-sensitive ordering analysis from probe entry to the hazardous call site: flag a path where platform_set_drvdata(pdev, …) has not executed before the call to the callee confirmed in Step 5 — this matches the pre-patch flaw where remove is invoked before drvdata is set (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS] 2).
7) Step 7: Additionally, flag if the probe can return (especially error returns) without ever calling platform_set_drvdata while having allocated and initialized a private state and calling a callee that reads drvdata — this captures early-failure paths like the arm_ni_init_cd() error branch in [FUNCTION_CONTENT].
8) Step 8: Exempt cases where the callee guards platform_get_drvdata with a robust NULL check before any dereference and handles NULL safely (e.g., immediate return without access) — this reduces false positives where NULL would not cause a crash (aligns with [ROOTCAUSE_ANALYSIS] emphasis on dereference).
9) Step 9: Exempt cases where platform_set_drvdata is unconditionally called along all feasible paths reaching the hazardous call site (dominates the site in control flow) — ensures we do not warn if the association is guaranteed before cleanup calls (as achieved by the fix in [PATCH_DIFF]).
10) Step 10: Prefer warnings where the same private state variable from Step 2 is passed to platform_set_drvdata when present, or is otherwise used by the callee via drvdata — strengthens the link between allocated state and drvdata usage (per [ROOTCAUSE_ANALYSIS] 3–5).

3. Target Elements
- Functions: probe functions with signature (struct platform_device*), and cleanup/remove functions taking struct platform_device*.
- Call sites: platform_set_drvdata, platform_get_drvdata, explicit cleanup calls from probe (e.g., arm_ni_remove(pdev)).
- Allocation sites: devm_kzalloc (or similar) creating a driver state pointer later assigned to fields (e.g., ni in [FUNCTION_CONTENT]).
- Condition checks and error paths: ret checks around initialization routines (e.g., ret from arm_ni_init_cd in [FUNCTION_CONTENT]).
- Member dereferences: uses of the result of platform_get_drvdata (implying non-NULL assumption).

4. Dataflow / Taint Considerations
- Track the platform_device* value (pdev) through calls and ensure the same object is used in platform_set_drvdata and platform_get_drvdata.
- Track the drvdata value returned by platform_get_drvdata to its first dereference; require a dereference on the analyzed path to establish risk (per [ROOTCAUSE_ANALYSIS] 4).
- Path-sensitively enforce ordering: platform_set_drvdata must occur before any call from the probe into a callee that dereferences platform_get_drvdata(pdev); otherwise, report.
- Optionally correlate the allocated state pointer (from devm_kzalloc) to being the intended drvdata by observing field initializations and intended assignment to drvdata (as in [PATCH_DIFF]).

5. Validation & Test Cases
- Positive: A probe like [FUNCTION_CONTENT] that allocates ni, initializes fields, calls a failing initializer (arm_ni_init_cd), then calls arm_ni_remove(pdev) and returns, without any prior platform_set_drvdata; remove uses platform_get_drvdata and dereferences — expect a warning.
- Negative: The patched version in [PATCH_DIFF] where platform_set_drvdata(pdev, ni) is executed before any initialization loop that may fail and call arm_ni_remove — expect no warning.
- Negative: A remove function that calls platform_get_drvdata but checks for NULL and returns without dereferencing — expect no warning.
- Test harness notes: Build small kernel-like stubs with struct platform_device, platform_set/get_drvdata, and minimal remove routines to validate interprocedural analysis and path sensitivity.

6. Estimated Effort & Priority
High — requires interprocedural analysis, path-sensitive ordering, and dereference detection, but yields high-impact kernel NULL-deref bugs as evidenced by [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION].

7. Likely False-Positive Sources & Mitigations
- Indirect wrappers around platform_get_drvdata not recognized: mitigate by focusing on direct calls to platform_get_drvdata.
- Callees with complex NULL checks before dereference: mitigate by requiring a proven dereference of the drvdata value on the analyzed path.
- Alternate mechanisms to store/retrieve drvdata (non-standard APIs): mitigate by limiting to canonical platform_set/get_drvdata and documenting as limitation.
- Paths infeasible due to environment-specific conditions: mitigate by preferring clear error-branch patterns (ret != 0 followed by cleanup call and return) as in [FUNCTION_CONTENT].

8. Limitations & Assumptions
- Assumes canonical APIs platform_set_drvdata/platform_get_drvdata are used; wrappers or custom storage are not detected.
- Assumes availability of the remove/cleanup callee body to confirm drvdata dereference; missing bodies may reduce precision.
- Does not infer driver core implicit callbacks; focuses on explicit calls from probe to cleanup as seen in [FUNCTION_CONTENT] and described in [ROOTCAUSE_ANALYSIS].
- Does not prove that the allocated state must be the drvdata value; uses heuristic signals (allocation + field writes) consistent with [FUNCTION_CONTENT] and the fix in [PATCH_DIFF].