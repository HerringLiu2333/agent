1. Plan Summary
Detect Linux platform drivers whose remove/cleanup code dereferences platform_get_drvdata() without ensuring probe associated driver data via platform_set_drvdata(), including probe error paths that invoke remove before setting drvdata.

2. Detection Steps
1) Step 1: Identify platform driver pairs — find static initializers of struct platform_driver and extract the .probe and .remove function symbols — aligns the analysis to the same driver instance to map lifecycle pairing.
2) Step 2: Model drvdata acquisition in remove — inside the .remove function, locate calls to platform_get_drvdata(pdev) and bind the returned pointer to a local variable — this is the object that will be dereferenced (root cause per [ROOTCAUSE_ANALYSIS]).
3) Step 3: Find unsafe dereferences in remove — search for field dereferences, array indexing, or pointer passing that implies dereference on the drvdata variable, without a dominating NULL guard that returns/aborts before deref — maps to “immediately dereferences ni->num_cds” in [ROOTCAUSE_ANALYSIS].
4) Step 4: Mitigate FPs in remove — if there is an if (!ptr) return/abort path that dominates all derefs of the ptr, suppress the alert — ensures we only report when NULL leads to a guaranteed risk.
5) Step 5: Link to the corresponding probe — retrieve the .probe function for the same platform_driver to assess whether it associates private data — the fix in [PATCH_DIFF] adds platform_set_drvdata(pdev, ni), which is the expected pattern.
6) Step 6: Check success paths in probe — verify that on all paths that lead to return 0 (successful bind), there is a prior call to platform_set_drvdata(pdev, X) where X is a non-NULL pointer-like value (e.g., result of allocation/initialization) — addresses the “probe completes without setting drvdata” path in [ROOTCAUSE_ANALYSIS].
7) Step 7: Model probe error paths invoking remove — within probe, find any call to the same .remove function (or a cleanup function that calls platform_get_drvdata(pdev)) before any platform_set_drvdata(pdev, …) — captures the explicit “arm_ni_remove(pdev) before drvdata is set” error path in [ROOTCAUSE_ANALYSIS].
8) Step 8: Ensure drvdata set dominates remove-in-probe — if remove is called in probe, require that a platform_set_drvdata(pdev, …) dominates that call; otherwise, flag — avoids false alarms where drvdata is correctly set prior to cleanup.
9) Step 9: Correlate both sides to report — report only when both conditions hold: unsafe dereference in remove (Step 3) and missing/late platform_set_drvdata in probe on success or error paths (Steps 6–8) — ties directly to the lifecycle bug described in [ROOTCAUSE_ANALYSIS].
10) Step 10: Optional robustness check — if the remove function obtains drvdata by other means (e.g., dev_get_drvdata(&pdev->dev)) but still dereferences without a dominating NULL check, treat equivalently — this reduces misses when minor API variants are used while keeping the same root cause.
11) Step 11: Severity ranking — prioritize findings where probe returns 0 without any platform_set_drvdata on that path (as fixed by [PATCH_DIFF]) over error-path-only issues — mirrors the high-impact trigger conditions in [ROOTCAUSE_ANALYSIS].
12) Step 12: Suppress benign patterns — suppress when remove never dereferences drvdata (e.g., only used in a NULL check), or when probe sets drvdata unconditionally before any potential cleanup call and before all return 0 paths — reduces noise when code is already safe.

3. Target Elements
- Initializations of struct platform_driver and their .probe and .remove function pointers.
- Calls to platform_get_drvdata(pdev) in remove and assignment to local variables.
- Pointer dereference sites: field access (->), array indexing on the drvdata pointer, or passing as a non-null-required argument.
- Conditional checks guarding drvdata (NULL tests) and their control-flow dominance.
- Calls to platform_set_drvdata(pdev, …) in probe and their control-flow dominance w.r.t. return 0 and any remove invocation.
- Calls to the remove function (or equivalent cleanup) made within probe error paths.
- Return statements in probe, specifically return 0 signaling success.

4. Dataflow / Taint Considerations
- Track the value returned by platform_get_drvdata(pdev) to its uses to detect dereferences without dominating NULL checks.
- In probe, track the presence and dominance of platform_set_drvdata(pdev, X) relative to success exits (return 0) and to any intra-probe call to remove.
- Consider basic aliasing where drvdata is copied to locals before dereference; treat all aliases as the same abstract value for NULL-guard analysis.
- Treat platform_device *pdev consistently when passed through helpers in the same function; if remove is invoked indirectly but with pdev as the same argument, assume it will call platform_get_drvdata similarly.

5. Validation & Test Cases
- Positive: Pre-patch pattern from [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS]: remove obtains ni = platform_get_drvdata(pdev); dereferences ni->num_cds; probe lacks platform_set_drvdata and calls remove(pdev) on error — expect a report.
- Positive: Probe returns 0 without any prior platform_set_drvdata, and remove dereferences drvdata without a NULL check — expect a report.
- Positive: Probe error path calls remove before any platform_set_drvdata and remove dereferences drvdata — expect a report.
- Negative: Post-patch pattern per [PATCH_DIFF]: probe calls platform_set_drvdata(pdev, ni) before loops/returns; remove dereferences drvdata — expect no report.
- Negative: Remove checks if (!ni) return; before any dereference — expect no report.
- Test harness notes: Run with whole-program compilation of driver files so the platform_driver initializer, probe, and remove are all visible to link .probe/.remove; include variants with multiple return paths in probe.

6. Estimated Effort & Priority
High — requires control-flow/dominance reasoning across probe success/error paths and correlation with remove dereferences, but confined to common kernel APIs and patterns.

7. Likely False-Positive Sources & Mitigations
- Use of alternative APIs/macros (e.g., dev_get_drvdata) not modeled: mitigate by recognizing common variants or limiting to platform_get_drvdata to reduce speculative matches.
- Indirect remove wrappers called in probe: mitigate by flagging only when the invoked function is the same .remove or trivially resolves to it; otherwise lower severity.
- Complex NULL guarding via helper functions: mitigate by recognizing straightforward dominating guards; document limitation for complex interprocedural guards.
- Drivers that intentionally never need drvdata in remove despite deref-looking patterns (e.g., dead code): mitigate by requiring actual deref on all feasible paths without a guard.

8. Limitations & Assumptions
- Assumes platform drivers use platform_get_drvdata/platform_set_drvdata as in [FILE_CONTENT]/[PATCH_DIFF]; other storage patterns (custom wrappers) may be missed.
- Assumes the .remove function shown in the platform_driver is the one analyzed and that its dereferences execute on unbind; dynamic registration indirection is not handled.
- Does not fully model inter-file aliasing or indirect calls beyond simple, same-translation-unit cases.
- Cannot prove runtime call ordering; relies on static evidence of remove being called from probe and missing drvdata set, as highlighted in [ROOTCAUSE_ANALYSIS].