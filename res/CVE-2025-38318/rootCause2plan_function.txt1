1. Plan Summary
Detect platform driver probe functions that can call a cleanup/remove routine which dereferences platform_get_drvdata(pdev) before drvdata is set via platform_set_drvdata(pdev, state), leading to a potential NULL pointer dereference on error paths.

2. Detection Steps
1) Step 1: Identify candidate probe functions — functions returning int, taking a parameter of type struct platform_device* (commonly named *_probe), and operating as a platform driver probe.
   Signals: Parameter type match to struct platform_device* (variable often named pdev); function name pattern “probe” is a bonus signal.

2) Step 2: Within a candidate probe, detect allocation of driver-private state.
   Signals: Result of devm_kzalloc (or equivalent managed alloc) using &pdev->dev is assigned to a local pointer (e.g., ni), followed by initialization of its fields (e.g., state->dev = &pdev->dev).

3) Step 3: Locate calls to platform_set_drvdata(pdev, state) in the probe and record their program order.
   Signals: Call expression with callee platform_set_drvdata, first argument is the same pdev value, second argument is the allocated state pointer; if absent, mark as “never set”.

4) Step 4: Identify potential cleanup/remove invocations from the probe that may occur on error paths before returning.
   Signals: Calls in the probe to a function taking pdev (e.g., arm_ni_remove(pdev)) reached under a condition where a prior operation failed (e.g., ret != 0 branches) or in general any call to a remove/cleanup-sounding function before function exit.

5) Step 5: For each cleanup/remove callee found in Step 4, analyze its body to see if it retrieves drvdata.
   Signals: presence of platform_get_drvdata(pdev) with pdev from the callsite; the return value is stored to a local pointer variable.

6) Step 6: Determine whether the drvdata retrieved in the cleanup/remove is dereferenced without a preceding NULL check.
   Signals: Member access (ptr->field), function calls that take the ptr as a non-null receiver/argument, or other dereference operations on the variable holding platform_get_drvdata’s result, with no dominating null-check guarding the use.

7) Step 7: Perform a path-sensitive ordering check in the probe: if there exists a path from function entry to the cleanup/remove call where platform_set_drvdata(pdev, state) has not occurred earlier on that path, mark this path as unsafe.
   Signals: Control-flow path exists where Step 3’s call is not encountered before the Step 4 call; also include the case where set_drvdata is entirely absent.

8) Step 8: Flag a finding when Steps 5–7 all hold: the probe can reach a cleanup/remove that dereferences platform_get_drvdata before drvdata is set on that path.
   Signals: Aggregate evidence includes the state allocation, missing/late set_drvdata relative to cleanup call, and dereference of get_drvdata in the callee.

9) Step 9: Strengthen precision with state-identity heuristics to correlate the allocated state with the intended drvdata.
   Signals: The allocated object is assigned pdev-related fields (e.g., state->dev = &pdev->dev) or is used in subsequent initialization loops, suggesting it is the driver’s private state expected to be stored as drvdata.

10) Step 10: Also detect late set_drvdata relative to any in-probe use of platform_get_drvdata(pdev).
    Signals: In the probe itself, if platform_get_drvdata(pdev) is dereferenced on any path that can be executed before a platform_set_drvdata call, flag similarly.

3. Limitations & Assumptions
- Assumes function role identification via type/signature/name (“probe”, “remove”) is sufficient; atypical naming may be missed.
- Interprocedural analysis depends on availability of remove/cleanup function bodies; cross-translation-unit boundaries may limit visibility.
- The checker assumes dereferencing get_drvdata without a dominating NULL check is unsafe; if the platform core guarantees non-NULL in some contexts, false positives may occur.
- Only patterns evidenced in the supplied materials are considered (platform_device, platform_set_drvdata/get_drvdata); other bus types or helper abstractions are out of scope.