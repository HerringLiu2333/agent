1. Plan Summary
Detect platform drivers whose remove/unbind path dereferences the result of platform_get_drvdata() while the probe path never calls platform_set_drvdata(), leading to a potential NULL dereference during teardown.

2. Detection Steps
1) Step 1: Identify candidate remove/unbind functions — look for functions taking a struct platform_device* and calling platform_get_drvdata(pdev) as per the remove path described in [ROOTCAUSE_ANALYSIS] — mitigate FPs by focusing on functions named or referenced as remove handlers or containing teardown logic (resource free, unregister).
2) Step 2: Capture the variable returned by platform_get_drvdata() — look for subsequent pointer member accesses (ptr->field), array subscripts via ptr, or passing ptr to functions likely to dereference it — mitigate FPs by requiring at least one direct dereference (e.g., ptr->...) after the get call.
3) Step 3: Check for null-check coverage — verify whether the dereference occurs on a path without an explicit null check gating it (e.g., if (!ptr) return/exit before deref) — mitigate FPs by excluding cases where all dereferences are guarded by a preceding null check on the same variable.
4) Step 4: Identify the corresponding probe function — in the same translation unit, find a function taking struct platform_device* and named like arm_ni_probe or referenced as a probe in driver registration, as indicated by [PATCH_DIFF] — mitigate FPs by preferring explicit ties via a platform_driver initializer if available.
5) Step 5: In the probe function, search for platform_set_drvdata(pdev, state_ptr) — absence indicates the flaw described in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS] — mitigate FPs by considering calls within any helper invoked by probe in the success path.
6) Step 6: Focus on the successful probe path — ensure analysis covers paths that reach a success return (e.g., return 0) after initializations like ni->num_cds, ni->part, ni->id = atomic_fetch_inc(&id) mentioned in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — mitigate FPs by requiring absence of platform_set_drvdata on all success paths.
7) Step 7: Confirm shared device context — ensure the pdev argument passed to platform_get_drvdata in remove is the same parameter symbol used in the probe function for potential platform_set_drvdata — mitigate FPs by avoiding cross-device mixing when multiple pdev variables exist.
8) Step 8: Strengthen signal from probe-side state initialization — optionally detect probe writing into a per-device struct (field assignments as in [PATCH_DIFF]) without binding it via platform_set_drvdata — mitigate FPs by combining this with Step 5’s absence check before flagging.
9) Step 9: Exclude benign patterns — exclude remove handlers that retrieve drvdata but do not dereference it (e.g., only compare to NULL or log) — mitigates FPs where NULL does not trigger a fault.
10) Step 10: Report when both conditions hold — remove path dereferences platform_get_drvdata without null-check, and probe lacks platform_set_drvdata on success — this directly maps to the root cause in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Function definitions of probe and remove handlers taking struct platform_device*.
- Calls to platform_get_drvdata(pdev) and platform_set_drvdata(pdev, ...).
- Variable assignments capturing platform_get_drvdata return values.
- Pointer dereferences (member access via ->, array indexing via *) of the drvdata pointer.
- Control-flow constructs around null checks and returns in remove.
- Driver registration structures (platform_driver) linking .probe and .remove (if present).

4. Dataflow / Taint Considerations
- Track dataflow from platform_get_drvdata(pdev) to pointer dereferences within the same remove function.
- Model control-flow predicates to detect absence of null checks guarding dereferences.
- Track calls in the probe’s success path to determine whether platform_set_drvdata(pdev, state_ptr) occurs before returning success.
- Associate the same pdev parameter across probe and remove within the same driver unit.

5. Validation & Test Cases
- Positive: A driver with remove calling platform_get_drvdata(pdev), dereferencing the returned pointer without a null check; probe initializes per-device state (e.g., sets fields) but never calls platform_set_drvdata(pdev, state_ptr) before returning 0 — expect a finding.
- Negative: A driver where probe calls platform_set_drvdata(pdev, state_ptr) on all success paths; remove retrieves drvdata and dereferences it — expect no finding.
- Negative: A driver where remove retrieves drvdata but checks for NULL and exits before any dereference — expect no finding.
- Test harness notes: Run on kernel modules containing platform drivers; include cases where .probe and .remove are connected via platform_driver and cases where they are merely conventionally named.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Drivers that use equivalent APIs (e.g., dev_set_drvdata/dev_get_drvdata) not covered by this pattern — mitigate by restricting to platform_* APIs as described in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].
- Conditional platform_set_drvdata calls that occur only on some success paths — mitigate by ensuring absence across all success returns.
- Complex multi-file drivers where probe/remove are in different files and linkage is not easily resolved — mitigate by limiting to same translation unit or explicit platform_driver ties.

8. Limitations & Assumptions
- Assumes the driver uses platform_get_drvdata in remove and platform_set_drvdata is the intended fix, based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; alternative association mechanisms are not considered.
- Assumes probe and remove are identifiable within the same translation unit or via platform_driver registration; cross-file resolution may be incomplete.
- Does not infer kernel-specific annotations or lifecycle nuances beyond what is implied in the supplied materials.