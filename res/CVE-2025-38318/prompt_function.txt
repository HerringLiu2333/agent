1. CVE Identifier
CVE-2025-38318

2. Vulnerability Type
NULL pointer dereference (error-path cleanup bug in platform driver)

3. Root Cause Summary
The probe routine arm_ni_probe() failed to associate its allocated device state (struct arm_ni *ni) with the platform device via platform_set_drvdata(). On initialization failure, arm_ni_probe() called arm_ni_remove(pdev), which in turn uses platform_get_drvdata(pdev). Because drvdata was never set, platform_get_drvdata() returned NULL and arm_ni_remove() dereferenced it, causing a kernel NULL pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
perf: ARM Network Interconnect (arm-ni) PMU platform driver

2) Pre-Patch Flaw:
arm_ni_probe() allocated and initialized ni but did not call platform_set_drvdata(pdev, ni) before any path that invokes arm_ni_remove(). The cleanup path inside probe executes arm_ni_remove(pdev) on failure without a valid drvdata to retrieve.

3) Trigger Condition:
Any failure in initializing a child component during probe, specifically when arm_ni_init_cd(ni, &cd, res->start) returns non-zero, leading to the error path that calls arm_ni_remove(pdev) before drvdata was set.

4) Impact Mechanism:
arm_ni_remove() calls platform_get_drvdata(pdev), receives NULL, and dereferences it, resulting in a kernel NULL pointer dereference and crash (denial of service) during device bind/probe or removal.

5. Patch Analysis
1) Fix Approach:
Ensure the driverâ€™s private state is registered with the platform device early in probe so that any subsequent remove/cleanup path can safely retrieve it.

2) Key Code Changes:
Added a single line in arm_ni_probe() after initializing ni fields:
- platform_set_drvdata(pdev, ni);
This guarantees arm_ni_remove() can obtain a valid ni via platform_get_drvdata() even on early failures.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The fix is purely an initialization ordering correction ensuring drvdata is set before any potential cleanup calls.

6. Broader Kernel Security Implications
This bug highlights the importance of establishing device-driver associations (drvdata) before any operation that might invoke remove/cleanup paths, especially in complex probe sequences with multiple failure points. Similar missing drvdata initializations in other drivers can lead to systemic NULL dereferences and easy denial-of-service conditions during device probing. Ensuring consistent driver core patterns (set drvdata immediately after allocation) improves robustness and reduces attack surface tied to error handling paths.