1. CVE Identifier
CVE-2024-58094

2. Vulnerability Type
Missing read-only state validation leading to NULL pointer dereference (Denial of Service)

3. Root Cause Summary
jfs_truncate_nolock() failed to check whether the filesystem/inode was read-only before initiating a transactional truncate sequence. On read-only mounts, JFS_SBI(sb)->log is NULL; entering the txBegin/txCommit path dereferences the NULL log and attempts journal-based modifications, causing a kernel crash. The patch adds an isReadOnly(ip) check to the early-return path, avoiding transaction-based truncation on read-only filesystems.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem, inode truncation and journaling path (fs/jfs/inode.c)

2) Pre-Patch Flaw:
jfs_truncate_nolock() only short-circuited when COMMIT_Nolink was set:
“if (test_cflag(COMMIT_Nolink, ip)) { … return; }”
It then proceeded to txBegin(), mutex_lock(commit_mutex), xtTruncate(..., COMMIT_TRUNCATE|COMMIT_PWMAP), txCommit(), txEnd() assuming a valid journal log, without verifying read-only state.

3) Trigger Condition:
Called on a read-only filesystem from the write failure path:
block_write_begin() → jfs_write_failed() → jfs_truncate() → jfs_truncate_nolock().
On RO mounts, JFS_SBI(tblk->sb)->log == NULL, and the transactional truncate path dereferences it (per PATCH_DESCRIPTION call stack).

4) Impact Mechanism:
Attempting txBegin/txCommit/txEnd with a NULL log leads to a NULL pointer dereference and kernel crash (DoS). It also represents an unsafe attempt to perform metadata modifications on a read-only filesystem.

5. Patch Analysis
1) Fix Approach:
Introduce an early read-only guard in jfs_truncate_nolock() to bypass transactional truncation and use a non-modifying path suitable for RO mode.

2) Key Code Changes:
Changed the early condition to:
“if (test_cflag(COMMIT_Nolink, ip) || isReadOnly(ip)) { xtTruncate(0, ip, length, COMMIT_WMAP); return; }”
This ensures no txBegin/txCommit path is taken when the inode is read-only; xtTruncate is invoked with COMMIT_WMAP and the function returns immediately.

3) Locking/Concurrency Impact:
By bailing out early on read-only, the function avoids taking JFS_IP(ip)->commit_mutex and starting a transaction (txBegin/txCommit/txEnd). No new locks are introduced; the patch reduces unnecessary locking/journaling in RO scenarios and prevents entering a path that assumes a writable journal.

6. Broader Kernel Security Implications
Consistent read-only checks across JFS metadata mutators prevent kernel crashes from routine I/O error-handling paths on RO mounts, reducing DoS vectors. Aligns jfs_truncate_nolock() with existing guards in jfs_commit_inode() and jfs_dirty_inode(), reinforcing the need to validate filesystem state before journaling or modifying metadata. This hardening improves robustness of filesystem error handling and reduces the attack surface where user-triggered writes to a RO FS could crash the kernel.