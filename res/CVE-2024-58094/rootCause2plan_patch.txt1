1. Plan Summary
Detect missing read-only state validation before entering JFS truncate/journaling code paths that dereference the JFS journal/log or perform transaction end, which can lead to NULL dereference on read-only mounts.

2. Detection Steps
1) Step 1: Scope to candidate locations â€” functions defined under fs/jfs that take a struct inode* parameter (commonly named ip) and participate in truncate/modify flows. Signals: function names like jfs_truncate_nolock or functions calling xtTruncate, or handling a loff_t length.

2) Step 2: Identify journaling/commit sinks within such functions. Signals: calls to txEnd, dereferences of a log pointer retrieved via JFS_SBI(...)->log, or other commit/journal-related operations present in the body.

3) Step 3: Identify the safe read-only handling pattern. Signals: a conditional that checks isReadOnly(ip) and, if true, calls xtTruncate(..., COMMIT_WMAP) followed by an early return, preventing entry into journaling/commit code.

4) Step 4: Determine control-flow dominance of read-only checks. Signals: absence of any isReadOnly(ip)-based guard that dominates all paths from function entry to the journaling/commit sinks identified in Step 2.

5) Step 5: Flag functions where journaling/commit sinks are reachable without a dominating isReadOnly(ip) guard. Signals: path existence from entry to txEnd or JFS_SBI(...)->log deref with no intervening isReadOnly(ip) gating that aborts or takes the safe path.

6) Step 6: Strengthen confidence by detecting the pre-patch pattern. Signals: presence of an early-return guard using test_cflag(COMMIT_Nolink, ip) that routes to xtTruncate(..., COMMIT_WMAP), but no analogous guard that checks isReadOnly(ip).

7) Step 7: Verify that the unguarded path does not call xtTruncate(..., COMMIT_WMAP) before reaching the journaling/commit sinks. Signals: control-flow path where xtTruncate with COMMIT_WMAP is not taken prior to txEnd or log access.

8) Step 8: Correlate inode argument usage. Signals: the same inode parameter (ip) is passed to both the guard candidates (if any) and to operations in the function (e.g., passed to xtTruncate or used to derive state), ensuring the check would be relevant if present.

9) Step 9: Optionally raise priority when the function is directly in the truncate call chain. Signals: function name jfs_truncate_nolock or being called by jfs_truncate/jfs_write_failed/block_write_begin (if call graph info is available).

10) Step 10: Produce a result with path evidence. Signals: entry point in the function, absence of isReadOnly(ip) guard, and the first journaling/commit sink (txEnd or JFS_SBI(...)->log deref) reached on the same path.

3. Limitations & Assumptions
- Assumes the read-only predicate is named isReadOnly and is invoked with the inode; alternative guard APIs/macros are not recognized.
- Assumes dereferencing JFS_SBI(...)->log or calling txEnd indicates journaling that must not run on read-only mounts; other equivalent sinks may be missed.
- Does not infer semantic read-only state from mounts; relies purely on syntactic presence/absence of isReadOnly(ip) guarding.
- Matching JFS_SBI(...)->log relies on recognizable member access; heavy macro indirection may reduce precision.
- The plan is JFS-specific; applicability to other filesystems or different transaction APIs is out of scope based on supplied materials.