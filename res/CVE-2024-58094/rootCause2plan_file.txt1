1. Plan Summary
Detect JFS metadata-modifying functions that initiate journaling transactions (txBegin/txCommit/txEnd or transactional xtTruncate) without a dominating isReadOnly(inode) guard that prevents entering the transaction path on read-only filesystems.

2. Detection Steps
1) Step 1: Scope to JFS inode/metadata mutators — functions in fs/jfs that call txBegin/txCommit/txEnd or xtTruncate with transactional flags (e.g., COMMIT_TRUNCATE | COMMIT_PWMAP).
2) Step 2: Identify the “subject inode” in each function — a struct inode* variable passed to these sinks or used to derive the superblock for txBegin (e.g., ip->i_sb for txBegin, ip passed to xtTruncate).
3) Step 3: Mark transaction sinks — calls to txBegin(ip->i_sb, …), txCommit(…, &ip, …), txEnd(…), and xtTruncate(tid, ip, …, COMMIT_TRUNCATE | COMMIT_PWMAP), where tid is non-zero or taken from txBegin.
4) Step 4: For each path to a transaction sink, check for a dominating read-only guard — a conditional that calls isReadOnly(subject inode) and, when true, prevents reaching any transaction sink (e.g., returns early or diverts control away).
5) Step 5: Accept safe early alternatives — consider it guarded if the true branch of isReadOnly(ip) returns or calls a non-transactional alternative like xtTruncate(0, ip, …, COMMIT_WMAP) and then returns.
6) Step 6: Flag missing guards — if any transaction sink is reachable from function entry without passing through a dominating isReadOnly(subject inode) guard, report the function and sink.
7) Step 7: Prioritize COMMIT_Nolink-only bails — if there is an early conditional that tests test_cflag(COMMIT_Nolink, ip) and bails out, but no analogous isReadOnly(ip) check before transaction sinks, elevate severity (mirrors the pre-patch flaw).
8) Step 8: Validate subject consistency — ensure the isReadOnly() check (if present) applies to the same inode variable that flows into txBegin/xtTruncate; disregard checks on unrelated inodes.
9) Step 9: Enforce control-flow strength — the isReadOnly() guard must dominate the sink along all paths; non-dominating or conditional guards that still allow sink reachability are considered insufficient.
10) Step 10: Heuristic context signal — optionally, treat functions reachable from jfs_truncate() or jfs_write_failed() within the same file as higher confidence findings if they lack a dominating isReadOnly guard.

3. Limitations & Assumptions
- Assumes txBegin/txCommit/txEnd and xtTruncate with COMMIT_TRUNCATE | COMMIT_PWMAP imply journaling that is unsafe on read-only filesystems; other modules not shown may alter this behavior.
- Only APIs and flags present in the supplied content are considered; additional safe patterns or guards elsewhere in the kernel are not modeled.
- The plan relies on intra-procedural dominance; it does not prove that callers already filter read-only state before invocation.
- Recognizing “safe alternatives” is limited to early return or xtTruncate with tid 0 and COMMIT_WMAP as per the patch; other safe patterns are not inferred.