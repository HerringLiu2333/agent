1. Plan Summary
Detect functions in JFS truncate/journaling paths that perform journal/log operations without a dominating read-only check, risking NULL log dereference and DoS on read-only mounts (based on [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]).

2. Detection Steps
1) Step 1: Objective — identify candidate JFS functions involved in truncate/journaling. Signals — functions in fs/jfs that take an inode-like parameter (e.g., ip) and contain calls to xtTruncate, txEnd, or access JFS_SBI(...)->log (from [ROOTCAUSE_ANALYSIS]/[PATCH_DESCRIPTION]). FP mitigation — restrict to files under fs/jfs and functions whose names or bodies indicate truncate semantics (e.g., contain "truncate" or call xtTruncate).

2) Step 2: Objective — detect potentially dangerous journal/log usage. Signals — intra-function occurrences of txEnd() and/or dereferences/uses of JFS_SBI(tblk->sb)->log prior to function exit (from [ROOTCAUSE_ANALYSIS]). FP mitigation — ensure the log value is actually used (passed to functions or dereferenced), not merely stored.

3) Step 3: Objective — find the intended safe early-return path for read-only mode. Signals — an if-branch that calls xtTruncate(..., COMMIT_WMAP) and returns early (from [PATCH_DESCRIPTION]/[PATCH_DIFF]). FP mitigation — confirm xtTruncate is invoked with COMMIT_WMAP and that the branch ends control flow (e.g., return).

4) Step 4: Objective — detect missing read-only guard. Signals — absence within the early-return condition of a check equivalent to isReadOnly(ip), especially when the condition currently only tests test_cflag(COMMIT_Nolink, ip) (from [PATCH_DIFF]). FP mitigation — only flag when dangerous journal/log usage (Step 2) is reachable on the remaining paths.

5) Step 5: Objective — verify dominance of read-only guard across all paths to journal/log usage. Signals — control-flow/path analysis showing a path from function entry to txEnd()/log use that is not dominated by a condition testing isReadOnly(ip) leading to an early return or safe path (from [ROOTCAUSE_ANALYSIS]). FP mitigation — require that no other earlier check reliably prevents read-only execution (e.g., verify no isReadOnly(ip) gating before the dangerous call).

6) Step 6: Objective — model the vulnerability trigger condition. Signals — existence of a feasible path where isReadOnly(ip) could be true (no guarding condition excludes it) and yet txEnd()/log access remains reachable (from [ROOTCAUSE_ANALYSIS]). FP mitigation — increase confidence if the function is known to be called from truncate/write failure paths (names/callers like jfs_truncate/jfs_write_failed per [PATCH_DESCRIPTION]).

7) Step 7: Objective — confirm non-safe journaling on the non-guarded path. Signals — presence of commit/journal operations beyond the safe COMMIT_WMAP truncation path (e.g., txEnd or log-dependent behavior) (from [ROOTCAUSE_ANALYSIS]). FP mitigation — suppress if all code paths use xtTruncate with COMMIT_WMAP before returning.

8) Step 8: Objective — detect pre-patch pattern specifically. Signals — if-condition with test_cflag(COMMIT_Nolink, ip) that calls xtTruncate(..., COMMIT_WMAP) and returns, but no disjunct for isReadOnly(ip) (from [PATCH_DIFF]). FP mitigation — require subsequent presence of txEnd()/log use later in the same function.

9) Step 9: Objective — avoid duplicate/benign reports. Signals — if a dominating check for isReadOnly(ip) exists anywhere before the first journal/log use, do not report (from [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]). FP mitigation — ensure dominance analysis considers all branches to the first dangerous use.

3. Target Elements
- Function definitions in fs/jfs (e.g., jfs_truncate_nolock) operating on struct inode-like parameters.
- Conditional checks and early-return branches (if statements combining test_cflag and/or isReadOnly).
- Calls to xtTruncate with flags, especially COMMIT_WMAP.
- Calls to txEnd or equivalent transaction-ending routines.
- Field/member access to JFS_SBI(...)->log or uses of a log pointer.
- Return statements controlling early exit from functions.
- Call sites linking jfs_truncate_nolock with jfs_truncate/jfs_write_failed/block_write_begin (for confidence boosting).

4. Dataflow / Taint Considerations
- Track control-flow paths from function entry to the first txEnd()/log access.
- Determine dominance of isReadOnly(ip)-guarded early-return/safe-path branches over these paths.
- Track the inode parameter (ip) through isReadOnly(ip) calls to ensure the correct object is being checked.
- Identify whether xtTruncate(..., COMMIT_WMAP) is on a path that returns before any journal/log usage.

5. Validation & Test Cases
- Positive: A function like jfs_truncate_nolock that (a) has an early return guarded only by test_cflag(COMMIT_Nolink, ip), (b) later calls txEnd() or dereferences JFS_SBI(...)->log; expect a finding.
- Positive: A truncate-like function that accesses JFS_SBI(...)->log without any preceding isReadOnly(ip) check and no safe COMMIT_WMAP early path; expect a finding.
- Negative: The patched version with if (test_cflag(COMMIT_Nolink, ip) || isReadOnly(ip)) { xtTruncate(..., COMMIT_WMAP); return; } and any later journal/log usage; expect no finding.
- Negative: A function that only calls xtTruncate(..., COMMIT_WMAP) and returns, with no txEnd()/log usage; expect no finding.
- Test harness notes: Run on fs/jfs sources; validate control-flow dominance and path feasibility to ensure the read-only guard must precede journal/log usage.

6. Estimated Effort & Priority
Medium: requires control-flow dominance and basic path feasibility analysis but limited to JFS patterns and APIs evident in the patch.

7. Likely False-Positive Sources & Mitigations
- Implicit read-only validation enforced by callers not visible in the analyzed unit; mitigate by boosting confidence when known callers match the provided call stack or by requiring intra-function guards.
- Macros obscuring isReadOnly or txEnd/log usage; mitigate by resolving common macros and requiring concrete calls/field accesses when possible.
- Functions where log is guaranteed non-NULL for other reasons; mitigate by focusing on read-only guard absence coupled with journal/log usage, as per [ROOTCAUSE_ANALYSIS].

8. Limitations & Assumptions
- Assumes isReadOnly(ip) is the canonical read-only check in JFS, as per [PATCH_DIFF]/[PATCH_DESCRIPTION]; alternative APIs are not considered.
- Assumes txEnd() and JFS_SBI(...)->log are the relevant journal/log operations causing NULL deref on read-only mounts (from [ROOTCAUSE_ANALYSIS]); other journaling functions are not enumerated.
- Does not prove that isReadOnly(ip) can be true at runtime; treats absence of a dominating guard as a potential vulnerability per the described trigger.