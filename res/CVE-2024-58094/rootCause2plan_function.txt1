1. Plan Summary
Detect JFS mutation routines that initiate transactional truncate/metadata updates without first guarding on read-only state, which can lead to NULL journal dereference and unintended writes on read-only filesystems.

2. Detection Steps
1) Step 1: Identify candidate functions that perform JFS transactional updates — look for calls to txBegin(...), txCommit(...), txEnd(...), and/or xtTruncate(...) with transactional flags (e.g., COMMIT_TRUNCATE or COMMIT_PWMAP) and a nonzero transaction handle.
2) Step 2: Within each candidate function, find the inode parameter used for the transaction — typically a struct inode* (e.g., ip) that is passed to xtTruncate(...) and whose ip->i_sb is used in txBegin(...).
3) Step 3: For each path from function entry to the first transactional operation (txBegin or xtTruncate with transactional flags), determine if there is an earlier guard that checks read-only state on the same inode.
4) Step 4: Recognize a valid read-only guard if a condition includes isReadOnly(ip) and on the true branch it short-circuits into a non-transactional path (e.g., calls xtTruncate with a zero transaction handle and COMMIT_WMAP) followed by an immediate return.
5) Step 5: Treat guards combined with other early-exit conditions (e.g., test_cflag(COMMIT_Nolink, ip) || isReadOnly(ip)) as sufficient, provided the isReadOnly(ip) branch prevents reaching txBegin/transactional xtTruncate.
6) Step 6: Flag as vulnerable any path that reaches txBegin(ip->i_sb, ...) or xtTruncate(..., COMMIT_TRUNCATE|COMMIT_PWMAP) without any preceding isReadOnly(ip)-based short-circuit.
7) Step 7: Also flag cases where an isReadOnly(ip) check exists but appears only after txBegin/txCommit/txEnd are invoked on that path (i.e., the read-only check does not prevent starting a transaction).
8) Step 8: Strengthen confidence by confirming additional transactional-context signals on the vulnerable path, such as mutex_lock(&JFS_IP(ip)->commit_mutex), mark_inode_dirty(ip), and a subsequent txCommit()/txEnd() sequence.
9) Step 9: When xtTruncate is used, ensure the “unsafe” path passes a nonzero transaction identifier and transactional flags (COMMIT_TRUNCATE or COMMIT_PWMAP), distinguishing it from the safe, non-transactional COMMIT_WMAP usage.
10) Step 10: Report the entry point of the transactional path (e.g., the txBegin or transactional xtTruncate call) along with the absence or lateness of an isReadOnly(ip) short-circuit that would have returned prior to starting a transaction.

3. Limitations & Assumptions
- Assumes the read-only check is performed via isReadOnly(ip); alternative APIs or mount-state checks are not covered.
- Assumes that “non-transactional” xtTruncate is characterized by a zero transaction handle and COMMIT_WMAP, per the provided context.
- Does not infer dynamic mount states or whether JFS_SBI(sb)->log is NULL; it flags purely based on missing pre-transaction read-only checks.
- Macro/flag resolution (e.g., identifying COMMIT_TRUNCATE/COMMIT_PWMAP/COMMIT_WMAP) depends on recognizable names; heavily aliased or indirect patterns may be missed.
- Scope is focused on JFS code paths using the txBegin/txCommit/txEnd framework; other subsystems or differently named transaction frameworks are not addressed.