1. Plan Summary
Detect improper use of IS_ERR()/PTR_ERR() to check the result of devm_kzalloc(), which returns NULL on failure, potentially leading to unchecked NULL dereferences in driver probe paths.

2. Detection Steps
1) Step 1: Identify variables assigned from calls to devm_kzalloc (objective: capture allocation sites that return NULL on error — signals: function call named "devm_kzalloc" whose return value is stored in a local/field variable).
2) Step 2: Find subsequent uses of IS_ERR(var) and/or PTR_ERR(var) on that same variable within the same function (objective: detect erroneous error-checking patterns — signals: conditional expressions or statements invoking IS_ERR(var), and return/error propagation using PTR_ERR(var)).
3) Step 3: Prioritize cases where IS_ERR(var) controls an early-return or error path (objective: focus on misuse that hides allocation failure — signals: branches like "if (IS_ERR(var)) return PTR_ERR(var);" or IS_ERR(var) followed by return/goto assigning PTR_ERR(var) or a negative error code).
4) Step 4: Check for absence of a correct NULL check on the same variable before its use (objective: reduce false positives — signals: no condition of the form "!var" (or equivalent null-check) guarding the subsequent code paths that use the variable).
5) Step 5: Identify dereferences or member accesses of the variable after the erroneous IS_ERR check (objective: confirm potential NULL dereference — signals: expressions like "var->field", "*var", array indexing "var[i]", or passing var to functions where it is dereferenced or treated as non-NULL).
6) Step 6: Ensure the dereference in Step 5 occurs on a path not dominated by a proper NULL check (objective: raise confidence — signals: control-flow/path reachability where dereference is reachable without an intervening "!var" guard).
7) Step 7: Track simple aliases of the devm_kzalloc result to catch indirect misuse (objective: handle common coding styles — signals: assignments, local copies, or casts where the same underlying pointer flows into IS_ERR/PTR_ERR checks or dereferences).
8) Step 8: Report findings when Steps 2 and 5 co-occur (high confidence) and when Step 2 occurs without Step 5 (medium confidence) (objective: produce actionable results — signals: include locations of the devm_kzalloc assignment and the IS_ERR/PTR_ERR misuse, and optionally the first dereference site).

3. Limitations & Assumptions
- The plan assumes devm_kzalloc returns NULL on failure; other allocation helpers with similar semantics are not covered due to lack of evidence in the provided materials.
- The checker does not verify runtime conditions; it approximates null-guard presence and reachability statically and may miss complex guards or path-specific reassignment.
- Determining whether a function argument is guaranteed to be dereferenced internally is not fully reliable without broader API models; dereference detection focuses on explicit member accesses or direct pointer deref operations.
- The plan relies on recognizing IS_ERR and PTR_ERR as functions/macros; macro expansions and unconventional wrappers may reduce detection accuracy.