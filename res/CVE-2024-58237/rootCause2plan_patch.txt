1. Plan Summary
Detect instances where code lacks the safety/validation/ordering patterns that the patch introduced, by generalizing from the syntactic and semantic changes in the patch and locating equivalent pre-patch constructs that omit those changes.

2. Detection Steps
1) Step 1: Objective — Identify the exact syntactic elements changed by the patch (functions, conditions, return-value checks, locking, etc.) — Signals: entities and AST nodes added/modified/removed in [PATCH_DIFF] — FP mitigation: Restrict subsequent matching to code contexts anchored by these identifiers and modules.
2) Step 2: Objective — Model the “guarding condition” or “validation” newly added — Signals: newly added conditional checks, early returns, assertions, or sanitization calls around sensitive operations — FP mitigation: Require same variables/operands/operational context as seen in [PATCH_DIFF].
3) Step 3: Objective — Model the “sink” operation that the new guard protects — Signals: operations directly following the patch’s new checks (e.g., dereference, call, state change, resource use) — FP mitigation: Bind sinks to the exact receivers/arguments/fields reflected in [PATCH_DIFF].
4) Step 4: Objective — Find occurrences of the sink without the corresponding guard — Signals: control-flow paths reaching the sink where the modeled guard condition or equivalent is absent — FP mitigation: Exclude paths with logically equivalent prior checks or sanitizers.
5) Step 5: Objective — If the patch adds return-value/error checks, detect call sites lacking such checks — Signals: calls to the same API where post-call condition handling (e.g., null/error/size/permission) is missing — FP mitigation: Accept alternative validated handling if semantically equivalent to the patch pattern.
6) Step 6: Objective — If the patch introduces sequencing or locking, detect unprotected access — Signals: accesses to the same resource/state without the lock/acquire/release or ordering introduced in [PATCH_DIFF] — FP mitigation: Recognize existing synchronization mechanisms that are equivalent.
7) Step 7: Objective — Track variables involved in the guard from their sources to the sink — Signals: dataflow from sources used in the new guard into the sink’s arguments/receivers — FP mitigation: Treat as safe if the dataflow passes through a sanitizer/normalizer analogous to additions in [PATCH_DIFF].
8) Step 8: Objective — Recognize guard equivalence to reduce false positives — Signals: conditions that are logically equivalent to the patch’s checks (negations, combined predicates, utility functions) — FP mitigation: Apply simple boolean normalization and aliasing of helper functions seen in [PATCH_DIFF].
9) Step 9: Objective — Handle interprocedural movement of checks — Signals: guards moved into callees or propagated to wrappers as indicated by [PATCH_DIFF] — FP mitigation: Require the same call graph relationships and variable roles as in the patch.
10) Step 10: Objective — Limit scope to relevant modules and variants — Signals: namespaces/files/feature flags affected by [PATCH_DIFF] — FP mitigation: Avoid matching in unrelated subsystems by anchoring on the same module boundaries and feature defines.

3. Target Elements
- Functions and methods changed or referenced in [PATCH_DIFF]
- Call sites to functions whose usage was guarded or validated by the patch
- Condition checks, early returns, and assertions introduced by the patch
- Resource/lock acquire and release sites newly added
- Sinks: dereferences, state mutations, external calls, or resource uses immediately after added checks
- Function return-value uses and error-handling branches added by the patch
- Module/namespace/file boundaries implicated in the patch

4. Dataflow / Taint Considerations
- Track values referenced by the new guard conditions to the sink operations they protect.
- Treat flows as safe if they pass through sanitizers/validators analogous to those introduced by the patch.
- Consider interprocedural propagation if checks are moved across function boundaries per [PATCH_DIFF].
- Model guard equivalence (e.g., helper wrapper functions vs. inline checks) as seen in the patch.

5. Validation & Test Cases
- Positive: A sample emulating the pre-patch pattern where a sink operation occurs without the added guard/validation/ordering; the checker should flag it.
- Negative: A sample emulating the post-patch pattern where the guard/validation/ordering is present and equivalent; the checker should not flag it.
- Test harness notes: Use differential testing on pre-patch vs. post-patch code snapshots derived from [PATCH_DIFF] to ensure only pre-patch instances are reported.

6. Estimated Effort & Priority
Unknown; contingent on the complexity of the changes in [PATCH_DIFF]. Default medium effort pending availability of patch details.

7. Likely False-Positive Sources & Mitigations
- Alternative but equivalent validations not identical to the patch pattern — Mitigate via logical equivalence and sanitizer recognition.
- Different modules using similarly named functions with different contracts — Mitigate by scoping to modules/files seen in [PATCH_DIFF].
- Contexts where invariants are guaranteed externally (e.g., framework preconditions) — Mitigate by allowing project-configurable trusted entry points or invariants.

8. Limitations & Assumptions
- No [PATCH_DESCRIPTION], [PATCH_DIFF], or [ROOTCAUSE_ANALYSIS] content is available; the specific vulnerability class, sinks, and guards are unknown.
- The plan assumes that [PATCH_DIFF] adds observable guards/validations/ordering around identifiable sinks; if the fix is non-local or semantic-only, additional project-specific modeling is required.
- Validation relies on access to pre- and post-patch snapshots to instantiate the abstract pattern into concrete signals.