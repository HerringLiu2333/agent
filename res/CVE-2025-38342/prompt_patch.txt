1. CVE Identifier
CVE-2025-38342

2. Vulnerability Type
Out-of-bounds read due to incorrect bounds check (off-by-one/length validation error)

3. Root Cause Summary
software_node_get_reference_args() validated only that the starting offset of the requested element was within the property buffer, not that the entire element fit. The pre-patch check "if (index * sizeof(*ref) >= prop->length)" failed to account for the full size of the element at index, allowing access when the buffer ended with a partial element. For malformed properties where prop->length is not a multiple of sizeof(*ref), this leads to reading past the end of the buffer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Device property software nodes (firmware node handling) in the software node subsystem

2) Pre-Patch Flaw:
An incorrect out-of-bounds check in software_node_get_reference_args() only verified the start offset (index * sizeof(*ref)) against prop->length, instead of requiring that (index + 1) * sizeof(*ref) be within prop->length. This permitted indexing into an incomplete trailing element and dereferencing beyond the allocated buffer.

3) Trigger Condition:
A malformed property where prop->length does not provide a full element for the requested index (e.g., prop->length not a multiple of sizeof(*ref)), such that index * sizeof(*ref) < prop->length but (index + 1) * sizeof(*ref) > prop->length.

4) Impact Mechanism:
Dereferencing ref_array[index] reads memory past prop->pointerâ€™s allocated length, causing an out-of-bounds read, which can lead to kernel memory exposure or a crash.

5. Patch Analysis
1) Fix Approach:
Strengthened the bounds check to ensure the entire element at the requested index fits within the property value by verifying "(index + 1) * sizeof(*ref) > prop->length" and returning -ENOENT if true.

2) Key Code Changes:
In software_node_get_reference_args():
- Replaced "if (index * sizeof(*ref) >= prop->length)" with "if ((index + 1) * sizeof(*ref) > prop->length)" to require sufficient bytes for a full element.
- No other logic changes; error returns and is_inline check remain.

3) Locking/Concurrency Impact:
None; the change is a pure arithmetic bounds check adjustment with no locking or ordering modifications.

6. Broader Kernel Security Implications
Correct element-size-aware bounds checking is critical when parsing variable-length properties to prevent OOB reads. This fix reduces the attack surface where malformed data can trigger memory violations in property processing routines. It highlights the importance of validating both the start offset and the full size of accessed elements, avoiding off-by-one errors and size miscalculations.