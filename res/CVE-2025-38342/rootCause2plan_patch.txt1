1. Plan Summary
Detect cases where code validates only the starting byte offset (index * element_size) against a buffer length before indexing a typed element, failing to ensure the entire element fits, leading to potential out-of-bounds read.

2. Detection Steps
1) Step 1: Identify element access — locate array-style or pointer-arithmetic reads of a typed element using an index (e.g., ref_array[index] or *(ref_array + index)), where the element type T is known or implied by sizeof(*ref)/sizeof(T).
2) Step 2: Correlate buffer and length — ensure the accessed pointer is derived from a buffer object that has an associated byte length field used in the same function (e.g., ref_array assigned from prop->pointer and length taken from prop->length belonging to the same base object).
3) Step 3: Find the guarding check — detect a conditional that compares index multiplied by element size against the buffer length (pattern: index * sizeof(T) on one side, length on the other) using a relational operator that allows access when only the start offset is within bounds (e.g., “>=” or “>” style checks on index*size vs length).
4) Step 4: Exclude correct “full-element” checks — suppress if, on the path guarding the access, there exists a condition ensuring a complete element fits (e.g., uses (index + 1) with element size against length, or compares index against length/sizeof(T) with a strict upper bound like index < length/sizeof(T) or equivalent).
5) Step 5: Verify control dependence — confirm the element access is control-dependent on the passing branch of the check from Step 3 (e.g., the failing branch returns/breaks, and the access happens only if the check permits it).
6) Step 6: Confirm size coherence — verify the element size used in the check matches the size of the element actually read (e.g., sizeof(*ref) corresponds to the type of ref_array[index]); tolerate benign casts if they do not change the logical element size.
7) Step 7: Strengthen pointer–length association — ensure the length used in the check corresponds to the same buffer as the pointer being indexed (e.g., both fields accessed via the same struct/base value; track simple assignments like ref_array = prop->pointer).
8) Step 8: Report when only start-offset is validated — emit a finding when Steps 1–3 and 5–7 hold and Step 4 does not; highlight that the guard validates index*sizeof(T) against length but does not ensure (index + 1)*sizeof(T) ≤ length, risking OOB on incomplete trailing elements.
9) Step 9: Cover reversed/equivalent forms — also match logically equivalent guard forms with operands swapped (e.g., length <= index*size) or negated conditions that still only validate start offset without the “+1” term.
10) Step 10: Handle multiple accesses — if several element reads share the same flawed guard, report each access or one consolidated finding per guard region to reduce noise.
11) Step 11: Recognize inline/early filters as unrelated — ignore unrelated precondition checks (e.g., is_inline) that do not constrain index vs length; they neither mitigate nor satisfy the full-element bound.
12) Step 12: Prioritize byte-length semantics — prefer cases where the compared “length” is a byte count (field names like length/len/size), but rely on structural linkage to the buffer rather than names alone to avoid name-based bias.

3. Limitations & Assumptions
- Assumes the length expression denotes bytes and corresponds to the same buffer being indexed; static analysis infers this via field/base correlation but cannot prove runtime invariants.
- May miss cases where element size is computed indirectly (e.g., via variables/macros) or where algebraically equivalent correct checks exist in non-obvious forms not recognized by the suppression criteria.
- May flag false positives if external invariants guarantee length is a multiple of element size, which the analyzer cannot verify.
- Does not address negative index or integer overflow issues; focuses solely on the start-offset vs full-element OOB pattern.
- Macro-heavy or inlined patterns could evade detection if they obscure the index*size vs length relationship beyond analyzable AST.