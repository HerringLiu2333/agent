1. Plan Summary
Detect insufficient bounds checks that validate only the starting offset (index * sizeof(element)) before indexing into a buffer-backed array, instead of ensuring the full element fits within the buffer length.

2. Detection Steps
1) Step 1: Identify code that derives an element array pointer from a buffer with an associated length field. Signals: a pointer variable assigned from a structure’s “pointer”-like field and a sibling “length”-like field accessed in the same function/scope.

2) Step 2: Find indexing into that array using an explicit index to obtain an element pointer. Signals: expressions like &base[index], base[index], or base + index producing an element pointer subsequently used.

3) Step 3: Locate the nearest guard condition that attempts to validate bounds using arithmetic on the index and element size against the length. Signals: a comparison that uses index * sizeof(element) (or sizeof(*element)) against the length, returning/aborting on the comparison being true.

4) Step 4: Classify the guard as “start-offset only” if it does not account for the full element size at the selected index. Signals: absence of (index + 1) in the arithmetic, and no equivalent check such as index < length / sizeof(element) that ensures a complete element fits.

5) Step 5: Confirm that, after the guard passes, the code computes the element pointer for the given index and proceeds to dereference it. Signals: ref = &base[index] followed by member access (e.g., ref->node, ref->args[i]) or copying from the element.

6) Step 6: Verify that the sizeof() operand in the guard matches the actual element type of the array being indexed. Signals: the sizeof() expression refers to the same type as the array element (e.g., sizeof(*ref) when ref points to base[index]).

7) Step 7: Exclude safe implementations that validate the complete element fits before dereference. Signals: any check ensuring (index + 1) * sizeof(element) <= length or an equivalent condition such as index < length / sizeof(element).

8) Step 8: Report a finding when an element is accessed after only a start-offset check and there is no complete-element bounds check. Signals: presence of element dereferences or copies following the insufficient guard, with the guard structured as index * sizeof(element) compared to length.

3. Limitations & Assumptions
- Assumes the “length” field represents the total byte size of the backing buffer and the array elements are laid out contiguously within it.
- Does not verify whether lengths are multiples of sizeof(element); flags based on the guard’s arithmetic, which may produce false positives if other implicit guarantees exist.
- Focuses on local patterns within a function; cross-function invariants or external validations are not considered.
- The specific property types (e.g., DEV_PROP_REF) and “inline” semantics are not required for detection and thus not enforced by the checker.