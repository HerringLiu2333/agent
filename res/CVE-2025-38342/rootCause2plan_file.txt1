1. Plan Summary
Detect array indexing guarded by an insufficient byte-length check that ensures only the start offset (index * element_size) is in-bounds but not that the full element fits, leading to potential out-of-bounds reads.

2. Detection Steps
1) Step 1: Identify candidate buffer/length pairs. Signals: a struct/object providing both a data pointer and a byte-length (e.g., prop->pointer and prop->length) and a typed pointer derived from that data (e.g., const struct software_node_ref_args *ref_array = prop->pointer).
2) Step 2: Identify array element access using an index. Signals: expressions of the form buf[index], &buf[index], or pointer arithmetic equivalent, where buf points to elements of a concrete type T (e.g., software_node_ref_args).
3) Step 3: Determine the element size used in checks. Signals: sizeof(T) or sizeof(*buf) referenced in comparisons involving the index and the length variable.
4) Step 4: Collect dominating guard conditions that compare index and length using element size. Signals: boolean conditions like index * sizeof(T) < length or index * sizeof(T) >= length (or their negations) that gate the array access.
5) Step 5: Detect insufficient “start-offset-only” checks. Signals: presence of a guard of the form index * sizeof(T) < length (or a negated >= check) without using (index + 1) or equivalent, preceding the array access.
6) Step 6: Verify absence of a sufficient “full-element” check. Signals: no dominating condition ensuring (index + 1) * sizeof(T) <= length, and no equivalent count-based check index < (length / sizeof(T)).
7) Step 7: Ensure the element is actually dereferenced/used after the guard. Signals: field access or copy from the chosen element (e.g., buf[index].field, reading ref->node or ref->args[i], memcpy from &buf[index]).
8) Step 8: Match pointer/length provenance to reduce false positives. Signals: the data pointer used for indexing is directly or transitively assigned from the same object that provides the length (e.g., buf derived from prop->pointer and length is prop->length).
9) Step 9: Confirm element size consistency between guard and access. Signals: the sizeof used in the guard corresponds to the actual element type of buf (e.g., sizeof(*ref) matches the element type used in buf[index]).
10) Step 10: Optionally refine using known preconditions to prioritize findings. Signals: dominating checks like prop->type == DEV_PROP_REF and !prop->is_inline, which indicate the data is an out-of-line array of references as in the vulnerable function.
11) Step 11: Exclude safe patterns using element count. Signals: earlier computation of count = length / sizeof(T) (or equivalent) and a guard index < count dominating the access.
12) Step 12: Report the issue with context. Signals: link the guard expression (showing missing +1), the array access site, and the length/pointer variables to explain that the check permits partial-element reads.

3. Limitations & Assumptions
- Assumes the checker can reason about dominance/path conditions; if checks occur in distant callers, they may be missed.
- Focuses on guards expressed with multiplication by sizeof or division by sizeof; non-obvious encodings (e.g., shifts, helper wrappers) may be missed.
- Assumes the data pointer and length are available in the same scope and can be associated (as in prop->pointer/prop->length); more complex aliasing may not be captured.
- Does not distinguish intentional partial reads; flags any case where a full-element guarantee is not enforced.
- Relies on accurate type recovery for sizeof(T) correspondence with the indexed element type.