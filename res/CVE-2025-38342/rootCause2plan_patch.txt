1. Plan Summary
Detect incorrect bounds checks that validate only the start offset (index * element_size) against a byte-length before accessing base[index], instead of ensuring the full element (index + 1) * element_size fits within the buffer.

2. Detection Steps
1) Step 1: Objective — Find element reads from a byte-addressed buffer. Signals — Array indexing or pointer arithmetic/dereference of a pointer to elements (e.g., ref_array[index]) where element_size conceptually is sizeof(*pointer) or the pointee type size. FP mitigation — Ignore cases where no actual dereference/read follows (only pointer computation).

2) Step 2: Objective — Identify dominating bounds checks tied to that access. Signals — An if-condition comparing index * element_size with a length expression, with an error/return on the “too large” branch and fall-through otherwise. FP mitigation — Require control-flow dominance: the check must guard the access on all reaching paths.

3) Step 3: Objective — Recognize the flawed “start-offset-only” check. Signals — Conditions of the form index * element_size >= length (or >) used to reject, allowing execution when index * element_size < length. FP mitigation — Correlate the element_size used in the check to the element actually dereferenced (e.g., sizeof(*ref)), as in the pre-patch code noted in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

4) Step 4: Objective — Determine if the full-element fit is not ensured. Signals — Absence of any dominating condition equivalent to (index + 1) * element_size <= length or index < length / element_size, matching the fix in [PATCH_DESCRIPTION] and [PATCH_DIFF]. FP mitigation — Accept algebraically equivalent variants (e.g., computed count = length / element_size with index < count).

5) Step 5: Objective — Ensure an actual read occurs after the flawed check. Signals — Use of base[index], dereference of the computed element address, or reading fields through that element after the check. FP mitigation — Exclude cases that only compute an address without reading or copying data.

6) Step 6: Objective — Confirm the length is a byte-length, not an element count. Signals — The check multiplies index by element_size when comparing to the length, consistent with byte-length semantics described in [ROOTCAUSE_ANALYSIS]. FP mitigation — If the length is already divided by element_size or documented/derived as a count (e.g., named “count” and no size multiplication), do not flag.

7) Step 7: Objective — Tie the property pointer and length together. Signals — The base pointer used in the access originates from a buffer associated with the length expression (e.g., fields like .pointer and .length, as in [PATCH_DIFF]). FP mitigation — Require dataflow correlation from the same structure or parameter set to reduce unrelated matches.

8) Step 8: Objective — Exclude code that guarantees element alignment globally. Signals — A dominating check that length % element_size == 0 or equivalent invariant ensuring no partial trailing element. FP mitigation — If such an invariant dominates the access, suppress the alert because start-offset check may be sufficient per [ROOTCAUSE_ANALYSIS Trigger Condition].

9) Step 9: Objective — Reduce noise for byte-sized elements. Signals — element_size equals 1 byte (char/uint8_t), making start-offset check equivalent to full-element fit. FP mitigation — Do not flag when element_size is 1.

10) Step 10: Objective — Account for aliasing/indirection. Signals — Track assignments to index, base pointer, and length through locals/parameters before the check and access. FP mitigation — Require that the aliased variables at the check and at the access refer to the same underlying values along the dominated path.

11) Step 11: Objective — Prioritize high-risk cases aligned with the kernel pattern. Signals — Structure fields commonly named length and pointer in the same struct, plus error return on failed check (e.g., -ENOENT), reflecting [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation — Use this as a ranking boost only; do not require exact names to avoid overfitting.

12) Step 12: Objective — Final confirmation that the flawed condition permits accessing an incomplete trailing element. Signals — There exists a feasible path where index * element_size < length and (index + 1) * element_size > length, and the element is read on that path (as described in [ROOTCAUSE_ANALYSIS]). FP mitigation — Use path feasibility with arithmetic reasoning on the same variables; if infeasible, suppress.

3. Target Elements
- Function bodies that parse buffers and reference arrays/pointers.
- Array indexing and pointer dereference expressions.
- Conditional checks comparing index * element_size with a length.
- Return/error statements guarding accesses.
- Structure fields representing buffer pointers and lengths (e.g., .pointer, .length).
- Assignments/aliases of index, base pointer, and length.
- Dominating invariants like length % element_size == 0 and index < length / element_size.

4. Dataflow / Taint Considerations
- Track dataflow from the buffer pointer to the dereference, and from the length source to the guarding check and any derived element-count expressions.
- Track the index variable from its definition through arithmetic to both the check and the dereference; maintain control-flow dominance relations between checks and accesses.

5. Validation & Test Cases
- Positive: Code that returns on (index * sizeof(*ref) >= length) but then reads ref_array[index] when index * size < length and (index + 1) * size may exceed length, matching [PATCH_DIFF] pre-patch behavior.
- Negative: Code that checks (index + 1) * sizeof(*ref) <= length (or index < length / sizeof(*ref)) before reading ref_array[index], matching the fix in [PATCH_DESCRIPTION].
- Negative: Code that enforces length % sizeof(*ref) == 0 and then checks index * sizeof(*ref) < length before access.
- Test harness notes: Include aliasing (intermediate variables for index/length/pointer), both >= and > variants, and element_size of 1 vs >1 to verify suppression.

6. Estimated Effort & Priority
High — Security impact is significant (OOB read) and the pattern is well-defined with manageable analysis complexity.

7. Likely False-Positive Sources & Mitigations
- Length variables that are element counts, not bytes; mitigate by requiring multiplication by element_size in the check.
- Code with earlier global invariants guaranteeing alignment; mitigate by checking for dominating modulo or equivalent invariants.
- Accesses that compute but do not dereference the element; mitigate by requiring a read/dereference use.
- Byte-sized elements; mitigate by excluding element_size == 1 cases.
- Alternate safe checks expressed differently; mitigate by recognizing algebraic equivalents (index < length / element_size).

8. Limitations & Assumptions
- Assumes length is a byte-length when multiplied by element_size in the check; the checker cannot always infer semantic units beyond such signals.
- Cannot prove absence of earlier invariants outside the current function or via complex interprocedural contracts.
- Does not handle integer overflow in (index + 1) * element_size analysis; the provided materials do not address overflow.
- Assumes zero-based indexing and that a dereference implies reading the full element size, consistent with [ROOTCAUSE_ANALYSIS].