1. Plan Summary
Detect array-element bounds checks that only ensure the start of the indexed element lies within a byte-sized buffer, but not that the entire element fits, leading to potential out-of-bounds reads as in software_node_get_reference_args.

2. Detection Steps
1) Step 1: Identify functions that index into an array of elements using an expression like &array[index] or array[index]. Signals: a variable used as an index in pointer arithmetic and subsequent field accesses (e.g., ref = &ref_array[index]; ref->node or ref->args[i]). FP mitigation: require the element type to be non-trivial (struct or size greater than 1 via sizeof(*elem)).

2) Step 2: Locate preceding bounds checks that compare index * sizeof(element) against a byte-length (e.g., prop->length). Signals: a condition with index multiplied by sizeof(*elem) compared to a variable named length or prop->length, as seen in [PATCH_DIFF]. FP mitigation: tie the length operand to the same storage backing the array (e.g., prop->pointer → ref_array) via simple dataflow.

3) Step 3: Flag cases where the check ensures only the start of the element is within bounds (index * sizeof(*elem) < length) but does not verify full coverage ((index + 1) * sizeof(*elem) <= length). Signals: absence of +1 in the multiplication term or equivalent division-based upper bound that accounts for complete element size. FP mitigation: ensure there is no additional check elsewhere in the function that enforces end-of-element coverage.

4) Step 4: Confirm that the buffer length and backing storage are tied to a property-like structure as in the root cause (prop->length governs ref_array = prop->pointer). Signals: presence of a property entry object and device property types (DEV_PROP_REF) used before indexing, matching [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: require prop->type == DEV_PROP_REF and prop->is_inline == false checks before the array access, mirroring the vulnerable context.

5) Step 5: Detect subsequent reads from the indexed element that access multiple fields or nested pointers (e.g., ref->node, ref->args[i]). Signals: field dereferences and array-element field copies loop. FP mitigation: prioritize cases that copy or dereference beyond a single scalar, aligning with the impact described in [ROOTCAUSE_ANALYSIS].

6) Step 6: Exclude code paths that compute an element count from the byte length and use that to validate index (index < length/sizeof(*elem)) combined with an additional check that the total requested bytes do not exceed length. Signals: patterns like property_entry_count_elems_of_size and property_entry_find that re-check total byte coverage (see [FILE_CONTENT]). FP mitigation: if such safeguards are found before access, suppress the alert.

7) Step 7: Highlight specific instance in software_node_get_reference_args where the guard is index * sizeof(*ref) >= prop->length and access follows (ref = &ref_array[index]; ref->node, ref->args), as per [PATCH_DIFF]. Signals: match the exact function and statements for high-confidence detection. FP mitigation: require this exact sequence and semantics to reduce noise.

8) Step 8: Ensure the checker distinguishes between byte-length buffers and element-count arrays to avoid misclassifying correct checks. Signals: the length variable represents bytes (prop->length) and is contrasted with sizeof(*elem); absence of a conversion to element count before index comparison. FP mitigation: treat length variables used in memcpy/property_find as byte-based indicators.

9) Step 9: Suppress cases where the code bounds index using (index + 1) * sizeof(*elem) <= length or equivalent safe patterns (e.g., checking requested element range against length). Signals: presence of +1 with multiplication or explicit end-offset computation compared to length, as fixed in [PATCH_DESCRIPTION]/[PATCH_DIFF]. FP mitigation: do not flag functions exhibiting the corrected check.

10) Step 10: Optionally, flag when the element type is known to be large (e.g., struct with multiple fields) to prioritize findings with higher crash risk. Signals: element type is a struct software_node_ref_args and used to access multiple members (ref->node, ref->args). FP mitigation: boost severity only when large struct types are involved.

3. Target Elements
- Function bodies performing array indexing into buffers that are sized by a byte-length field.
- If-statements/guards comparing index * sizeof(element) to a byte-length.
- Assignments linking length fields (e.g., prop->length) to pointers (e.g., prop->pointer → ref_array).
- Field dereferences on the indexed element (e.g., ref->node, ref->args[i]).
- Type checks and inline-storage checks (prop->type == DEV_PROP_REF, prop->is_inline).

4. Dataflow / Taint Considerations
- Track dataflow from a property length field (prop->length) into the guard expression.
- Track dataflow from a property pointer field (prop->pointer) into the array base used for indexing (ref_array).
- Ensure the same index variable used in the guard is used in the subsequent array indexing.
- Identify propagation to element field accesses that rely on full element presence.

5. Validation & Test Cases
- Positive: Pre-patch software_node_get_reference_args with if (index * sizeof(*ref) >= prop->length) followed by ref = &ref_array[index]; ref->node; ref->args[i]; expect a finding.
- Negative: Patched software_node_get_reference_args with if ((index + 1) * sizeof(*ref) > prop->length); expect no finding.
- Negative: Functions that compute array_len = prop->length / sizeof(T) and then verify total bytes via property_entry_find before memcpy; expect no finding.
- Test harness notes: Run checker on the provided file; verify the single targeted finding disappears after applying the patch hunk from [PATCH_DIFF].

6. Estimated Effort & Priority
High — pattern is common and leads to kernel OOB reads; the signals are well-structured (guards, indexing, and property metadata).

7. Likely False-Positive Sources & Mitigations
- Code with additional implicit invariants (e.g., trusted inputs guaranteeing alignment) not visible to static analysis; mitigate by requiring explicit end-of-element checks or element-count validation.
- Index validated elsewhere via division to element count and rechecked for total bytes; mitigate by recognizing property_entry_count_elems_of_size/property_entry_find patterns.
- Single-scalar element types where start-within-bounds suffices; mitigate by requiring element size > 1 or struct type and field dereferences.

8. Limitations & Assumptions
- The checker cannot know runtime alignment (whether length is a multiple of sizeof(element)); it relies on conservative pattern detection (start-only checks are suspect).
- Assumes element sizes are expressed via sizeof(*elem) in the code; alternative size calculations may not be recognized.
- Scope is guided by the provided file and patterns; broader kernel instances may require cataloging similar property/length idioms beyond those shown in [FILE_CONTENT].