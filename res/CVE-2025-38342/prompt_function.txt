1. CVE Identifier
CVE-2025-38342

2. Vulnerability Type
Out-of-bounds read due to incorrect bounds validation

3. Root Cause Summary
The function software_node_get_reference_args() used an insufficient length check when accessing the index-th element of a reference array stored in a property. The pre-patch condition “if (index * sizeof(*ref) >= prop->length)” only ensured the starting offset was within bounds, but did not guarantee that the entire element (index + 1 elements worth) fit within prop->length. For malformed properties (e.g., lengths not a multiple of sizeof(*ref) or truncated), this allowed ref = &ref_array[index] and subsequent dereferences of ref->node/args to read past the property buffer, causing an out-of-bounds read and potentially invalid pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Device property framework (software nodes) in the firmware node (fwnode) handling path

2) Pre-Patch Flaw:
In software_node_get_reference_args(), the bounds check used “index * sizeof(*ref) >= prop->length” (pre-patch code) instead of verifying that (index + 1) elements fit, permitting selection of an element whose end extends beyond prop->length.

3) Trigger Condition:
A DEV_PROP_REF property that is not inline, with a malformed length (e.g., not a multiple of sizeof(struct software_node_ref_args) or shorter than expected), combined with an index such that index * sizeof(*ref) < prop->length but (index + 1) * sizeof(*ref) > prop->length.

4) Impact Mechanism:
The function computes ref = &ref_array[index] and reads ref->node and ref->args[i]; if the property buffer does not contain a complete element, this results in out-of-bounds reads and may lead to an invalid pointer dereference when calling software_node_fwnode(ref->node) or copying args, potentially causing a kernel crash.

5. Patch Analysis
1) Fix Approach:
Strengthen the bounds check to ensure the full index-th element fits within the property’s length, preventing any partial-element access.

2) Key Code Changes:
In software_node_get_reference_args(), replace the check:
- Pre-patch: if (index * sizeof(*ref) >= prop->length) return -ENOENT;
- Post-patch: if ((index + 1) * sizeof(*ref) > prop->length) return -ENOENT;
This guarantees at least (index + 1) * sizeof(*ref) bytes are present before accessing ref_array[index].

3) Locking/Concurrency Impact:
No locking or concurrency logic was changed; the fix is purely a bounds validation correction.

6. Broader Kernel Security Implications
Correct bounds validation in property parsing prevents out-of-bounds reads that can lead to kernel crashes or unintended memory exposure via invalid pointer dereferences. Ensuring complete-element checks when indexing structured arrays reduces the attack surface from malformed firmware node properties. This change hardens the device property framework’s resilience against malformed or corrupted inputs, improving overall kernel robustness.