1. Plan Summary
Detect preconditions that only validate the start offset when indexing into a length-bounded array of structs, missing the “full element fits” check that prevents out-of-bounds reads (as in the pre-patch software_node_get_reference_args pattern).

2. Detection Steps
1) Step 1: Objective: Find candidate buffer-to-struct-array patterns. Signals: a length in bytes (e.g., prop->length) and a raw pointer (e.g., prop->pointer) that is cast/assigned to a pointer-to-struct array used with an index (based on FUNCTION_CONTENT). FP mitigation: Restrict to cases where the array element is dereferenced (struct field access) after indexing.
2) Step 2: Objective: Extract the guarding bounds check for the index. Signals: an if-condition that compares index * sizeof(element) against the byte length with a start-offset-only form (e.g., index * sizeof(*ref) >= length), as shown in PATCH_DIFF and ROOTCAUSE_ANALYSIS. FP mitigation: Ensure this condition dominates the indexing site (control-flow guard) and there is no stricter check closer to the use.
3) Step 3: Objective: Flag insufficient checks that do not ensure a complete element fits. Signals: absence of any subsequent check equivalent to “(index + 1) * sizeof(element) <= length” or “length - index*sizeof(element) >= sizeof(element)” or “index < length/sizeof(element)” (full-element fit), per PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS. FP mitigation: Treat any verified full-element check as safe and suppress the alert.
4) Step 4: Objective: Confirm risky use after the weak check. Signals: array[index] taken (e.g., ref = &ref_array[index]) followed by dereferences of fields (e.g., ref->node, ref->args[i]) as in FUNCTION_CONTENT; this maps to OOB read impact in ROOTCAUSE_ANALYSIS. FP mitigation: Require at least one field read or copy from the indexed element.
5) Step 5: Objective: Reduce FPs where array length correctness is validated elsewhere. Signals: earlier validation that length is an exact multiple of sizeof(element) or a computed element count used for bounds (e.g., count = length/sizeof(element); index < count). FP mitigation: If such divisibility or count-based checks dominate the use, suppress the finding because start-offset check would be sufficient in that context.
6) Step 6: Objective: Prioritize property-like patterns matching the documented bug. Signals: presence of a type gate (e.g., prop->type == DEV_PROP_REF or != DEV_PROP_REF) and non-inline check (prop->is_inline), mirroring FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS. FP mitigation: Use these as strengthening heuristics (do not require), and score/report with higher confidence when present.
7) Step 7: Objective: Exclude trivial byte-sized element cases. Signals: sizeof(element) equals 1 (byte arrays), where start-offset and end-of-element checks coincide. FP mitigation: Suppress when sizeof(element) == 1.
8) Step 8: Objective: Handle arithmetic masking via temporaries/macros. Signals: index multiplied by sizeof(element) stored in a temp and compared to length, or equivalent algebraic forms; ensure semantic equivalence to start-offset-only check from PATCH_DIFF. FP mitigation: Require clear dataflow from index and sizeof(element) into the guard; avoid speculative algebraic rewrites that could invert inequality semantics.
9) Step 9: Objective: Distinguish write-only patterns from read dereferences. Signals: if the indexed element is not read (no field access or memcpy-out), deprioritize since OOB read risk is lower. FP mitigation: Either suppress or assign lower severity without field reads, aligning with ROOTCAUSE_ANALYSIS focus on OOB read.
10) Step 10: Objective: Check for later loops copying subfields from the element (e.g., args loop). Signals: a loop that reads fields from the indexed struct (ref->args[i]) after the weak guard, as in FUNCTION_CONTENT. FP mitigation: Require this to increase confidence the access extends beyond just a pointer read.

3. Target Elements
- If-conditions guarding array indexing into a length-bounded buffer.
- Assignments casting/aliasing a raw pointer (void*/byte buffer) to a pointer-to-struct array.
- Array indexing expressions and address-of element computations (&array[index]).
- Struct field dereferences from the indexed element.
- Dominator relationships between checks and uses within the same function.

4. Dataflow / Taint Considerations
- Track the dataflow from a byte-length source (e.g., prop->length) and a raw pointer (e.g., prop->pointer) to the typed array pointer.
- Track the index variable from its definition/parameter to the guard condition and the array indexing expression.
- Track sizeof(element) where element is the pointee type of the array used in indexing.
- Recognize equivalent guard forms when index*sizeof(element) is computed through temporaries before comparison to length.

5. Validation & Test Cases
- Positive: A function that assigns arr = (T*)buf; if (idx * sizeof(*arr) >= len) return -1; t = &arr[idx]; use t->field; Expected: flagged as missing full-element check (pre-patch pattern from PATCH_DIFF/ROOTCAUSE_ANALYSIS).
- Negative: Same but with if ((idx + 1) * sizeof(*arr) > len) return -1; Expected: not flagged (matches PATCH_DESCRIPTION fix).
- Negative: Code computing count = len / sizeof(*arr); if (idx >= count) return -1; t = &arr[idx]; use t->field; Expected: not flagged (full-element count-based check).
- Negative: Code with prior check ensuring len % sizeof(*arr) == 0 and then using the start-offset guard; Expected: not flagged due to divisibility validation.
- Test harness notes: Validate dominance (guard precedes use) and ensure the checker recognizes sizeof through typedefs and temporaries.

6. Estimated Effort & Priority
Medium effort, high priority (prevents OOB read as documented in ROOTCAUSE_ANALYSIS).

7. Likely False-Positive Sources & Mitigations
- Length validated for element alignment elsewhere that the checker fails to recognize; mitigate by scanning for divisibility or count checks dominating the use.
- Algebraically different but correct guards (e.g., len - idx*sizeof >= sizeof); mitigate by detecting these equivalences and suppressing.
- Cases with sizeof(element) == 1; mitigate by explicit suppression as they are safe-equivalent.
- Index not used for dereference; mitigate by requiring field reads or copies from the element.

8. Limitations & Assumptions
- The plan assumes intra-procedural analysis; checks validated in callers may be missed.
- It cannot always prove that length is a multiple of sizeof(element) without whole-program reasoning; may yield conservative results.
- It assumes sizeof(element) is determinable at the use site; opaque/incomplete types may limit detection.
- Based on PATCH_DIFF, FUNCTION_CONTENT, and ROOTCAUSE_ANALYSIS, the pattern is generalized to similar buffer-backed struct arrays; other contexts not matching these signals are out of scope.