1. CVE Identifier
CVE-2025-38275

2. Vulnerability Type
NULL pointer dereference due to inconsistent error handling (NULL vs ERR_PTR)

3. Root Cause Summary
The helper qmp_usb_iomap() returned the raw pointer from devm_ioremap() for non-exclusive mappings. devm_ioremap() may return NULL on failure, but the caller only tested the return with IS_ERR(), which does not catch NULL. This allowed a NULL to bypass error detection and be dereferenced later, causing a kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm QMP USB PHY driver (phy: qcom-qmp-usb), function qmp_usb_iomap(), used by qmp_usb_parse_dt_legacy()

2) Pre-Patch Flaw:
- In qmp_usb_iomap(), when exclusive == false:
  - The code returned devm_ioremap(dev, res.start, resource_size(&res)) directly.
  - Callers (e.g., qmp_usb_parse_dt_legacy) validated the result only with IS_ERR(), not against NULL.
- Because devm_ioremap can return NULL, the callerâ€™s IS_ERR(qmp->pcs) check failed to detect the error, leaving qmp->pcs as NULL.

3) Trigger Condition:
- Device trees that select the legacy parsing path and explicitly set exclusive = false (e.g., compatibles "qcom,sdx65-qmp-usb3-uni-phy" and "qcom,sm8350-qmp-usb3-uni-phy") cause qmp_usb_iomap() to use devm_ioremap().
- If devm_ioremap() fails and returns NULL (e.g., due to invalid/zero-sized resource or memory mapping failure), IS_ERR() in qmp_usb_parse_dt_legacy does not catch it, and subsequent code proceeds with a NULL pcs pointer.

4) Impact Mechanism:
- Subsequent register accesses via qmp->pcs (e.g., qmp_usb_init() calling qphy_setbits(pcs, ...)) dereference the NULL pointer, causing a NULL pointer dereference and kernel crash (denial of service).

5. Patch Analysis
1) Fix Approach:
Normalize error reporting by converting a NULL return from devm_ioremap() into an ERR_PTR using IOMEM_ERR_PTR(-ENOMEM), ensuring IS_ERR() detects the failure consistently.

2) Key Code Changes:
- In qmp_usb_iomap():
  - Introduced a local variable: void __iomem *mem;
  - Replaced the direct return of devm_ioremap(...) with:
    - mem = devm_ioremap(...);
    - if (!mem) return IOMEM_ERR_PTR(-ENOMEM);
    - return mem;
- No changes to the exclusive path (devm_of_iomap), which already returns ERR_PTR on failure.

3) Locking/Concurrency Impact:
None. The change is purely in error handling of a mapping helper and does not alter locking, concurrency, or ordering semantics.

6. Broader Kernel Security Implications
This issue highlights the importance of consistent error handling across APIs that use mixed conventions (NULL vs ERR_PTR). Drivers that rely solely on IS_ERR() must ensure upstream helpers never return NULL on failure to avoid undetected errors leading to NULL dereferences. Converting NULL to ERR_PTR aligns with common kernel patterns and prevents denial-of-service conditions triggered by malformed device tree entries or mapping failures.