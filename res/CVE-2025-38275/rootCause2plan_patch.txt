1. Plan Summary
Detect kernel helper functions that return raw results from NULL-returning APIs (e.g., devm_ioremap) while callers only perform IS_ERR()-style error checks, leading to unchecked NULL dereferences.

2. Detection Steps
1) Step 1: Identify candidate wrapper functions returning a pointer (e.g., void __iomem*) that directly return the result of devm_ioremap without intervening checks. Signals: a return statement whose operand is a call to devm_ioremap; no preceding NULL-to-ERR_PTR conversion or NULL check; based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: restrict to functions whose return type is a pointer and whose returned value is exactly the devm_ioremap result.

2) Step 2: Classify inconsistent callee error semantics within the same wrapper. Signals: the same function also returns values from devm_of_iomap or returns IOMEM_ERR_PTR(...) on other paths, indicating ERR_PTR-style errors, per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]. FP mitigation: require distinct branches (e.g., via a conditional) that select between devm_ioremap and either devm_of_iomap or IOMEM_ERR_PTR(...).

3) Step 3: Confirm absence of explicit NULL handling after devm_ioremap in the wrapper. Signals: no local variable assigned from devm_ioremap that is checked against NULL before return; absence of IOMEM_ERR_PTR(-ENOMEM) or similar conversion as added in [PATCH_DIFF]. FP mitigation: do not flag if any path converts a NULL result from devm_ioremap into an ERR_PTR before returning.

4) Step 4: Summarize the wrapper’s error mode as “may return NULL or ERR_PTR depending on path.” Signals: presence of Step 1 and Step 2 patterns together; this reflects the root cause inconsistency described in [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure both paths are potentially reachable (no constant conditions that eliminate a side).

5) Step 5: Find call sites of such wrappers where the return is tested only with IS_ERR(). Signals: variable assigned from the wrapper call is checked by a condition invoking IS_ERR(var) (or logically equivalent), consistent with [ROOTCAUSE_ANALYSIS]. FP mitigation: exclude call sites that also check var == NULL or !var before use.

6) Step 6: Ensure the control flow proceeds to a “success” path when IS_ERR() is false. Signals: the branch where IS_ERR(x) is false leads to subsequent use of the pointer; this matches the trigger condition outlined in [ROOTCAUSE_ANALYSIS]. FP mitigation: require that the IS_ERR() check dominates the use, i.e., the use lies on a path where IS_ERR() is known false.

7) Step 7: Confirm dangerous use of the value after the IS_ERR()-only check. Signals: dereference of the pointer value or passing it to routines that operate on valid mappings (e.g., register access), aligning with the “invalid dereference” effect in [ROOTCAUSE_ANALYSIS]. FP mitigation: require a concrete dereference operation (field access, array indexing, or unary *), or a call argument position that semantically expects a valid mapping.

8) Step 8: Report combined issues: a wrapper with inconsistent/NULL-returning semantics and a caller that only uses IS_ERR() before dereference. Rationale: this matches the full vulnerability chain from [ROOTCAUSE_ANALYSIS] (NULL bypasses IS_ERR and is later dereferenced). FP mitigation: only report when both the wrapper summary (Step 4) and call-site misuse (Steps 5–7) are satisfied.

9) Step 9: Secondary (intra-procedural) issue in the wrapper alone for consistency hardening. Signals: a wrapper that returns devm_of_iomap on one path and raw devm_ioremap on another without NULL-to-ERR_PTR conversion, as pre-patch in [PATCH_DIFF]. FP mitigation: lower severity unless at least one caller satisfying Steps 5–7 exists.

10) Step 10: Optional strengthening using parameter cues. Signals: a boolean parameter (e.g., exclusive) guarding the choice between devm_of_iomap and devm_ioremap, mirroring [PATCH_DIFF]; this increases confidence in branch inconsistency. FP mitigation: treat this as a boosting heuristic, not a hard requirement.

3. Target Elements
- Functions that return pointer types (especially void __iomem* wrappers).
- Return statements and their operands.
- Calls to devm_ioremap and devm_of_iomap.
- Conditionals/branches selecting between different mapping APIs or IOMEM_ERR_PTR returns.
- Macros/functions indicating error-encoded pointers (IS_ERR, IOMEM_ERR_PTR).
- Call sites: variable initializations/assignments from wrapper calls.
- Condition checks around return values (IS_ERR, NULL checks).
- Pointer dereferences and uses indicating mapping access.

4. Dataflow / Taint Considerations
- Track the value returned by the wrapper to call sites and through variables to uses.
- Model control dependencies: success path where IS_ERR(x) is false and no intervening NULL check exists must lead to a dereference/use.
- Summarize wrapper behavior: a path may yield NULL (from devm_ioremap) and another yields ERR_PTR (from devm_of_iomap/IOMEM_ERR_PTR), reflecting inconsistent error conventions.

5. Validation & Test Cases
- Positive: A wrapper that returns devm_ioremap(...) directly in one branch and devm_of_iomap(...) in another; callers only check IS_ERR(ret) before dereferencing ret. Expected: reported.
- Negative: Patched variant where the wrapper checks if devm_ioremap(...) returns NULL and converts it to IOMEM_ERR_PTR(-ENOMEM) before returning. Expected: not reported.
- Negative: Caller that checks both IS_ERR(ret) and ret == NULL (or !ret) before use. Expected: not reported.
- Test harness notes: Create small kernel-like stubs for devm_ioremap, devm_of_iomap, IS_ERR, and IOMEM_ERR_PTR; simulate the exclusive flag and of_address_to_resource path as in [PATCH_DIFF].

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Misclassification of API semantics beyond devm_ioremap/devm_of_iomap; mitigate by limiting to these APIs per provided evidence.
- Path-sensitivity gaps causing missed recognition of NULL checks; mitigate by requiring clear absence of NULL checks dominating the use.
- Uses that do not actually dereference; mitigate by requiring concrete dereference or a well-known use context requiring a valid mapping.

8. Limitations & Assumptions
- Assumes devm_ioremap may return NULL and devm_of_iomap returns ERR_PTR on failure, per [ROOTCAUSE_ANALYSIS]; no other APIs are modeled.
- Assumes IS_ERR and IOMEM_ERR_PTR are identifiable in the codebase.
- Does not infer all kernel-specific dereference contexts beyond generic pointer dereferences; specialized register access helpers are not enumerated in the provided materials.