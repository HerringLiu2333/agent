1. Plan Summary
Detect functions that mix ERR_PTR-style returns with unchecked raw returns from APIs that can return NULL (e.g., devm_ioremap), allowing NULL to bypass callers’ IS_ERR-only checks and cause NULL dereference.

2. Detection Steps
1) Step 1: Identify candidate functions — functions returning a pointer type (including void __iomem *) that contain at least one return of an ERR_PTR/IOMEM_ERR_PTR expression anywhere in the body. Objective: mark functions that adopt error-pointer semantics on some paths.

2) Step 2: Within each candidate function, find return sites that directly return the result of APIs known to return NULL on failure but not ERR_PTR (seeded with devm_ioremap). Objective: locate raw propagation of potentially-NULL pointers.

3) Step 3: For those return sites, trace if the returned expression is either the direct call result or a variable dataflow-equivalent to that result without an intervening NULL check. Objective: ensure we capture both direct and assigned-then-returned patterns.

4) Step 4: Exclude return paths where the potentially-NULL value is checked (e.g., if (!ptr) …) and converted to an ERR_PTR/IOMEM_ERR_PTR before returning. Objective: avoid flagging already-correct conversions that normalize NULL to ERR_PTR.

5) Step 5: Confirm inconsistency by requiring at least one other return path in the same function that returns an ERR_PTR/IOMEM_ERR_PTR. Objective: ensure the function mixes NULL-returning APIs with error-pointer semantics, matching the root cause.

6) Step 6: Optionally, further strengthen the signal by detecting other return paths that return values from APIs likely to use ERR_PTR semantics (e.g., devm_of_iomap used as a return expression) or explicit IOMEM_ERR_PTR(-EINVAL) returns. Objective: increase confidence that callers expect ERR_PTR-only failures.

7) Step 7: Report each inconsistent return site with the path condition (e.g., the branch guarding it) and the specific API (e.g., devm_ioremap) involved. Objective: provide actionable context to fix by adding a NULL-to-ERR_PTR conversion.

8) Step 8: Optional call-site corroboration — identify call sites of the flagged function where the return value is checked with IS_ERR (or similar) but lacks an explicit NULL check before subsequent use/dereference. Objective: validate exploitability by showing that NULL would bypass the caller’s checks.

9) Step 9: At call sites identified in Step 8, highlight subsequent uses that assume non-NULL (e.g., dereference, offset computation, I/O access using the returned pointer) without prior NULL checks. Objective: demonstrate potential NULL dereference impact paths.

3. Limitations & Assumptions
- The seeded list of APIs that may return NULL but not ERR_PTR is limited to devm_ioremap per the provided materials; other similar APIs are not modeled here.
- The plan assumes that any return of ERR_PTR/IOMEM_ERR_PTR establishes error-pointer semantics for the function; documentation intent is not available.
- Call-site analysis (Steps 8–9) may be incomplete without comprehensive modeling of IS_ERR checks, NULL checks, and dereference patterns across files.
- The plan does not assert devm_of_iomap’s exact failure convention; it is only used as an optional consistency signal when returned directly.