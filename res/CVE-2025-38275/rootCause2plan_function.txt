1. Plan Summary
Detect functions that mix ERR_PTR-style error signaling with raw NULL-returning pointer APIs, causing callers that only use IS_ERR() to miss NULL failures and dereference NULL.

2. Detection Steps
1) Step 1: Identify candidate wrapper functions returning pointer-like types (e.g., void __iomem *) that sometimes return an ERR_PTR value. Signals: return statements using IOMEM_ERR_PTR or other ERR_PTR-like macros; this indicates the function adopts error-pointer semantics (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS). FP mitigation: require at least one explicit ERR_PTR/IOMEM_ERR_PTR return in the function.

2) Step 2: Within those functions, find returns that directly propagate the result of devm_ioremap without a NULL-to-ERR_PTR conversion. Signals: a return expression that is a call to devm_ioremap, or returning a local variable assigned from devm_ioremap with no preceding !ptr check that converts it to IOMEM_ERR_PTR (based on PATCH_DIFF and FUNCTION_CONTENT). FP mitigation: exclude cases where there is an explicit if (!mem) return IOMEM_ERR_PTR(...).

3) Step 3: Flag functions where both Step 1 and Step 2 hold as “mixed error convention” wrappers. Signals: presence of at least one ERR_PTR/IOMEM_ERR_PTR return and at least one devm_ioremap-propagating return. FP mitigation: ensure both paths are reachable under different conditions (e.g., different branches) rather than dead code.

4) Step 4: For each flagged wrapper, locate call sites capturing its return value. Signals: assignments of the call result to a variable or immediate use in conditions. FP mitigation: focus on same-translation-unit first to reduce analysis cost and noise.

5) Step 5: At call sites, detect error handling that checks only IS_ERR() on the returned value. Signals: conditions using IS_ERR(var) or IS_ERR(ptr) without accompanying NULL checks (based on ROOTCAUSE_ANALYSIS “callers only tested for error pointers with IS_ERR()”). FP mitigation: treat presence of a subsequent or alternative branch that checks var == NULL or !var as mitigating.

6) Step 6: Identify dereferences or usage implying a valid mapping after only IS_ERR() passes. Signals: pointer dereference, pointer arithmetic, or passing as a non-optional __iomem parameter after a code path where IS_ERR() is false but no NULL check occurred. FP mitigation: require a feasible path from the call through an IS_ERR()-only check to a dereference.

7) Step 7: Prioritize reports where the wrapper’s other return path already uses ERR_PTR/IOMEM_ERR_PTR (exclusive path like devm_of_iomap) while the devm_ioremap path returns raw pointer. Signals: distinct branches with ERR_PTR-like return vs raw devm_ioremap return (based on FUNCTION_CONTENT and PATCH_DIFF). FP mitigation: de-prioritize if all return paths use only NULL semantics (no ERR_PTR returns).

8) Step 8: Suggest the fix pattern only conceptually: enforce consistent error semantics by converting devm_ioremap NULL to IOMEM_ERR_PTR(-ENOMEM). Rationale: mirrors the applied fix (PATCH_DESCRIPTION and PATCH_DIFF) and maps to the root cause (ROOTCAUSE_ANALYSIS).

9) Step 9: Optionally detect and annotate the absence of resource_size/of_address_to_resource errors only as context, not as a trigger. Signals: presence of of_address_to_resource followed by devm_ioremap return without NULL conversion (FUNCTION_CONTENT). FP mitigation: do not report solely on resource handling; keep the core condition from Steps 3–6 mandatory.

10) Step 10: Rank severity higher if multiple callers perform only IS_ERR() checks and subsequent dereferences. Signals: number of call sites satisfying Step 5 and Step 6. FP mitigation: suppress if every caller performs a NULL check before use.

3. Target Elements
- Functions returning pointer-like types (e.g., void __iomem *).
- Return statements and their expressions within such functions.
- Calls to devm_ioremap and assignments of their results.
- Calls to IOMEM_ERR_PTR/ERR_PTR and IS_ERR.
- Call sites of the flagged wrapper functions.
- Pointer dereference sites and value-flow from function return to dereference.

4. Dataflow / Taint Considerations
- Track the return value of the wrapper function to variables at call sites.
- Model guard conditions: whether the value has been checked by IS_ERR() and whether a NULL check occurred on the same value along the path.
- Verify a path where IS_ERR() is false (not an error-pointer) leads to a dereference without any intervening NULL check.

5. Validation & Test Cases
- Positive: A wrapper returns IOMEM_ERR_PTR(-EINVAL) on one path and directly returns devm_ioremap(...) on another; a caller only checks IS_ERR() then dereferences the pointer. Expected: flagged for mixed semantics and unsafe caller usage (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS).
- Positive: The wrapper returns raw devm_ioremap result with no NULL handling; another branch returns devm_of_iomap; caller checks only IS_ERR() and uses the pointer. Expected: flagged.
- Negative: Post-patch pattern where devm_ioremap result is checked for NULL and converted to IOMEM_ERR_PTR(-ENOMEM) before return (PATCH_DIFF). Expected: no findings.
- Negative: Caller performs both IS_ERR() and NULL checks before any dereference. Expected: no findings.
- Test harness notes: Ensure macro recognition for IS_ERR/IOMEM_ERR_PTR and correct modeling of __iomem pointer dereference at call sites.

6. Estimated Effort & Priority
Medium: requires interprocedural analysis (return-path review and call-site checks) but with focused patterns (devm_ioremap, ERR_PTR/IOMEM_ERR_PTR, IS_ERR).

7. Likely False-Positive Sources & Mitigations
- Functions that never intend to use ERR_PTR semantics but incidentally return an ERR_PTR macro in unreachable code; mitigate by requiring reachability and at least one clear devm_ioremap path.
- Callers that perform implicit NULL validation via helper wrappers not recognized; mitigate by scanning common NULL-check idioms and known wrappers nearby.
- Misclassification of callee semantics; mitigate by restricting to devm_ioremap as the NULL-returning API explicitly cited (PATCH_DESCRIPTION).

8. Limitations & Assumptions
- Assumes devm_ioremap may return NULL and not ERR_PTR (PATCH_DESCRIPTION); other APIs are not considered due to lack of evidence.
- Assumes IOMEM_ERR_PTR/ERR_PTR and IS_ERR are the macros used for error-pointer conventions; other project-specific variants are not covered by the provided data.
- Does not infer kernel-wide calling conventions beyond what ROOTCAUSE_ANALYSIS states; relies on detecting IS_ERR-only checks at call sites to validate impact.