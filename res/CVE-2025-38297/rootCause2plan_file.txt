1. Plan Summary
Detect divisions where a struct field used as a divisor is conditionally uninitialized based on device type, leading to divide-by-zero in paths reachable for non-CPU devices, as seen in em_compute_costs() using table[i].performance.

2. Detection Steps
1) Step 1: Identify divisor sites where a division uses a field of an EM perf-state as the denominator (e.g., table[i].performance). Signals: binary division where RHS reads a field from an array/pointer parameter representing an EM table; maps to the root cause where cost = power_res / table[i].performance [FILE_CONTENT]. FP mitigation: require the divisor originates from a parameter or alias named/typed consistently with EM perf state arrays.

2) Step 2: Check for missing non-zero or device-type guards at the division. Signals: absence of checks ensuring table[i].performance != 0 or absence of _is_cpu_device(dev) gating before entering the division loop; maps to root cause of unguarded division [ROOTCAUSE_ANALYSIS]. FP mitigation: do not alert if a dominating check ensures nonzero performance or returns early for non-CPU devices (as added by the patch [PATCH_DIFF]).

3) Step 3: Locate initialization sites of the performance field. Signals: assignments to table[i].performance occur only in em_init_performance(), which returns early for non-CPU devices via if (!_is_cpu_device(dev)) return; [FILE_CONTENT]. FP mitigation: confirm there are no other unconditional initializers of performance in the same file; if others exist and are not device-type-gated, suppress.

4) Step 4: Trace zero-initialization of the EM table memory. Signals: EM tables are allocated via kzalloc in em_table_alloc(), implying performance defaults to zero [FILE_CONTENT]; also copies via memcpy in em_table_dup() can propagate zeros. FP mitigation: require a feasible path where the table is newly allocated or duplicated from a table whose performance is not guaranteed nonzero for non-CPU devices.

5) Step 5: Confirm call sequencing where compute is invoked after init that may skip non-CPU. Signals: in em_create_perf_table(), em_init_performance() is called then em_compute_costs() unconditionally [FILE_CONTENT]; maps to the flaw since non-CPU devices skip init but still enter compute. FP mitigation: ensure both functions are in the same path and share the same dev/table objects.

6) Step 6: Establish feasibility for non-CPU devices to reach compute. Signals: em_create_pd() has an else branch for non-CPU devices, then calls em_create_perf_table(), which calls em_compute_costs() [FILE_CONTENT]; maps to the trigger condition [ROOTCAUSE_ANALYSIS]. FP mitigation: require a path through the non-CPU branch (dev->bus != &cpu_subsys) to the compute call.

7) Step 7: Exclude safe alternative cost paths based on flags and callbacks. Signals: the compute function uses cb->get_cost only when flags include EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost is present; otherwise it divides by performance [FILE_CONTENT]. FP mitigation: only flag when a caller passes cb == NULL (e.g., em_dev_compute_costs() and em_recalc_and_update()) or flags not proven to include ARTIFICIAL (e.g., MICROWATTS or 0 as in em_dev_register_perf_domain() -> em_create_perf_table()).

8) Step 8: Validate presence of at least one concrete vulnerable call site. Signals: calls to em_compute_costs() with cb NULL and flags 0 (em_dev_compute_costs()) or with flags set from non-ARTIFICIAL registration (em_dev_register_perf_domain() when microwatts) [FILE_CONTENT]. FP mitigation: require at least one such call path to the division without intervening guards.

9) Step 9: Check for missing early-return device-type gating in the compute function itself. Signals: in the vulnerable version, em_compute_costs() lacks the early if (!_is_cpu_device(dev)) return 0; added by patch [PATCH_DIFF]. FP mitigation: if such a guard is present before the division loop, suppress the alert.

10) Step 10: Consider update paths that recompute costs on existing tables. Signals: em_recalc_and_update() calls em_compute_costs() with cb NULL and flags pd->flags [FILE_CONTENT]; maps to the broader trigger in updates [ROOTCAUSE_ANALYSIS]. FP mitigation: only flag if pd->flags are not conclusively ARTIFICIAL and the device can be non-CPU.

11) Step 11: Ensure no local remediation checks exist in compute. Signals: verify that within the division loop, there are no checks that ensure performance is set (e.g., writes to performance or explicit zero checks) [FILE_CONTENT]. FP mitigation: suppress if such writes/checks exist within the function before division.

12) Step 12: Rank findings higher when all three signals align: zero-inited allocation path, device-type-skipped initialization, and unguarded division in compute reachable for non-CPU devices; this directly maps to the root cause [ROOTCAUSE_ANALYSIS]. FP mitigation: lower rank or suppress if any of these three pillars is missing.

3. Target Elements
- Function definitions performing cost computation (e.g., em_compute_costs()).
- Division expressions where the denominator is a struct field (performance) read from an EM table.
- Assignment sites to struct em_perf_state.performance (e.g., em_init_performance()).
- Memory allocation sites for EM tables (kzalloc in em_table_alloc()) and copy sites (memcpy in em_table_dup()).
- Device-type checks (_is_cpu_device(dev)) and their control-flow effects (early returns).
- Call sites to em_compute_costs() from em_create_perf_table(), em_dev_compute_costs(), and em_recalc_and_update().
- Flag handling for EM_PERF_DOMAIN_ARTIFICIAL and EM_PERF_DOMAIN_MICROWATTS; presence/absence of cb->get_cost.

4. Dataflow / Taint Considerations
- Track dataflow of the table pointer from allocation (kzalloc) or duplication into compute functions.
- Track the performance field’s definition sites; if only assigned under a device-type guard, treat as potentially zero for non-CPU flows.
- Track the dev parameter through call chains to align device-type checks (presence/absence) with compute invocation.
- Track flags and cb arguments into em_compute_costs() to decide if the division path is taken (cb NULL or flags not including ARTIFICIAL).
- Consider propagation of zero-initialized performance via memcpy in em_table_dup().

5. Validation & Test Cases
- Positive: A non-CPU device registers an EM via em_dev_register_perf_domain() with microwatts set; em_create_perf_table() calls em_init_performance() (skips) then em_compute_costs() (divides by performance) — expect a finding.
- Positive: em_recalc_and_update() on a non-CPU device with pd->flags not including ARTIFICIAL calls em_compute_costs() with cb NULL — expect a finding.
- Negative: Patched em_compute_costs() with early if (!_is_cpu_device(dev)) return 0; before the division loop — expect no finding.
- Negative: Artificial EM path where flags include EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost is used — expect no finding.
- Test harness notes: Run intra-file analysis to confirm call-path feasibility and control-flow dominance of guards; validate that kzalloc-based allocation is recognized.

6. Estimated Effort & Priority
High — kernel stability issue with clear structural patterns; requires interprocedural dataflow and control-flow dominance analysis.

7. Likely False-Positive Sources & Mitigations
- Other files initializing performance for non-CPU devices unknown to the analysis; mitigate by requiring absence of alternative assignments in reachable code or by allowing project-wide search for performance writes.
- Inability to conclusively evaluate flags/callbacks; mitigate by requiring concrete call sites with cb NULL or literal non-ARTIFICIAL flags.
- Macro indirections around flags or device-type checks; mitigate by matching conceptual semantics (e.g., artificial vs microwatts) using known constants from this file.
- Paths where performance becomes nonzero via runtime updates not visible statically; mitigate by prioritizing newly allocated table paths.

8. Limitations & Assumptions
- Assumes kzalloc zero-initializes performance as indicated in em_table_alloc() [FILE_CONTENT]; does not model external initializations outside this file.
- Assumes _is_cpu_device(dev) correctly indicates CPU vs non-CPU devices as per [FILE_CONTENT].
- Does not prove at runtime that a non-CPU device will register; relies on feasibility of call paths shown in [FILE_CONTENT].
- Function pointer resolution for cb->get_cost is limited; relies on flags and explicit cb NULL paths observed in this file.