1. Plan Summary
Detect division-by-zero risks in EM cost computation where cost = power_res / table[i].performance occurs without a zero check or CPU-only device gating.

2. Detection Steps
1) Step 1: Identify EM cost-computation functions that accept a device pointer and an em_perf_state table, and write to table[i].cost inside a loop over nr_states; signals: function parameters (struct device*, struct em_perf_state*), loop indexing table[], and assignments to table[i].cost.
2) Step 2: Within such functions, locate divisions whose denominator is table[i].performance or any variable that dataflows from table[index].performance; signals: binary division with RHS referencing the performance field of em_perf_state.
3) Step 3: Confirm the division is in the non-artificial fallback path (i.e., inside the else branch of a condition like “if ((flags & EM_PERF_DOMAIN_ARTIFICIAL) && cb->get_cost)”); signals: surrounding conditional that checks EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost followed by an else containing the division.
4) Step 4: Check there is no preceding validation ensuring the denominator is non-zero on the execution path to the division; signals: absence of conditionals in the dominating block/path testing table[i].performance != 0 or equivalent before the division.
5) Step 5: Verify the function lacks a device-type guard that restricts execution to CPU devices before the division; signals: absence of an early-return based on a call to _is_cpu_device(dev) (or equivalent) prior to the loop/body containing the division.
6) Step 6: Confirm the function does not initialize table[i].performance before using it as the division denominator; signals: absence of assignments to table[*].performance within the function (especially within or before the loop).
7) Step 7: Ensure the division path can be taken when cb->get_cost is NULL or flags don’t include EM_PERF_DOMAIN_ARTIFICIAL; signals: the else branch is reachable without additional guards that would prevent entry when cb->get_cost is null or flags lack EM_PERF_DOMAIN_ARTIFICIAL.
8) Step 8: If Steps 2–7 hold concurrently, report the division as a potential division-by-zero vulnerability tied to uninitialized/zero performance for non-CPU devices; signals: include function name, the specific else-branch condition, and the denominator expression.

3. Limitations & Assumptions
- Cannot prove at compile time that table[i].performance is zero or uninitialized; the checker assumes risk when no zero-check or initialization is present.
- Device-type determination is limited to detecting presence/absence of a _is_cpu_device(dev) early guard; alternative gating mechanisms may be missed.
- Flags (EM_PERF_DOMAIN_ARTIFICIAL) and cb->get_cost values are runtime-dependent; the checker assumes the else path is reachable if not explicitly prevented.
- The plan relies on the naming and structure shown (em_perf_state.performance, _is_cpu_device, EM_PERF_DOMAIN_ARTIFICIAL); variations in other codebases may reduce precision.