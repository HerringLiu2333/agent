1. Plan Summary
Detect divisions where em_perf_state::performance is used as a divisor in EM cost computation without guarding for CPU device type or checking for zero, which can cause a divide-by-zero for non-CPU devices.

2. Detection Steps
1) Step 1: Objective: find EM/EAS cost computation sites. Signals: functions that perform “cost” computations and contain a loop over performance states (e.g., iterating i over nr_states) as seen in em_compute_costs; FP mitigation: prioritize functions named em_compute_costs or with similar semantics, per the patch context in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
2) Step 2: Objective: identify division operations using performance as the denominator. Signals: binary division where the right-hand side is a field access to table[i].performance (em_perf_state::performance) within these functions; FP mitigation: ensure the field is from an em_perf_state-like structure used in cost calculation loops.
3) Step 3: Objective: confirm device context relevant to EM. Signals: function parameters include struct device* dev, matching em_compute_costs signature; FP mitigation: restrict to functions with dev parameter to align with [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
4) Step 4: Objective: detect missing device-type guard. Signals: absence of a control-flow gate that checks _is_cpu_device(dev) (or equivalent CPU device predicate) before reaching the division; FP mitigation: ensure the check is not present anywhere dominating the division site, per the fix in [PATCH_DIFF].
5) Step 5: Objective: detect missing zero-denominator checks. Signals: no condition ensuring table[i].performance != 0 immediately before the division (e.g., no guarding if/performance validation in the loop body); FP mitigation: treat explicit nonzero checks or assertions as sufficient to suppress alerts.
6) Step 6: Objective: confirm the denominator value is not locally initialized in the function. Signals: absence of assignments to table[i].performance prior to the division within the same function; FP mitigation: if the function writes performance before dividing and ensures it’s nonzero, do not report.
7) Step 7: Objective: strengthen the “reachable for non-CPU devices” hypothesis. Signals: absence of early returns or guards that skip cost computation for non-CPU devices (e.g., no !_is_cpu_device(dev) return before the loop), as added in [PATCH_DIFF]; FP mitigation: if any device-type skip exists, suppress.
8) Step 8: Objective: consolidate findings to reduce false positives. Signals: only report when all are true: division by performance, dev parameter present, no CPU guard, no zero-check, and no local nonzero initialization; FP mitigation: exclude divisions where performance participates only in multiplication/addition or is checked against zero.

3. Target Elements
- Function definitions that perform EM/EAS cost computation (e.g., em_compute_costs).
- Parameters of type struct device* within these functions.
- Loops iterating over performance states (nr_states, index i) in EM routines.
- Field accesses to em_perf_state::performance used in arithmetic expressions, especially as a divisor.
- Condition checks involving device type (calls to _is_cpu_device(dev) or similar).
- Early returns or guards that skip logic for non-CPU devices.
- Local assignments to table[i].performance within the function.

4. Dataflow / Taint Considerations
- Track dataflow from table[i].performance to the denominator position of a division; ensure the path is unguarded by zero checks.
- Track control-flow from function entry with dev parameter to the division site, looking for dominating guards calling _is_cpu_device(dev).
- Track whether table[i].performance is assigned a nonzero value locally before the division; lack of such flows indicates potential reliance on external initialization (per [ROOTCAUSE_ANALYSIS]).

5. Validation & Test Cases
- Positive: A pre-patch em_compute_costs that loops over nr_states and divides by table[i].performance without any _is_cpu_device(dev) guard or performance!=0 check; expect a report.
- Negative: The patched em_compute_costs with if (!_is_cpu_device(dev)) return 0; before the loop as in [PATCH_DIFF]; expect no report.
- Negative: A variant where before division the code checks if (table[i].performance == 0) and skips or returns; expect no report.
- Test harness notes: Place these samples in a mock EM subsystem file with struct em_perf_state and struct device definitions to allow field/parameter matching.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Other modules where performance is always guaranteed nonzero by construction: mitigate by requiring explicit local nonzero checks or device-type guards.
- Aliased or differently named performance fields: mitigate by restricting to em_perf_state::performance in EM/EAS context per [ROOTCAUSE_ANALYSIS].
- Indirect device-type validation via wrappers not named _is_cpu_device: mitigate by documenting that only the explicit _is_cpu_device(dev) guard is recognized per [PATCH_DIFF].

8. Limitations & Assumptions
- Assumes the vulnerable pattern is confined to EM cost computations using em_perf_state::performance as a divisor, based on [ROOTCAUSE_ANALYSIS].
- Cannot prove external initialization performed by em_init_performance; relies on local checks/guards to infer safety.
- Only recognizes the explicit _is_cpu_device(dev) guard; equivalent device-type checks not named the same may be missed.
- Does not evaluate runtime device types; purely static structural analysis.