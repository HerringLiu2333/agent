1. Plan Summary
Detect division-by-zero risks in EM cost computations where table[i].performance is used as a divisor without ensuring the device is a CPU or that performance is non-zero.

2. Detection Steps
1) Step 1: Identify candidate functions that compute EM costs per performance state and accept parameters like struct device* dev and struct em_perf_state* table. Signals: a loop iterating over nr_states that indexes table[i] and computes a variable named cost or similar.

2) Step 2: Within these functions, locate arithmetic division operations whose right-hand operand reads the performance field from em_perf_state entries. Signals: expressions of the form table[index].performance used as the divisor.

3) Step 3: Confirm the division occurs inside a loop over performance states. Signals: a for-loop that bounds by nr_states and indexes table via a loop variable (e.g., i).

4) Step 4: Check for any explicit non-zero guard on the performance field before the division. Signals: absence of conditionals like table[i].performance != 0 or equivalent checks immediately guarding the divisor.

5) Step 5: Determine whether the cost computation region is gated by a device-type predicate. Signals: presence or absence of a check invoking _is_cpu_device(dev) that either wraps the loop or causes an early return on !_is_cpu_device(dev).

6) Step 6: If the division uses table[i].performance as a divisor without a non-zero check and the function lacks a device-type guard (_is_cpu_device(dev) gating or early return), flag the site as vulnerable. Objective: capture the pre-patch flaw where non-CPU devices lead to division-by-zero.

7) Step 7: Optionally refine confidence by verifying that table[i].performance is not assigned to a non-zero value within the function before the division. Signals: no writes to table[...].performance in the function body prior to use.

8) Step 8: Produce findings that include the function name (e.g., em_compute_costs), the loop context (iteration over nr_states), the divisor expression (table[i].performance), and evidence of missing guards (no _is_cpu_device(dev) gate and no non-zero check).

3. Limitations & Assumptions
- Assumes that em_perf_state::performance is only initialized by em_init_performance() for CPU devices, as stated; the checker cannot verify initialization across call paths.
- Cannot definitively determine at analysis time whether a given dev is non-CPU or whether the function will be invoked for non-CPU devices; relies on absence of _is_cpu_device(dev) gating as the indicator.
- Relies on the presence of field names and types (em_perf_state, performance, nr_states) as described; variations in naming or structure may cause misses.
- Does not reason about integer arithmetic that might avoid division-by-zero through other invariants; flags based on missing guards rather than full semantic proof.