1. Plan Summary
Detect division-by-zero risks in EM cost computation by finding divisions by table[i].performance that lack device-type gating and zero checks in em_compute_costs-like logic.

2. Detection Steps
1) Step 1: Identify the EM cost-computation function scope. Signals: a function named em_compute_costs taking (struct device *dev, struct em_perf_state *table, const struct em_data_callback *cb, int nr_states, unsigned long flags), and the comment “Compute the cost of each performance state” [FUNCTION_CONTENT]; FP mitigation: restrict to this exact function signature or similarly named functions in the PM/EM subsystem.
2) Step 2: Locate the loop over performance states. Signals: a for-loop iterating i from nr_states - 1 down to 0 with table[i] usage [FUNCTION_CONTENT]; FP mitigation: require the loop writes table[i].cost and references table[i].frequency to match EM semantics.
3) Step 3: Find divisions where the divisor is table[i].performance. Signals: an assignment to cost using power_res / table[i].performance in the non-artificial path [FUNCTION_CONTENT]; FP mitigation: ensure the divisor is exactly the performance field of em_perf_state.
4) Step 4: Confirm presence of the artificial cost alternative and that the division sits in the else branch. Signals: an if branch checking (flags & EM_PERF_DOMAIN_ARTIFICIAL) && cb->get_cost and calling cb->get_cost, with the division in the else branch [FUNCTION_CONTENT]; FP mitigation: require both EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost references to appear exactly as described.
5) Step 5: Determine that the else branch is potentially reachable. Signals: flags and cb->get_cost are not constants proven to force the if branch always true; i.e., no unconditional return or guard preventing the else branch [FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS]; FP mitigation: if analysis can prove flags always include EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost is always non-null in this function, do not flag.
6) Step 6: Check for a prior non-zero/validation guard on table[i].performance. Signals: absence of any immediate check like “if (!table[i].performance)” or error-handling before the division [FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS]; FP mitigation: if any explicit zero check or sanitization of table[i].performance precedes the division, do not flag.
7) Step 7: Verify the function does not initialize table[i].performance. Signals: no assignments to table[i].performance anywhere in em_compute_costs [FUNCTION_CONTENT]; FP mitigation: if performance is assigned or derived safely in this function prior to the division, lower the finding severity.
8) Step 8: Detect absence of device-type gating at function entry. Signals: missing early return “if (!_is_cpu_device(dev)) return 0;” that was added by the patch [PATCH_DIFF]; FP mitigation: if a device-type guard or equivalent ensures the division only runs for CPU devices, treat as mitigated.
9) Step 9: Correlate with EM/EAS context to raise confidence. Signals: references to EM_MAX_POWER, EM_PERF_DOMAIN_ARTIFICIAL, and EM_PERF_STATE_INEFFICIENT in the same function [FUNCTION_CONTENT]; FP mitigation: only flag when at least one of these EM-specific symbols co-occurs, reducing hits in unrelated modules.
10) Step 10: Report a vulnerability when all hold: division by table[i].performance in else path; else path reachable; no zero-check; and no device-type gate. Rationale: maps to the root cause where non-CPU devices have uninitialized performance and division-by-zero occurs [ROOTCAUSE_ANALYSIS]; FP mitigation: require all four conditions to reduce incidental divisions.
11) Step 11: Optionally rank severity higher when the divisor is an unsigned type and there’s evidence the function can run for non-CPU devices. Signals: generic dev parameter with no constraints and lack of gating [PATCH_DIFF, ROOTCAUSE_ANALYSIS]; FP mitigation: decrease severity if analysis shows calls are CPU-only via callers (if resolvable).
12) Step 12: Highlight remediation hints tied to patch. Signals: recommend adding _is_cpu_device(dev) gating or explicit zero-check on table[i].performance as per the fix [PATCH_DIFF]; FP mitigation: only suggest relevant mitigations consistent with EM design.

3. Target Elements
- Functions: em_compute_costs (or exact signature provided).
- Loops over arrays/indices: table[i] across nr_states.
- Arithmetic operations: integer division expressions.
- Conditionals: branches on EM_PERF_DOMAIN_ARTIFICIAL and cb->get_cost.
- Structure field accesses: table[i].performance, table[i].cost, table[i].power, table[i].frequency.
- Early-return guards: device-type gating like _is_cpu_device(dev).

4. Dataflow / Taint Considerations
- Track control-flow into the else branch where division occurs, ensuring it is reachable when flags lack EM_PERF_DOMAIN_ARTIFICIAL or cb->get_cost is NULL.
- Track absence of any sanitization or assignment to table[i].performance along the path to the division within the function.
- Treat dev’s type as unconstrained unless a guard like _is_cpu_device(dev) is present; without it, paths from non-CPU devices are considered possible.

5. Validation & Test Cases
- Positive: Pre-patch em_compute_costs where cost = power_res / table[i].performance appears in the else branch, with no _is_cpu_device(dev) guard and no zero-check [FUNCTION_CONTENT].
- Negative: Post-patch version including “if (!_is_cpu_device(dev)) return 0;” before the loop, keeping the same division; checker should not report because device-type gating mitigates the root cause [PATCH_DIFF].
- Negative: Variant where an explicit check “if (!table[i].performance) return -EINVAL;” precedes the division; checker should not report due to zero-check.
- Test harness notes: Run the checker on both versions of em_compute_costs to verify differential behavior; include a synthetic case where flags always force cb->get_cost path to confirm the else branch reachability filter.

6. Estimated Effort & Priority
Medium effort, high priority due to kernel crash/Denial-of-Service risk [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Divisions by unrelated “performance” fields in non-EM code; mitigate by requiring EM-specific symbols and function signature.
- Paths where analysis cannot conclusively determine reachability of else branch; mitigate by requiring lack of proofs that the artificial path is always taken.
- Cases where device-type gating exists via different helper names; mitigate by noting absence of any device-type guard and documenting uncertainty.

8. Limitations & Assumptions
- The checker cannot confirm external initialization (e.g., em_init_performance) for CPU devices; assumes non-CPU devices may have zero performance [ROOTCAUSE_ANALYSIS].
- The implementation of _is_cpu_device(dev) is unknown; the checker assumes its presence implies safe gating [PATCH_DIFF].
- Caller constraints and flag values may be unknown; reachability analysis is conservative, potentially missing cases where runtime values guarantee safety.