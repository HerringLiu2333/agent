1. CVE Identifier
CVE-2025-38297

2. Vulnerability Type
Division-by-zero due to missing device-type validation and uninitialized field usage

3. Root Cause Summary
em_compute_costs() calculates “cost” using table[i].performance for all devices, but table[i].performance is only initialized for CPU devices in em_init_performance(). For non-CPU devices, em_init_performance() returns early, leaving performance as zero from kzalloc. The unchecked division “cost = power_res / table[i].performance;” causes a divide-by-zero when a non-CPU device’s EM is computed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Power management Energy Model (EM) framework, used by EAS (Energy-Aware Scheduling)

2) Pre-Patch Flaw:
- em_init_performance() explicitly skips non-CPU devices: “if (!_is_cpu_device(dev)) return;”, so performance is not set.
- em_compute_costs() then unconditionally computes “cost” for all devices, performing “cost = power_res / table[i].performance;” without verifying device type or ensuring performance is non-zero.
- There is no guard against zero performance nor alternative path for non-CPU devices when cb->get_cost is not provided.

3) Trigger Condition:
- Registering or updating an EM for a non-CPU device (dev->bus != &cpu_subsys) where flags do not indicate EM_PERF_DOMAIN_ARTIFICIAL (i.e., normal microwatts path) leads em_create_perf_table() to:
  - call em_init_performance() (which skips non-CPU),
  - then call em_compute_costs(), which divides by table[i].performance == 0.
- Similar division can be triggered during EM updates (e.g., em_recalc_and_update()) for non-CPU devices.

4) Impact Mechanism:
- Division by zero in kernel context leads to a trap/oops and potential system crash (denial of service), affecting stability when non-CPU devices engage EM cost computation.

5. Patch Analysis
1) Fix Approach:
Add an early device-type check in em_compute_costs() to skip cost computation for non-CPU devices, preventing the division by a non-initialized performance value.

2) Key Code Changes:
- In em_compute_costs():
  - Added:
    - “if (!_is_cpu_device(dev)) return 0;” before the cost computation loop.
- This change ensures the “cost = power_res / table[i].performance;” line is never executed for non-CPU devices whose performance is not initialized.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The fix is a pure logic guard (early return) inside em_compute_costs(), leaving existing mutex (em_pd_mutex) and RCU usage unchanged elsewhere.

6. Broader Kernel Security Implications
- Prevents system-wide crashes when EM is used by non-CPU devices, improving robustness of PM/EM integration.
- Highlights the need for strict type-based gating and initialization checks in cross-subsystem calculations (EAS vs. generic devices).
- Reduces the attack surface for denial-of-service scenarios originating from driver interactions that register EM for non-CPU devices without artificial cost callbacks.