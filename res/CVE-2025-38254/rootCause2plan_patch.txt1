1. Plan Summary
Detect call sites of drm_edid_raw() that (a) dereference the returned pointer without a dominating NULL check and/or (b) compute a copy length from edid->extensions and copy into a fixed-size raw_edid buffer without a dominating bounds check against that buffer’s capacity.

2. Detection Steps
1) Step 1: Identify call expressions to drm_edid_raw() and bind the returned pointer to a local variable (e.g., edid). Signals: a function call named drm_edid_raw with its result stored or used, and subsequent uses of that result.

2) Step 2: For each such edid variable, locate subsequent dereferences or field accesses (e.g., edid->extensions) and uses as a pointer value (casts to uint8_t*, source in copy calls). Signals: member access on the result, address use, or implicit dereference.

3) Step 3: Determine whether a dominating NULL check for edid exists before these uses. Signals: a control-flow-dominating condition that tests edid against NULL and enforces an early return or otherwise prevents the unsafe path when NULL.

4) Step 4: Report a potential NULL dereference if edid is dereferenced (including accessing edid->extensions) on any control-flow path not dominated by a non-NULL guard. Signals: absence of a guarding condition on all paths to the dereference.

5) Step 5: Identify copy operations where the source data originates from edid and the destination is a fixed-size buffer like sink->dc_edid.raw_edid. Signals: calls to memmove/memcpy (or similar) with source expression referencing edid (possibly cast) and destination referencing a statically sized array field (array type or sizeof applied elsewhere).

6) Step 6: Trace the length argument of the copy to see if it is computed from edid->extensions (optionally via an intermediate variable like sink->dc_edid.length). Signals: arithmetic expressions of the form EDID_LENGTH * (edid->extensions + 1) or otherwise linearly dependent on edid->extensions.

7) Step 7: Infer the destination buffer capacity in “EDID blocks” by dividing its byte capacity by EDID_LENGTH when possible. Signals: sizeof(destination-buffer) is statically known; presence of the EDID_LENGTH constant in the same scope or usage pattern.

8) Step 8: Check for a dominating bounds check that constrains edid->extensions to be strictly less than the capacity (e.g., edid->extensions < sizeof(dst)/EDID_LENGTH) prior to computing the length and performing the copy. Signals: control-flow-dominating condition comparing edid->extensions against a capacity expression derived from destination size and EDID_LENGTH.

9) Step 9: Report a potential out-of-bounds write if the copy length depends on edid->extensions and there is no dominating bounds check that ties extensions to the destination capacity. Signals: dataflow from edid->extensions to length, fixed-size destination, and absence of a capacity-based guard.

10) Step 10: Also flag the case where sink->dc_edid.length is computed from edid->extensions and later used as the copy size into raw_edid without an intervening capacity check. Signals: dataflow from edid->extensions to sink->dc_edid.length to memmove/memcpy size, with no dominating capacity guard before either the length computation or the copy.

11) Step 11: Prioritize findings occurring in the AMD/DRM EDID handling context to reduce noise. Signals: variable/field names like raw_edid, dc_edid, and the presence of EDID_LENGTH or functions in the amdgpu_dm/display path (when file/module metadata is available).

12) Step 12: De-duplicate reports by merging null-deref and OOB-copy findings at the same call site of drm_edid_raw(), but still emit both categories if both conditions are met. Signals: same edid variable and same function scope.

3. Limitations & Assumptions
- Assumes CodeQL can identify dominating conditions and perform inter/intra-procedural dataflow from edid->extensions to length and then to copy size.
- Assumes EDID_LENGTH and destination buffer size (sizeof) are resolvable; if not, the checker may conservatively flag size-dependent copies without confirming exact capacity math.
- Assumes recognition of memmove/memcpy-like copies; custom wrappers may be missed unless modeled.
- Type/field names (extensions, raw_edid, dc_edid) are taken from the provided snippet; different naming in other code paths may require broader heuristics on “field from edid governs copy length into fixed-size buffer.”
- The checker cannot verify runtime values; it relies on static absence of guards, which may yield false positives if equivalent guards exist but are not analyzable (e.g., via macros or indirect checks).