1. Plan Summary
Detect call sites of drm_edid_raw() where the returned EDID pointer is dereferenced or used to size a memory copy into a fixed-size raw_edid buffer without prior NULL and bounds validation, as seen in dm_helpers_read_local_edid().

2. Detection Steps
1) Step 1: Identify calls to drm_edid_raw() and bind the result variable (e.g., “edid”) — look for function calls named drm_edid_raw with an assigned pointer result — based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS], this is the untrusted source; mitigate FPs by restricting analysis to paths that subsequently use the result.
2) Step 2: Check for dereferences of the result (member access like edid->extensions) — look for field/struct member access on the returned pointer — this maps to NULL deref root cause; mitigate by confirming presence of a dominating non-NULL check (e.g., “if (!edid) return …”) before any dereference on the same path.
3) Step 3: Detect computations of copy length from edid->extensions — look for arithmetic of the form EDID_LENGTH multiplied by (extensions + 1) assigned to a length variable — this maps to the unvalidated length used in [ROOTCAUSE_ANALYSIS]; mitigate by ignoring cases where extensions is previously validated against buffer capacity.
4) Step 4: Find memory copy calls using that computed length — look for memmove/memcpy where the third argument is the derived length and the source is (uint8_t *)edid or edid — this connects length to actual copying as in [PATCH_DIFF]; mitigate by ensuring the destination is a fixed-size buffer (e.g., sink->dc_edid.raw_edid).
5) Step 5: Identify destination buffers that are fixed-size raw_edid arrays — look for fields named raw_edid and sizeof(raw_edid) usage — this targets the specific vulnerable sink per [PATCH_DIFF]; mitigate by excluding dynamic allocations or non-fixed buffers.
6) Step 6: Check for absence of bounds validation on extensions — look for a missing condition comparing edid->extensions to sizeof(dest)/EDID_LENGTH before computing length or copying — this maps to the OOB write root cause in [ROOTCAUSE_ANALYSIS]; mitigate by suppressing when a guard exists (e.g., as added in [PATCH_DIFF]).
7) Step 7: Check for absence of bounds validation on computed length — look for no condition that ensures computed length ≤ sizeof(dest) prior to memmove/memcpy — this directly addresses overlong copy; mitigate by suppressing if any prior check bounds the length against sizeof(dest).
8) Step 8: Detect dereference-before-check sequences — ensure control-flow analysis verifies that the first use of edid (e.g., edid->extensions) occurs without a preceding NULL check on all paths from the call — this captures the NULL dereference described in [ROOTCAUSE_ANALYSIS]; mitigate by recognizing early returns or error handling paths that guard.
9) Step 9: Correlate the two hazards in the same function scope — report if either (a) deref without NULL check or (b) copy into raw_edid using extension-derived length without bounds check is present — this aligns with the dual vulnerability type in [ROOTCAUSE_ANALYSIS]; mitigate by requiring a concrete copy into raw_edid for the OOB case.
10) Step 10: Exclude cases where the code returns EDID_BAD_INPUT or equivalent after validation — look for early-return patterns triggered by invalid edid or extension count — this avoids flagging patched/secure patterns per [PATCH_DIFF]; mitigate by recognizing conditions that directly guard and abort the operation.

3. Target Elements
- Functions that call drm_edid_raw(), especially dm_helpers_read_local_edid().
- Call sites returning a pointer to EDID data and subsequent pointer dereferences (edid->extensions).
- Assignments computing length from EDID_LENGTH and edid->extensions.
- Memory copy operations (memmove/memcpy) from edid to sink->dc_edid.raw_edid.
- Fixed-size array fields (raw_edid) and sizeof() capacity checks.
- Conditional checks guarding NULL or bounds (extensions vs. capacity).
- Early-return or error-handling code paths (e.g., EDID_BAD_INPUT).

4. Dataflow / Taint Considerations
- Track dataflow from drm_edid_raw() result to:
  - First dereference use (edid->extensions) to detect NULL-deref without guarding checks.
  - Arithmetic deriving copy length from edid->extensions and EDID_LENGTH.
  - Arguments to memmove/memcpy (source = edid, length = derived value, dest = raw_edid).
- Track control-flow guards:
  - Non-NULL checks on edid dominating dereference.
  - Bounds checks on edid->extensions against sizeof(raw_edid)/EDID_LENGTH or computed length against sizeof(raw_edid).

5. Validation & Test Cases
- Positive: Code that calls drm_edid_raw(), immediately reads edid->extensions, computes EDID_LENGTH * (extensions + 1), and memmove()s into sink->dc_edid.raw_edid without any NULL or bounds checks; expect detection of both hazards.
- Negative: Code identical to [PATCH_DIFF] with “if (!edid || edid->extensions >= sizeof(sink->dc_edid.raw_edid) / EDID_LENGTH) return EDID_BAD_INPUT;” before computing length and copying; expect no findings.
- Negative: Code that validates computed length ≤ sizeof(sink->dc_edid.raw_edid) before memmove, even if edid is non-NULL; expect no OOB finding and potentially a NULL-deref finding only if dereferenced before a NULL check.
- Test harness notes: Run on functions handling EDID in DRM AMD driver; ensure the checker recognizes sizeof(raw_edid) and EDID_LENGTH constants in capacity checks.

6. Estimated Effort & Priority
High — memory safety in kernel paths with untrusted hardware inputs warrants priority, and the pattern requires combined control-flow and dataflow reasoning.

7. Likely False-Positive Sources & Mitigations
- Aliased pointers where edid is validated through another variable name; mitigate by alias analysis linking the call result to subsequent uses.
- Capacity checks expressed differently (e.g., validating computed length rather than extensions); mitigate by recognizing either form of guard (extensions vs. length).
- Contexts where edid is guaranteed non-NULL by external contracts not visible in the current function; mitigate by requiring an in-function or dominating guard.
- Destinations not actually fixed-size or larger than any computed length; mitigate by focusing on raw_edid and requiring evidence of fixed-size via sizeof().

8. Limitations & Assumptions
- Assumes EDID_LENGTH and raw_edid represent block size and capacity respectively, as implied by [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; the checker cannot infer actual sizes without macro resolution.
- Assumes the vulnerability pattern centers on drm_edid_raw() and raw_edid; other EDID sources or sinks are not covered by this plan.
- Cannot determine hardware validity or runtime values; relies purely on structural validation presence.
- The plan does not model all possible forms of bounds checks beyond comparing extensions or computed length to sizeof(raw_edid).