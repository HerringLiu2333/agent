1. Plan Summary
Detect uses of drm_edid_raw() where the returned EDID pointer is dereferenced or used to size/copy into a fixed-size buffer without a dominating NULL check and without a bounds check on edid->extensions relative to the destination buffer capacity.

2. Detection Steps
1) Step 1: Identify calls to drm_edid_raw() whose return value flows into a pointer variable (e.g., edid) and is subsequently used within the same function. Signals: assignment from drm_edid_raw(drm_edid) to a variable and dataflow uses of that variable.

2) Step 2: Track dereferences or copy-source uses of the returned pointer. Signals: field access like edid->extensions, casts of edid to a byte pointer, and passing edid as the source argument to memmove/memcpy.

3) Step 3: Check for the absence of a dominating NULL check before any dereference/use. Signals: along at least one path to edid->extensions or to memmove/memcpy with source edid, there is no prior condition that ensures edid != NULL or returns/branches on !edid.

4) Step 4: Detect copy-length values derived from edid->extensions. Signals: expressions that compute a length from edid->extensions, commonly EDID_LENGTH * (edid->extensions + 1), assigned to a length variable (e.g., sink->dc_edid.length) or used directly as the third argument of memmove/memcpy.

5) Step 5: Resolve the copy destination and determine whether it is a fixed-size buffer. Signals: destination is a struct field that is an array (e.g., sink->dc_edid.raw_edid), or a buffer whose capacity is referenced via sizeof(dest) in nearby code.

6) Step 6: Verify whether a bounds check on edid->extensions relative to the destination capacity dominates the copy. Signals: a condition like edid->extensions >= sizeof(dest) / EDID_LENGTH (or equivalent check ensuring (extensions + 1) * EDID_LENGTH <= sizeof(dest)) that guards both the length computation and the memmove/memcpy.

7) Step 7: Flag missing-bounds cases where the copy length derived from edid->extensions can exceed the destination capacity. Signals: the copy executes on a path where no guard ensures the computed length fits within sizeof(dest), even if a NULL check exists.

8) Step 8: Flag missing-NULL-check cases where edid->extensions is read or edid is used as a memmove/memcpy source without a dominating edid != NULL guard. Signals: any dereference/use reachable from the drm_edid_raw() assignment with no prior non-null validation.

9) Step 9: Exempt safe patterns with defensive validation. Signals: an early return or branch (e.g., returning EDID_BAD_INPUT) that triggers when !edid or when edid->extensions exceeds the capacity; ensure that this guard dominates all subsequent uses (length computation and memmove).

10) Step 10: Handle loop constructs and retries. Signals: ensure dominance checks consider loop bodies (e.g., do-while) and that guards occur before each iteration’s dereference/copy within the loop body.

11) Step 11: Prioritize findings when both risks exist. Signals: if both a missing NULL check and a missing bounds check occur on the same path, raise a combined report; otherwise classify as either “potential NULL deref” or “potential out-of-bounds write.”

3. Limitations & Assumptions
- Assumes CodeQL can determine dominance of guards over uses across branches and loops; complex control flow may reduce precision.
- Assumes the destination buffer is identifiable as fixed-size (e.g., via array type or nearby sizeof(dest)); if not, bounds-check presence may be indeterminable.
- Treats EDID_LENGTH as a constant; variations in how length is computed (e.g., different constants or formulas) may require broader pattern matching than shown.
- Does not verify external invariants guaranteeing non-NULL edid; flags rely on local control-flow validation rather than global contracts.