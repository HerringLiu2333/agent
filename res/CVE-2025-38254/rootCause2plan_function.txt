1. Plan Summary
Detect uses of drm_edid_raw() whose result is dereferenced or used to size a copy into a fixed-size EDID buffer without (a) a dominating NULL check and (b) a bounds check that ensures (extensions + 1) EDID blocks fit the destination, as in the pre-patch flaw.

2. Detection Steps
1) Step 1: Objective—Locate call sites of drm_edid_raw() that bind its result to a variable (e.g., “edid”). Signals—A call to drm_edid_raw() with the return value stored in a pointer to struct edid/const struct edid (per [FUNCTION_CONTENT]). FP mitigation—Constrain to call results that are used subsequently in the same function.

2) Step 2: Objective—Find dereferences or field accesses on the returned pointer that could null-deref. Signals—Any edid->… access (specifically edid->extensions per [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]) or passing edid as a pointer argument to other APIs. FP mitigation—Require absence of a dominating check like “if (!edid) … return/guard” on all paths to the dereference (as added in [PATCH_DIFF]).

3) Step 3: Objective—Identify copy operations sourced from the returned EDID pointer. Signals—Calls to memmove/memcpy where the source argument is edid or a cast of it (e.g., (uint8_t *)edid) as shown in [FUNCTION_CONTENT]. FP mitigation—Require that the destination is a concrete fixed-size buffer (array type or struct field with known size), such as sink->dc_edid.raw_edid.

4) Step 4: Objective—Detect length values derived from edid->extensions used for the copy. Signals—Length expression dataflow dependent on edid->extensions, commonly in the form const * (edid->extensions + 1) (EDID_LENGTH multiplier as in [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]). FP mitigation—Tolerate algebraic variants but require a clear dependence on the “extensions” field and an addition of 1 or equivalent block-count semantics to avoid unrelated arithmetic.

5) Step 5: Objective—Check for missing bounds validation relative to the destination capacity. Signals—Absence of any dominating condition that compares either (a) extensions against a capacity-derived bound (e.g., extensions < sizeof(dest)/EDID_LENGTH, as per [PATCH_DIFF]) or (b) computed length against sizeof(dest). FP mitigation—Treat explicit capping (e.g., min(computed_len, sizeof(dest))) or early error-return guards as sufficient; accept equivalent dominant checks even with different but equivalent forms.

6) Step 6: Objective—Check for missing NULL validation before using edid->extensions or passing the pointer to copy. Signals—Absence of a dominating “edid != NULL” guard or early return on NULL prior to the first dereference/copy (as newly added in [PATCH_DIFF]). FP mitigation—If the call site is in a context proven to return non-NULL by contract is not inferable; only suppress when there is an explicit dominating guard.

7) Step 7: Objective—Assess whether sink->dc_edid.length is set from the unvalidated extensions and then consumed by memmove. Signals—Assignment where sink->dc_edid.length depends on edid->extensions (EDID_LENGTH * (extensions + 1)) followed by memmove using that length (per [FUNCTION_CONTENT]). FP mitigation—Treat as safe if a dominating guard ensures the computed length fits the destination or the length is subsequently clamped before use.

8) Step 8: Objective—Classify findings by severity based on which validations are missing. Signals—If both NULL and bounds checks are absent, report as “NULL dereference + potential OOB write” (per [ROOTCAUSE_ANALYSIS]); if only NULL check is missing, report as “possible NULL dereference”; if only bounds check is missing, report as “possible out-of-bounds write.” FP mitigation—Require that the risky operations (dereference/copy) are reachable from the call site on at least one unguarded path.

9) Step 9: Objective—Limit analysis scope to EDID flows that are plausibly untrusted. Signals—Call paths where drm_edid was read from ACPI or DDC and forwarded to drm_edid_raw() (as in [FUNCTION_CONTENT]), then used to fill sink->dc_edid.raw_edid. FP mitigation—Prefer cases where the source buffer is hardware-derived and the destination is a fixed-size kernel buffer, matching the scenario in [ROOTCAUSE_ANALYSIS].

10) Step 10: Objective—De-duplicate reports within the same call site. Signals—Multiple dereferences/copies following a single unsafe use chain from drm_edid_raw(). FP mitigation—Emit one consolidated alert per call site with a summary of missing checks and the first risky use.

3. Target Elements
- Call sites of drm_edid_raw() and the variable capturing its return.
- Field accesses of the returned pointer, especially edid->extensions.
- Assignments computing lengths from edid->extensions.
- Calls to memmove/memcpy where source is edid and destination is a fixed-size buffer (e.g., sink->dc_edid.raw_edid).
- Dominating condition checks guarding NULL or bounds against destination capacity.
- Early returns with EDID_BAD_INPUT or similar error signaling (as in [PATCH_DIFF]).

4. Dataflow / Taint Considerations
- Track dataflow from the drm_edid_raw() return to:
  - Field accesses (edid->extensions).
  - Computed length variables (e.g., sink->dc_edid.length).
  - Copy call length parameters and source arguments.
- Track control-flow dominance of guards that mention:
  - edid pointer nullness.
  - Comparisons between edid->extensions or computed length and destination capacity (sizeof(dest), sizeof(dest)/EDID_LENGTH).
- Treat edid->extensions as tainted/untrusted input influencing copy size until validated.

5. Validation & Test Cases
- Positive: Pre-patch dm_helpers_read_local_edid() from [FUNCTION_CONTENT] where edid is used without NULL check and length derives from edid->extensions with no capacity guard; expect two findings (NULL deref risk and OOB write risk, or a combined finding).
- Negative: Patched version from [PATCH_DIFF] adding “if (!edid || extensions >= sizeof(dest)/EDID_LENGTH) return EDID_BAD_INPUT;” before computing length and copying; expect no findings.
- Test harness notes: Include variants where the guard is expressed as length <= sizeof(dest) or using min() capping to ensure the checker recognizes equivalent safe patterns.

6. Estimated Effort & Priority
High priority; Medium effort (requires interprocedural dataflow from call result through arithmetic to copy, plus dominance analysis for guards).

7. Likely False-Positive Sources & Mitigations
- Contracts guaranteeing drm_edid_raw() never returns NULL: mitigate by requiring explicit guards, not assumed contracts.
- Capacity checks performed in helper functions not visible to the checker: mitigate by limiting to dominating checks in the same function or inlined contexts.
- Destinations that are not fixed-size arrays (e.g., dynamically sized buffers): mitigate by only flagging when destination size is statically knowable.
- Non-standard arithmetic forms for safe bounds checks: mitigate by allowing common equivalents (direct length vs sizeof(dest), extensions vs capacity/EDID_LENGTH, or min() clamping).

8. Limitations & Assumptions
- Assumes the checker can recognize EDID_LENGTH as a constant factor but does not require its numeric value; relies on dependency on edid->extensions as the key signal (based on [ROOTCAUSE_ANALYSIS]).
- Cannot prove non-NULL by undocumented API contracts; requires explicit code guards.
- Might not resolve sizes for flexible arrays or opaque pointers, limiting detection to statically sized buffers.
- Focused on drm_edid_raw() usage patterns as evidenced in [PATCH_DIFF]/[FUNCTION_CONTENT]; other similar helper APIs are out of scope due to lack of evidence.