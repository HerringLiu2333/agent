1. Plan Summary
Detect pre-patch EDID handling bugs where code dereferences a potentially NULL EDID pointer or copies EDID bytes into a fixed-size buffer using a length derived from edid->extensions without validating pointer or bounds.

2. Detection Steps
1) Step 1: Objective: Find call sites retrieving an EDID pointer via drm_edid_raw(). Signals: A variable assigned from a call to drm_edid_raw() in any function, especially dm_helpers_read_local_edid() as shown in [PATCH_DIFF]/[FILE_CONTENT]. FP mitigation: Limit to call sites where the returned pointer is subsequently used in the same function.

2) Step 2: Objective: Flag NULL-dereference risk on the EDID pointer. Signals: Access to fields like edid->extensions or casting edid to uint8_t* for copying without a preceding dominance check “if (!edid) return/handle error” as added in [PATCH_DIFF] and described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Require that no equivalent null-check dominates all uses of the EDID pointer in the path (control-flow dominance).

3) Step 3: Objective: Identify potentially unsafe copy-length computations from EDID extensions. Signals: An expression computing a byte length as EDID_LENGTH * (edid->extensions + 1), or assigning it to sink->dc_edid.length, as in [FILE_CONTENT] and highlighted in [ROOTCAUSE_ANALYSIS]. FP mitigation: Confirm the computation’s operand is the same EDID pointer obtained from drm_edid_raw() (dataflow).

4) Step 4: Objective: Detect out-of-bounds writes into fixed-size EDID buffers. Signals: Calls to memmove/memcpy where source is the EDID pointer and destination is a raw EDID buffer field (e.g., sink->dc_edid.raw_edid), with the length argument derived from Step 3. FP mitigation: Prefer destinations that are struct fields likely to be fixed-size (per [PATCH_DESCRIPTION]: “fixed size raw_edid array”); if size cannot be inferred, require absence of any bounds check on extensions versus destination capacity.

5) Step 5: Objective: Verify presence or absence of bounds checks on extensions relative to destination capacity. Signals: A check of the form “edid->extensions < sizeof(dest)/EDID_LENGTH” (or logically equivalent) before computing/copying, as added in [PATCH_DIFF]. FP mitigation: Only report when no dominating check exists comparing extensions to a computed capacity tied to the destination buffer.

6) Step 6: Objective: Catch unsafe use when the copy length is indirectly derived via an intermediate variable. Signals: Dataflow from edid->extensions to sink->dc_edid.length (computed with EDID_LENGTH multiplier) and then used as the memmove length. FP mitigation: Require both dataflow steps (extensions -> length -> memmove) and no intervening clamp of length or extensions.

7) Step 7: Objective: Treat EDID validity checks as insufficient for size safety. Signals: Presence of drm_edid_is_valid() or checksum logic without a size/capacity comparison; this should not suppress the alert (per [ROOTCAUSE_ANALYSIS] the flaw is independent of checksum validity). FP mitigation: Do not consider checksum checks as bounds checks.

8) Step 8: Objective: Exclude cases where the destination is dynamically sized to the computed length. Signals: Destination obtained via allocation using the computed length, or a vector-like container that grows to fit; not a fixed-size array/field. FP mitigation: Require the destination be a statically declared array or a struct array field (e.g., raw_edid), or use sizeof(dest) present in code to confirm fixed capacity.

9) Step 9: Objective: Ensure the guard placement precedes all risky operations. Signals: Control-flow analysis confirming that the null and bounds checks dominate the subsequent extension-based length computation and memmove. FP mitigation: If checks exist but are placed after the computation or copy, still flag.

10) Step 10: Objective: Detect direct dereference without preceding null-check even if no copy occurs (pure NULL-deref). Signals: Any use of edid->extensions before any (!edid) guard following drm_edid_raw() as described in [ROOTCAUSE_ANALYSIS]. FP mitigation: Only flag when the dereference is reachable and not guarded by a dominating null-check.

3. Target Elements
- Function bodies containing calls to drm_edid_raw().
- Field accesses on struct edid (e.g., edid->extensions).
- Memory copy operations (memmove/memcpy) where the source is an EDID pointer and the destination is a raw EDID buffer field.
- Length computations using EDID_LENGTH multiplied by (extensions + 1).
- Conditional checks around pointer validity and extension bounds.
- Assignments to sink->dc_edid.length and subsequent uses.

4. Dataflow / Taint Considerations
- Track dataflow from the return value of drm_edid_raw() to:
  - Field dereferences (edid->extensions).
  - Casts to byte pointers used as copy source.
- Track dataflow from edid->extensions through arithmetic expressions that compute the copy length (EDID_LENGTH * (extensions + 1)), including via intermediate variables (e.g., sink->dc_edid.length).
- Track control-flow dominance of null and bounds checks over dereferences and copy operations.

5. Validation & Test Cases
- Positive: The pre-patch pattern in dm_helpers_read_local_edid() where edid = drm_edid_raw(drm_edid); then sink->dc_edid.length = EDID_LENGTH * (edid->extensions + 1); followed by memmove(..., (uint8_t *)edid, sink->dc_edid.length) without prior null/bounds checks (from [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS]). Expected: Flag both NULL-deref risk and potential OOB write.
- Negative: The patched code adding “if (!edid || edid->extensions >= sizeof(sink->dc_edid.raw_edid) / EDID_LENGTH) return EDID_BAD_INPUT;” before computing length and copying (from [PATCH_DIFF]). Expected: No findings.
- Negative: A function that computes length from extensions but clamps extensions against destination capacity and checks edid != NULL before any use. Expected: No findings.
- Test harness notes: Use kernel code snippets with realistic structs/fields for raw_edid; include EDID_LENGTH constant and sizeof(dest) patterns to exercise bounds-check recognition.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Unknown destination capacity when sizeof(dest) is not visible: Mitigate by requiring evidence of a fixed-size array field or explicit sizeof(dest) usage.
- Guards implemented in helper functions not visible to the checker: Mitigate by demanding local dominance checks in the same function.
- Paths proven unreachable by external conditions: Mitigate with conservative control-flow; allow suppression when a guard dominates all uses.
- Validations that check EDID integrity but not size: Do not treat drm_edid_is_valid() or checksum logic as sufficient; require explicit bounds checks.

8. Limitations & Assumptions
- The exact size of sink->dc_edid.raw_edid is not provided; the checker assumes it is a fixed-size array based on [PATCH_DESCRIPTION], and relies on sizeof(dest) when present.
- The semantics of EDID_LENGTH are assumed as the byte size of one EDID block per [ROOTCAUSE_ANALYSIS]/[FILE_CONTENT], but the checker cannot verify macro values.
- Modeling of helper API guarantees for drm_edid_raw() is based solely on [ROOTCAUSE_ANALYSIS], which states it may return NULL or overly long data; cross-file validations may be missed.
- The plan does not cover other EDID paths beyond drm_edid_raw() usage due to limited evidence.