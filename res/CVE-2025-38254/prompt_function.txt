1. CVE Identifier
CVE-2025-38254

2. Vulnerability Type
- Missing input validation leading to NULL pointer dereference
- Out-of-bounds write (buffer overflow) in kernel memory

3. Root Cause Summary
dm_helpers_read_local_edid() used the pointer returned by drm_edid_raw() without validating it and computed a copy length from edid->extensions without verifying it fit into the fixed-size sink->dc_edid.raw_edid buffer. Specifically, the code immediately did:
- edid = drm_edid_raw(drm_edid);
- sink->dc_edid.length = EDID_LENGTH * (edid->extensions + 1);
- memmove(sink->dc_edid.raw_edid, (uint8_t *)edid, sink->dc_edid.length);
This allowed a NULL return to be dereferenced and an excessive extensions value to drive memmove past the destination bufferâ€™s bounds.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- DRM/AMD display (amdgpu_dm), EDID handling path

2) Pre-Patch Flaw:
- No NULL check on the result of drm_edid_raw()
- No bounds check ensuring (edid->extensions + 1) EDID blocks fit in sink->dc_edid.raw_edid before computing length and copying

3) Trigger Condition:
- drm_edid_raw() returns NULL (e.g., invalid/missing EDID)
- drm_edid_raw() returns an EDID whose extensions field claims too many blocks (e.g., with a bad/malicious adapter), making (extensions + 1) exceed the destination array capacity

4) Impact Mechanism:
- NULL pointer dereference when accessing edid->extensions or copying from a NULL pointer, causing kernel Oops
- Out-of-bounds write in memmove to sink->dc_edid.raw_edid due to oversized length computation, causing kernel memory corruption and potential crash/instability

5. Patch Analysis
1) Fix Approach:
- Defensive validation of the drm_edid_raw() result and the extension count prior to computing the copy length and performing memmove
- Early return with EDID_BAD_INPUT on invalid pointer or oversized EDID

2) Key Code Changes:
- Added:
  if (!edid ||
      edid->extensions >= sizeof(sink->dc_edid.raw_edid) / EDID_LENGTH)
      return EDID_BAD_INPUT;
- This guarantees edid is non-NULL and that (extensions + 1) blocks fit into raw_edid (since extensions < size/EDID_LENGTH ensures (extensions + 1) <= size/EDID_LENGTH)

3) Locking/Concurrency Impact:
- None. The change is purely input validation and early-exit; no locking/ordering or RCU semantics were introduced or altered.

6. Broader Kernel Security Implications
- EDID handling is fed by external hardware and must be treated as untrusted; missing validations can lead to kernel crashes or memory corruption from malformed devices.
- Similar paths using drm_edid_raw() or copying EDID data should be audited for NULL and bounds checks against fixed-size buffers.
- This reinforces the need for strict size checks derived from destination buffer capacity and mandatory NULL checks after helper calls that may fail.