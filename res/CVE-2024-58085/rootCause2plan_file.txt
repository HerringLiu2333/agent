1. Plan Summary
Detect kernel write handlers that grow an internal buffer based on user input without a hard upper bound and allocate with kmalloc/kzalloc lacking __GFP_NOWARN, enabling allocator “too large allocation” warnings (as in tomoyo_write_control pre-patch).

2. Detection Steps
1) Step 1: Identify candidate write handlers. Signals: functions returning ssize_t that take a const char __user * buffer and a length parameter (int/size_t), as in tomoyo_write_control (based on FILE_CONTENT). FP mitigation: require presence of get_user/copy_from_user usage inside the function.

2) Step 2: Confirm user-driven loop that appends data until a sentinel newline. Signals: a loop over a counter initially set from the length parameter (e.g., avail_len = buffer_len) that decrements per iteration, reading a byte from the __user pointer and appending to a destination buffer, with a check for '\n' to terminate (based on FILE_CONTENT). FP mitigation: require the loop writes into a persistent buffer (e.g., struct member like head->write_buf) across iterations.

3) Step 3: Find dynamic growth path that doubles buffer size when nearly full. Signals: condition like avail >= size - 1, computation len = size * 2 (or growth factor >1), followed by a kmalloc/kzalloc allocation of the new size, copying/moving old content, freeing old buffer, and updating pointer and size (based on FILE_CONTENT). FP mitigation: restrict to growth factor derived from current size (not a small fixed increment).

4) Step 4: Check allocator flags miss __GFP_NOWARN on the growth allocation. Signals: kzalloc/kmalloc called with GFP_* flags that do not include __GFP_NOWARN; the patched version added GFP_NOFS | __GFP_NOWARN (based on PATCH_DIFF). FP mitigation: do not report if __GFP_NOWARN is present.

5) Step 5: Verify absence of pre-allocation upper bounds. Signals: no nearby check that caps len (e.g., comparing to KMALLOC_MAX_SIZE or a defined maximum line length) before allocation; no early -EINVAL/-EMSGSIZE on excessive line length (based on ROOTCAUSE_ANALYSIS noting “no upper bound” and “no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE”). FP mitigation: suppress findings if a hard cap or validation exists before allocating.

6) Step 6: Confirm user-controllable growth is feasible in a single write. Signals: loop’s iteration bound derived from the length parameter and continues until newline or length exhaustion; char read via get_user/copy_from_user (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: require both dataflow from the write length parameter to loop counter and read from __user pointer.

7) Step 7: Check error handling relies solely on allocator failure. Signals: if (!newbuf) sets error = -ENOMEM and breaks, with no guard to prevent repeated large attempts beyond a cap; pre-patch code behaved this way (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: omit if code clearly rate-limits, caps, or short-circuits on prior failures for large sizes.

8) Step 8: Correlate the growth path with the write handler’s policy parsing gate. Signals: post-newline parsing only occurs after newline, so unbounded lines force repeated growth before parsing (based on FILE_CONTENT). FP mitigation: require the sentinel check and “dispatch on newline” pattern to reduce noise from non-line-based protocols.

9) Step 9: Report a finding when all are true: user-driven append loop until newline, exponential/bounded-by-size growth, allocation via kmalloc/kzalloc lacking __GFP_NOWARN, and no pre-allocation hard cap (maps to root cause per ROOTCAUSE_ANALYSIS and PATCH_DIFF). FP mitigation: provide evidence points (function name, loop condition, allocation callsite, flags used).

3. Target Elements
- Functions: write handlers with signature ssize_t f(..., const char __user *buf, int/size_t len).
- Loops: loops consuming user data until newline or length exhaustion.
- Allocation sites: kmalloc/kzalloc/kcalloc calls used to grow buffers, especially len = old_size * 2 style.
- Condition checks: “buffer nearly full” predicates (avail >= size - 1) and sentinel checks (c == '\n').
- Flags/arguments: GFP flags for allocations, presence/absence of __GFP_NOWARN.
- Return paths: error handling on allocation failure.

4. Dataflow / Taint Considerations
- Track taint from the length parameter and the __user buffer pointer into the loop controls (avail_len) and the appended byte (via get_user/copy_from_user).
- Track the destination buffer pointer and size variables across iterations to the allocation size computation (len = size * factor).
- Ensure the allocation size is driven solely by previous size and loop progress (and not bounded by a fixed max).

5. Validation & Test Cases
- Positive: A function like tomoyo_write_control pre-patch that reads from const char __user *buffer in a loop until '\n', doubles head->writebuf_size when full, allocates with kzalloc(len, GFP_NOFS) (no __GFP_NOWARN), and lacks any max-size check; expect a finding.
- Negative: Same function with kzalloc(len, GFP_NOFS | __GFP_NOWARN) as in PATCH_DIFF; expect no finding.
- Negative: A write handler that doubles buffer but first enforces if (len > KMALLOC_MAX_SIZE) return -EINVAL (or a fixed practical cap like 32KB); expect no finding.
- Negative: A loop growing a buffer not fed by __user reads (e.g., kernel-generated data) or that uses bounded chunks with a fixed maximum; expect no finding.
- Test harness notes: Run on kernel codebases; ensure modeling of __user, get_user/copy_from_user, and GFP flags/macros.

6. Estimated Effort & Priority
Medium: Requires kernel-specific patterns (Linux __user, GFP flags) and multi-step correlation, but constrained signals are clear.

7. Likely False-Positive Sources & Mitigations
- Drivers or kernel code that grow buffers from kernel data (mitigate by requiring __user sources).
- Growth patterns with implicit bounds not recognized (mitigate by scanning for any max checks or constants akin to KMALLOC_MAX_SIZE).
- Non-standard allocators or macro-wrapped allocations (mitigate by recognizing common kmalloc/kzalloc variants and macro expansions where feasible).

8. Limitations & Assumptions
- Assumes availability of kernel-specific annotations (__user) and recognition of GFP flags and __GFP_NOWARN macro.
- Cannot precisely determine KMALLOC_MAX_SIZE or allocator behavior in all builds; uses heuristic presence of bound checks.
- Does not quantify actual size thresholds; flags based on structural absence of NOWARN and bounds per ROOTCAUSE_ANALYSIS and PATCH_DIFF.