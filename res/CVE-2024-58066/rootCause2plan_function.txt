1. Plan Summary
Detect misuse of IS_ERR()/PTR_ERR() on results from NULL-returning allocation APIs (e.g., devm_kzalloc), which can mask allocation failure and lead to NULL pointer dereference.

2. Detection Steps
1) Step 1: Objective — Identify allocation sites that return NULL on failure. Signals — Calls to devm_kzalloc assigned to a pointer variable as shown in [PATCH_DIFF]/[FUNCTION_CONTENT]. FP mitigation — Restrict to devm_kzalloc (explicitly evidenced in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).

2) Step 2: Objective — Find incorrect error checks on these allocation results. Signals — An immediate or near-following condition using IS_ERR(var) where var is the result of devm_kzalloc (per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation — Ensure the condition compares the same variable assigned from devm_kzalloc and is intended as an error check (e.g., in an if-statement or conditional return path).

3) Step 3: Objective — Detect misuse of PTR_ERR() with the allocation result. Signals — PTR_ERR(var) applied to the devm_kzalloc result, especially used as a return value, as shown in the pre-patch code in [PATCH_DIFF]/[FUNCTION_CONTENT]. FP mitigation — Require that PTR_ERR(var) is used in error handling context (e.g., in a branch guarding allocation failure) to indicate API contract misunderstanding.

4) Step 4: Objective — Establish that the incorrect check allows execution to proceed. Signals — The IS_ERR(var) check does not trigger early return on NULL because devm_kzalloc returns NULL (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]); thus control flow continues past the check. FP mitigation — Use path analysis to confirm a path where the IS_ERR check is the only guard and there is no intervening NULL check (!var or var == NULL).

5) Step 5: Objective — Confirm dereference/use of the potentially NULL pointer. Signals — Member access or dereference of var (e.g., var->field) after the incorrect IS_ERR check, as in pxa_unit->base = ... shown in [FUNCTION_CONTENT]. FP mitigation — Require a clear dereference on the path without a prior NULL check to avoid flagging purely theoretical issues.

6) Step 6: Objective — Recognize correct error-check patterns to avoid false positives. Signals — Presence of a NULL check (!var or var == NULL) on the devm_kzalloc result followed by return -ENOMEM as in [PATCH_DIFF]. FP mitigation — If such a NULL check precedes all dereferences, do not report.

7) Step 7: Objective — Differentiate APIs that legitimately return ERR_PTR values. Signals — Calls like devm_platform_ioremap_resource followed by IS_ERR/PTR_ERR as in [FUNCTION_CONTENT], indicating correct ERR_PTR-based handling. FP mitigation — Maintain a small allowlist of ERR_PTR-returning APIs (at minimum, treat devm_platform_ioremap_resource as such based on [FUNCTION_CONTENT]) and exclude them.

8) Step 8: Objective — Detect mixed or contradictory checks that still misuse NULL-only APIs. Signals — Branches that check IS_ERR(var) for devm_kzalloc and elsewhere use PTR_ERR(var) as return code, with no NULL check. FP mitigation — Only report if at least one dereference is reachable after such checks without a prior NULL check (Step 5).

9) Step 9: Objective — Prioritize issues likely to crash. Signals — The first dereference after the incorrect check occurs unconditionally on the path (e.g., an assignment to var->field as in [FUNCTION_CONTENT]). FP mitigation — De-prioritize/report separately if dereference is inside a conditional that also checks for NULL.

10) Step 10: Objective — Suggest remediation pattern in findings (for human review). Signals — Recommend replacing IS_ERR(var)/PTR_ERR(var) with NULL check and return -ENOMEM as shown in [PATCH_DIFF]. FP mitigation — Only include this guidance when the source API is devm_kzalloc per [PATCH_DESCRIPTION].

3. Target Elements
- Function bodies (probe-like functions or any function using devm_kzalloc).
- Call sites to devm_kzalloc and the receiving variable.
- Conditional checks immediately after allocation (if-statements using IS_ERR on the allocation result).
- Uses of PTR_ERR with the allocation variable (particularly in return statements).
- Pointer dereferences/member accesses of the allocation variable.
- Calls to known ERR_PTR-returning APIs (e.g., devm_platform_ioremap_resource) to avoid false flags.

4. Dataflow / Taint Considerations
- Track the variable assigned from devm_kzalloc through local control flow to identify guarding conditions (IS_ERR vs NULL checks).
- Path-sensitively ensure a path exists where: allocation occurs → only IS_ERR(var) is checked (no NULL check) → dereference of var happens.
- Track uses of PTR_ERR(var) tied to the allocation variable to identify API contract mismatch in error paths.

5. Validation & Test Cases
- Positive: Pre-patch snippet from [FUNCTION_CONTENT]/[PATCH_DIFF] where devm_kzalloc result is checked with IS_ERR and then dereferenced via pxa_unit->base = ...; expect a report.
- Negative: Patched snippet from [PATCH_DIFF] where devm_kzalloc result is checked with !pxa_unit and returns -ENOMEM; expect no report.
- Negative: Code that calls devm_platform_ioremap_resource, checks IS_ERR, and returns PTR_ERR on failure as in [FUNCTION_CONTENT]; expect no report (correct usage for ERR_PTR-returning API).
- Test harness notes: Run intra-file analysis focusing on driver probe-like functions; ensure path feasibility is considered between allocation, checks, and dereference.

6. Estimated Effort & Priority
High — Based on [ROOTCAUSE_ANALYSIS] highlighting a recurring class of API contract mismatches across drivers with DoS impact.

7. Likely False-Positive Sources & Mitigations
- Unknown wrapper APIs around allocations with different contracts; mitigation: limit to devm_kzalloc per evidence and allow manual extension.
- Complex control flow where a NULL check is implicit or inlined; mitigation: require a clear syntactic NULL check before dereference to suppress.
- Cases with no subsequent dereference; mitigation: require a concrete dereference on the path to report.

8. Limitations & Assumptions
- Assumes a curated list of NULL-returning vs ERR_PTR-returning APIs; from provided materials, only devm_kzalloc (NULL) and devm_platform_ioremap_resource (ERR_PTR) are known.
- Does not account for interprocedural propagation of the allocated pointer; focuses on local function scope as in [FUNCTION_CONTENT].
- Cannot infer kernel-wide macro expansions or custom wrappers not shown; may miss issues hidden behind such abstractions.