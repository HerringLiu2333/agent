1. Plan Summary
Detect misuse of IS_ERR/PTR_ERR error-pointer handling applied to the result of devm_kzalloc, which returns NULL on failure, leading to potential NULL pointer dereference.

2. Detection Steps
1) Step 1: Identify assignments where a variable is initialized from a call to devm_kzalloc(&pdev->dev, size, GFP_*). Signals: a call expression named devm_kzalloc and its returned value captured into a pointer-typed variable.

2) Step 2: Within the same function, locate any conditionals or expressions invoking IS_ERR(var) where var is the result of devm_kzalloc. Signals: function-like use of IS_ERR with the same variable as argument, typically in an if-statement.

3) Step 3: Find return statements that use PTR_ERR(var) to produce an error code when var comes from devm_kzalloc. Signals: return of an expression PTR_ERR(var) linked to the same variable.

4) Step 4: Confirm that devm_kzalloc returns NULL on failure (as per patch description) and does not return ERR_PTR; treat any IS_ERR/PTR_ERR usage on its result as an error-handling mismatch. Signals: the callee name exactly matches devm_kzalloc.

5) Step 5: Trace forward from the devm_kzalloc assignment to find dereferences or member accesses of var (e.g., var->field) after the IS_ERR check. Signals: field access, unary dereference, or passing var to functions that expect non-NULL pointers.

6) Step 6: Check for absence of a guarding NULL check on var before those dereferences (e.g., !var or var == NULL). Signals: control-flow contexts where dereferences are reachable without a preceding NULL check dominating their execution.

7) Step 7: Raise a finding when both conditions hold: (a) IS_ERR/PTR_ERR is used on the devm_kzalloc result, and (b) there exists a path where var is dereferenced without a preceding NULL check. Signals: path-sensitive reachability from allocation to dereference through the incorrect check.

8) Step 8: Also raise a (lower-severity) finding when IS_ERR/PTR_ERR is used on the devm_kzalloc result even if no dereference is found, as this indicates incorrect error handling that may be latent. Signals: presence of misuse without confirmed deref.

9) Step 9: Exclude cases where the misuse does not apply (e.g., IS_ERR/PTR_ERR used on results from APIs documented to return ERR_PTR like devm_platform_ioremap_resource). Signals: callee name does not match devm_kzalloc for the variable under check.

10) Step 10: Classify the issue and suggest the correct check: replace IS_ERR(var)/PTR_ERR(var) with a NULL check and return -ENOMEM. Signals: mapping the incorrect pattern to the fix described in the patch.

3. Limitations & Assumptions
- The plan assumes only devm_kzalloc is modeled as returning NULL on failure; other APIs returning NULL vs ERR_PTR are not identified in the provided materials.
- Determining whether a function “expects non-NULL pointers” is inferred from dereference/member access, not from full API specifications.
- Path dominance and reachability rely on CodeQL’s control-flow analysis; complex macro expansions of IS_ERR/PTR_ERR are assumed to be resolvable to calls.