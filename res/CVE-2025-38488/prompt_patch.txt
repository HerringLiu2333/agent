1. CVE Identifier
CVE-2025-38488

2. Vulnerability Type
Use-after-free due to missing asynchronous crypto completion handling (lifetime management/race window)

3. Root Cause Summary
crypt_message() assumed AEAD operations are always synchronous and did not set a completion callback or wait for completion. It directly invoked crypto_aead_encrypt/decrypt and then freed the request buffer (creq) even when the operation returned -EINPROGRESS and continued asynchronously. This premature free caused a use-after-free when the hardware crypto driver later accessed the aead_request from the freed buffer. The flaw originated when prior changes for CVE-2024-50047 removed the async handling from crypt_message(), but crypto_alloc_aead() could still select async implementations.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SMB client (CIFS) encryption/decryption path using the kernel crypto API (SMB3 AEAD) in crypt_message().

2) Pre-Patch Flaw:
crypt_message() did not register an async callback or wait on completion and immediately freed creq after:
“rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);”
With async AEAD, this returns -EINPROGRESS and completes later, but the request storage was already freed.

3) Trigger Condition:
Use of hardware crypto accelerators or any AEAD implementation that performs asynchronous operations, causing crypto_aead_encrypt/decrypt() to return -EINPROGRESS in crypt_message().

4) Impact Mechanism:
The function freed the aead_request backing buffer (kvfree_sensitive(creq, ...)) before the async operation completed. The crypto driver then accessed the freed request memory during its completion, leading to use-after-free, kernel crashes, and reported NULL pointer dereferences.

5. Patch Analysis
1) Fix Approach:
Restore proper asynchronous crypto handling by tracking completion and waiting before freeing resources. The patch declares a completion wait object, sets an async callback on the request, and uses crypto_wait_req() to block until the AEAD operation finishes, covering both synchronous and asynchronous implementations.

2) Key Code Changes:
- Added DECLARE_CRYPTO_WAIT(wait) in crypt_message().
- Added aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait) to register completion handling.
- Replaced the direct call with a waited call: rc = crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait).
These changes ensure the request buffer isn’t freed until the operation completes.

3) Locking/Concurrency Impact:
The patch introduces proper synchronization with the crypto subsystem via the crypto wait API, eliminating the race window between freeing creq and async completion. No new locks are added; instead, completion waiting (crypto_wait_req) ensures correct lifetime management of the request memory for both sync and async paths.

6. Broader Kernel Security Implications
Kernel code using the crypto API must not assume synchronous behavior; implementations may be async even without requesting CRYPTO_ALG_ASYNC explicitly. Mismanaging async completion leads to severe lifetime bugs (use-after-free) involving sensitive buffers (keys and request state), causing crashes or potential data leakage. The fix demonstrates the correct pattern: set callbacks and wait for completion before freeing or reusing request memory. Other kernel paths interfacing with AEAD or similar crypto operations should audit for similar assumptions to prevent regressive UAF vulnerabilities, especially when hardware accelerators are present.