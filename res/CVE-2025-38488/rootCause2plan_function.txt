1. Plan Summary
Detect kernel call sites where an AEAD encrypt/decrypt operation may complete asynchronously but the associated request buffer is freed without registering a completion callback and waiting for completion, leading to use-after-free (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).

2. Detection Steps
1) Step 1: Identify AEAD operation sites — find functions that call crypto_aead_encrypt(...) or crypto_aead_decrypt(...) and use an aead_request as input — these are the potential async operations per ROOTCAUSE_ANALYSIS.
2) Step 2: Resolve the aead_request object — locate the aead_request value passed into the AEAD call and its provenance (e.g., out-parameter from helper like smb2_get_aead_req), confirming it is the request backing the operation (FUNCTION_CONTENT).
3) Step 3: Check for async readiness — verify whether aead_request_set_callback(...) is called on the same aead_request prior to the AEAD call; absence indicates no completion notification path (PATCH_DIFF notes this was added).
4) Step 4: Check for completion waiting — verify whether crypto_wait_req(...) is used to wrap or process the result of the AEAD call along the same path; absence indicates no waiting for async completion (PATCH_DIFF).
5) Step 5: Track request-containing allocation — identify the memory region that contains the aead_request (e.g., the “creq” buffer returned by smb2_get_aead_req(...) alongside the aead_request out-parameter) using dataflow from the helper to the request pointer (FUNCTION_CONTENT and PATCH_DESCRIPTION).
6) Step 6: Detect premature free — find deallocation of the request or its containing region (e.g., kvfree_sensitive(creq, ...)) occurring after the AEAD call and before any proven completion wait, along any feasible control-flow path (FUNCTION_CONTENT).
7) Step 7: Correlate missing async handling with free — flag only if both conditions hold: no aead_request_set_callback + no crypto_wait_req, and a free of the request or its container occurs post-call; this maps to the race described in ROOTCAUSE_ANALYSIS.
8) Step 8: Ensure AEAD request is live across the call — confirm that the freed region aliases/contains the aead_request passed to crypto_aead_encrypt/decrypt (e.g., via the out-parameter relation from smb2_get_aead_req and subsequent use of the same req) to avoid unrelated frees (FUNCTION_CONTENT).
9) Step 9: Exempt safe pattern — suppress if aead_request_set_callback is set and the AEAD call’s completion is joined via crypto_wait_req before any free, matching the fixed pattern (PATCH_DIFF).
10) Step 10: Guard against trivial FPs — suppress if there is no deallocation of the request or its containing memory within the function (or escape occurs without free), as the UAF hazard hinges on freeing while an async op may still be in-flight (ROOTCAUSE_ANALYSIS).
11) Step 11: Consider rc handling only as secondary — do not treat checking the return code alone as safe unless crypto_wait_req is used; async implementations can return -EINPROGRESS, and without waiting the lifetime bug persists (PATCH_DESCRIPTION).
12) Step 12: Prefer intra-procedural confirmation — require that allocation/out-parameter binding, AEAD call, and free occur within the same function (e.g., crypt_message) to maintain high precision about lifetime ordering (FUNCTION_CONTENT).

3. Target Elements
- Call sites to crypto_aead_encrypt and crypto_aead_decrypt.
- aead_request objects and their initialization (aead_request_set_tfm, aead_request_set_crypt, aead_request_set_ad).
- Calls to aead_request_set_callback and crypto_wait_req.
- Allocation sites/helpers yielding both a request container and the aead_request via out-parameters (e.g., smb2_get_aead_req).
- Deallocation calls freeing the request or its containing buffer (e.g., kvfree_sensitive).
- Control-flow and ordering between AEAD call, potential wait, and free.

4. Dataflow / Taint Considerations
- Track binding between the request container pointer (e.g., creq) returned from a helper and the aead_request out-parameter (req) to model containment.
- Propagate the aead_request value to the AEAD call to ensure the same object is used in the operation.
- Track deallocation calls that free the container that holds the aead_request used in the AEAD call.
- Ensure the ordering: AEAD call happens before free and no intervening crypto_wait_req on the path.

5. Validation & Test Cases
- Positive: Pre-patch crypt_message (FUNCTION_CONTENT) where crypto_aead_encrypt/decrypt is called without aead_request_set_callback or crypto_wait_req, followed by kvfree_sensitive(creq, ...); expect a finding.
- Positive: Variant where req and creq come from smb2_get_aead_req and free occurs in an error path after the AEAD call without any wait; expect a finding.
- Negative: Patched version (PATCH_DIFF) using aead_request_set_callback and crypto_wait_req before kvfree_sensitive; expect no finding.
- Negative: Function that performs AEAD call, does not free the request/container in the function, and returns; expect no finding for UAF.
- Test harness notes: Run on CIFS crypt_message before and after the patch; validate that only the pre-patch variant is flagged.

6. Estimated Effort & Priority
High — requires interrelated dataflow (out-params), control-flow ordering, and API pattern recognition across kernel crypto calls.

7. Likely False-Positive Sources & Mitigations
- Synchronous-only AEAD implementations assumed by the code: mitigate by requiring a concrete free of the request/container post-call without wait.
- Alternative waiting/completion mechanisms not modeled: mitigate by focusing on the canonical safe pattern (aead_request_set_callback + crypto_wait_req) described in PATCH_DIFF and ROOTCAUSE_ANALYSIS.
- Misidentifying container/request aliasing: mitigate by demanding explicit out-parameter linkage from helper (e.g., smb2_get_aead_req) to aead_request and the freed container pointer.

8. Limitations & Assumptions
- Assumes the presence of the canonical Linux crypto API patterns; alternative synchronization mechanisms are not recognized due to lack of evidence in provided materials.
- Cannot statically determine algorithm sync guarantees; flags are based on absence of wait/callback plus freeing, per ROOTCAUSE_ANALYSIS stating mask=0 does not ensure sync.
- Does not model cross-function lifetimes if allocation and free occur in different functions; plan focuses on intra-procedural cases evidenced in FUNCTION_CONTENT.