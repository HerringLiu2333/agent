1. Plan Summary
Detect AEAD crypto calls (encrypt/decrypt) that do not account for asynchronous completion and free or invalidate the request buffer before ensuring completion, leading to use-after-free.

2. Detection Steps
1) Step 1: Locate AEAD operations — identify calls to crypto_aead_encrypt(req) and crypto_aead_decrypt(req) and extract the aead_request* argument used.
2) Step 2: Track the request buffer — from where the aead_request* is derived, track any pointer to the surrounding allocation that contains it (e.g., a variable like creq returned by smb2_get_aead_req and passed alongside req).
3) Step 3: Check for async readiness — before the AEAD call, look for aead_request_set_callback(req, …, crypto_req_done, …) on the same req variable to determine whether an async callback is configured.
4) Step 4: Check for completion waiting — see if the AEAD call’s return is passed through crypto_wait_req(...) (either directly as an argument or via an intermediate variable), paired with a DECLARE_CRYPTO_WAIT(...) object.
5) Step 5: Identify missing wait — if neither aead_request_set_callback nor crypto_wait_req is present around the AEAD call on this req, mark the invocation as potentially asynchronous without synchronization.
6) Step 6: Find immediate frees — after the AEAD call (and before any observed completion wait), look for frees of the request buffer or its container (e.g., kvfree_sensitive(creq, ...), kfree/kvfree) where the freed pointer may alias/match the container holding req.
7) Step 7: Propagate aliasing — use data-flow to relate frees to the allocation that produced req (e.g., smb2_get_aead_req(...) returning creq while setting req to an interior pointer) and flag if that container is freed while the async operation may still be in progress.
8) Step 8: EINPROGRESS handling — detect if the AEAD return value is checked for -EINPROGRESS without subsequently awaiting completion (no crypto_wait_req and no equivalent wait), and still frees the container; flag such paths.
9) Step 9: Multi-path analysis — explore all post-call control-flow paths in the function; flag any path that frees the req container or returns early without a crypto_wait_req for the in-flight operation.
10) Step 10: Suppression for correct pattern — if code sets a callback and uses crypto_wait_req(...) to synchronize completion before any free, do not report.
11) Step 11: Report focus — report at the AEAD call site, referencing the subsequent free site (e.g., kvfree_sensitive(creq,...)) and absence of crypto_wait_req as the reason.
12) Step 12: De-duplicate — merge multiple findings in the same function involving the same req/container into a single alert to reduce noise.

3. Limitations & Assumptions
- Assumes crypto_aead_encrypt/decrypt may complete asynchronously even if crypto_alloc_aead() mask is zero; thus, lack of crypto_wait_req is treated as unsafe.
- Alternative completion mechanisms (custom completions not using crypto_wait_req but functionally equivalent) may not be recognized and could yield false positives.
- Precise aliasing between req and its containing allocation depends on tracking helper functions (e.g., smb2_get_aead_req); if code uses different helpers/patterns, the checker may miss or over-approximate container relationships.