1. CVE Identifier
CVE-2025-38488

2. Vulnerability Type
Use-after-free due to missing asynchronous crypto completion handling (lifetime management bug)

3. Root Cause Summary
crypt_message() in the SMB client freed the AEAD request buffer immediately after invoking crypto_aead_encrypt()/decrypt(), assuming synchronous completion. When an async AEAD implementation is selected, those calls can return -EINPROGRESS and complete later; freeing the request buffer early causes the crypto driver to access freed memory, leading to a use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SMB/CIFS client encryption path (fs/…/smb2 operations), specifically crypt_message() in the SMB3 transform/encrypt/decrypt handling.

2) Pre-Patch Flaw:
- In crypt_message(), after preparing the aead_request and scatterlist, the code called crypto_aead_encrypt(req) or crypto_aead_decrypt(req) and then immediately freed the request buffer with kvfree_sensitive(creq, sensitive_size).
- No async callback (aead_request_set_callback) was registered, and no wait (crypto_wait_req) was performed to ensure completion before freeing memory.
- Pre-patch code snippet: rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req); … kvfree_sensitive(creq, sensitive_size); (no callback/wait).

3) Trigger Condition:
- Selection of an asynchronous AEAD crypto implementation (e.g., via hardware accelerators) where crypto_aead_encrypt()/decrypt() returns -EINPROGRESS.
- crypto_alloc_aead() with mask=0 does not guarantee synchronous operation; async implementations can be chosen (as noted in the patch description).

4) Impact Mechanism:
- The function frees the buffer that contains the aead_request while the async crypto operation is still in progress.
- The crypto driver later dereferences the freed request memory, producing a use-after-free, typically manifesting as kernel crashes (e.g., NULL dereferences), data corruption, or unpredictable behavior.

5. Patch Analysis
1) Fix Approach:
Restore proper asynchronous crypto handling by integrating the kernel crypto wait infrastructure:
- Declare a completion wait object.
- Register an async completion callback on the AEAD request.
- Use crypto_wait_req() to wait for completion of encrypt/decrypt, thereby deferring buffer free until the operation finishes.

2) Key Code Changes:
- In crypt_message():
  - Added DECLARE_CRYPTO_WAIT(wait);
  - Added aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait);
  - Replaced direct invocation with a waited call: rc = crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait);
- This ensures that kvfree_sensitive(creq, sensitive_size) happens after completion rather than during an in-flight operation.
- Diff evidence (function: crypt_message):
  - Before: rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
  - After: set callback + rc = crypto_wait_req(…).

3) Locking/Concurrency Impact:
- No changes to CIFS/server locks; the fix adds synchronization with the crypto subsystem by waiting for asynchronous completion through crypto_wait_req() and callback.
- CRYPTO_TFM_REQ_MAY_BACKLOG flag allows proper handling of backlogged requests, avoiding races with the hardware crypto engine.
- The primary concurrency issue (freeing memory before async completion) is resolved by wait+callback ordering, removing the race window that led to UAF.

6. Broader Kernel Security Implications
- Kernel subsystems using the crypto API must not assume synchronous completion; they must handle -EINPROGRESS and ensure request/lifetime management accordingly.
- Mishandling async crypto can cause severe memory safety violations (UAF) especially when hardware accelerators are present.
- Proper use of aead_request_set_callback and crypto_wait_req is essential for safe operation across diverse crypto implementations, improving robustness against class-wide async handling bugs.