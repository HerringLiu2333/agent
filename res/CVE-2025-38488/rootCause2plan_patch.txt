1. Plan Summary
Detect kernel call sites that invoke crypto_aead_encrypt/decrypt without proper asynchronous completion handling (callback + wait) and then free the request buffer before completion, leading to a use-after-free.

2. Detection Steps
1) Step 1: Identify AEAD operation sites — find calls to crypto_aead_encrypt or crypto_aead_decrypt with an aead_request* argument — this pinpoints the potentially asynchronous crypto operations noted in the root cause ([ROOTCAUSE_ANALYSIS] 3, 5.1-5.2).
2) Step 2: Correlate request and its backing storage — within the same function, find prior construction of the aead_request via a helper like smb2_get_aead_req that returns a buffer (e.g., creq) and populates the aead_request* via an out-parameter — this matches the allocation pattern described ([PATCH_DESCRIPTION] and [PATCH_DIFF]).
3) Step 3: Confirm request setup — check for aead_request_set_crypt and/or aead_request_set_ad on the same aead_request* to increase confidence that the request is active — this reduces noise by ensuring you’re analyzing a real AEAD crypto request path ([PATCH_DIFF]).
4) Step 4: Check for absence of async readiness — verify that no aead_request_set_callback is made on the same request in the current function prior to the AEAD call — lack of a callback is a strong signal the code assumes synchronous behavior ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS] 3, 5.2).
5) Step 5: Check for absence of a completion wait — verify that there is no crypto_wait_req call that wraps or follows the AEAD call using a matching wait object — absence indicates the function does not wait for possible asynchronous completion ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS] 3, 5.1-5.2).
6) Step 6: Detect premature resource release — after the AEAD call, look for a free of the backing buffer (e.g., kvfree_sensitive on creq) or other deallocation of the storage that contains the aead_request — premature free maps to the use-after-free window described ([PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS] 3-4).
7) Step 7: Correlate free-before-completion — ensure the free occurs before any completion wait (e.g., crypto_wait_req) or confirmed completion point — this establishes the precise race leading to UAF ([ROOTCAUSE_ANALYSIS] 3-4).
8) Step 8: Recognize safe patterns and suppress — if the code sets a callback (aead_request_set_callback) and uses crypto_wait_req to block until completion, do not flag, even if a free follows — this mirrors the patch’s correct fix ([PATCH_DIFF], [PATCH_DESCRIPTION]).
9) Step 9: Handle ternary or conditional dispatch — if the call site conditionally uses encrypt or decrypt (e.g., enc ? crypto_aead_encrypt : crypto_aead_decrypt), treat both branches identically; require callback + wait on the same request variable — this matches the fixed pattern that wraps both operations in crypto_wait_req ([PATCH_DIFF]).
10) Step 10: Return-path resource lifetime — if the function returns or unwinds (e.g., goto cleanup) and frees the backing buffer without any prior completion wait after the AEAD call, flag — returning without a wait still risks late driver access to freed memory ([ROOTCAUSE_ANALYSIS] 3-4).

3. Target Elements
- Function call sites to crypto_aead_encrypt and crypto_aead_decrypt.
- aead_request construction sites (e.g., smb2_get_aead_req out-parameter) and associated backing storage variables (e.g., creq).
- Request setup calls: aead_request_set_crypt, aead_request_set_ad.
- Async handling constructs: aead_request_set_callback, DECLARE_CRYPTO_WAIT/crypto_req_done usage, crypto_wait_req.
- Resource release calls: kvfree_sensitive on the backing buffer (creq) or equivalent deallocators.
- Control-flow/return paths that free the backing storage after the AEAD call.

4. Dataflow / Taint Considerations
- Track the relation between the aead_request* (req) and its backing buffer (creq) created by a function like smb2_get_aead_req that returns creq and fills &req.
- Propagate aliases of req and creq within the function to detect frees of the correct storage.
- Ensure the free site is post-dominated by the AEAD call and strictly pre-dominated by any completion wait; flag only when free can occur before completion wait.
- Consider both branches of conditional encrypt/decrypt dispatch using the same req.

5. Validation & Test Cases
- Positive: Function allocates creq via smb2_get_aead_req(&req), sets crypt/ad, directly calls crypto_aead_encrypt(req), then calls kvfree_sensitive(creq) without aead_request_set_callback or crypto_wait_req — expect a finding.
- Positive: Same as above but with conditional enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req) and immediate free of creq — expect a finding.
- Negative: Function allocates creq/req, sets callback via aead_request_set_callback, invokes crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait), then frees creq — expect no finding.
- Negative: Function allocates creq/req, sets callback and calls crypto_wait_req before any deallocation or return — expect no finding.
- Test harness notes: Validate control-flow with early returns and cleanup labels to ensure the checker recognizes frees occurring on all paths before a completion wait.

6. Estimated Effort & Priority
Medium — requires intra-procedural dataflow (req-to-creq relationship), call-sequence pattern matching, and control-flow reasoning; high security impact per [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION].

7. Likely False-Positive Sources & Mitigations
- Custom completion mechanisms (not using crypto_wait_req) that still guarantee completion before free; mitigate by requiring absence of both aead_request_set_callback and crypto_wait_req before flagging.
- Cases where the backing buffer is not freed (no UAF risk) but the checker misidentifies a free; mitigate by strictly correlating the freed pointer to the known backing storage (creq) derived from the allocation helper.
- Asynchronous-safe designs split across functions (completion handled elsewhere); mitigate by scoping to single-function patterns where allocation, call, and free occur in the same function.

8. Limitations & Assumptions
- Assumes the request’s backing storage is identifiable (e.g., via smb2_get_aead_req) and freed in the same function; interprocedural lifetime analysis is not covered by this plan.
- Does not detect misuse when no free occurs (potential leak but not UAF); the focus is on pre-completion frees as per [ROOTCAUSE_ANALYSIS].
- Assumes correct identification of kernel crypto API functions and naming (aead_request_set_callback, crypto_wait_req, kvfree_sensitive) per [PATCH_DIFF]; custom wrappers are not recognized.
- Cannot confirm whether the underlying algorithm is async-capable; per [PATCH_DESCRIPTION], the checker treats all AEAD calls as potentially async regardless of mask.