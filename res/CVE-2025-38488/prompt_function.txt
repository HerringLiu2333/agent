1. CVE Identifier
CVE-2025-38488

2. Vulnerability Type
Use-after-free due to missing asynchronous crypto completion handling (race between freeing request buffer and AEAD completion)

3. Root Cause Summary
- The function crypt_message() assumed AEAD operations are always synchronous and freed the request buffer immediately after invoking crypto_aead_encrypt()/crypto_aead_decrypt().
- When an async AEAD implementation is selected (e.g., hardware accelerator), these calls can return -EINPROGRESS and complete later, but the code did not set a callback or wait for completion.
- As a result, the allocated request buffer (creq) holding the aead_request and associated memory was freed while the crypto operation was still in progress, leading to use-after-free by the crypto driver.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- SMB client (CIFS) encryption/decryption path in the Linux kernel, function crypt_message().

2) Pre-Patch Flaw:
- After preparing the AEAD request, the code executed:
  - rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
  - kvfree_sensitive(creq, sensitive_size);
- It neither set an async callback via aead_request_set_callback() nor waited via crypto_wait_req(), incorrectly assuming synchronous completion.

3) Trigger Condition:
- Use of a crypto AEAD implementation that completes asynchronously (e.g., hardware crypto accelerators) causing crypto_aead_encrypt()/decrypt() to return -EINPROGRESS.
- This can occur regardless of the mask used in crypto_alloc_aead(), since mask=0 does not guarantee synchronous algorithms.

4) Impact Mechanism:
- The in-flight crypto operation later accesses the aead_request and associated memory that was already freed (creq), resulting in a use-after-free.
- This manifests as kernel crashes (e.g., NULL pointer dereferences) and potential memory corruption.

5. Patch Analysis
1) Fix Approach:
- Restore proper asynchronous crypto handling by registering a completion callback and waiting for completion before freeing the request buffer.
- Ensure the function blocks until the AEAD operation completes, whether it is synchronous or asynchronous.

2) Key Code Changes:
- Added DECLARE_CRYPTO_WAIT(wait) to manage completion wait state.
- Added aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait) to receive completion notifications and handle backlog.
- Replaced direct invocation with a waited call:
  - rc = crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait);
- These changes ensure kvfree_sensitive(creq, sensitive_size) runs only after the crypto operation has completed.

3) Locking/Concurrency Impact:
- No new spinlocks/mutexes; instead, uses the crypto APIâ€™s completion/wait mechanism to serialize freeing memory with operation completion.
- Eliminates the race window between async completion and buffer lifetime by ordering the free after completion notification.
- CRYPTO_TFM_REQ_MAY_BACKLOG allows proper queuing behavior without introducing new deadlocks or contention.

6. Broader Kernel Security Implications
- Kernel users of the crypto API must not assume synchronous operation; they must always handle possible asynchronous completion with callbacks and waits.
- Failing to wait for async completion commonly leads to lifetime bugs (use-after-free) across subsystems integrating with hardware-accelerated crypto.
- The fix illustrates the correct pattern: set callback + crypto_wait_req() to ensure safe memory lifetimes and robust behavior regardless of the selected crypto implementation.