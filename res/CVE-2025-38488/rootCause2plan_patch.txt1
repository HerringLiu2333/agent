1. Plan Summary
Detect kernel AEAD encryption/decryption code paths that call crypto_aead_encrypt/decrypt without waiting for possible asynchronous completion and then free the aead_request’s backing storage, creating a use-after-free race.

2. Detection Steps
1) Step 1: Identify candidate functions that construct and use a struct aead_request. Signals: calls to aead_request_set_crypt and/or aead_request_set_ad, and a local variable of type struct aead_request* subsequently passed to crypto_aead_encrypt or crypto_aead_decrypt.
2) Step 2: Detect direct invocation of crypto_aead_encrypt(req) or crypto_aead_decrypt(req) whose return value is assigned to an rc-like variable without being wrapped by crypto_wait_req. Signals: the callee is crypto_aead_encrypt/decrypt, and the call result is not passed as the first argument to crypto_wait_req.
3) Step 3: Check for absence of explicit async completion setup. Signals: no call to aead_request_set_callback on the same req before the encrypt/decrypt call in the analyzed function.
4) Step 4: Check for absence of completion waiting. Signals: the function does not declare a wait object (e.g., via DECLARE_CRYPTO_WAIT) and does not invoke crypto_wait_req with a wait parameter after initiating the crypto operation.
5) Step 5: Track the backing memory that holds the aead_request. Signals: a helper call that returns a buffer (e.g., a variable like creq) and also initializes req via an out-parameter, or any pattern where req is derived from/points into a buffer that is subsequently freed.
6) Step 6: Detect freeing or sensitive reclaim of the backing buffer in the same function after the crypto call. Signals: calls to kvfree_sensitive on the buffer identified in Step 5, occurring post crypto_aead_encrypt/decrypt and without an intervening crypto_wait_req.
7) Step 7: Correlate the request and the freed buffer to establish a lifetime violation. Signals: req is initialized prior to the crypto call and used by crypto_aead_encrypt/decrypt; the buffer that produced or contains req is freed while no completion wait has happened.
8) Step 8: Strengthen confidence when the AEAD transform is acquired with crypto_alloc_aead using mask=0 in the same code path. Signals: presence of crypto_alloc_aead(..., 0) suggests async implementations may be selected, increasing the risk when Steps 2–7 match.
9) Step 9: Exclude safe patterns where the code sets aead_request_set_callback and waits via crypto_wait_req before any free. Signals: aead_request_set_callback is present, crypto_wait_req is called, and the free of the backing buffer occurs only after the wait returns.
10) Step 10: Report a finding only when all of the following hold: direct crypto_aead_encrypt/decrypt call, no aead_request_set_callback, no crypto_wait_req, and freeing (kvfree_sensitive) of the backing buffer or equivalent in the same function post-call. Signals: conjunction of Steps 2–7 without Step 9.

3. Limitations & Assumptions
- Static analysis cannot determine whether a given AEAD implementation is actually asynchronous at runtime; detection assumes it may be async per crypto_alloc_aead(..., 0).
- The plan focuses on kvfree_sensitive as the observed free; other deallocation APIs may exist but are not in the supplied materials.
- Precisely proving that the freed buffer “contains” or backs the aead_request may require alias/dataflow heuristics; if the relation is indirect or spans multiple functions, the checker may miss or misclassify cases.
- Callback-only designs or alternative synchronization mechanisms (other than crypto_wait_req) are not described; the checker may flag them as suspicious due to missing evidence.
- The materials cover the SMB client path; other subsystems with similar patterns are assumed analogous but are not enumerated here.