1. Plan Summary
Detect AEAD encryption/decryption call sites that free the request buffer without handling asynchronous completion (no callback or wait), leading to use-after-free when hardware crypto returns -EINPROGRESS.

2. Detection Steps
1) Step 1: Identify functions that prepare an aead_request and invoke crypto_aead_encrypt or crypto_aead_decrypt. Signals: presence of aead_request_set_tfm/aead_request_set_crypt/aead_request_set_ad followed by crypto_aead_encrypt/decrypt; this maps to the vulnerable path in crypt_message (from [FILE_CONTENT], [ROOTCAUSE_ANALYSIS]). FP mitigation: restrict to call sites where aead_request pertains to AEAD ops in the same function.
2) Step 2: Determine whether aead_request_set_callback is configured for the request prior to the AEAD call. Signals: absence of aead_request_set_callback(req, …) near the request; maps to missing async handling noted in [PATCH_DESCRIPTION]/[PATCH_DIFF]. FP mitigation: allow matches only if callback is not set anywhere on the same req variable in the function.
3) Step 3: Check if the AEAD call is wrapped with crypto_wait_req to block until completion. Signals: absence of crypto_wait_req(...) using the return value of crypto_aead_encrypt/decrypt; aligns with fix in [PATCH_DIFF]. FP mitigation: accept equivalent waits only if they clearly guard completion of the same req call site.
4) Step 4: Track the lifetime of the aead_request and its backing buffer after the AEAD call. Signals: immediate freeing of the buffer containing the request (e.g., kvfree_sensitive(creq, sensitive_size) or kfree on a region that holds req) in the same function after the AEAD call; maps to the use-after-free described in [ROOTCAUSE_ANALYSIS]. FP mitigation: require evidence that the freed buffer is the storage that contains req (e.g., req derived from that allocation pointer as in smb2_get_aead_req returning creq).
5) Step 5: Verify whether the code branches on the AEAD call’s return value to handle -EINPROGRESS correctly. Signals: absence of rc check for -EINPROGRESS and no deferred free; ties to trigger condition in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]. FP mitigation: if there is a branch that defers freeing upon -EINPROGRESS or uses a completion path, do not flag.
6) Step 6: Raise severity when the AEAD transform is allocated with crypto_alloc_aead using mask=0. Signals: calls like crypto_alloc_aead("gcm(aes)" or "ccm(aes)", 0, 0) feeding the req; maps to the note that mask=0 does not guarantee sync in [PATCH_DESCRIPTION]. FP mitigation: treat this as a confidence booster rather than a sole trigger; only flag when combined with Steps 2–5.
7) Step 7: Exclude cases where crypto_wait_req is used and the free occurs after wait completion. Signals: presence of DECLARE_CRYPTO_WAIT + crypto_req_done + crypto_wait_req pattern (as in [PATCH_DIFF]); reduces false positives. FP mitigation: ensure dataflow shows the free is post-wait.
8) Step 8: Flag cases where a callback is set but there is still an immediate free and no wait. Signals: aead_request_set_callback present but code frees request storage with no crypto_wait_req; matches a variant of the same UAF class. FP mitigation: only report if the free is executed unconditionally in the same function and no completion synchronization is observed.
9) Step 9: Confirm the AEAD operation length includes the authentication tag for decrypt paths or signature copy for encrypt paths; ensure it’s the same pattern as crypt_message. Signals: usage of sign/Signature and crypt_len adjustments (from [FILE_CONTENT]); maps to recognizing the typical AEAD request context. FP mitigation: use as context qualifier, not a trigger.

3. Target Elements
- Function bodies that call crypto_aead_encrypt or crypto_aead_decrypt.
- aead_request preparation sites: aead_request_set_tfm, aead_request_set_crypt, aead_request_set_ad.
- Async handling APIs: aead_request_set_callback, crypto_wait_req, DECLARE_CRYPTO_WAIT, crypto_req_done.
- Memory allocation of AEAD request backing storage and frees: smb2_get_aead_req/smb2_aead_req_alloc returns, kvfree_sensitive/kfree of the buffer.
- Return value handling of AEAD calls (rc checks and branching).

4. Dataflow / Taint Considerations
- Track the dataflow from the AEAD request allocation container (e.g., creq) to the req pointer to establish that freeing the container frees the request.
- Track the control-flow from the AEAD call to subsequent frees to determine whether any wait or EINPROGRESS handling intervenes.
- Track the transform allocation (crypto_alloc_aead result tfm) to the aead_request_set_tfm and AEAD call site to raise confidence in async possibility.

5. Validation & Test Cases
- Positive: Pre-patch crypt_message in [FILE_CONTENT], where crypto_aead_encrypt/decrypt is called and kvfree_sensitive(creq, sensitive_size) happens immediately with no aead_request_set_callback and no crypto_wait_req; expect a report.
- Negative: Patched crypt_message in [PATCH_DIFF], which adds DECLARE_CRYPTO_WAIT, aead_request_set_callback, and crypto_wait_req; expect no report.
- Positive (variant): Code that sets a callback but still frees the request storage without waiting; expect a report.
- Test harness notes: Use function-level analysis with inter-procedural dataflow to relate req to its allocation and frees; ensure the checker recognizes both encrypt and decrypt paths.

6. Estimated Effort & Priority
High, due to the need for inter-procedural dataflow to connect the request storage to frees and to reason about async handling patterns.

7. Likely False-Positive Sources & Mitigations
- Synchronous-only AEAD implementations: mitigate by requiring absence of wait/callback and presence of immediate free plus mask=0 allocation for higher confidence.
- Frees of unrelated buffers: mitigate by proving req originates from the freed allocation region.
- Custom completion handling outside standard crypto_wait_req: mitigate by whitelisting patterns that clearly block until completion (e.g., equivalent wait constructs or rc-based deferral on -EINPROGRESS).

8. Limitations & Assumptions
- Assumes crypto_wait_req or aead_request_set_callback are the canonical mechanisms; alternative synchronization patterns may be missed.
- Cannot determine runtime algorithm sync properties; relies on static presence/absence of wait/callback as per [PATCH_DESCRIPTION].
- The plan infers that freeing the container buffer invalidates req based on [FILE_CONTENT]; if code uses separate storage, detection may need refinement.