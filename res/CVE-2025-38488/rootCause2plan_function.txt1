1. Plan Summary
Detect kernel AEAD crypto call sites that free the AEAD request or its backing buffer without handling possible asynchronous completion (missing callback/wait), leading to use-after-free.

2. Detection Steps
1) Step 1: Identify AEAD operation sites — locate calls to crypto_aead_encrypt(req) or crypto_aead_decrypt(req) where req is a struct aead_request*.
2) Step 2: Trace the request provenance — find where req is prepared (e.g., via a helper that takes &req as an out-parameter) and whether a backing buffer (e.g., creq) is returned alongside req.
3) Step 3: Check async readiness — before the encrypt/decrypt call, verify whether aead_request_set_callback(req, ...) is invoked on the same req; absence indicates no async completion notification is set.
4) Step 4: Check completion waiting — verify whether the return of crypto_aead_encrypt/decrypt is routed through crypto_wait_req(..., wait) or an equivalent wait sequence; absence indicates no waiting for completion.
5) Step 5: Look for immediate freeing — after the encrypt/decrypt call and before any completion wait, detect freeing of the request or its container, e.g., kvfree_sensitive(backing_buffer, ...) where backing_buffer was produced by the helper that also filled &req.
6) Step 6: Correlate lifetimes — confirm that the freed buffer aliases the AEAD request’s storage (e.g., helper returned creq and populated req; later creq is freed) so the request structure could still be in use by the async driver.
7) Step 7: Examine return-code handling — if the result of encrypt/decrypt is assigned but not passed to crypto_wait_req and there is no check/branch for async (-EINPROGRESS) before freeing, increase confidence of the issue.
8) Step 8: Confirm absence of wait-state plumbing — ensure no DECLARE_CRYPTO_WAIT(...) or similar wait object is present/used to gate the free; absence reinforces that freeing may precede completion.
9) Step 9: Establish ordering — ensure the free occurs in the same function scope and post-dominates the encrypt/decrypt call while no callback/wait post-dominates the call, indicating a potential race window.
10) Step 10: Report when all core conditions hold — (a) AEAD encrypt/decrypt on req, (b) no callback set, (c) no wait used, and (d) freeing of req or its backing buffer before any completion, as a likely use-after-free with async AEAD implementations.
11) Step 11: Suppress when safe pattern is present — do not flag if the code sets aead_request_set_callback on req and wraps encrypt/decrypt with crypto_wait_req using a wait object before any free.
12) Step 12: Add context in findings — include the encrypt/decrypt call, the helper that produced req and its backing buffer, and the free site, to guide remediation toward adding aead_request_set_callback and crypto_wait_req.

3. Limitations & Assumptions
- The plan assumes the freeing function is observable (e.g., kvfree_sensitive) and that the backing buffer-returning helper also exposes req via an out-parameter; other allocation/free patterns may be missed.
- The plan treats absence of aead_request_set_callback and crypto_wait_req as proxies for missing async handling; alternative correct wait mechanisms (not shown in the supplied materials) may cause false positives.
- Precise alias analysis to prove the request resides within the freed buffer may be non-trivial; the checker may approximate by using dataflow from the helper that returns a buffer and populates &req.