1. Plan Summary
Detect missing cpu_latency_qos_remove_request cleanup on probe/init error paths after cpu_latency_qos_add_request, which can leave a dangling pm_qos request linked in the global list and cause use-after-free/list corruption.

2. Detection Steps
1) Step 1: Identify call sites to cpu_latency_qos_add_request and capture the first argument expression (the pm_qos request object, e.g., &isys->pm_qos) and the enclosing function. This defines the “resource acquisition” point and the resource identity to track.

2) Step 2: From immediately after the add call, enumerate all reachable exits of the function (return statements and gotos to cleanup labels that lead to a return). Classify exits as “error returns” if they return a non-zero constant (e.g., -ENOMEM, -EINVAL) or a variable that was set to a non-zero/negative error code along the path.

3) Step 3: For each error-return path, check whether there is a call to cpu_latency_qos_remove_request using the same pm_qos request object identity that post-dominates the add on that path. If no such remove call exists before the error return, mark this path as a potential leak of the pm_qos request.

4) Step 4: Specifically model goto-based unwind: for each goto target label reachable after the add (e.g., out_* labels), ensure the code within or following that label (up to the return) includes a cpu_latency_qos_remove_request for the same request object. If any reachable error label chain lacks the remove before the return, flag it.

5) Step 5: Increase confidence by detecting typical cleanup indicators on the same error path (calls whose names suggest freeing/unmapping/cleanup, such as free_*, *_free_*, *_unmap_*, *_cleanup, or the driver-specific ones present like ipu6_cpd_free_pkg_dir, ipu6_buttress_unmap_fw_image, free_fw_msg_bufs). If such cleanups occur without a matching pm_qos remove, prioritize the finding.

6) Step 6: Exclude the normal success path: do not require a remove on the path that returns success (e.g., return 0) because teardown is expected in the device remove path. Only report if the missing remove is on error-returning paths after the add.

7) Step 7: Handle conditional adds: if the add call is guarded by a condition, restrict analysis to error paths that flow through the true branch (i.e., where the add definitely happened). Do not flag paths that can bypass the add entirely.

8) Step 8: Normalize request-object identity to handle simple aliasing and expression variants (e.g., &isys->pm_qos vs. a local variable holding that address). Treat a remove as matching if it is called with an expression that refers to the same underlying pm_qos_request object as the add.

9) Step 9: Guard against false matches from ordering: ensure the remove call occurs after the add along the path (i.e., not earlier in the function or in a different label unreachable from the add). Do not consider removes that are executed only on success path or only in other functions (e.g., module remove handler) as satisfying the error-path requirement.

10) Step 10: Report each issue with precise context: the location of the add, one representative unmatched error-return path (with the involved cleanup labels), and the absence of a matching remove before return. This guides placement of the missing cpu_latency_qos_remove_request in the appropriate error-unwind label.

3. Limitations & Assumptions
- Determining “error return” values precisely may be approximate; the checker assumes negative constants or variables commonly used for error codes indicate errors.
- The analysis focuses on in-function error unwinding; it does not infer asynchronous cleanup or devm-managed lifetimes that could indirectly remove the request.
- Alias resolution is limited to straightforward cases; complex interprocedural aliasing or macro indirections may evade matching.
- The plan targets cpu_latency_qos_add_request/cpu_latency_qos_remove_request specifically, as evidenced in the materials; it does not generalize to other pm_qos APIs not shown.