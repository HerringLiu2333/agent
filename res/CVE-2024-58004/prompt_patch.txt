1. CVE Identifier
CVE-2024-58004

2. Vulnerability Type
Use-after-free leading to kernel list corruption (dangling pm_qos request)

3. Root Cause Summary
The isys_probe error path in drivers/media/pci/intel/ipu6 failed to deregister a CPU latency PM QoS request before freeing the associated driver structures. This left a plist entry (isys->pm_qos) in the global pm_qos list pointing to freed memory. Subsequent pm_qos operations (e.g., pm_qos_update_target via cpu_latency_qos_update_request) acted on the corrupted list, triggering list_add corruption warnings and potential kernel instability.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Media subsystem, Intel IPU6 input system driver (drivers/media/pci/intel/ipu6), interacting with PM QoS CPU latency infrastructure.

2) Pre-Patch Flaw:
- isys_probe’s error unwind path did not call cpu_latency_qos_remove_request(&isys->pm_qos) before freeing resources, leaving a registered QoS request with its backing memory freed.

3) Trigger Condition:
- Probe failure after a CPU latency QoS request was created/registered, followed by freeing isys-related memory; later, any CPU latency QoS update (cpu_latency_qos_update_request → pm_qos_update_target → plist_add) touches the corrupted list node.

4) Impact Mechanism:
- The stale list node causes invalid prev/next pointers in the pm_qos plist, producing “list_add corruption” warnings (as in list_debug.c) and risking kernel memory corruption or crashes during QoS updates.

5. Patch Analysis
1) Fix Approach:
- Ensure proper cleanup on the error path by explicitly removing the CPU latency QoS request prior to freeing resources, preventing a dangling list node.

2) Key Code Changes:
- In isys_probe(), at the error label out_remove_pkg_dir_shared_buffer, added:
  - cpu_latency_qos_remove_request(&isys->pm_qos);
- This aligns cleanup order so the pm_qos request is deregistered before memory associated with isys is released.

3) Locking/Concurrency Impact:
- No driver-local locking changes. The fix relies on PM QoS infrastructure’s internal synchronization within cpu_latency_qos_remove_request to safely remove the request, correcting the previous ordering bug (deregistration now precedes memory free).

6. Broader Kernel Security Implications
- Error-path resource deregistration is critical; omissions can corrupt shared kernel data structures and propagate instability across subsystems. This case shows that leaving global registrations (like PM QoS requests) active after freeing device memory can lead to cross-subsystem crashes and denial-of-service. The fix highlights the need to audit probe/remove error paths for proper teardown of registered objects (lists, notifiers, QoS requests, work items).