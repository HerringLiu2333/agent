1. CVE Identifier
CVE-2024-58004

2. Vulnerability Type
Use-after-free leading to global list corruption (lifetime/cleanup bug in pm_qos request handling)

3. Root Cause Summary
The driver added a CPU latency QoS request during probe but failed to remove it when the probe errored and unwound. Specifically, isys_probe called cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE) and, on subsequent error paths, freed related resources without calling cpu_latency_qos_remove_request. This left a pm_qos request node pointing to freed memory still linked in the global pm_qos plist, causing list corruption and potential UAF when other subsystems updated their QoS requests.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Media: Intel IPU6 input system driver (drivers/media/pci/intel/ipu6/ipu6-isys.c)
- PM QoS CPU latency request infrastructure (pm_qos/plist)

2) Pre-Patch Flaw:
- In isys_probe, after successfully calling cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE), the error-unwind path did not call cpu_latency_qos_remove_request. The isys->pm_qos request remained in the pm_qos global list while the backing isys memory was freed, leaving a dangling list node.

3) Trigger Condition:
- Any probe failure after the QoS request was added, such as alloc_fw_msg_bufs(isys, 20) returning < 0 and jumping to out_remove_pkg_dir_shared_buffer, caused the driver to free or unmap resources without removing the QoS request. Subsequent pm_qos operations by other drivers (e.g., i915 via cpu_latency_qos_update_request) exercised the corrupted global list, triggering list_add corruption warnings in __list_add_valid_or_report → plist_add → pm_qos_update_target.

4) Impact Mechanism:
- The pm_qos global plist contained a node referencing freed isys->pm_qos memory, so list operations (add/update/traverse) touched invalid pointers. This manifested as “list_add corruption” warnings and could lead to use-after-free, memory corruption, and potential kernel crashes when the QoS list was manipulated by any participant.

5. Patch Analysis
1) Fix Approach:
- Ensure symmetric cleanup by removing the CPU latency QoS request in the probe error path before freeing/unmapping resources. This eliminates the dangling node from the global pm_qos list and prevents UAF/list corruption.

2) Key Code Changes:
- In isys_probe’s error-unwind label out_remove_pkg_dir_shared_buffer, the patch adds:
  cpu_latency_qos_remove_request(&isys->pm_qos);
- Evidence in diff:
  Function: isys_probe
  Hunk: at label out_remove_pkg_dir_shared_buffer
  Prior behavior included freeing firmware package directory without removing QoS request; the new line fixes that omission.

3) Locking/Concurrency Impact:
- No explicit lock changes; pm_qos APIs handle internal synchronization. The change addresses lifetime correctness so concurrent pm_qos users no longer traverse a freed list node. This removes the race window/UAF caused by dangling membership in a shared global list.

6. Broader Kernel Security Implications
Leaving shared-core data structures (like pm_qos global lists) with dangling nodes can destabilize unrelated subsystems, as seen with i915 triggering list corruption. Such lifetime bugs in error paths are widely impactful and can escalate to kernel crashes or exploitable memory corruption. The fix highlights the necessity of symmetrical resource teardown, especially for globally visible objects, to maintain system integrity across drivers.