1. Plan Summary
Detect missing cpu_latency_qos_remove_request calls on error/unwind paths after cpu_latency_qos_add_request is performed during device probing/initialization, which can leave a dangling pm_qos request node and cause global list corruption (based on [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]).

2. Detection Steps
1) Step 1: Objective: identify initialization/probe functions that may add a CPU latency QoS request. Signals: functions referenced as a driver’s .probe (e.g., isys_probe assigned in isys_driver per [FILE_CONTENT]) or other init-like functions; within them, a call to cpu_latency_qos_add_request. FP mitigation: restrict primary focus to .probe functions and calls within the same file/module to reduce scope.

2) Step 2: Objective: collect the specific request object passed to cpu_latency_qos_add_request. Signals: the first argument expression to cpu_latency_qos_add_request (e.g., &isys->pm_qos in isys_probe per [FILE_CONTENT]); track its identity through aliasing to the same struct field/variable. FP mitigation: ensure argument equivalence via direct field/variable identity rather than loose pointer arithmetic or unrelated aliases.

3) Step 3: Objective: enumerate all control-flow paths from the add_request call to any function exit that indicates failure. Signals: returns with non-zero ret, goto to cleanup labels, and labels preceding a final return (e.g., out_remove_pkg_dir_shared_buffer → release_firmware → return ret per [FILE_CONTENT]). FP mitigation: classify exits as “error exits” by checking ret < 0 or non-zero return values along the path.

4) Step 4: Objective: check if cpu_latency_qos_remove_request is called on each error-exit path before the function returns. Signals: presence of a call to cpu_latency_qos_remove_request with the same request object as in Step 2 on the path (added at out_remove_pkg_dir_shared_buffer in [PATCH_DIFF]). FP mitigation: require argument identity match to the same request object, not just any remove_request call.

5) Step 5: Objective: strengthen error-path recognition by looking for cleanup/unmapping/freeing calls indicative of resource teardown after add_request. Signals: calls like ipu6_cpd_free_pkg_dir, ipu6_buttress_unmap_fw_image, release_firmware, free_fw_msg_bufs in isys_probe’s unwind path ([FILE_CONTENT]); returning after these without a remove_request correlates to the root cause. FP mitigation: only flag if at least one such cleanup/free/unmap call occurs on the path, matching the “memory/resource free before remove” pattern from [ROOTCAUSE_ANALYSIS].

6) Step 6: Objective: avoid false alarms on success paths that rely on remove in the module’s remove() callback. Signals: confirm the same module implements cpu_latency_qos_remove_request in its .remove function (isys_remove calls cpu_latency_qos_remove_request per [FILE_CONTENT]). FP mitigation: do not require a remove_request on success-return paths of .probe when a matching .remove exists; only enforce removal on probe failure paths.

7) Step 7: Objective: detect post-add paths that free or invalidate the container of the request object before removal. Signals: evidence of freeing/unmapping operations and final returns, while the request object belongs to a structure allocated in probe (e.g., isys via devm_kzalloc in [FILE_CONTENT]). Why: maps to UAF risk from [ROOTCAUSE_ANALYSIS]. FP mitigation: tie the request object to the lifetime of the containing structure allocated within the same function to ensure relevance.

8) Step 8: Objective: optional corroboration that the request remains active and globally visible, increasing risk if not removed. Signals: subsequent calls to cpu_latency_qos_update_request using the same object in other functions (e.g., isys_runtime_pm_resume/suspend per [FILE_CONTENT]) indicate participation in the global list. FP mitigation: use this as a confidence booster, not a requirement for flagging.

9) Step 9: Objective: report a finding if any path satisfies: add_request occurs, an error-exit or cleanup path is reachable after add, and remove_request with the same object is absent on that path. Signals: path analysis combining Steps 3–5. FP mitigation: exclude paths that neither free/unmap resources nor return error (to avoid benign setups).

10) Step 10: Objective: highlight particularly risky patterns where add_request precedes goto-based unwind chains. Signals: presence of multiple labeled cleanup blocks (e.g., free_fw_msg_bufs, out_remove_pkg_dir_shared_buffer, remove_shared_buffer, release_firmware in [FILE_CONTENT]) and a missing remove_request in earlier labels pre-patch (the line added in [PATCH_DIFF] addresses this). FP mitigation: only flag when a label reachable from add_request leads to return ret without remove_request.

3. Target Elements
- Functions assigned to driver .probe fields (e.g., isys_probe from [FILE_CONTENT]).
- Call sites of cpu_latency_qos_add_request, cpu_latency_qos_remove_request, and cleanup/free/unmap functions (evidence in [FILE_CONTENT]).
- Control-flow constructs: goto labels and associated cleanup blocks, returns with ret values.
- Struct field references to the request object (e.g., isys->pm_qos) and its containing allocation site.

4. Dataflow / Taint Considerations
- Track the specific request object passed to add_request through the function’s CFG to exits.
- Model path-sensitive flows: from add_request to error exits, ensuring remove_request is encountered with the same object on those paths.
- Associate the request object to its containing struct allocated in the same function to reflect lifetime tie-in.

5. Validation & Test Cases
- Positive: Pre-patch isys_probe path where cpu_latency_qos_add_request is called and a subsequent goto out_remove_pkg_dir_shared_buffer returns error without cpu_latency_qos_remove_request; expect a finding (based on [ROOTCAUSE_ANALYSIS] and [FILE_CONTENT]).
- Negative: Post-patch isys_probe where out_remove_pkg_dir_shared_buffer includes cpu_latency_qos_remove_request(&isys->pm_qos) before returning; expect no finding (based on [PATCH_DIFF]).
- Test harness notes: Run the checker on the affected file and a synthetic variant that adds a pm_qos request in a probe-like function with multiple cleanup labels, ensuring one missing removal triggers a finding.

6. Estimated Effort & Priority
High: requires path-sensitive analysis of error-unwind patterns and argument identity matching across cleanup labels in kernel-style code.

7. Likely False-Positive Sources & Mitigations
- Probes that cannot fail after add_request: mitigate by requiring an actual error-return path from CFG.
- Functions where the request object’s lifetime is guaranteed until .remove is called even on failure: mitigate by checking for cleanup/free/unmap on the path and non-zero return.
- Indirect removal in helper functions not recognized: mitigate by allowing recognized remove_request wrappers if present; otherwise, limit to direct calls.

8. Limitations & Assumptions
- Assumes the checker can resolve the .probe assignment to identify probe context (as in isys_driver from [FILE_CONTENT]); other init contexts may be missed.
- Does not fully determine devres-managed lifetimes; uses presence of cleanup/free/unmap calls and non-zero returns as proxies for error teardown (per [ROOTCAUSE_ANALYSIS]).
- Assumes remove_request on success is handled in .remove; the checker focuses on error paths within the same function.