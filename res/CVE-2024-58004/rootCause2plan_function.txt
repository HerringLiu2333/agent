1. Plan Summary
Detect missing deregistration of CPU latency PM QoS requests on probe/error paths: find cpu_latency_qos_add_request calls whose request object can be freed or the function unwinds without a matching cpu_latency_qos_remove_request.

2. Detection Steps
1) Step 1: Objective — locate each call to cpu_latency_qos_add_request and bind the exact request expression (e.g., &isys->pm_qos). Signals — function call to cpu_latency_qos_add_request with a pointer/field address argument; capture the callee, argument expression, and enclosing function. FP mitigation — scope to intra-procedural analysis within the defining function where add occurs.

2) Step 2: Objective — model post-add error paths within the function. Signals — conditional checks of return values after the add, followed by gotos to cleanup labels or direct returns (as seen with ret < 0 -> goto out_remove_pkg_dir_shared_buffer, based on FUNCTION_CONTENT). FP mitigation — only consider paths that are control-dependent on failure checks (ret < 0 or non-zero ret).

3) Step 3: Objective — identify cleanup labels/blocks reachable after the add. Signals — labels referenced by gotos after the add (e.g., free_fw_msg_bufs, out_remove_pkg_dir_shared_buffer, remove_shared_buffer, release_firmware per FUNCTION_CONTENT) and the statements they contain. FP mitigation — exclude labels that are provably unreachable from any path following the add.

4) Step 4: Objective — verify presence of cpu_latency_qos_remove_request on the same request before each error exit. Signals — within each reachable cleanup region and along each error path to a return, search for cpu_latency_qos_remove_request invoked with an argument that aliases the add’s request expression. FP mitigation — require argument equivalence (same field/pointer) using field-sensitive aliasing to avoid counting removes on different requests.

5) Step 5: Objective — detect teardown/deallocation of the owning object after the add and before any remove. Signals — calls indicative of teardown/free/unmap/destroy targeting the same object or its members (e.g., free_fw_msg_bufs(isys), mutex_destroy(&isys->...), ipu6_buttress_unmap_fw_image(adev,...), release_firmware(...) observed in FUNCTION_CONTENT), followed by return of error code. FP mitigation — limit to teardown that operates on the same logical instance whose field was used in the add (e.g., functions receiving isys or destroying its members), and only consider these when paired with a non-success return.

6) Step 6: Objective — flag missing remove when any path from the add reaches a return (non-zero/ret) or teardown without an intervening remove. Signals — existence of a path where cpu_latency_qos_remove_request is absent prior to return or prior to a block that frees/destroys related resources, as in pre-patch behavior described in ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION. FP mitigation — exclude paths that end in the normal success return (ret == 0) and require that the path is error-specific (e.g., ret < 0).

7) Step 7: Objective — account for placement of remove at intermediate labels. Signals — if a remove appears at a specific label (e.g., PATCH_DIFF added cpu_latency_qos_remove_request at out_remove_pkg_dir_shared_buffer), ensure all error gotos after the add eventually pass through a label containing a remove. FP mitigation — compute reachability to confirm the remove-dedicated label post-dominates all error exits reachable after the add.

8) Step 8: Objective — handle multiple potential failure sites after the add. Signals — multiple ret checks and gotos (e.g., alloc_fw_msg_bufs failure -> out_remove_pkg_dir_shared_buffer; isys_register_devices failure -> free_fw_msg_bufs), ensuring each failure route passes through a remove. FP mitigation — require coverage of all branches in the CFG from the add to any error return.

9) Step 9: Objective — avoid false positives when ownership/lifetime is clearly transferred. Signals — absence of any teardown of the object in the current function and presence of documented removal in the caller is not inferable here; conservatively only report when in-function teardown or error return exists (as in FUNCTION_CONTENT). FP mitigation — do not flag if no teardown and the function returns success unconditionally after add.

10) Step 10: Objective — produce actionable diagnostics. Signals — include the add call location, the first error label/return reachable without a matching remove, and the nearest teardown calls along that path (e.g., free_fw_msg_bufs, mutex_destroy) to emphasize potential UAF/list corruption (ROOTCAUSE_ANALYSIS). FP mitigation — aggregate multiple missing-remove paths in the same function into a single report to reduce noise.

3. Target Elements
- Functions containing calls to cpu_latency_qos_add_request.
- Call sites to cpu_latency_qos_add_request and cpu_latency_qos_remove_request.
- Goto labels and their basic blocks used for error unwinding.
- Conditional checks assigning to/using ret and subsequent gotos/returns.
- Resource teardown calls (free_*, unmap_*, release_*, *_destroy) acting on the same object whose field is registered.
- Return statements that return an error code after the add.

4. Dataflow / Taint Considerations
- Track the identity of the QoS request object passed to add (e.g., &isys->pm_qos) and match by field-sensitive equivalence to the argument of remove.
- Track control-flow from the add to all reachable error exits and cleanup labels; verify a remove occurs on each path before return or before teardown of the owning object.
- Track whether teardown calls operate on the same object instance (e.g., functions receiving isys or destroying isys members) to infer lifetime end.

5. Validation & Test Cases
- Positive: A function that calls cpu_latency_qos_add_request(&obj->pm_qos), then upon a failure (ret < 0) jumps to a cleanup label that destroys/frees obj members and returns ret, but does not call cpu_latency_qos_remove_request(&obj->pm_qos) along that path (mirrors pre-patch isys_probe per ROOTCAUSE_ANALYSIS/FUNCTION_CONTENT).
- Negative: A function that calls cpu_latency_qos_add_request(&obj->pm_qos) and ensures every error path post-add flows through a label containing cpu_latency_qos_remove_request(&obj->pm_qos) before other cleanup and return (matches PATCH_DIFF fix).
- Test harness notes: Use simplified kernel-like functions with gotos/labels and structured error unwinding to exercise path coverage across multiple failure sites.

6. Estimated Effort & Priority
High — requires path-sensitive intra-procedural analysis with argument equivalence and heuristic identification of teardown.

7. Likely False-Positive Sources & Mitigations
- Lifetime intentionally extends beyond the function (cleanup deferred elsewhere): mitigate by requiring in-function teardown or error return to flag.
- Remove performed in a callee invoked along the cleanup path: mitigate by initially focusing on direct calls in the same function and optionally whitelisting well-known helper wrappers if evidence shows their use.
- Ambiguous aliasing of the request object: mitigate by matching exact field/address expressions and avoiding broad alias assumptions.

8. Limitations & Assumptions
- Assumes that teardown/destroy/free calls observed after the add indicate end-of-lifetime of the struct holding the request (as described in PATCH_DESCRIPTION and evidenced by FUNCTION_CONTENT cleanup code).
- Does not interprocedurally confirm devm-managed frees or external lifetime transfers; analysis is intra-procedural.
- Focuses specifically on cpu_latency_qos_add_request/remove_request pairing per ROOTCAUSE_ANALYSIS/PATCH_DIFF and may miss analogous patterns for other global registrations not listed here.