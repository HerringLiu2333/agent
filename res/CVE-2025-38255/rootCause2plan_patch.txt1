1. Plan Summary
Detect kernel code paths where kcalloc is called with a potentially zero element count (no dominating non-zero validation), and the returned pointer is later dereferenced or only NULL-checked, risking ZERO_SIZE_PTR dereference.

2. Detection Steps
1) Step 1: Locate zero-sized allocation candidates — find calls to kcalloc and identify the element-count argument (the “num” parameter conceptually associated with how many elements are allocated).
2) Step 2: Trace the count source — record the variable/expression flowing into the kcalloc count argument, giving priority to function parameters and values propagated through assignments and simple arithmetic.
3) Step 3: Check for non-zero validation — examine control-flow dominance before the kcalloc call to see if there is an explicit guard that ensures the count is non-zero (e.g., early return or error path when count == 0), and mark calls lacking such a dominating guard.
4) Step 4: Capture the allocated pointer — identify the lvalue receiving the kcalloc result and track its dataflow through subsequent statements in the same function (and direct inlined/helper calls if possible).
5) Step 5: Identify unsafe uses — detect dereference-style operations on the allocated pointer (e.g., pointer dereference, array indexing, memcpy/memset use, or being passed to functions that are known to operate on memory buffers).
6) Step 6: Bitmap-operation sink recognition — specifically recognize passing the allocated pointer into bitmap operations like __bitmap_or (or analogous bitmap utilities) as a dereference sink.
7) Step 7: Assess guarding conditions — check whether uses of the allocated pointer are guarded only by a NULL-check (e.g., if (ptr) …) without any guarantee that the count was non-zero; consider this insufficient because ZERO_SIZE_PTR is non-NULL.
8) Step 8: Report likely vulnerabilities — flag paths where (a) kcalloc count can be zero due to missing dominating non-zero check, and (b) the returned pointer is subsequently used in a way that implies dereference (including after mere NULL-checks).
9) Step 9: Prioritize by zero-taint provenance — elevate findings where the count originates directly from a function parameter or external input propagated through call chains without zero-checks before kcalloc.
10) Step 10: Reduce noise with post-allocation checks — suppress findings if, after allocation and before any use, there is an explicit check preventing use when the count is zero (e.g., a guard on the same count or an early return on zero).

3. Limitations & Assumptions
- The plan assumes kcalloc(0, …) returns ZERO_SIZE_PTR, as stated; other allocators or wrappers are not covered unless explicitly modeled.
- Proving count is zero is conservative; absence of a dominating non-zero guard is treated as “potentially zero,” which can yield false positives.
- Recognition of “bitmap operations” is limited to functions explicitly observed (e.g., __bitmap_or); other dereference-like sinks are detected generically via pointer use patterns.
- Interprocedural propagation beyond straightforward inlining/wrapper calls may be incomplete without extended dataflow modeling.
- The plan does not infer semantic contracts (e.g., callers always pass non-zero) unless enforced by explicit checks in code.