1. Plan Summary
Detect kernel code paths where kcalloc is invoked with a possibly-zero element count and the returned pointer is later indexed/dereferenced without a dominating check that the count is > 0, risking ZERO_SIZE_PTR dereference.

2. Detection Steps
1) Step 1: Identify allocation sites — calls to kcalloc where the first argument (element count) is a non-constant or a constant that can be zero, and record the variable/expression and the receiving pointer variable.
2) Step 2: Classify the count as “maybe-zero” — mark as maybe-zero if it is a function parameter, a value propagated from external inputs, or any non-constant not dominated by an explicit check enforcing count > 0 on all paths leading to uses.
3) Step 3: Track the allocated pointer — follow dataflow from the kcalloc result through assignments, aliases, and arguments passed to functions, stopping when overwritten or sanitized.
4) Step 4: Find dereference-like uses — flag uses where the pointer is base of array indexing (ptr[index]), unary dereference (*ptr or *(ptr+off)), member access (ptr->field), or address-of of an indexed element (&ptr[index]).
5) Step 5: Connect allocation to use — compute control-flow reachability from the kcalloc site to each dereference-like use and build at least one feasible path where the pointer value from the allocation reaches that use.
6) Step 6: Guard analysis for safety — for each path, check whether it is dominated by an explicit count > 0 check (e.g., if (count == 0) return; or if (count > 0) enclosing the dereference); if not, consider the path unsafe.
7) Step 7: Treat NULL-checks as insufficient — do not consider checks like if (!ptr) safe guards, because ZERO_SIZE_PTR is non-NULL and does not prevent dereference.
8) Step 8: Inter-procedural propagation — when the allocated pointer is passed to a callee, examine the callee for dereference-like uses of the corresponding parameter and reapply Steps 5–7 using the original maybe-zero count fact.
9) Step 9: Recognize safe early returns — suppress findings when there is a function-level early return on count == 0 that dominates both the allocation and all dereference-like uses (matches the patch’s fix pattern).
10) Step 10: Prioritize non-count-bounded uses — elevate cases where dereference occurs outside loops or conditions that bound iterations by count, or within branches that do not imply count > 0 (e.g., conditions like count <= nodes).

3. Limitations & Assumptions
- The analysis assumes that kcalloc with a zero element count returns a non-NULL ZERO_SIZE_PTR, per the provided root-cause analysis; other allocators are not considered.
- Precise proof that a count can be zero may require whole-program invariants not visible to the checker; absence of a dominating count > 0 check is used as a proxy.
- Loop-safety reasoning is conservative: the checker does not fully prove that a dereference inside a loop is unreachable when count == 0; explicit count > 0 guards are required to suppress.
- Macro-induced dereferences may be missed if they do not manifest as array indexing or direct dereference in the analyzed AST.
- Inter-procedural analysis depth is assumed to be bounded; deep call chains or function pointers may lead to false negatives.