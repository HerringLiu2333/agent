1. Plan Summary
Detect kernel patterns where a zero-sized allocation (e.g., kcalloc with a zero “count”) can return a non-NULL sentinel that bypasses NULL-only checks and is then dereferenced or used as an array, as in the pre-patch group_cpus_evenly().

2. Detection Steps
1) Step 1: Objective: Find candidate zero-sized allocations. Signals: Calls to kcalloc(count, elem_size, …) where the count argument is a non-constant or can be zero (based on [ROOTCAUSE_ANALYSIS] and [FUNCTION_CONTENT]). FP mitigation: Exclude calls with a statically provable positive constant count.

2) Step 2: Objective: Check for missing pre-allocation validation that rejects zero count. Signals: Absence of an early branch that returns/aborts when count == 0 before the allocation (as added in [PATCH_DIFF]). FP mitigation: Consider any explicit count > 0 guard (direct or via equivalent conditions) as sufficient to suppress a finding.

3) Step 3: Objective: Identify inadequate post-allocation validation. Signals: The allocation result is tested only for NULL (e.g., if (!ptr) …) and no additional validation of count or special-case handling for zero-sized allocation (mirroring [FUNCTION_CONTENT] “if (!masks) goto …”). FP mitigation: If there is any check that ensures count > 0 prior to first use, do not report.

4) Step 4: Objective: Link the allocation to subsequent pointer uses indicative of dereference. Signals: The allocated pointer is dereferenced, indexed, or used in cpumask/bitmap operations via callees; or passed to a function that operates on array entries (e.g., passed as “masks” to __group_cpus_evenly as in [FUNCTION_CONTENT] and deref indication in [ROOTCAUSE_ANALYSIS]). FP mitigation: Require at least one definite dereference or a pass to a function alongside the related count where subsequent array-like access is likely.

5) Step 5: Objective: Confirm the count can be zero along a feasible path. Signals: The count derives from a function parameter or external input with no dominating check count > 0; uses later compare count in ways that do not enforce positivity (e.g., nr_present >= numgrps in [FUNCTION_CONTENT]). FP mitigation: Demand a control-flow path from allocation to use where no guard enforces count > 0.

6) Step 6: Objective: Verify the allocated pointer value can propagate to the use site without being overwritten. Signals: Dataflow from the kcalloc result to the dereference/pass-through with no reassignment that introduces a different pointer value. FP mitigation: If the pointer is conditionally reassigned to a known-valid buffer before use, suppress the report.

7) Step 7: Objective: Detect function-call patterns that imply dereference in callees. Signals: The allocated pointer is passed to a function together with the same count variable (e.g., __group_cpus_evenly(curgrp, numgrps, …, masks) from [FUNCTION_CONTENT]); and [ROOTCAUSE_ANALYSIS] links the callee to cpumask/bitmap operations. FP mitigation: Only flag when the pair (pointer, count) flows together to the callee without a prior zero-count guard.

8) Step 8: Objective: Ensure reporting focuses on the root cause (missing zero-count guard leading to ZERO_SIZE_PTR misuse). Signals: Presence of Steps 1–5 combined: kcalloc with possibly zero count, no early count==0 guard, NULL-only check, and a subsequent dereference/use. FP mitigation: If the function returns NULL immediately on count==0 (as per [PATCH_DIFF]), do not report.

3. Target Elements
- Function parameters and local variables representing “count” or “num groups.”
- Allocation sites: calls to kcalloc(count, size, flags).
- Post-allocation checks: conditional branches testing the allocated pointer and/or count.
- Pointer use sites: dereferences, indexing, memcpy/bitmap/cpumask operations, and calls like __group_cpus_evenly with the pointer and count.
- Control-flow branches that could guard zero counts (early returns) before allocation or use.
- Return-value paths where the allocated pointer is returned or passed along.

4. Dataflow / Taint Considerations
- Track dataflow from the count parameter/variable into the kcalloc count argument and to any callee alongside the allocated pointer.
- Track dataflow from the allocation result to dereferences, indexing, or passes to functions that are known (in context) to operate on array entries (e.g., __group_cpus_evenly as indicated by [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]).
- Model control-flow to ensure there is no dominating guard that enforces count > 0 between function entry and first pointer use.

5. Validation & Test Cases
- Positive: A function like pre-patch group_cpus_evenly() that calls kcalloc(numgrps, …), only checks “if (!masks)” and then passes masks to __group_cpus_evenly or dereferences it, with no “if (numgrps == 0) return …” guard (from [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]). Expected: flagged.
- Negative: The patched version with “if (numgrps == 0) return NULL;” before allocation (from [PATCH_DIFF]). Expected: not flagged.
- Negative: A function that checks “if (count == 0) { handle-and-return; }” before allocation or use, or that conditionally avoids any dereference when count == 0. Expected: not flagged.
- Test harness notes: Validate both intra-procedural flows and call-pair flow (pointer and count passed together) to ensure reachability without zero-count guards.

6. Estimated Effort & Priority
High priority; medium effort (requires modeling of kernel allocators, path feasibility for zero counts, and pointer-use correlation).

7. Likely False-Positive Sources & Mitigations
- Code intentionally tolerating ZERO_SIZE_PTR by never dereferencing it: mitigate by requiring a definite dereference or array-like use.
- Implicit external preconditions guaranteeing count > 0 not visible to the analyzer: mitigate by requiring absence of any local guard and by demanding a reachable path to use.
- Functions that accept zero-sized allocations and short-circuit internally: mitigate by recognizing early-return patterns before any use in caller or callee when evident.

8. Limitations & Assumptions
- Based on [ROOTCAUSE_ANALYSIS], the checker assumes kcalloc(0, …) can yield a non-NULL sentinel (ZERO_SIZE_PTR); it does not know exact macro values or all allocators with similar behavior beyond kcalloc in this context.
- The plan infers that passing the allocated pointer to __group_cpus_evenly leads to dereference (per [ROOTCAUSE_ANALYSIS]); details of callee bodies are not provided.
- The checker may not model complex inter-module invariants that ensure count > 0 outside the analyzed function.
- Locking/concurrency aspects are out of scope since [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS] indicate a pure input validation fix.