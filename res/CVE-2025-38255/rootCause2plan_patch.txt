1. Plan Summary
Detect kernel code paths where a size/count parameter may be zero, is used as the count in kcalloc (creating a ZERO_SIZE_PTR), and the resulting pointer is subsequently dereferenced without a guarding check, leading to an invalid pointer dereference as in CVE-2025-38255.

2. Detection Steps
1) Step 1: Objective — find candidate allocations that can return ZERO_SIZE_PTR; Signals — calls to kcalloc where the count argument is directly or transitively dataflow-dependent on a function parameter or variable; FP mitigation — exclude calls where the count is a compile-time positive constant or proven > 0 by surrounding guards.
2) Step 2: Objective — assess lack of zero-check on the count before allocation; Signals — along at least one entry-to-call path, absence of a dominating condition that enforces count > 0 (e.g., no if (count == 0) return/skip and no if (count > 0) guard); FP mitigation — require dominance (or postdominated early return) of an explicit zero/positive check to clear a candidate.
3) Step 3: Objective — model that null-checks are insufficient in this context; Signals — presence of checks of the allocated pointer against NULL only; Why — per [ROOTCAUSE_ANALYSIS], ZERO_SIZE_PTR is non-NULL so null checks won’t prevent deref; FP mitigation — do not treat pointer != NULL checks as protection unless combined with count > 0 at the use site.
4) Step 4: Objective — track uses of the allocated pointer that imply dereference; Signals — direct dereference (*p), array indexing (p[i]), structure/field access via pointer, memmove/memcpy/memset-like calls with p as source/dest, or passing p to known bitmap operations (e.g., __bitmap_or) as in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; FP mitigation — restrict to uses reachable from the allocation without an intervening guard that ensures count > 0.
5) Step 5: Objective — ensure the risky use is on a path where count can be zero; Signals — path feasibility analysis showing a path from function entry with count == 0 to the dereferencing use; FP mitigation — require the use not be postdominated by a check enforcing count > 0.
6) Step 6: Objective — detect missing early-return pattern added by the patch; Signals — in functions structurally similar to group_cpus_evenly, absence of an early return on count==0 before any allocations or uses (as added in [PATCH_DIFF]); FP mitigation — if an equivalent early return or skip block exists, do not report.
7) Step 7: Objective — strengthen confidence when the allocation result is treated as valid memory; Signals — pointer is stored to a variable with a “masks/array/buffer” naming pattern and subsequently iterated or combined (e.g., bitmap operations, loops), as seen with bitmap ops in [PATCH_DESCRIPTION]; FP mitigation — this is advisory; do not rely solely on naming to trigger an alert.
8) Step 8: Objective — consolidate a report; Signals — existence of (1) potential zero count to kcalloc, (2) no dominating count>0 guard, and (3) a reachable dereference-like use; FP mitigation — suppress if there is a comprehensive guard either before allocation or around all uses that ensures count > 0.

3. Target Elements
- Function definitions with size/count parameters used to dimension allocations.
- Call sites to kcalloc (array allocations) where count may be zero.
- Conditional checks comparing the count to zero or greater-than-zero.
- Allocation result variables and their subsequent use sites (dereferences and function arguments).
- Calls to bitmap operations (e.g., __bitmap_or) and similar routines that likely dereference provided buffers, as implicated in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].

4. Dataflow / Taint Considerations
- Track dataflow from function parameters/variables to the kcalloc count argument to determine dependence and potential zero value.
- Track control-flow predicates that constrain the count (e.g., count == 0, count > 0) and their dominance relative to allocations and uses.
- Track dataflow from the allocation result variable to dereference-like uses and calls that imply dereference (including __bitmap_or paths noted in [ROOTCAUSE_ANALYSIS]).
- Treat NULL checks on the allocation result as non-mitigating unless paired with a count > 0 guard at the relevant use.

5. Validation & Test Cases
- Positive: A function foo(unsigned n) calls p = kcalloc(n, ...); later calls __bitmap_or(p, ...); there is no if (n == 0) return/skip and no if (n > 0) guard around allocation/use — expect a finding (mirrors [ROOTCAUSE_ANALYSIS]).
- Positive: A function alloc(unsigned cnt) does p = kcalloc(cnt, ...); if (!p) return ERR; memcpy(p, src, ...); without any cnt > 0 guard — expect a finding.
- Negative: The patched pattern: if (numgrps == 0) return NULL; followed by allocations/uses — expect no finding (matches [PATCH_DIFF]).
- Negative: Allocation guarded: if (n > 0) { p = kcalloc(n, ...); use p; } else return/skip — expect no finding.
- Test harness notes: Use small kernel-like stubs with kcalloc, bitmap-like calls, and guards to validate dominance/path-sensitivity and dereference recognition.

6. Estimated Effort & Priority
High — kernel DoS per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS], requiring interprocedural dataflow and control-dominance analysis but within typical CodeQL capabilities.

7. Likely False-Positive Sources & Mitigations
- Cases where zero-sized allocations are intentionally used as sentinels and never dereferenced; mitigate by requiring a concrete dereference-like use reachable on the zero path.
- Complex indirect guards on count (e.g., validated in a different function); mitigate via interprocedural guard tracking when feasible and allowing suppressions where postconditions are established.
- Functions where the allocation pointer is reassigned to a safe value before use; mitigate by tracking last-def to use.
- Calls to non-dereferencing functions with pointer parameters; mitigate by preferring clear dereference patterns (derefs, indexing, mem* ops, and known bitmap ops).

8. Limitations & Assumptions
- Assumes kcalloc with a zero count returns a non-NULL ZERO_SIZE_PTR as stated in [ROOTCAUSE_ANALYSIS]; other allocators are not modeled unless explicitly kcalloc-like.
- Does not enumerate all dereferencing callees beyond generic patterns and the bitmap operations cited in [PATCH_DESCRIPTION]; some dereferences via opaque calls may be missed.
- Cannot reliably infer runtime constraints from external configuration (e.g., configfs) beyond code-level guards.
- Precise modeling of ZERO_SIZE_PTR propagation across module boundaries may be limited without full kernel-specific libraries.