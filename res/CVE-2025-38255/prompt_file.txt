1. CVE Identifier
CVE-2025-38255

2. Vulnerability Type
NULL/ZERO_SIZE_PTR pointer dereference leading to kernel crash (DoS)

3. Root Cause Summary
group_cpus_evenly() did not validate that numgrps > 0 before allocating and indexing the cpumask array. When numgrps was 0, kcalloc(numgrps, ...) returned ZERO_SIZE_PTR, which was later dereferenced via cpumask operations (e.g., cpumask_or(&masks[curgrp], ...)) in __group_cpus_evenly(), causing a kernel Oops.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
lib/group_cpus (CPU grouping helper used by subsystems like block multiqueue)

2) Pre-Patch Flaw:
- Missing input validation for numgrps in group_cpus_evenly() allowed zero groups.
- The function proceeded to allocate masks = kcalloc(numgrps, ...) which returns ZERO_SIZE_PTR for zero-sized allocations, not NULL.
- Subsequent calls to __group_cpus_evenly() performed cpumask operations on &masks[curgrp], dereferencing ZERO_SIZE_PTR.

3) Trigger Condition:
- Passing numgrps == 0 to group_cpus_evenly(). Per the patch description, this occurred when echo 0 > poll_queues in null_blk via blk_mq_map_queues -> group_cpus_evenly.

4) Impact Mechanism:
- With numgrps==0, __group_cpus_evenly() enters the numgrps <= nodes path and executes cpumask_or(&masks[curgrp], ...), dereferencing ZERO_SIZE_PTR (address 0x10) and triggering a NULL pointer dereference in __bitmap_or, leading to a kernel Oops and denial of service.

5. Patch Analysis
1) Fix Approach:
Early parameter validation: immediately return NULL from group_cpus_evenly() when numgrps == 0, preventing zero-sized allocation and any subsequent dereference of an invalid masks pointer.

2) Key Code Changes:
- Added at the start of group_cpus_evenly():
  if (numgrps == 0)
      return NULL;
- This directly addresses the unsafe kcalloc(numgrps, ...) and downstream accesses such as cpumask_or(&masks[curgrp], ...).

3) Locking/Concurrency Impact:
- None. The change only adds an early return based on an input parameter. No locking, ordering, or RCU changes.

6. Broader Kernel Security Implications
- Kernel helpers that allocate arrays based on caller-provided sizes must reject zero-sized allocations unless all downstream code is guaranteed to handle ZERO_SIZE_PTR safely. This fix hardens the API boundary of group_cpus_evenly() and prevents denial-of-service via invalid configuration inputs.
- Similar size checks may be warranted in other call sites and helper functions that index into arrays allocated with potentially zero elements, especially when used across subsystems (e.g., block layer queue mapping).