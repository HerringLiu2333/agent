1. CVE Identifier
CVE-2025-38255

2. Vulnerability Type
NULL/invalid pointer dereference due to zero-sized allocation (ZERO_SIZE_PTR misuse)

3. Root Cause Summary
group_cpus_evenly() failed to validate that numgrps was non-zero before allocating the masks array, allowing kcalloc(0, ...) to return ZERO_SIZE_PTR, which is non-NULL and thus not caught by the existing NULL check. The function then passed this invalid pointer to __group_cpus_evenly(), which performed cpumask operations (e.g., __bitmap_or) that dereferenced the pointer, causing a kernel oops. The flawed pre-patch logic was the absence of a guard for numgrps == 0 and reliance on a “!masks” check that does not detect ZERO_SIZE_PTR.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
lib/group_cpus (CPU mask grouping utility used by block layer mapping)

2) Pre-Patch Flaw:
- masks = kcalloc(numgrps, sizeof(*masks), GFP_KERNEL) with numgrps == 0 returns ZERO_SIZE_PTR.
- The subsequent check “if (!masks) goto fail_node_to_cpumask;” does not catch ZERO_SIZE_PTR, and the code proceeds to use masks.
- __group_cpus_evenly() expects a valid masks array and performs cpumask operations that dereference masks entries.

3) Trigger Condition:
Writing 0 to poll_queues via configfs in null_blk (echo 0 > poll_queues) propagates numgrps == 0 into group_cpus_evenly(), leading to a call chain through blk_mq_map_queues and ultimately __group_cpus_evenly with an invalid masks pointer.

4) Impact Mechanism:
ZERO_SIZE_PTR is dereferenced during bitmap/cpumask operations (observed at __bitmap_or+0x48), resulting in a kernel NULL pointer dereference (address 0x10) and system crash (DoS).

5. Patch Analysis
1) Fix Approach:
Introduce explicit input validation: early return if numgrps == 0 to avoid zero-sized allocation and subsequent invalid pointer use.

2) Key Code Changes:
- Added at function entry:
  “if (numgrps == 0) return NULL;”
This prevents kcalloc(numgrps, ...) from being called with numgrps == 0 and avoids passing ZERO_SIZE_PTR to __group_cpus_evenly().

3) Locking/Concurrency Impact:
No changes to locking or concurrency. Existing logic around cpu_present_mask copying (data_race) remains unchanged; the fix is purely an input validation and memory safety correction.

6. Broader Kernel Security Implications
- Prevents a user-triggerable kernel crash via configuration paths that can set group count to zero, reducing denial-of-service risk in block-mq users and other callers of group_cpus_evenly().
- Highlights the importance of validating size/count parameters before allocations to avoid ZERO_SIZE_PTR hazards.
- Encourages consistent input validation across helper utilities in lib/ to harden against similar invalid-pointer dereference issues.