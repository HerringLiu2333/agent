1. CVE Identifier
CVE-2025-38255

2. Vulnerability Type
NULL/invalid pointer dereference caused by zero-size allocation (ZERO_SIZE_PTR misuse), leading to kernel denial of service.

3. Root Cause Summary
group_cpus_evenly() did not validate its numgrps argument and proceeded when numgrps == 0. This led to kcalloc() being invoked with a zero count, returning ZERO_SIZE_PTR rather than NULL. The function then treated this non-NULL sentinel as a valid pointer and later dereferenced it (e.g., via bitmap operations), causing a kernel Oops.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
lib/ group_cpus (cpumask grouping utilities), indirectly used by the block layer (blk-mq) and drivers like null_blk.

2) Pre-Patch Flaw:
- In group_cpus_evenly(unsigned int numgrps), there was no early check for numgrps == 0.
- The code path allocated arrays based on numgrps; with zero, kcalloc() returned ZERO_SIZE_PTR, which was subsequently dereferenced.

3) Trigger Condition:
- Passing numgrps == 0 to group_cpus_evenly(), e.g., via null_blk when writing “0” to poll_queues in configfs, which propagates to blk_mq_update_nr_hw_queues() -> blk_mq_map_queues() -> group_cpus_evenly().

4) Impact Mechanism:
- ZERO_SIZE_PTR (0x10) from kcalloc(…, 0, …) is treated as a valid pointer.
- Subsequent operations like __bitmap_or within __group_cpus_evenly() dereference this pointer, causing a NULL/invalid pointer dereference and kernel panic (DoS).

5. Patch Analysis
1) Fix Approach:
Introduce an early return in group_cpus_evenly() to reject numgrps == 0, avoiding zero-sized allocations and subsequent invalid pointer dereferences.

2) Key Code Changes:
- In group_cpus_evenly():
  - Added:
    - if (numgrps == 0)
    -     return NULL;
- This check precedes allocations such as zalloc_cpumask_var(&nmsk, GFP_KERNEL), preventing the ZERO_SIZE_PTR condition entirely.

3) Locking/Concurrency Impact:
None. The change is a simple argument validation and early return; no locking, ordering, or concurrency semantics were modified.

6. Broader Kernel Security Implications
- Prevents a straightforward denial-of-service path where user-configurable parameters (e.g., via configfs) can induce a kernel panic.
- Ensures safer handling of zero-dimensional configurations across subsystems relying on CPU mask grouping.
- Highlights the need for explicit zero-argument validation in utility functions that allocate arrays based on caller-provided sizes to avoid ZERO_SIZE_PTR misuse.