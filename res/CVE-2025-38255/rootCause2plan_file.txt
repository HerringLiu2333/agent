1. Plan Summary
Detect kernel patterns where an array is allocated with a potentially zero count (e.g., kcalloc(numgrps, ...)), the allocation result is assumed non-null-safe, and later indexed/dereferenced (directly or in a callee) without a dominating guard that ensures the count is > 0, leading to ZERO_SIZE_PTR dereference.

2. Detection Steps
1) Step 1: Objective: Find zero-sized array allocation candidates. Signals: Calls to kcalloc(countExpr, elemSize, ...) where countExpr is a variable/parameter (e.g., numgrps) not syntactically a constant > 0; record the allocated pointer and its count expression. FP mitigation: Exclude cases where countExpr is syntactically a constant >= 1.

2) Step 2: Objective: Bind the allocated pointer to its intended bound. Signals: Associate the allocation result variable (e.g., masks) with countExpr from Step 1 and propagate through simple assignments and argument passing. FP mitigation: Stop propagation on overwrites/reassignments or if the pointer escapes in ways that cannot be analyzed (e.g., stored in global without uses in current scope).

3) Step 3: Objective: Identify dereference/indexing uses of the allocated array. Signals: Uses like ptr[index], &ptr[index], *(ptr + index), or passing &ptr[index] to functions; also passing ptr to functions where it is indexed. FP mitigation: Exclude uses guarded by loops with bounds index < countExpr that imply zero iterations when countExpr == 0.

4) Step 4: Objective: Check whether dereference is control-dominated by a guard ensuring countExpr > 0 (or > index). Signals: Dominating conditions such as if (countExpr == 0) return/skip; if (countExpr > 0) { deref ... }; or equivalent comparisons ensuring countExpr >= index+1. FP mitigation: Respect dominance and short-circuit control flow; treat early returns on count==0 as adequate guards (as per the fix in [PATCH_DIFF]).

5) Step 5: Objective: Detect reliance on null-pointer checks that are insufficient for ZERO_SIZE_PTR. Signals: After allocation, presence of if (!ptr) checks without any guard on countExpr prior to deref/use; note that kcalloc(0, ...) returns a non-NULL ZERO_SIZE_PTR per [ROOTCAUSE_ANALYSIS]. FP mitigation: Only flag when a deref exists on some path that is not dominated by countExpr > 0 (Step 4).

6) Step 6: Objective: Interprocedural pair analysis for array-size API pairs. Signals: At call sites, identify functions receiving both the array pointer and a size/count argument (e.g., __group_cpus_evenly(startgrp, numgrps, ..., masks) per [FILE_CONTENT]); correlate that the size arg equals the allocation countExpr. FP mitigation: Require a strong SSA/dataflow match (same variable or directly derived) and analyze callee bodies only when available.

7) Step 7: Objective: In callees, detect unguarded indexing of the passed pointer. Signals: In the callee, indexing/addressing of the array parameter (e.g., &masks[curgrp]) without a dominating check that the associated size parameter > 0 or > index; consider paths where alternative conditions (e.g., numgrps <= nodes) still permit deref as shown in [ROOTCAUSE_ANALYSIS]. FP mitigation: Do not flag if all derefs are within loops/blocks guarded by size > 0 or by index ranges proven < size.

8) Step 8: Objective: Identify index expressions that can be zero, making ZERO_SIZE_PTR deref immediate. Signals: Index variables initialized to 0 or possibly 0 on entry (e.g., curgrp = startgrp; startgrp=0 in caller per [FILE_CONTENT]); absence of guards incrementing before first deref. FP mitigation: If index is proven >= 1 before first use (dominant increment/guard), de-prioritize or suppress.

9) Step 9: Objective: Flag patterns where size-derived variables are recomputed but do not prevent first deref. Signals: Computations like last_grp = numgrps and wrapping logic that do not impose a pre-deref size>0 check (as in __group_cpus_evenly’s numgrps <= nodes path leading to cpumask_or(&masks[curgrp], ...) per [FILE_CONTENT]). FP mitigation: Only consider this when an actual deref exists prior to any size>0 guard.

10) Step 10: Objective: Produce findings when all risk conditions align. Signals: A path from kcalloc(countExpr, ...) where countExpr may be zero, through a non-null-safe check (or none), to an array deref (local or in callee) without a dominating count>0 guard. FP mitigation: Suppress if there is an explicit early return on count==0 in the allocator function (as added in [PATCH_DIFF]).

3. Target Elements
- Allocation sites: calls to kcalloc(count, size, ...); the result variable and count expression.
- Control flow and condition checks: comparisons involving the count variable.
- Array dereference sites: subscript expressions, address-of element expressions, and equivalent pointer arithmetic.
- Function signatures/call sites where an array pointer and a size parameter are paired.
- Interprocedural usage in callees that index the passed array pointer.

4. Dataflow / Taint Considerations
- Track dataflow from the count expression into the allocation site and into any size parameter passed to callees.
- Track the allocation result pointer through assignments and arguments into dereference sites.
- Relate pointer parameters and size parameters interprocedurally when they originate from the same allocation/count (as in group_cpus_evenly -> __group_cpus_evenly per [FILE_CONTENT]).
- Treat unconstrained function parameters (like numgrps) as possibly zero unless guarded.

5. Validation & Test Cases
- Positive: Pre-patch group_cpus_evenly in [FILE_CONTENT]: masks = kcalloc(numgrps, ...); subsequent &masks[curgrp] in __group_cpus_evenly without a dominating numgrps > 0 guard; only !masks null-check present; expect a finding (as described in [ROOTCAUSE_ANALYSIS]).
- Negative: Patched version in [PATCH_DIFF]: early if (numgrps == 0) return NULL; expect no finding.
- Negative: A function that allocates ptr = kcalloc(n, ...); immediately checks if (n == 0) return; later uses ptr[i] within for (i = 0; i < n; i++); expect no finding.
- Test harness notes: Run analysis with interprocedural tracking enabled to resolve the call from group_cpus_evenly to __group_cpus_evenly and correlate masks with numgrps.

6. Estimated Effort & Priority
Medium effort; interprocedural array-size pairing and dominance analysis are required but well-scoped. Priority is high for kernel code due to ZERO_SIZE_PTR semantics and DoS risk (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Cases where count is computed to be > 0 by invariants not trivially visible: mitigate by honoring explicit guards and loop bounds.
- Callees that appear to index but are only executed under size > 0 conditions in callers: mitigate via interprocedural dominance where possible; otherwise downgrade severity if uncertain.
- Allocations followed by pointer escape to unknown code: mitigate by requiring an observed deref within the analysis scope.

8. Limitations & Assumptions
- Assumes kernel semantics where kcalloc(0, ...) returns a non-NULL ZERO_SIZE_PTR (per [ROOTCAUSE_ANALYSIS]); the checker may over-report in environments without this behavior.
- May not fully prove non-zero counts when they depend on complex numeric reasoning or external constraints not evident in code.
- Interprocedural pairing assumes the size argument in the callee corresponds to the allocation’s count (as in __group_cpus_evenly’s numgrps and masks per [FILE_CONTENT]); mismatched APIs may be missed.