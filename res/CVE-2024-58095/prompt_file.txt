1. CVE Identifier
CVE-2024-58095

2. Vulnerability Type
Improper state validation leading to illegal write attempts (read-only filesystem write enforcement failure), causing potential denial of service (errors/crash).

3. Root Cause Summary
In fs/jfs/jfs_extent.c, the functions extAlloc() and extRecord() unconditionally invoked txBeginAnon(ip->i_sb) without verifying that the filesystem was not mounted read-only. This missing read-only check allowed initiation of journaling/transactional modifications on a read-only JFS superblock, which could lead to errors or crashes when upper layers inadvertently reached these paths during write operations.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem extent allocation/recording (fs/jfs/jfs_extent.c), specifically extAlloc() and extRecord().

2) Pre-Patch Flaw:
Both extAlloc() and extRecord() called txBeginAnon(ip->i_sb) at function entry with no guard for read-only mounts. Evidence:
- extAlloc(): “/* This blocks if we are low on resources */ txBeginAnon(ip->i_sb);”
- extRecord(): “txBeginAnon(ip->i_sb);”
No isReadOnly() or equivalent check was present before initiating a transaction.

3) Trigger Condition:
Invoking JFS write paths that reach extent allocation/recording while the filesystem is mounted read-only, e.g., from jfs_get_block during block_write_begin:
Call trace (from patch description): txBeginAnon -> extAlloc -> jfs_get_block -> block_write_begin -> jfs_write_begin.

4) Impact Mechanism:
Starting a journal transaction (txBeginAnon) on a read-only superblock attempts to prepare/perform modifications that are forbidden, leading to internal errors or kernel crashes in the journaling/extent code path. This can manifest as denial of service when writes are issued to a read-only mounted JFS.

5. Patch Analysis
1) Fix Approach:
Introduce a precondition check to enforce read-only semantics by rejecting modification attempts before any transaction is started. The functions now early-return with -EIO and log an error when isReadOnly(ip) is true.

2) Key Code Changes:
- In extAlloc():
  Added:
  “if (isReadOnly(ip)) { jfs_error(ip->i_sb, "read-only filesystem\n"); return -EIO; }”
  placed before the existing txBeginAnon(ip->i_sb) call.
- In extRecord():
  Added the same isReadOnly(ip) check and early return before txBeginAnon(ip->i_sb).
These changes gate all subsequent operations (txBeginAnon, commit_mutex locking, extent updates) on a non-read-only condition.

3) Locking/Concurrency Impact:
- The new early-return prevents acquisition of JFS_IP(ip)->commit_mutex and avoids entering txBeginAnon, which can block when resources are low. No new locks were introduced and existing lock ordering remains unchanged; the patch simply prevents incorrect transactional/locking paths from executing under read-only mounts.

6. Broader Kernel Security Implications
Enforcing read-only semantics at the extent allocation and recording boundaries reduces the risk of illegal state transitions in the filesystem and prevents crashes originating from journaling code invoked on read-only mounts. This hardening mitigates denial-of-service vectors where user actions or misconfigurations route write attempts into JFS despite read-only mounts, improving overall filesystem robustness and consistency with VFS expectations.