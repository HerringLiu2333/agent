1. CVE Identifier
CVE-2024-58095

2. Vulnerability Type
Missing state validation / improper enforcement of read-only mount semantics leading to denial of service (kernel crash)

3. Root Cause Summary
The JFS extent routines extAlloc and extRecord unconditionally initiated a transaction via txBeginAnon without verifying that the filesystem was mounted writable. On a read-only mount, attempting to begin a transaction and perform extent allocation/update violates mount flags and can drive journaling/extent code into error paths, resulting in kernel errors or crashes. The patch adds a read-only check (isReadOnly(ip)) and early return to prevent entering txBeginAnon and subsequent modification logic when the superblock is read-only.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem extent management and journaling transaction initiation (fs/jfs/jfs_extent.c: extAlloc, extRecord)

2) Pre-Patch Flaw:
Both extAlloc and extRecord called txBeginAnon(ip->i_sb) at function entry with no guard against read-only mounts. Example (pre-patch): "txBeginAnon(ip->i_sb);" appears at the start of extAlloc and extRecord, enabling write-related operations regardless of mount state.

3) Trigger Condition:
Any write path that reaches JFS extent allocation or recording on a read-only mounted JFS filesystem. The provided call trace shows extAlloc invoked via jfs_get_block and jfs_write_begin during a write to a file on a read-only mount.

4) Impact Mechanism:
Starting an anonymous transaction and attempting extent allocation/update on a read-only superblock can cause internal journaling/metadata operations to access or modify structures that are not writable, leading to errors or kernel crashes. This manifests as a denial of service when user-space triggers write operations on a read-only JFS mount.

5. Patch Analysis
1) Fix Approach:
Defensive gating: add an explicit read-only check before any transaction initiation or extent mutation in extAlloc and extRecord, returning an error to prevent modification attempts on read-only mounts.

2) Key Code Changes:
- In extAlloc: inserted "if (isReadOnly(ip)) { jfs_error(ip->i_sb, 'read-only filesystem'); return -EIO; }" prior to txBeginAnon.
- In extRecord: inserted the same read-only check and early return before txBeginAnon.
These changes ensure txBeginAnon and subsequent extent/journal operations are not executed when ip->i_sb is read-only.

3) Locking/Concurrency Impact:
No changes to locking primitives or ordering; the commit_mutex is no longer acquired in read-only scenarios due to the early return, which reduces unnecessary lock operations. The primary effect is preventing transaction start and lock acquisition on an invalid (read-only) state, thereby avoiding potential error paths and crashes.

6. Broader Kernel Security Implications
Enforcing read-only mount semantics at low-level filesystem mutation points is critical to prevent privilege escalation via unintended metadata changes and to avoid denial of service from journal/metadata inconsistencies. This patch strengthens JFSâ€™s adherence to VFS mount flags and reduces the attack surface where user-space write attempts on read-only filesystems could destabilize the kernel. Similar checks should be audited across other JFS mutation paths to ensure comprehensive protection against RO violations.