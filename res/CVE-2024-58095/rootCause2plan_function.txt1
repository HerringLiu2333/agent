1. Plan Summary
Detect JFS functions that initiate a transaction (txBeginAnon) using a superblock from an inode without a preceding, dominating read-only check that prevents reaching the transaction on read-only mounts.

2. Detection Steps
1) Step 1: Identify candidate call sites — locate calls to txBeginAnon where the argument is a superblock derived from a struct inode (e.g., an expression like <inode_var>->i_sb or data-flow equivalent from a struct inode parameter).
2) Step 2: Scope to relevant code — restrict analysis to JFS code paths (e.g., fs/jfs/jfs_extent.c or functions that also call JFS extent/journal helpers), to match the affected subsystem.
3) Step 3: Confirm potential mutation intent — in the same function as the txBeginAnon call, look for signals of metadata/data modification such as calls to xtInsert, xtExtend, xtUpdate, dquot_alloc_block, dbFree, mark_inode_dirty, or locking JFS_IP(ip)->commit_mutex.
4) Step 4: Bind the inode used — identify the specific struct inode variable whose superblock flows to the txBeginAnon argument; prefer function parameters like ip used consistently with i_sb and JFS_IP(ip).
5) Step 5: Search for read-only guard — check for a conditional that tests isReadOnly on that same inode (isReadOnly(<bound_inode>)) occurring before the txBeginAnon call along all paths.
6) Step 6: Verify effective gating — ensure the read-only check’s true branch enforces an early exit that prevents reaching txBeginAnon (e.g., immediate return of an error like -EIO or a control-flow branch that guarantees the call is unreachable under the read-only condition).
7) Step 7: Dominance analysis — require that the effective read-only guard dominates the txBeginAnon call; i.e., there is no feasible path from function entry to txBeginAnon that lacks the guard or bypasses its early exit.
8) Step 8: Report missing guard — if no such dominating, effective isReadOnly(<bound_inode>) check exists, flag the txBeginAnon call as a potential violation of read-only mount semantics.
9) Step 9: Reduce noise with conjunction — only report when Steps 3 and 7 are both satisfied (transaction initiation plus mutation signals without a dominating read-only guard), mirroring the extAlloc/extRecord pre-patch flaw.

3. Limitations & Assumptions
- Assumes read-only validation is performed via isReadOnly(inode); alternative mechanisms or checks on superblock flags are not considered due to lack of evidence.
- Intra-procedural focus: checks performed in callers are not accounted for and may yield false positives if a higher-level guard exists.
- File scoping to JFS is inferred from provided paths; if the same pattern appears elsewhere with different APIs, this plan will not detect it.
- The exact set of “mutation” functions is limited to those mentioned (xtInsert, xtExtend, xtUpdate, dquot_alloc_block, dbFree, mark_inode_dirty, commit_mutex locking) and may miss other write-side indicators not provided.