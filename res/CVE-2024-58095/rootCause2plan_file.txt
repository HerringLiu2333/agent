1. Plan Summary
Detect calls that start JFS transactions (txBeginAnon) using an inode’s superblock without a preceding read-only check (isReadOnly(ip)) that gates all paths, in functions that perform extent allocation/recording work.

2. Detection Steps
1) Step 1: Objective — locate transaction-start sites; Signals — calls to txBeginAnon; Why — based on ROOTCAUSE_ANALYSIS and FILE_CONTENT, txBeginAnon was invoked unconditionally; FP mitigation — restrict initial scope to fs/jfs files or functions including jfs_* headers (from FILE_CONTENT includes).
2) Step 2: Objective — associate txBeginAnon’s argument with an inode; Signals — find txBeginAnon argument expression dataflow-equivalent to some ip->i_sb in the same function; Why — ROOTCAUSE_ANALYSIS shows the vulnerable calls used ip->i_sb; FP mitigation — require a canonical inode-typed variable (struct inode*) in scope supplies the superblock argument via field access.
3) Step 3: Objective — ensure the function is performing extent/recording style modifications; Signals — presence of calls such as xtInsert, xtExtend, xtUpdate, dbAlloc, dquot_alloc_block, mark_inode_dirty, or locking JFS_IP(ip)->commit_mutex as in FILE_CONTENT; Why — PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS pinpoint extAlloc/extRecord and these operations; FP mitigation — require at least one such “write-like” signal in the same function.
4) Step 4: Objective — check for a read-only guard before transaction start; Signals — a conditional using isReadOnly(ip) whose true branch exits the function (e.g., return error) before reaching txBeginAnon, optionally logging via jfs_error as in PATCH_DIFF; Why — PATCH_DIFF added “if (isReadOnly(ip)) { jfs_error(...); return -EIO; }” before txBeginAnon; FP mitigation — ensure the guard uses the same inode variable linked in Step 2.
5) Step 5: Objective — enforce dominance of the guard; Signals — control-flow analysis showing that on all paths to the txBeginAnon call, an isReadOnly(ip) check either is false or, if true, prevents reaching txBeginAnon via an early return; Why — ROOTCAUSE_ANALYSIS requires the guard to prevent illegal transaction start; FP mitigation — only flag when there exists at least one feasible path to txBeginAnon that is not gated by such an early-return check.
6) Step 6: Objective — flag missing or misplaced guards; Signals — absent isReadOnly(ip) check, or the check appears after txBeginAnon in control-flow order; Why — FILE_CONTENT shows txBeginAnon at function entry and ROOTCAUSE_ANALYSIS states the flaw is “unconditionally invoked”; FP mitigation — ignore unrelated checks that do not use isReadOnly(ip) on the same inode variable.
7) Step 7: Objective — catch partial guarding; Signals — presence of an isReadOnly(ip) check that does not dominate all incoming paths to the txBeginAnon call (e.g., inside a branch not covering all flows); Why — PATCH_DIFF ensures check is unconditional; FP mitigation — require proven lack of dominance before reporting.
8) Step 8: Objective — strengthen confidence via “modification intent”; Signals — after txBeginAnon, look for mark_inode_dirty or xtInsert/xtUpdate patterns as in FILE_CONTENT, or commit_mutex lock; Why — these confirm the path is intended to modify filesystem state; FP mitigation — require at least one such post-transaction “write-like” signal to raise severity.
9) Step 9: Objective — avoid deferring to caller-guards (defense-in-depth); Signals — even if caller functions appear to check read-only, still flag callee if it lacks its own guard; Why — PATCH_DESCRIPTION/ROOTCAUSE_ANALYSIS justify adding the check inside extAlloc/extRecord; FP mitigation — document as design choice; optionally lower severity if annotated evidence of consistent caller-side guard exists (not required here).
10) Step 10: Objective — prioritize known vulnerable patterns; Signals — functions named extAlloc or extRecord in fs/jfs/jfs_extent.c; Why — PATCH_DIFF and ROOTCAUSE_ANALYSIS identify these; FP mitigation — classify these as high-confidence matches when unguarded.
11) Step 11: Objective — de-duplicate reports; Signals — aggregate multiple txBeginAnon call sites within the same function into a single finding; Why — reduces noise when a function has several transaction starts; FP mitigation — one report per function unless guard presence differs per call.
12) Step 12: Objective — suggest remediation; Signals — absence of early-return on read-only; Why — PATCH_DIFF shows correct pattern (isReadOnly + jfs_error + -EIO return) before txBeginAnon; FP mitigation — include remediation hint only when confidence is high per Steps 2–8.

3. Target Elements
- Function definitions in fs/jfs, especially fs/jfs/jfs_extent.c.
- Call sites to txBeginAnon.
- Member accesses linking inode to superblock (ip->i_sb).
- Conditional checks using isReadOnly(ip) and associated early returns.
- Calls indicating modification intent: xtInsert, xtExtend, xtUpdate, dbAlloc, dquot_alloc_block, mark_inode_dirty.
- Locking of JFS_IP(ip)->commit_mutex.
- Calls to jfs_error.

4. Dataflow / Taint Considerations
- Track dataflow from a struct inode* variable ip to the super_block* passed to txBeginAnon via ip->i_sb.
- Track control dependence: is txBeginAnon post-dominated by an early-return taken when isReadOnly(ip) is true?
- Path feasibility: identify any path to txBeginAnon not gated by a read-only guard with early return.
- Post-call confirmation: observe subsequent “write-like” calls to validate modification context.

5. Validation & Test Cases
- Positive: A function like extAlloc(struct inode *ip, ...) that calls txBeginAnon(ip->i_sb) early, then locks commit_mutex and calls xtInsert/mark_inode_dirty, with no preceding isReadOnly(ip) early-return (matches FILE_CONTENT pre-patch).
- Positive: A function like extRecord(struct inode *ip, ...) that calls txBeginAnon(ip->i_sb) with no prior isReadOnly(ip) guard (matches FILE_CONTENT pre-patch).
- Negative: Same functions with an if (isReadOnly(ip)) { jfs_error(...); return -EIO; } placed before txBeginAnon (matches PATCH_DIFF).
- Negative: A function where txBeginAnon is not passed ip->i_sb (no inode linkage), or where a dominating isReadOnly(ip) early-return exists on all paths.
- Test harness notes: Run on the pre-patch jfs_extent.c to ensure two findings (extAlloc, extRecord); run on the patched version to ensure zero findings.

6. Estimated Effort & Priority
Medium — requires intra-procedural dataflow and control-dominance analysis, plus API/field matching; high priority for filesystem robustness given ROOTCAUSE_ANALYSIS impact.

7. Likely False-Positive Sources & Mitigations
- Caller-enforced read-only checks not visible intra-procedurally; mitigation: document intentional callee-side enforcement requirement and optionally downgrade severity if clear caller guards are proven (out of scope here).
- Non-modifying transaction uses (if any) where txBeginAnon is safe on read-only; mitigation: require “write-like” signals (xt*/dbAlloc/mark_inode_dirty/commit_mutex) to classify as vulnerable.
- Superblock obtained from a different inode or alias; mitigation: require direct ip->i_sb linkage in the same function.

8. Limitations & Assumptions
- Assumes isReadOnly(ip) is the authoritative read-only predicate for JFS (from PATCH_DIFF/ROOTCAUSE_ANALYSIS); other FS-specific checks are not considered.
- Assumes txBeginAnon implies intent to modify in this context (based on PATCH_DESCRIPTION and FILE_CONTENT); if txBeginAnon can be used for read-only flows elsewhere, the checker’s “write-like” confirmation mitigates but may not eliminate all FPs.
- Interprocedural caller guards are not modeled; the plan intentionally favors local (callee) enforcement as per the fix.
- The plan is tailored to JFS code paths evidenced here (extAlloc, extRecord) and may not detect analogous patterns in other subsystems without adapting API names.