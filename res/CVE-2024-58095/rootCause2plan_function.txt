1. Plan Summary
Detect functions that initiate JFS transactions for an inode’s superblock and perform extent/metadata updates without first validating that the filesystem is not mounted read-only.

2. Detection Steps
1) Step 1: Identify candidate functions that call txBeginAnon using an inode’s superblock — signals: a function with a struct inode* parameter (e.g., ip) and a call that passes ip->i_sb to txBeginAnon — FP mitigation: restrict to files/paths consistent with JFS extent code (e.g., fs/jfs/jfs_extent.c) as evidenced by [PATCH_DIFF] and [FUNCTION_CONTENT].
2) Step 2: Confirm the function is a mutation path — signals: presence (after txBeginAnon) of operations like xtInsert/xtUpdate/xtExtend, dquot_alloc_block, dbFree, mark_inode_dirty, or locking JFS_IP(ip)->commit_mutex (seen in [FUNCTION_CONTENT]) — FP mitigation: require at least one such post-transaction mutation signal to avoid flagging read-only-safe or no-op paths.
3) Step 3: For each txBeginAnon call, check for a prior read-only guard — signals: an if-condition calling isReadOnly(ip) that leads to an early return/error path before reaching txBeginAnon (as added in [PATCH_DIFF]) — FP mitigation: ensure the guard dominates the txBeginAnon call in control flow, not just present elsewhere.
4) Step 4: Validate the guard’s effect is to prevent modification attempts — signals: the guarded branch includes an error report (e.g., jfs_error) and returns an error code, as in [PATCH_DIFF] — FP mitigation: consider the guard acceptable if it unconditionally prevents reaching txBeginAnon on the read-only condition, regardless of exact error code.
5) Step 5: Match the inode used in guard and transaction — signals: the same inode variable (ip) flows to both isReadOnly(ip) and txBeginAnon(ip->i_sb) (from [FUNCTION_CONTENT]) — FP mitigation: use basic dataflow/alias reasoning to ensure the isReadOnly check protects the exact superblock passed to txBeginAnon.
6) Step 6: Ensure the guard precedes other mutation gates — signals: the isReadOnly(ip) check occurs before locking JFS_IP(ip)->commit_mutex or other mutation calls, mirroring [PATCH_DIFF] and [FUNCTION_CONTENT] — FP mitigation: if the guard occurs only after txBeginAnon or after significant mutations, still flag as vulnerable.
7) Step 7: Flag missing or ineffective guards — signals: any path where txBeginAnon(ip->i_sb) is reachable without a preceding isReadOnly(ip)-based early return — FP mitigation: ignore paths where earlier conditions provably return unconditionally on read-only; otherwise, prefer conservative flagging per [ROOTCAUSE_ANALYSIS] to capture the pre-patch flaw.
8) Step 8: Aggregate and report at the function level — signals: functions like extAlloc and extRecord as exemplars (from [FUNCTION_CONTENT] and [PATCH_DIFF]) — FP mitigation: include evidence summary (presence of txBeginAnon, mutations, absence of guard) to assist triage.

3. Target Elements
- Functions with a struct inode* parameter used to access ip->i_sb.
- Call sites of txBeginAnon that pass ip->i_sb.
- Condition checks invoking isReadOnly(ip) and their control-flow impact (early return).
- Post-transaction mutation calls: xtInsert, xtUpdate, xtExtend, dquot_alloc_block, dbFree, mark_inode_dirty.
- Lock boundaries: mutex_lock(&JFS_IP(ip)->commit_mutex) relative to guards and txBeginAnon.

4. Dataflow / Taint Considerations
- Track the inode parameter (ip) to confirm that ip->i_sb flows into txBeginAnon.
- Ensure the same ip is used in isReadOnly(ip) and in txBeginAnon(ip->i_sb), accounting for simple aliases and field dereferences.
- Control-flow dominance: the isReadOnly(ip)-triggered early return must dominate all paths reaching the txBeginAnon call to be considered safe.

5. Validation & Test Cases
- Positive: Pre-patch extAlloc and extRecord (from [FUNCTION_CONTENT]) — both call txBeginAnon(ip->i_sb) without a preceding isReadOnly(ip) early return; expect findings.
- Negative: Patched extAlloc and extRecord (from [PATCH_DIFF]) — both have isReadOnly(ip) checks with error return before txBeginAnon; expect no findings.
- Test harness notes: Run on fs/jfs/jfs_extent.c and verify the checker reports exactly the two pre-patch sites and is silent on the patched versions.

6. Estimated Effort & Priority
High. The pattern requires control-flow dominance and simple dataflow over kernel-style code, but the signals are strong and the impact per [ROOTCAUSE_ANALYSIS] is a kernel crash/DoS.

7. Likely False-Positive Sources & Mitigations
- Functions that call txBeginAnon but do not perform mutations: mitigate by requiring mutation signals post-transaction.
- Guards implemented via different helper names: mitigate by focusing on isReadOnly(ip) as per [PATCH_DIFF]; document as a limitation.
- External invariants enforced by callers: cannot reliably infer; mitigate by privileging intra-function guards and reporting with evidence for human review.

8. Limitations & Assumptions
- Assumes isReadOnly(ip) is the canonical guard for read-only state in this context (per [PATCH_DIFF]); other guard mechanisms are not identified in the provided materials.
- Scope is inferred from JFS extent code (fs/jfs/jfs_extent.c); applicability to other filesystems or other JFS paths is not determinable from inputs.
- The checker does not verify that txBeginAnon itself handles read-only safely; it relies on [ROOTCAUSE_ANALYSIS] stating it does not, pre-patch.
- Exact error reporting behavior (jfs_error, -EIO) is not required for safety; only early return dominance is enforced.