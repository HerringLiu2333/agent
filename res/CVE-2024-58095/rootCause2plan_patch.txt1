1. Plan Summary
Detect JFS call sites that initiate a journaling transaction (txBeginAnon) using a superblock derived from an inode without a dominating read-only check (isReadOnly on that inode) that prevents the call on read-only mounts.

2. Detection Steps
1) Step 1: Scope to the JFS filesystem code to reduce noise — consider only C functions located under the fs/jfs/ directory and focus on calls to txBeginAnon.
2) Step 2: For each txBeginAnon call, resolve its argument to a superblock expression and check whether it is ip->i_sb or dataflow-equivalent to an inode’s i_sb field obtained from a variable (e.g., function parameter or local) representing a struct inode.
3) Step 3: Identify the inode variable associated with the superblock argument (the ip from which ip->i_sb is accessed), tracking simple aliases and assignments within the enclosing function.
4) Step 4: Within the same function, locate any conditions that call isReadOnly with that inode variable (same dataflow identity) and determine the control-flow effect of the check (e.g., if (isReadOnly(ip)) …).
5) Step 5: Determine whether a positive isReadOnly(ip) check leads to a function exit or an unconditional bypass of the txBeginAnon call (e.g., return or goto to an exit path) — conceptually, the “read-only” branch should prevent reaching txBeginAnon.
6) Step 6: Alternatively, accept a negative guard pattern where the txBeginAnon call is control-dependent on !isReadOnly(ip) (i.e., the call is inside a branch that executes only when the filesystem is not read-only).
7) Step 7: Perform dominance analysis: verify that at least one of the valid guard patterns (Steps 5–6) dominates all paths to the txBeginAnon call; if any path reaches the call without the guard, treat it as unprotected.
8) Step 8: Exclude superficial checks: if isReadOnly(ip) is only logged or inspected without causing an early exit or without enclosing the txBeginAnon call under a negated condition, treat the call as unguarded.
9) Step 9: Flag as vulnerable any txBeginAnon call using a superblock derived from an inode where no dominating guard (Steps 5–7) is found, i.e., the call can execute even when isReadOnly(ip) is true.
10) Step 10: In the alert message (out of band of the checker logic), reference the missing read-only enforcement before transaction initiation and suggest adding an early exit on isReadOnly(ip) before txBeginAnon, as done in extAlloc and extRecord.

3. Limitations & Assumptions
- Assumes txBeginAnon is the relevant transaction initiation function; other transaction starters are not considered due to lack of evidence.
- Assumes the canonical read-only check is isReadOnly(ip); other possible checks (e.g., using different APIs or checking superblock flags) are not modeled.
- Restricting to fs/jfs/ reduces false positives but may miss similar issues elsewhere.
- The checker cannot infer external preconditions (e.g., callers guaranteeing read-write mounts), so some findings may be false positives.
- The plan does not require specific error handling (e.g., jfs_error logging or -EIO); it only requires prevention of the txBeginAnon call on read-only paths.