1. Plan Summary
Detect JFS functions that initiate a transaction (txBeginAnon) using an inode’s superblock without a prior, dominating read-only check that aborts the path, which can permit illegal modifications on read-only filesystems.

2. Detection Steps
1) Step 1: Identify candidate call sites — look for calls to txBeginAnon within fs/jfs code, especially in fs/jfs/jfs_extent.c.
2) Step 2: Bind the superblock source — for each txBeginAnon call, resolve its argument to an expression of the form <inode_expr>->i_sb and track the corresponding inode expression (<inode_expr>).
3) Step 3: Establish inode availability — confirm that the inode expression is a function parameter or a local that is dataflow-equivalent to a function parameter representing an inode (e.g., ip).
4) Step 4: Define modification intent context (optional confidence boost) — check whether the function body also performs modification-related operations (e.g., locking JFS_IP(ip)->commit_mutex, xtInsert/xtExtend/xtUpdate, dquot_alloc_block, mark_inode_dirty) after starting the transaction.
5) Step 5: Search for read-only guard — before the txBeginAnon call (in control flow), look for a condition that calls isReadOnly on the same inode expression (or an alias) and whose true branch prevents reaching txBeginAnon (e.g., returns an error).
6) Step 6: Verify path coverage — ensure that the read-only guard dominates the txBeginAnon call site (i.e., on all paths to txBeginAnon, the guard has executed and the true branch exits early).
7) Step 7: Accept typical remediation pattern — if the guard includes logging via jfs_error and returns a negative errno (e.g., -EIO), treat it as a valid enforcement; absence of logging should not be required but can reduce confidence.
8) Step 8: Flag violations — report any txBeginAnon call where no dominating isReadOnly(inode) early-exit guard exists.
9) Step 9: Handle multiple call sites — if a function contains multiple txBeginAnon calls, require that each is dominated by a read-only guard; otherwise, flag the uncovered call sites.
10) Step 10: Reduce false positives (optional filter) — prioritize findings where modification intent (Step 4 signals) is present; still flag pure txBeginAnon starts lacking a guard, but mark them lower confidence.

3. Limitations & Assumptions
- Assumes read-only state is checked via isReadOnly on the same inode used for txBeginAnon; alternative helper APIs or superblock-level checks are not covered due to lack of evidence.
- Assumes that passing ip->i_sb (or equivalent) to txBeginAnon denotes initiating a write-capable transaction; if txBeginAnon could be safe on read-only in other contexts, this is not discernible here.
- Does not prove that callers enforce read-only elsewhere; analysis is intra-procedural by design to match the patch’s local fix.
- The optional modification-intent signals (xtInsert/xtExtend/xtUpdate, commit_mutex, quota ops, mark_inode_dirty) are heuristic and derived from provided file content; similar operations elsewhere may differ.