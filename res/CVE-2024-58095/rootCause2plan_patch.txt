1. Plan Summary
Detect calls to txBeginAnon that are not preceded by a read-only mount check on the same inode/superblock, which could initiate a transaction on a read-only filesystem.

2. Detection Steps
1) Step 1: Objective — Identify transactional entry points. Signals — All call sites of txBeginAnon within JFS code paths (as implicated by the call trace in ROOTCAUSE_ANALYSIS). FP mitigation — Restrict initial scope to fs/jfs/* and functions handling inode or extent operations per PATCH_DIFF and ROOTCAUSE_ANALYSIS.

2) Step 2: Objective — Bind the transaction to an inode context. Signals — For each txBeginAnon call, resolve its superblock argument and determine if it is derived from a struct inode (e.g., ip->i_sb) passed into the enclosing function. FP mitigation — Only consider call sites where the superblock is dataflow-related to a function parameter of type inode*, matching extAlloc/extRecord patterns in PATCH_DIFF.

3) Step 3: Objective — Detect required read-only guard presence. Signals — In the enclosing function, search for a conditional using isReadOnly on the same inode that dominates the txBeginAnon call and prevents execution (e.g., early return) when read-only (as added in PATCH_DIFF). FP mitigation — Require that the check’s true branch exits the function or otherwise guarantees txBeginAnon is not reached, minimizing matches to non-blocking logging-only checks.

4) Step 4: Objective — Flag missing guards. Signals — If no dominating isReadOnly(ip)-style check exists before txBeginAnon on the same inode/superblock, mark the call as a potential violation (pre-patch flaw described in ROOTCAUSE_ANALYSIS). FP mitigation — Confirm the absence of any earlier guard in the same function using control-flow dominance rather than simple syntactic adjacency.

5) Step 5: Objective — Corroborate that the context is a modifying path. Signals — Look for additional modification indicators in the same function: extent operations (extAlloc/extRecord naming per PATCH_DIFF) or locking of JFS_IP(ip)->commit_mutex (seen in PATCH_DIFF). FP mitigation — Only report when at least one such indicator co-occurs, aligning with the journaling/extent write paths in ROOTCAUSE_ANALYSIS.

6) Step 6: Objective — Use callchain evidence to strengthen findings. Signals — Attempt to find call paths from known write entry points (e.g., jfs_write_begin and jfs_get_block as in ROOTCAUSE_ANALYSIS call trace) to the function containing the txBeginAnon call. FP mitigation — If all observed callers enforce a read-only check before reaching the callee, suppress the alert; otherwise, keep the finding.

7) Step 7: Objective — Account for guards in helper wrappers. Signals — If txBeginAnon is only invoked via a wrapper within the same function body, ensure the guard analysis also checks paths leading into that wrapper call. FP mitigation — Require that any wrapper-internal check targets the same inode/superblock; otherwise, treat as unguarded.

8) Step 8: Objective — Recognize equivalent early returns co-located with logging. Signals — Treat patterns that log an error (e.g., jfs_error with the same superblock) and then return (as in PATCH_DIFF) as valid guards. FP mitigation — Ignore logging-only without a return, as it wouldn’t prevent txBeginAnon execution.

9) Step 9: Objective — Avoid double-counting. Signals — If multiple txBeginAnon calls exist in the same function on the same inode/sb, merge them into one finding unless different control paths demonstrate different guard coverage. FP mitigation — Report path-specific gaps only when some paths to a call lack a guard while others are guarded.

10) Step 10: Objective — Reduce noise from non-inode-based transactions. Signals — Skip txBeginAnon invocations where the superblock argument is not dataflow-related to any inode* in scope (the root cause centers on inode->sb read-only state, per ROOTCAUSE_ANALYSIS and PATCH_DIFF). FP mitigation — This avoids flagging system-wide or already prevalidated contexts not shown in the supplied materials.

11) Step 11: Objective — Prioritize ext* extent code. Signals — Assign higher severity to unguarded txBeginAnon calls in fs/jfs/jfs_extent.c and functions named extAlloc/extRecord (explicitly affected in PATCH_DIFF). FP mitigation — This aligns weighting with the concrete vulnerable sites given.

12) Step 12: Objective — Ensure final path feasibility. Signals — Confirm there exists at least one executable path from function entry to txBeginAnon that does not encounter a read-only early exit. FP mitigation — Use control-flow feasibility to suppress dead-code or always-guarded paths.

3. Target Elements
- Function call sites: txBeginAnon(...)
- Function parameters and fields: struct inode* parameters, access to ip->i_sb
- Condition checks: isReadOnly(ip) guarding logic with early return
- Error/reporting calls: jfs_error(ip->i_sb, ...)
- Lock boundaries: mutex_lock(&JFS_IP(ip)->commit_mutex) as a write-context hint
- File/module scope: fs/jfs/jfs_extent.c and related JFS sources

4. Dataflow / Taint Considerations
- Track dataflow from a struct inode* parameter to its superblock field used as the txBeginAnon argument.
- Track control dependencies to determine if an isReadOnly(ip) check dominates and blocks the path to txBeginAnon.
- Optionally traverse limited-depth call chains from jfs_write_begin/jfs_get_block to the target function to corroborate write-path relevance.

5. Validation & Test Cases
- Positive: Pre-patch extAlloc/extRecord in fs/jfs/jfs_extent.c that call txBeginAnon(ip->i_sb) without any dominating isReadOnly(ip) early return should be flagged (as described in ROOTCAUSE_ANALYSIS and shown in PATCH_DIFF before the added guard).
- Negative: Post-patch extAlloc/extRecord with the added isReadOnly(ip) check returning -EIO before txBeginAnon should not be flagged (matches PATCH_DIFF).
- Negative: A function calling txBeginAnon where the superblock is not derived from an inode parameter should not be flagged (outside the evidenced pattern).
- Test harness notes: Run on the pre- and post-patch versions; compare that only pre-patch sites are reported, with path feasibility confirming an unguarded path to txBeginAnon.

6. Estimated Effort & Priority
High: Requires dominance analysis, intra-procedural dataflow from inode to superblock argument, and optional bounded interprocedural call-path checks.

7. Likely False-Positive Sources & Mitigations
- Read-only enforcement performed exclusively in callers not analyzed: mitigate with optional call-graph traversal from known write entry points (ROOTCAUSE_ANALYSIS call trace).
- Alternative guard mechanisms not using isReadOnly(ip): mitigate by focusing on evidenced guard (PATCH_DIFF) and allowing suppression via manual triage.
- Logging without early return mistaken as a guard: require that the read-only branch prevents reaching txBeginAnon.

8. Limitations & Assumptions
- Assumes isReadOnly(ip) is the canonical read-only predicate for JFS as per PATCH_DIFF; other guard APIs/macros are not considered due to lack of evidence.
- Assumes txBeginAnon must not be invoked on a read-only superblock, per ROOTCAUSE_ANALYSIS; the checker does not verify mount semantics beyond this.
- Interprocedural validation is limited to known call traces (e.g., via jfs_write_begin) mentioned in ROOTCAUSE_ANALYSIS; broader caller enforcement cannot be fully determined from the provided materials.