1. Plan Summary
Detect kernel error paths that test IS_ERR on a pointer returned from a call, invoke extent_io_tree_panic(), but do not exit and then use the same pointer, risking ERR_PTR dereference.

2. Detection Steps
1) Step 1: Identify pointer variables assigned from function calls that are immediately checked with IS_ERR(var). Signals: an assignment “var = call(…)” followed by a conditional “if (IS_ERR(var))” and optionally “ret = PTR_ERR(var)”.

2) Step 2: Within the IS_ERR(var) branch, detect a call to extent_io_tree_panic(…) (the btrfs panic helper). Signal: any invocation of extent_io_tree_panic with the error code (e.g., ret) and contextual strings like "insert".

3) Step 3: Determine whether the IS_ERR branch lacks an explicit control-flow exit right after the panic call. Signals: absence of return, goto to a cleanup/out label, or loop-breaking statements before the branch ends.

4) Step 4: Compute that normal execution can fall through from the end of the IS_ERR branch to later statements in the same function. Signal: reachability from the end of the error branch to subsequent statements without mandatory control-transfer.

5) Step 5: On the fallthrough path, find subsequent uses of the same pointer variable. Signals: passing var as an argument (e.g., cache_state(var, …)) or dereferencing operations (member access, pointer arithmetic).

6) Step 6: Confirm there is no intervening guard that revalidates var or excludes ERR_PTR before the use. Signals: absence of another IS_ERR/IS_ERR_OR_NULL check on var and no equivalently safe predicate guarding the use.

7) Step 7: Ensure var is not reassigned to a different (safe) value between the IS_ERR branch and the subsequent use. Signal: dataflow showing the first post-branch use of var still refers to the value flagged as ERR_PTR.

8) Step 8: Optionally mark cache_state(var, …) as a likely dereference sink per the patch context to prioritize findings. Signal: specific callee names “cache_state” receiving var.

9) Step 9: Emit a result when all conditions hold: IS_ERR(var) → extent_io_tree_panic() → no exit → reachable use of var. Include locations for the panic call and first unsafe use to demonstrate the fallthrough hazard.

3. Limitations & Assumptions
- Assumes IS_ERR/PTR_ERR idioms imply ERR_PTR semantics; code using different idioms may be missed.
- Assumes extent_io_tree_panic does not guarantee termination under all builds; the checker cannot infer CONFIG_BUG at analysis time.
- Determining whether a callee dereferences its argument (e.g., cache_state) may require models; without them, the checker flags use-as-pointer as potentially unsafe.
- Scope is centered on the btrfs pattern shown; other subsystems with different panic helpers or naming may not be detected unless similarly modeled.