1. Plan Summary
Detect missing early exit/guard after detecting an ERR_PTR via IS_ERR(), where control flow falls through and later dereferences or uses the error pointer (e.g., passing it to cache_state), as seen pre-patch in btrfs_convert_extent_bit.

2. Detection Steps
1) Step 1: Objective: Identify error-pointer checks. Signals: An if-condition testing IS_ERR(var) (based on ROOTCAUSE_ANALYSIS “missing early exit/guard after detecting IS_ERR”); also record if var was assigned from a call immediately before. FP mitigation: Require that var is pointer-typed or later used in pointer-like contexts.

2) Step 2: Objective: Recognize the “panic but continue” error path. Signals: In the true branch of IS_ERR(var), find a call to extent_io_tree_panic(...) (from PATCH_DIFF and ROOTCAUSE_ANALYSIS) and optionally observe ret = PTR_ERR(var) nearby as corroboration. FP mitigation: Anchor primarily on extent_io_tree_panic to align with evidence; treat ret = PTR_ERR(var) as a supporting (non-required) clue.

3) Step 3: Objective: Determine if the error path lacks an explicit exit. Signals: The IS_ERR-true branch does not end in an unconditional return/goto/break/continue and there’s no unconditional transfer to an out/cleanup label (per PATCH_DIFF “goto out” fix). FP mitigation: Exclude cases where the branch contains return/goto or a call known to be explicitly noreturn (if available in the project’s metadata).

4) Step 4: Objective: Confirm fallthrough use of the potentially ERR_PTR variable. Signals: After the if(IS_ERR(var)) block, find subsequent reachable statements that use var, without an intervening dominating reassignment to var. FP mitigation: Require that no assignment to var appears on all paths between the if and the use.

5) Step 5: Objective: Classify unsafe uses likely to dereference. Signals: Uses including pointer dereference operators (->, *var), array indexing via var, or passing var to a function where the corresponding parameter is a pointer expected to be valid (e.g., cache_state(var, ...) per PATCH_DIFF/ROOTCAUSE_ANALYSIS). FP mitigation: Prefer uses where the callee is known to operate on a valid object (e.g., cache_state) or where dereference syntax is explicit.

6) Step 6: Objective: Ensure the use is not guarded by a non-error condition. Signals: The subsequent use is not syntactically within an else-block of the same IS_ERR(var), nor dominated by a check ensuring !IS_ERR(var). FP mitigation: Use control-flow dominance: exclude uses that are exclusively under a guard that ensures var is not an ERR_PTR.

7) Step 7: Objective: Track “error-taint” along the true path. Signals: Treat var as error-tainted on the IS_ERR-true path and stop taint on reassignment or an explicit early exit; report if a tainted use (from Step 5) is reachable. FP mitigation: Reset taint if var is revalidated (e.g., a subsequent if (!IS_ERR(var)) with enforced else return/goto).

8) Step 8: Objective: Prioritize strong matches. Signals: Elevate cases that match the exact pattern from PATCH_DIFF: call result checked by IS_ERR, extent_io_tree_panic invoked, and immediate post-if call to cache_state(var, ...). FP mitigation: For weaker patterns (no cache_state), require an explicit dereference to reduce noise.

3. Target Elements
- Function bodies in kernel-style C where ERR_PTR/IS_ERR patterns appear.
- If-conditions using IS_ERR(x) and the associated true-branch statements.
- Calls to extent_io_tree_panic(...) (from PATCH_DIFF).
- Variable assignments from function calls followed by IS_ERR checks.
- Subsequent uses of the checked variable: pointer dereferences and function call arguments (e.g., cache_state).
- Control-flow exits: return, goto (especially to cleanup/out labels), break, continue.

4. Dataflow / Taint Considerations
- Treat a variable as “error-tainted” on the path where IS_ERR(var) is true.
- Propagate error-taint until reassignment of var or an explicit early exit from the current function/scope.
- Flag uses where an error-tainted var is dereferenced or passed to a callee that expects a valid pointer.
- Do not propagate across an else-branch that guarantees !IS_ERR(var).

5. Validation & Test Cases
- Positive: 
  - Pattern from ROOTCAUSE_ANALYSIS/PATCH_DIFF:
    inserted_state = insert_state(...);
    if (IS_ERR(inserted_state)) { ret = PTR_ERR(inserted_state); extent_io_tree_panic(...); }
    cache_state(inserted_state, cached_state); // should be flagged.
  - Variant: same as above but with an explicit dereference inserted_state->foo after the if; should be flagged.
- Negative:
  - Same setup but with goto out; immediately after extent_io_tree_panic and no use before out; should not be flagged (PATCH_DIFF fix).
  - Same setup but use occurs only within an else { cache_state(inserted_state, ...) }; should not be flagged.
  - Same setup but inserted_state is reassigned to a known-good pointer before use; should not be flagged.
- Test harness notes: Use minimal C files emulating kernel helpers (stubs for IS_ERR, PTR_ERR, extent_io_tree_panic, cache_state) to drive control/dataflow; include cases with and without else and with various exits.

6. Estimated Effort & Priority
Medium: Requires path-sensitive control-flow and simple taint of error states, plus function call/argument use classification.

7. Likely False-Positive Sources & Mitigations
- Panic-like calls that are truly noreturn in all builds: may still be flagged; mitigation: optionally recognize noreturn attributes but retain a setting to still flag due to CONFIG_BUG scenarios (ROOTCAUSE_ANALYSIS).
- Passing var to functions that do not dereference it: mitigate by prioritizing known dereferencing functions (e.g., cache_state) or explicit dereference syntax.
- Complex macros obscuring IS_ERR or exits: mitigate by relying on the canonical IS_ERR usage and explicit return/goto detection.

8. Limitations & Assumptions
- Only extent_io_tree_panic and cache_state are confirmed by supplied materials; generalization to other “panic” or dereferencing functions is not evidenced here.
- The checker assumes IS_ERR semantics imply ERR_PTR and that dereferencing or passing to cache_state requires a valid pointer (per ROOTCAUSE_ANALYSIS).
- Build-time config like CONFIG_BUG cannot be inferred; the checker flags potential issues irrespective of noreturn assumptions, consistent with the described root cause.