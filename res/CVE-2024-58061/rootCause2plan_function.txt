1. Plan Summary
Insufficient evidence provided to define the specific vulnerability; this plan outlines a generic, patch-driven CodeQL detection scaffold to be parameterized once [PATCH_DIFF], [PATCH_DESCRIPTION], and [ROOTCAUSE_ANALYSIS] are available.

2. Detection Steps
1) Step 1: Objective — derive the precise vulnerability signature from the patch; conceptual signals — identify code constructs introduced or modified in [PATCH_DIFF] (e.g., new validation, bounds checks, error handling, locking, or sanitizer invocations); FP mitigation — restrict subsequent search to patterns that mirror the exact patch-introduced logic and location types.
2) Step 2: Objective — detect pre-patch code paths missing the newly added safeguards; conceptual signals — find uses of the same variables/resources/functions as in [PATCH_DIFF] without the added checks/guards; FP mitigation — require structurally similar context (same API, same call sequences, same resource lifecycle) as in the patched sites.
3) Step 3: Objective — model dataflow to risky operations implicated by the patch; conceptual signals — track flows from inputs/allocations to sinks changed in [PATCH_DIFF] (e.g., dereferences, arithmetic, copy, syscall, free/close) that now have guards; FP mitigation — only flag flows that bypass equivalent gating conditions introduced by the patch.
4) Step 4: Objective — identify missing return-value or error checks if the patch adds them; conceptual signals — calls to the same APIs where [PATCH_DIFF] shows added return-value inspection or error handling; FP mitigation — require that the function’s return status influences control flow in the patch, and flag only analogous call sites lacking that influence.
5) Step 5: Objective — detect insufficient bounds or type validation if the patch adds it; conceptual signals — array/string/memory operations or casts that, post-patch, are guarded by length/type checks; FP mitigation — demand a one-to-one mapping of operands/indices and guard predicates matching those added by the patch.
6) Step 6: Objective — detect missing synchronization if the patch introduces locks or atomic operations; conceptual signals — accesses to the same shared state or critical section code that the patch encloses in locking; FP mitigation — constrain to the same shared variables or functions highlighted in [PATCH_DIFF].
7) Step 7: Objective — identify missing permission/authentication checks if the patch adds them; conceptual signals — privileged actions or sensitive configuration accesses newly gated by an auth/permission predicate; FP mitigation — flag only the same action patterns and contexts where the patch added authorization checks.
8) Step 8: Objective — detect lifetime/cleanup issues if the patch adds resource management; conceptual signals — allocations/opens where patch adds corresponding free/close/finalize on all paths; FP mitigation — only flag paths through the same resources that lack cleanup symmetry shown in [PATCH_DIFF].
9) Step 9: Objective — confirm path feasibility to reduce noise; conceptual signals — ensure flagged flows reach the sink without intervening guards equivalent to the patch and with feasible control paths; FP mitigation — apply control- and data-dependence checks mirroring the patch’s gating logic.
10) Step 10: Objective — scope to affected modules/functions; conceptual signals — limit search to files/functions implicated in [PATCH_DIFF]/[PATCH_DESCRIPTION]; FP mitigation — avoid scanning unrelated areas to reduce spurious matches.
11) Step 11: Objective — rank findings by similarity to patched instances; conceptual signals — measure structural similarity (same API, operand roles, control patterns) between flagged sites and patched sites; FP mitigation — report only high-similarity matches.
12) Step 12: Objective — validate against [FUNCTION_CONTENT] if available; conceptual signals — confirm that the pre-patch function exhibits the same missing guard or misuse addressed by the patch; FP mitigation — suppress if the function already contains an equivalent safeguard.

3. Target Elements
- Functions and methods touched or referenced by [PATCH_DIFF]/[PATCH_DESCRIPTION].
- Call sites to APIs whose handling changed in the patch (e.g., added return-value checks or guards).
- Resource allocation/deallocation sites if lifecycle management was added.
- Condition checks and lock boundaries introduced by the patch.
- Function return-value uses and error-handling blocks added in the patch.

4. Dataflow / Taint Considerations
- Track flows from sources implicated by the patch (e.g., user input, external data, allocations) to sinks altered in [PATCH_DIFF] (e.g., memory operations, privileged actions).
- Require absence of gating predicates equivalent to those introduced (bounds checks, null checks, permission checks) along the flow.
- Model control dependence so that guards introduced by the patch are recognized when present and their absence is used to flag.

5. Validation & Test Cases
- Positive: Pre-patch snippet replicating the exact unsafe pattern removed/guarded by the patch (same API, same operands) without the added checks; expect a finding.
- Negative: Post-patch snippet with the added checks/guards in place; expect no finding.
- Test harness notes: Build minimal functions mirroring the patched context and vary presence/absence of the guard to confirm specificity.

6. Estimated Effort & Priority
Medium — effort depends on availability of [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] to parameterize signals; building a robust similarity and guard-absence check is straightforward once specifics are known.

7. Likely False-Positive Sources & Mitigations
- Generic patterns that resemble the patch but differ semantically; mitigate by requiring close structural and API-context similarity to patched sites.
- Alternative safe idioms (different guards achieving same safety); mitigate by recognizing logical equivalence of guards, not exact syntactic matches.
- Infeasible paths where guards exist in different branches; mitigate by control-flow feasibility checks.

8. Limitations & Assumptions
- Missing [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] prevent identifying the specific vulnerability class, sources/sinks, and guards.
- Assumes the patch adds explicit, identifiable safeguards (checks, locks, error handling) that can be mirrored as detection signals.
- Cannot determine language, frameworks, APIs, or project scope; the checker must be instantiated per repository once details are available.