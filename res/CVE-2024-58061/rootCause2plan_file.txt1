1. Plan Summary
Differential detection: infer the vulnerable condition from the patch’s added checks/guards and flag similar operations elsewhere that lack those protections.

2. Detection Steps
1) Step 1: Identify the code elements touched by the patch — functions/methods, parameters, and operations — by inspecting [PATCH_DIFF] for added/removed AST nodes (e.g., conditionals, validations, sanitizers, early returns).
2) Step 2: Extract the “guard” logic introduced by the patch (e.g., null checks, bounds checks, authorization checks, input sanitization) as conceptual predicates, based on new conditionals, wrappers, or helper calls appearing in [PATCH_DIFF].
3) Step 3: Determine the core “sink” operation being protected (e.g., dereference, buffer write, sensitive API call) by locating the specific statements the new guards now dominate or wrap.
4) Step 4: From [FILE_CONTENT], enumerate other occurrences of the same sink operation (same API/call pattern or data use) across the codebase, including variants within sibling functions or modules.
5) Step 5: For each occurrence, check whether an equivalent guard predicate (as derived in Step 2) dominates or encloses the sink; signal cases where the sink is reachable without the guard.
6) Step 6: If the patch adds sanitization or transformation calls, identify those as “sanitizers” and flag sink usages where data flows to the sink without passing through any of the added sanitizers.
7) Step 7: If the patch adds parameter or state validation (e.g., range checks, type checks), detect sinks using those parameters/states without prior validation by recognizing missing conditional checks or validation helpers.
8) Step 8: If the patch introduces error-handling or early returns before the sink on invalid states, flag paths that reach the same sink without analogous error-handling gates.
9) Step 9: If [PATCH_DESCRIPTION] references specific sources (e.g., user input, network, file), model those sources and perform a taint-style reachability check to the sink, requiring the presence of the patch’s sanitizers/guards; report flows lacking them.
10) Step 10: If the patch restricts configuration or capability checks, identify the capability/flag reads and report sink executions that are not gated by the same checks.
11) Step 11: Prioritize findings where [ROOTCAUSE_ANALYSIS] (if available) indicates a particular precondition (e.g., “null pointer,” “overflow,” “auth bypass”) by matching the exact guard semantics added in the patch.
12) Step 12: Deduplicate and report: group by sink kind and missing guard type; include the function/context and the specific absent guard pattern inferred from the patch.

3. Limitations & Assumptions
- No [PATCH_DESCRIPTION], [PATCH_DIFF], or [FILE_CONTENT] were provided; exact APIs, sources, sinks, and guard semantics cannot be specified.
- CVE type and root cause are unknown due to missing [ROOTCAUSE_ANALYSIS]; the plan assumes a patch added protective checks around a specific sink.
- The checker must be parameterized once the actual patch details (guards, sanitizers, sinks, sources) are available; otherwise, only generic guard-missing patterns can be applied.