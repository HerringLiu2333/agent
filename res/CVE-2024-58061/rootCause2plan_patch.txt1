1. Plan Summary
Patch-differencing driven detection to find code paths where a sensitive operation (sink) executes without the guard/validation/check introduced by the patch.

2. Detection Steps
1) Step 1: Objective — Identify the “guard” added by the patch; Signals — New or strengthened conditions, validations, sanitizer/normalizer/authorization calls, or precondition checks wrapped around an operation introduced in the patch.
2) Step 2: Objective — Identify the protected operation(s) (sinks); Signals — The statements/expressions that became control-dependent on the newly added guard (e.g., moved under an if/try or preceded by a new validator call).
3) Step 3: Objective — Abstract the guard; Signals — Extract the guard’s predicate structure (boolean condition, null/range/bounds/permission checks) and/or the set of functions that must be called before the sink (sanitizers/validators).
4) Step 4: Objective — Abstract the sink; Signals — The API calls, operations, or code patterns that were placed under the guard by the patch (including their receivers/arguments and relevant types).
5) Step 5: Objective — Define the required dominance/flow relation; Signals — Control-dependence (sink post-dominated by guard) and/or dataflow requirement (data to the sink must pass through the validator function introduced by the patch).
6) Step 6: Objective — Search for unguarded occurrences; Signals — Instances of the same or equivalent sink where the guard condition does not dominate the sink and no equivalent validator/sanitizer is on all reaching paths.
7) Step 7: Objective — Handle indirections/wrappers; Signals — Sinks invoked via helper functions or wrappers and guards implemented in helper precondition functions (detect guard equivalence via call graphs and simple predicate equivalence such as null/range/permission checks).
8) Step 8: Objective — Incorporate source sensitivity if implied by the patch; Signals — If the guard is input validation/sanitization, treat untrusted sources (e.g., parameters/environment) as taint sources and require traversal through the introduced validator before reaching the sink.
9) Step 9: Objective — Exclude guarded variants; Signals — Do not report when alternative, logically equivalent guards dominate the sink (e.g., same predicate written differently or a recognized equivalent validator function).
10) Step 10: Objective — Scope findings to affected contexts; Signals — Limit to functions/files/modules touched by the patch or to sinks with the same signature/type context the patch targeted to reduce noise.
11) Step 11: Objective — Produce actionable evidence; Signals — For each finding, capture the sink location, the nearest missing guard, and a representative path showing reachability without the guard/validator.
12) Step 12: Objective — Allow project-specific tuning; Signals — Configuration points for listing equivalent guards, validators, and additional source kinds inferred from the patch.

3. Limitations & Assumptions
- The PATCH_DESCRIPTION, PATCH_DIFF, and ROOTCAUSE_ANALYSIS are not provided, so the exact guard, sink, and vulnerability class are unknown; this plan is a general patch-guided template.
- Instantiation requires the actual patch to extract the guard and sink patterns; without it, source kinds and equivalence rules cannot be precisely defined.
- Determining logical equivalence of guards beyond simple patterns (null/range/permission checks) may need project annotations or manual curation.