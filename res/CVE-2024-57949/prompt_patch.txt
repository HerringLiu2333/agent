1. CVE Identifier
CVE-2024-57949

2. Vulnerability Type
Concurrency/locking bug due to incorrect interrupt-state management

3. Root Cause Summary
its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq) to protect vlpi_lock while being called in a context where interrupts had already been disabled by irq_get_desc_lock() via raw_spin_lock_irqsave(). On scope exit, guard(raw_spinlock_irq) restored (enabled) interrupts, violating the caller’s expectation that interrupts remain disabled until irq_put_desc_unlock(). This premature re-enablement created a race window and triggered a warning when irq_put_desc_unlock() observed interrupts enabled.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IRQ chip driver for ARM GICv3 ITS (drivers/irqchip/irq-gic-v3-its.c)

2) Pre-Patch Flaw:
Within its_irq_set_vcpu_affinity(), the code used an IRQ-disabling guard on vlpi_lock:
“guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);”
This was incorrect because the function is invoked under irq_set_vcpu_affinity() → irq_get_desc_lock() which already disables interrupts. The guard’s unlock path re-enabled interrupts, breaking nested interrupt-disabled semantics.

3) Trigger Condition:
Calling irq_set_vcpu_affinity() leads to irq_get_desc_lock() (raw_spin_lock_irqsave()), then into its_irq_set_vcpu_affinity() where guard(raw_spinlock_irq) is used; upon leaving the guard scope, interrupts are enabled before irq_put_desc_unlock() runs.

4) Impact Mechanism:
Interrupts become enabled in the middle of a nested critical section, allowing interrupt handlers or concurrent code to run and potentially access ITS event_map/IRQ descriptor state without proper serialization. This violates lock/IRQ nesting invariants, produces kernel warnings in irq_put_desc_unlock(), and opens a race window with possible state inconsistencies; specific memory-safety impacts are Unknown/Not determinable.

5. Patch Analysis
1) Fix Approach:
Stop manipulating interrupt state in the nested lock; use a plain spinlock guard so the outer irqsave-disabled state is preserved.

2) Key Code Changes:
In its_irq_set_vcpu_affinity():
- Replaced guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock) with guard(raw_spinlock)(&its_dev->event_map.vlpi_lock).

3) Locking/Concurrency Impact:
The inner lock no longer re-enables interrupts on scope exit, maintaining the caller’s interrupt-disabled state until irq_put_desc_unlock(). This removes the race window and prevents warnings by restoring correct lock/IRQ nesting and ordering.

6. Broader Kernel Security Implications
Correct preservation of interrupt state across nested locking is critical in IRQ management paths; misuse of IRQ-disabling guards inside already IRQ-disabled contexts can introduce subtle races and deadlocks. This fix highlights the need to choose lock primitives that match the calling context, and to avoid irq-restoring lock variants in functions potentially invoked with interrupts disabled. Similar patterns elsewhere should be audited to prevent concurrency violations.