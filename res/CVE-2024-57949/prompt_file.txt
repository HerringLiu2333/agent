1. CVE Identifier
CVE-2024-57949

2. Vulnerability Type
Concurrency/locking bug due to incorrect interrupt state management (premature IRQ re-enable in a nested IRQ-disabled critical section)

3. Root Cause Summary
its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq) to protect its_dev->event_map.vlpi_lock while being called from a context where interrupts were already disabled by irq_get_desc_lock() (raw_spin_lock_irqsave). Exiting the guard(raw_spinlock_irq) scope re-enabled interrupts, violating the outer critical section’s IRQ-disabled invariant and opening a race window. The patch replaces guard(raw_spinlock_irq) with guard(raw_spinlock), ensuring the lock is taken and released without changing IRQ state and preserving the caller’s interrupt disablement.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ARM GICv3 ITS (Interrupt Translation Service) irqchip driver, specifically vCPU affinity handling for virtual LPIs (GICv4).

2) Pre-Patch Flaw:
- Function: its_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info).
- Pre-patch, it used guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock); which disables IRQs on lock acquisition and re-enables them on scope exit.
- This function is invoked in the call chain irq_set_vcpu_affinity() → irq_get_desc_lock() → its_irq_set_vcpu_affinity() where irq_get_desc_lock() uses raw_spin_lock_irqsave(), already disabling interrupts. The guard(raw_spinlock_irq) re-enabled interrupts when leaving the guard, breaking the nested interrupt-disabled section.

3) Trigger Condition:
Calling irq_set_vcpu_affinity() for an ITS-backed interrupt when the IRQ descriptor lock is held with interrupts disabled (via irq_get_desc_lock()), leading to its_irq_set_vcpu_affinity() acquiring/releasing vlpi_lock with guard(raw_spinlock_irq).

4) Impact Mechanism:
- Exiting its_irq_set_vcpu_affinity() with interrupts enabled (due to guard(raw_spinlock_irq)) while still inside the irq_desc critical section causes irq_put_desc_unlock() warnings and can allow interrupts to be delivered into code assuming interrupts remain disabled. This creates a race window in protected ITS and vLPI state transitions, risking concurrency violations (data corruption or deadlock) and kernel warnings.

5. Patch Analysis
1) Fix Approach:
Stop altering IRQ state inside its_irq_set_vcpu_affinity(). Use a spinlock that does not manipulate IRQs, preserving the outer caller’s interrupt state.

2) Key Code Changes:
- Change in drivers/irqchip/irq-gic-v3-its.c at its_irq_set_vcpu_affinity():
  - From: guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);
  - To:   guard(raw_spinlock)(&its_dev->event_map.vlpi_lock);
This removes the IRQ disable/enable behavior tied to the lock guard, ensuring interrupts remain disabled as set by the caller.

3) Locking/Concurrency Impact:
- Previously, raw_spinlock_irq guard re-enabled interrupts on scope exit, violating nested IRQ-disabled semantics established by irq_get_desc_lock().
- Now, raw_spinlock guard only locks/unlocks the spinlock without touching IRQ state. Interrupts remain disabled across the whole irq_desc critical section until irq_put_desc_unlock(), eliminating the race window and lockdep warnings.

6. Broader Kernel Security Implications
Incorrect management of IRQ state in nested critical sections can undermine core locking assumptions, leading to hard-to-debug races, warnings, or potential data corruption in low-level interrupt controllers. Ensuring that functions respect the calling context’s IRQ state (especially when invoked under irq_desc locks) is critical in irqchip drivers and similar subsystems. This fix demonstrates the importance of choosing lock primitives that match the required IRQ semantics to prevent concurrency vulnerabilities.