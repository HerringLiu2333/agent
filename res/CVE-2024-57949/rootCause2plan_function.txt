1. Plan Summary
Detect functions that, when called from an IRQ-disabled section, perform locking with an IRQ-enabling unlock (e.g., guard(raw_spinlock_irq)), causing premature re-enabling of interrupts inside a nested critical section.

2. Detection Steps
1) Step 1: Objective — Identify caller regions that disable interrupts. Signals — Calls to irq_get_desc_lock() or raw_spin_lock_irqsave(...) that remain in effect until a matching irq_put_desc_unlock() or raw_spin_unlock_irqrestore(...). FP mitigation — Require a balanced, recognizable pair (disable followed by unlock/restore) in the same function to ensure a true IRQ-disabled region per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].

2) Step 2: Objective — Mark function calls occurring while the IRQ-disabled region is active. Signals — Calls made between the disable (irq_get_desc_lock/raw_spin_lock_irqsave) and the matching unlock/restore. FP mitigation — Exclude calls clearly after the matching unlock/restore or guarded by code paths that re-enable interrupts before the call.

3) Step 3: Objective — Within the callee, detect use of guard(raw_spinlock_irq). Signals — A call expression invoking guard with the raw_spinlock_irq variant, e.g., guard(raw_spinlock_irq)(...). FP mitigation — Ensure reachability from function entry to the guard site (i.e., not in dead code or behind an always-false condition), based on [FUNCTION_CONTENT]/[PATCH_DIFF].

4) Step 4: Objective — Model the effect of guard(raw_spinlock_irq) as unconditionally enabling interrupts on scope exit. Signals — Associate guard(raw_spinlock_irq) with raw_spin_unlock_irq behavior that enables interrupts regardless of prior state (per [ROOTCAUSE_ANALYSIS]). FP mitigation — Only flag when the call context is inside an active IRQ-disabled region identified in Steps 1–2.

5) Step 5: Objective — Detect explicit IRQ-enabling unlocks inside the callee as equivalent misuse. Signals — Presence of raw_spin_unlock_irq(...) or spin_unlock_irq(...) in the callee without a local irqsave/irqrestore pairing encapsulating the entire critical section. FP mitigation — Exclude cases where the callee pairs spin_lock_irqsave/local_irq_save with spin_unlock_irqrestore restoring the prior state, as these are less likely to unconditionally enable interrupts.

6) Step 6: Objective — Strengthen the contextual expectation that interrupts remain disabled across the callee. Signals — In the caller, a post-call use of irq_put_desc_unlock() (mentioned in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]) or raw_spin_unlock_irqrestore(...) as the matching end of the region. FP mitigation — Prioritize/report findings where such a “must-still-be-disabled” expectation function appears after the nested call.

7) Step 7: Objective — Identify mismatch between outer irqsave-style disable and inner irq-style lock. Signals — Outer region established by irq_get_desc_lock/raw_spin_lock_irqsave; inner callee uses guard(raw_spinlock_irq) or irq-style unlock, which re-enables interrupts without consulting saved flags. FP mitigation — Require that the outer disable was established by an irqsave variant (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]) to focus on true mismatch cases.

8) Step 8: Objective — Ensure the suspicious inner lock/unlock is not fully contained within a local scope that preserves IRQ state. Signals — Check that no local flags-based save/restore spans the guard(raw_spinlock_irq) scope in the callee. FP mitigation — If a local irqsave/irqrestore spans the entire lifetime of the inner lock scope, deprioritize (though still potentially risky), otherwise flag.

9) Step 9: Objective — Aggregate evidence across call paths. Signals — Build interprocedural paths from an IRQ-disabled caller region to a callee that contains the IRQ-enabling lock/unlock pattern. FP mitigation — Report only when a complete path exists without an observed re-enable in between (no local_irq_enable/spin_unlock_irqrestore before the call).

10) Step 10: Objective — Prioritize functions in the IRQ subsystem and ITS path matching the reported issue. Signals — File path or symbol names consistent with drivers/irqchip/irq-gic-v3-its.c and its_irq_set_vcpu_affinity (from [FUNCTION_CONTENT]/[PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation — Use these as high-confidence cases; keep broader matches as lower confidence.

3. Target Elements
- Function definitions and bodies (e.g., its_irq_set_vcpu_affinity).
- Calls to IRQ state/locking APIs: irq_get_desc_lock, irq_put_desc_unlock, raw_spin_lock_irqsave, raw_spin_unlock_irqrestore, guard(raw_spinlock_irq), guard(raw_spinlock), raw_spin_unlock_irq, spin_unlock_irq.
- Call sites occurring between IRQ disable and corresponding restore/unlock.
- Control-flow blocks determining reachability of guard/raw_spin_* calls.
- File/module context for IRQ subsystem code (e.g., drivers/irqchip).

4. Dataflow / Taint Considerations
- Conceptually track an “IRQs-disabled” state from irq_get_desc_lock/raw_spin_lock_irqsave until irq_put_desc_unlock/raw_spin_unlock_irqrestore in the caller.
- Propagate this state interprocedurally to callees invoked while the state is active.
- Within the callee, model guard(raw_spinlock_irq) as an IRQ-enabling action at scope exit; similarly, model raw_spin_unlock_irq/spin_unlock_irq as enabling actions.
- Ensure there is no intervening IRQ restore/enable on the path from disable to the callee call.

5. Validation & Test Cases
- Positive: Caller A() performs irq_get_desc_lock(); calls its_irq_set_vcpu_affinity(); then calls irq_put_desc_unlock(); callee contains guard(raw_spinlock_irq)(...); expect a finding (mirrors [FUNCTION_CONTENT]/[PATCH_DESCRIPTION]).
- Positive: Caller uses raw_spin_lock_irqsave(flags); calls B(); later raw_spin_unlock_irqrestore(flags); callee B() uses raw_spin_unlock_irq(...); expect a finding.
- Negative: Caller uses irq_get_desc_lock(); calls callee that uses guard(raw_spinlock)(...); expect no finding (matches [PATCH_DIFF] fix).
- Negative: Caller does not disable interrupts; callee uses guard(raw_spinlock_irq); expect no finding due to missing outer IRQ-disabled context.
- Test harness notes: Validate interprocedural reachability and region tracking; include tests with conditional paths to ensure guard site reachability analysis.

6. Estimated Effort & Priority
Medium-High: Requires interprocedural region tracking, modeling of guard(raw_spinlock_irq) semantics, and IRQ state matching; high priority given concurrency/interrupt correctness in low-level IRQ code per [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Guard/raw unlock present but unreachable at runtime: mitigate via reachability analysis.
- Callee performs additional save/restore of IRQ state not recognized: mitigate by checking for irqsave/irqrestore pairs spanning the inner critical section.
- Missing modeling of non-standard wrappers around IRQ APIs: mitigate by prioritizing known APIs (from provided materials) and marking others as lower confidence.
- Context where enabling interrupts inside the region is intentional and safe: mitigate by requiring the caller’s explicit “must-still-be-disabled” postcondition (e.g., irq_put_desc_unlock) for high-confidence reports.

8. Limitations & Assumptions
- Assumes guard(raw_spinlock_irq) implies raw_spin_unlock_irq that unconditionally enables interrupts, based on [ROOTCAUSE_ANALYSIS]; actual macro expansion is not available.
- Only APIs named in the provided materials are treated as canonical IRQ state manipulators; other kernel wrappers may be missed.
- Does not prove absence of tiny re-disable windows; flags are raised when any enabling can occur within a disabled region, per the described bug.
- Assumes correct pairing of irq_get_desc_lock with irq_put_desc_unlock and raw_spin_lock_irqsave with raw_spin_unlock_irqrestore in the same caller function for region delimitation, per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].