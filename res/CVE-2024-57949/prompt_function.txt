1. CVE Identifier
CVE-2024-57949

2. Vulnerability Type
Incorrect interrupt state/locking misuse leading to premature interrupt enable (concurrency bug)

3. Root Cause Summary
its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq) on vlpi_lock, which unlocks with raw_spin_unlock_irq and unconditionally enables interrupts. The function is invoked under irq_set_vcpu_affinity() after irq_get_desc_lock() has disabled interrupts using raw_spin_lock_irqsave(), so enabling interrupts inside this nested critical section violates the interrupt-disabled nesting invariant. This creates a window where interrupts may run while the IRQ descriptor lock is still active, and causes irq_put_desc_unlock() to warn due to the unexpected interrupt state. The root cause was introduced by commit b97e8a2f7130, which replaced a raw_spin_[un]lock pair with guard(raw_spinlock_irq) in this path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IRQ subsystem, ARM GICv3 ITS (drivers/irqchip/irq-gic-v3-its.c)

2) Pre-Patch Flaw:
Within its_irq_set_vcpu_affinity(), the code used guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock), causing raw_spin_unlock_irq on scope exit and enabling interrupts regardless of prior state.

3) Trigger Condition:
When irq_set_vcpu_affinity() calls its_irq_set_vcpu_affinity() while holding the IRQ descriptor lock obtained via irq_get_desc_lock(), which disables interrupts using raw_spin_lock_irqsave().

4) Impact Mechanism:
Interrupts are re-enabled inside a nested interrupt-disabled section, violating locking expectations and opening a race window in vLPI map/unmap/prop_update operations and IRQ descriptor handling; additionally, irq_put_desc_unlock() detects and warns about the incorrect interrupt state.

5. Patch Analysis
1) Fix Approach:
Prevent any modification of interrupt state in its_irq_set_vcpu_affinity() by switching from guard(raw_spinlock_irq) to guard(raw_spinlock), preserving the outer interrupt-disabled context.

2) Key Code Changes:
One-line change in its_irq_set_vcpu_affinity(): guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock); replaced with guard(raw_spinlock)(&its_dev->event_map.vlpi_lock); (PATCH_DIFF hunk at drivers/irqchip/irq-gic-v3-its.c:1967).

3) Locking/Concurrency Impact:
The lock now uses raw_spin_lock/unlock without toggling interrupts, maintaining proper interrupt-disabled nesting established by irq_get_desc_lock() and eliminating the race window and warning on irq_put_desc_unlock(); overall lock ordering and atomicity are preserved without unintended interrupt enable.

6. Broader Kernel Security Implications
Incorrect use of _irq locking variants inside nested interrupt-disabled sections can inadvertently enable interrupts and break locking invariants, risking race conditions in low-level IRQ/chip paths. This fix highlights the need to match lock variants (_irq/_irqsave vs plain) to calling context to avoid interrupt state corruption. Similar patterns elsewhere could lead to subtle concurrency bugs affecting interrupt handling, virtual LPI management, and kernel stability under KVM/ITS operations.