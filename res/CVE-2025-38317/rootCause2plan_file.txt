1. Plan Summary
Detect kernel write handlers that copy user-controlled data into a fixed-size kernel buffer using copy_from_user (or equivalent) without first constraining the copy length to the buffer capacity (as shown by the ath12k_write_htt_stats_type flaw).

2. Detection Steps
1) Step 1: Identify candidate write handlers. Look for static functions returning ssize_t that take parameters (const char __user* user_buf, size_t count, ...), matching the file write signature seen in ath12k_write_htt_stats_type (based on [FILE_CONTENT]). Reduce FPs by prioritizing functions with “write” semantics (name contains “write” or used in file_operations) but do not rely solely on naming.

2) Step 2: Locate fixed-size buffer allocations for user data. Match allocations like kzalloc/kvzalloc/kmalloc/vmalloc with a size expression that becomes the buffer capacity (e.g., const int size = 32; char *buf = kzalloc(size, ...)) or stack arrays like char buf[N] (based on [FILE_CONTENT]). Reduce FPs by requiring the buffer to be used as the destination of a user copy (see next step).

3) Step 3: Find copy-from-user style calls. Identify calls to copy_from_user (destination, user_buf, length) where destination aliases the buffer found in Step 2 and length is dataflow-dependent on the function’s count parameter (as in copy_from_user(buf, user_buf, count) in [FILE_CONTENT]). Reduce FPs by excluding cases where length is a constant ≤ buffer capacity.

4) Step 4: Require absence of a pre-copy bound check against capacity. Check that no dominating conditional enforces count <= buffer capacity or otherwise rejects count > capacity before the copy (e.g., the added if (count > size) return ... in [PATCH_DIFF] and discussed in [ROOTCAUSE_ANALYSIS]). Use path sensitivity: the unsafe path to copy_from_user must exist without such a guard.

5) Step 5: Recognize safe clamping patterns. Treat as safe when the copy length argument is min(count, capacity) or when count is reassigned or bounded to a value <= capacity prior to the copy (e.g., if (count > size) count = size; or explicit min). Reduce FPs by accepting equivalent patterns that guarantee length ≤ capacity along all paths.

6) Step 6: Account for capacity aliases. Track the symbolic “capacity” value through variables (e.g., size variable used both in kzalloc(size, ...) and in guards, as in [PATCH_DIFF]). Reduce FPs by requiring the guard compares count (or its aliases) to the same capacity expression (or a provably equal one).

7) Step 7: Include stack buffers. Also flag copy_from_user into fixed-size stack arrays (char buf[N]) when the length is count (or alias) without a guard bounding count to N. Reduce FPs by ensuring the destination pointer definitely refers to this array (no unknown aliasing).

8) Step 8: Exempt safe helpers. If the code uses helpers known to do bounded copies internally (e.g., simple_write_to_buffer; analogous to simple_read_from_buffer in [FILE_CONTENT] for reads), treat them as safe. Reduce FPs by maintaining a whitelist of safe kernel APIs.

9) Step 9: Track taint from user length. Treat the count parameter as user-controlled and propagate through simple assignments and arithmetic into the copy length argument. Reduce FPs by stopping taint when a guard conclusively constrains it to <= capacity.

10) Step 10: Highlight debugfs contexts (optional prioritization). If the function is exported via debugfs file_operations (as in [FILE_CONTENT] ath12k_debugfs_htt_stats_register creating files and using write ops), raise priority but do not require it for detection. Reduce FPs by not using this as the only criterion.

11) Step 11: Report only when overflow is feasible. Require that capacity is a finite, concrete bound (constant or resolvable variable) and that count is not provably ≤ capacity at the copy site. Reduce FPs by excluding cases where interprocedural contracts or earlier sanitization prove safety.

12) Step 12: Provide precise diagnostics. Point to the allocation defining capacity, the unbounded copy_from_user call, and the missing or ineffective guard, referencing the pattern fixed by adding if (count > size) return -EINVAL (from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).

3. Target Elements
- Function definitions with (const char __user* user_buf, size_t count) parameters (write handlers).
- Memory allocation sites for buffers (kzalloc/kmalloc/kvzalloc/vmalloc) and fixed-size stack arrays.
- Calls to copy_from_user (and similar raw user copy APIs).
- Condition checks comparing count (or aliases) to buffer capacity before the copy.
- File operation tables (for optional prioritization), debugfs registration sites (as context from [FILE_CONTENT]).

4. Dataflow / Taint Considerations
- Treat the count parameter as tainted (user-controlled length).
- Track taint through assignments and arithmetic into the third argument of copy_from_user.
- Track buffer capacity from allocation size expressions and fixed array sizes to the destination pointer at the copy site.
- Model guards that de-taint or constrain count to ≤ capacity (e.g., count = min(count, size); if (count > size) return).

5. Validation & Test Cases
- Positive: Function allocates char *buf = kzalloc(32, GFP_KERNEL); then copy_from_user(buf, user_buf, count); no check of count vs 32 (mirroring [FILE_CONTENT] pre-patch). Expect a report.
- Positive: char buf[64]; if (count < 1000) { copy_from_user(buf, user_buf, count); } no further bound; expect a report.
- Negative: if (count > size) return -EINVAL; char *buf = kzalloc(size,...); copy_from_user(buf, user_buf, count); (as per [PATCH_DIFF]); expect no report.
- Negative: char buf[32]; size_t n = min(count, sizeof(buf)); copy_from_user(buf, user_buf, n); expect no report.
- Test harness notes: Run on small kernels or synthetic files simulating debugfs write handlers; verify path-sensitivity (both guarded and unguarded paths).

6. Estimated Effort & Priority
Medium: Requires dataflow and dominance/path-sensitivity but is a common, high-impact kernel pattern.

7. Likely False-Positive Sources & Mitigations
- Guards implemented in helper functions or macros not inlined: mitigate with interprocedural summary for common clamp helpers.
- Non-obvious capacity (e.g., dynamic sizes or multiple reassignments): mitigate by requiring resolvable capacity or emitting lower-confidence findings.
- Alternate safe copy APIs misidentified as unsafe: maintain a whitelist of bounded helpers.

8. Limitations & Assumptions
- Assumes copy_from_user semantics and kernel API patterns; checker may miss custom wrappers not modeled.
- Precise aliasing between buffer variables and capacity expressions may be hard; conservatively require clear linkage to reduce FPs.
- The materials confirm the core bad pattern (unbounded copy_from_user into kzalloc(size) buffer) and the fix (count > size guard) [PATCH_DIFF], [FILE_CONTENT], [ROOTCAUSE_ANALYSIS]; broader variants beyond copy_from_user are not covered by the evidence.