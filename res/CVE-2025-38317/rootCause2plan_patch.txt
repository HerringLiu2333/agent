1. Plan Summary
Detect kernel write handlers that allocate a fixed-size heap buffer and use the user-supplied write length (count) to write into that buffer without first bounding count by the buffer size, leading to heap overflow.

2. Detection Steps
1) Step 1: Objective — identify candidate Linux write handlers. Signals — functions with signature matching a write callback (returns ssize_t, params include struct file*, const/char __user* buffer, size_t count, loff_t*), often named with write_ or _write_ and used in debugfs paths (based on ROOTCAUSE_ANALYSIS). FP mitigation — prioritize static functions with such signatures and names; de-prioritize unrelated helpers.

2) Step 2: Objective — find fixed-size heap buffer allocations. Signals — calls to kzalloc/kmalloc allocating a size taken from a local variable or literal (e.g., const int size = 32; char *buf = kzalloc(size, ...), as in PATCH_DIFF/ROOTCAUSE_ANALYSIS). FP mitigation — ensure the allocated size is not derived from count or a function of count (i.e., truly fixed).

3) Step 3: Objective — bind the allocated buffer to a symbolic capacity. Signals — associate the destination pointer (e.g., buf) with the fixed size value (size constant or constant expression). FP mitigation — if multiple sizes or reallocations exist, only consider the smallest guaranteed capacity on the path to the write.

4) Step 4: Objective — track user-controlled length flowing from the write callback’s count parameter. Signals — dataflow from count into variables used as lengths or loop bounds, or directly into APIs that write to buf. FP mitigation — stop propagation when count is clamped via min/count <= size checks; see Steps 5–6.

5) Step 5: Objective — detect missing length validation before first write into buf. Signals — absence, on all paths reaching the write, of a precondition comparing count against the buffer capacity (e.g., if (count > size) return -EINVAL), as added in PATCH_DIFF. FP mitigation — accept equivalent forms such as early returns on count > size, or setting an effective length to min(count, size) before use.

6) Step 6: Objective — detect writes into buf whose extent depends on count (or a value derived from count) without clamping. Signals — calls or loops that write to buf using count (or tainted variants) as the number of bytes/iterations; examples include generic copy/mem APIs or manual loops (ROOTCAUSE_ANALYSIS notes “subsequent processing wrote past the end”). FP mitigation — do not flag if the used length is proven <= capacity along all paths (e.g., via min or explicit bounds checks).

7) Step 7: Objective — ensure path sensitivity to catch unsafe paths. Signals — if there are conditional checks on count, verify at least one feasible path reaches the write with count potentially > capacity. FP mitigation — if all paths have a guard enforcing count ≤ capacity, suppress.

8) Step 8: Objective — prefer debugfs contexts to reduce noise. Signals — function naming (e.g., ath12k_write_*), file/module comments mentioning debugfs, or being part of wireless/debugfs components (ROOTCAUSE_ANALYSIS). FP mitigation — elevate findings in debugfs-like contexts; lower confidence elsewhere unless the pattern is clear.

9) Step 9: Objective — handle off-by-one conventions. Signals — recognize that a check like count > size corresponds to the fix in PATCH_DIFF; treat count >= size as also acceptable if the code writes a trailing NUL, but do not require it. FP mitigation — do not enforce strict off-by-one policy; accept any conservative cap that prevents count from exceeding capacity.

10) Step 10: Objective — exclude safe dynamic allocations sized by count. Signals — allocations where buf capacity is at least count (e.g., kvmalloc(count)), and writes use that capacity. FP mitigation — if capacity is computed from count and no smaller fixed limit is imposed, suppress as safe.

3. Target Elements
- Functions: write handlers (ssize_t, struct file*, user buffer, size_t count, loff_t*).
- Allocation sites: kzalloc/kmalloc of fixed-size buffers stored to local pointers.
- Condition checks: comparisons between count and a buffer size constant/variable; min/clamp patterns.
- Call sites/loops: operations that write into the allocated buffer using count (or derived) as length/bound.
- Return-value uses: early returns on invalid sizes (e.g., -EINVAL) prior to allocation/processing.

4. Dataflow / Taint Considerations
- Treat the parameter count as a tainted length source.
- Track taint into variables used as write lengths or loop bounds that target the allocated buffer.
- Treat min(count, size), clamps, or explicit checks (count <= size) as sanitizers that clear taint for over-capacity risk.
- Associate the destination buffer pointer with its fixed capacity and check that the tainted length cannot exceed this capacity on any path.

5. Validation & Test Cases
- Positive: A write handler that does const int size = 32; char *buf = kzalloc(size,...); then copy_from_user(buf, user, count) without a prior count <= size guard — expect a finding.
- Positive: Same as above but with indirect use of count (e.g., len = count; memcpy(buf, src, len)) and no clamp — expect a finding.
- Negative: Same allocation but with if (count > size) return -EINVAL; before the write (as in PATCH_DIFF) — no finding.
- Negative: Code that clamps len = min(count, size); and uses len for the write — no finding.
- Test harness notes: Exercise path-sensitive cases with conditional checks and multiple early returns; include a case where allocation uses k*alloc(count) to ensure suppression.

6. Estimated Effort & Priority
Medium effort; High priority for kernel security code given the impact described in ROOTCAUSE_ANALYSIS and the simplicity of the fix in PATCH_DIFF.

7. Likely False-Positive Sources & Mitigations
- Implicit clamps inside helper APIs not modeled: mitigate by focusing on explicit checks or widely-known length-capping idioms.
- Contexts that are not debugfs but share similar signatures: mitigate by prioritizing debugfs-like naming/comments; still report others with lower confidence.
- Complex control flow where some paths validate and others don’t: use path-sensitive analysis to require at least one feasible unsafe path.

8. Limitations & Assumptions
- Specific copy/write APIs used inside the handler are not provided; the plan assumes generic writes or copies parameterized by count exist (ROOTCAUSE_ANALYSIS).
- Debugfs registration sites and file_operations bindings are not shown; identification of write handlers relies on signature and naming heuristics.
- Off-by-one safety policies vary; the plan accepts any check that prevents count from exceeding capacity, consistent with PATCH_DIFF.