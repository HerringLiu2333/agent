1. Plan Summary
Detect kernel write handlers that copy a user-supplied length into a fixed-size heap buffer via copy_from_user without validating that the length is within the buffer capacity.

2. Detection Steps
1) Step 1: Identify candidate functions that act as write handlers with a parameter of type const char __user * and a size_t count. Signals: function signature matching ath12k_write_htt_stats_type-style (file*, const char __user*, size_t count, loff_t*) and presence of copy_from_user.
2) Step 2: Locate calls to copy_from_user whose third argument is the count parameter or dataflow derived from it. Signals: direct use of count or variables/dataflow that originate from count as the length for copy_from_user.
3) Step 3: For each such call, find the destination buffer and trace its most recent allocation site in the function. Signals: kzalloc/kmalloc/kcalloc with a single size argument assigned to the same variable later passed as the destination to copy_from_user.
4) Step 4: Extract the buffer capacity from the allocation call. Signals: size is a constant literal or a local const/int variable (e.g., “const int size = 32”) used as the allocation size.
5) Step 5: Confirm the destination passed to copy_from_user aliases the allocated buffer and is not adjusted to a larger region. Signals: no pointer arithmetic expanding the region; the destination is the same variable returned from the allocator.
6) Step 6: Check that the copy length is not explicitly bounded by the buffer capacity. Signals: the third argument of copy_from_user is count (or unbounded dataflow from count), not size or a min(count, size)-like bounded expression.
7) Step 7: Verify absence of a dominating guard that enforces count ≤ capacity before the copy. Signals: no prior conditional (e.g., if (count > size) return or equivalent) that guarantees count is within bounds on the path to the copy_from_user call.
8) Step 8: Verify absence of any reassignment that clamps count to a safe value before the copy. Signals: no statement that redefines the effective copy length to size or a bounded value used by copy_from_user.
9) Step 9: Confirm the buffer is heap-based to match the root cause. Signals: allocation via kzalloc/kmalloc/kcalloc rather than stack arrays; heap pointer used as copy destination.
10) Step 10: Flag a potential heap overflow when an unvalidated count is copied into a fixed-size allocated buffer. Signals: Steps 2–9 satisfied, indicating missing input length validation in a user-to-kernel copy.

3. Limitations & Assumptions
- Assumes the checker can resolve dataflow from count to the copy length and aliasing between allocation sites and copy destinations; complex aliasing may reduce precision.
- Does not detect stack-buffer cases or other copy APIs beyond copy_from_user, since only copy_from_user is evidenced.
- Assumes “capacity” is statically derivable from the allocation size; macro expansions or indirect computations may be hard to resolve.
- Privilege context (debugfs/root-only) is not considered; the checker focuses purely on memory safety.
- Control-flow dominance checks rely on intra-procedural analysis; inter-procedural guards or wrappers that validate count may be missed.