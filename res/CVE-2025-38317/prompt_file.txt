1. CVE Identifier
CVE-2025-38317

2. Vulnerability Type
Heap-based buffer overflow (out-of-bounds write) via debugfs write handler

3. Root Cause Summary
In ath12k_write_htt_stats_type(), a fixed-size 32-byte kernel buffer is allocated, but the code copies user data into it using copy_from_user(buf, user_buf, count) without verifying that count <= 32. This missing bounds check permits copying more than 32 bytes into the buffer, corrupting adjacent heap memory. The patch adds an explicit size check to reject writes larger than the buffer, preventing the overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath12k Wi-Fi driver debugfs interface for HTT extended statistics (function ath12k_write_htt_stats_type in drivers/net/wireless/ath/ath12k debug code).

2) Pre-Patch Flaw:
The function allocates a 32-byte buffer (const int size = 32; char *buf = kzalloc(size, GFP_KERNEL);) and then performs copy_from_user(buf, user_buf, count) with unbounded count. There was no validation of the incoming user write length against the buffer size, enabling memory corruption when count > 32.

3) Trigger Condition:
A privileged user (debugfs is root-only) writes more than 32 bytes to the debugfs file "htt_stats_type", causing ath12k_write_htt_stats_type() to receive a count value exceeding the allocated buffer size.

4) Impact Mechanism:
copy_from_user writes past the end of the 32-byte buffer, corrupting adjacent heap memory in the kernel. This can lead to crashes (kernel oops), unpredictable behavior, or potential exploitation paths associated with heap overflows, despite the root-only access limitation.

5. Patch Analysis
1) Fix Approach:
Input length validation was added to enforce that the user-provided write size does not exceed the allocated buffer size, aborting the operation if it does.

2) Key Code Changes:
In ath12k_write_htt_stats_type():
- Added:
  if (count > size)
      return -EINVAL;
This check is placed before the buffer allocation and the subsequent copy_from_user call, ensuring count is within bounds.

3) Locking/Concurrency Impact:
No changes to locking or concurrency. The functionâ€™s existing wiphy_lock/unlock usage remains unaffected; the new check only guards the input length and does not alter synchronization or ordering.

6. Broader Kernel Security Implications
This fix underscores the importance of rigorous bounds checking in debugfs handlers, which often process user-provided data in kernel context. Even root-only interfaces must avoid memory corruption to prevent denial-of-service and maintain kernel integrity. Similar patterns should be audited across other debugfs write paths to ensure buffer sizes are respected and copy_from_user calls are bounded appropriately.