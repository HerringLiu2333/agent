1. Plan Summary
Detect NULL-dereference in error paths where a failed pointer-returning call is followed by dereferencing that pointer (or an associated pointer stored in a container) for logging or other actions.

2. Detection Steps
1) Step 1: Identify functions where a local pointer variable is assigned from a call and immediately checked for NULL (e.g., “ar = ath12k_mac_assign_vif_to_vdev(...); if (!ar) ...”). Signals: assignment from a call to a pointer-typed variable followed by a null-check branch for that variable; maps to [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]. FP mitigation: require the check to be the immediate control predicate for the block containing the subsequent uses.

2) Step 2: Within the NULL branch, find dereferences or member accesses of the checked pointer variable or fields of structs that hold an associated pointer of the same type (e.g., ar, or arvif->ar, or a chain like arvif->ar->ab). Signals: any member/field access through the checked pointer or a field whose static type matches the checked pointer type; maps to “arvif->ar->ab” in [PATCH_DIFF]/[FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: exclude cases where the pointer or its containing field is reassigned and proven non-NULL within the branch before use.

3) Step 3: Flag function calls inside the NULL branch that take arguments derived by dereferencing the null-checked pointer or its associated field (e.g., ath12k_warn(arvif->ar->ab, ...)). Signals: call arguments with base expressions that match the dereference patterns from Step 2; maps to [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure there is no intervening null-check specifically guarding the dereference (e.g., “if (arvif->ar) ...”) within the same path.

4) Step 4: Model the association between the failed call’s return and the container field used later (e.g., ath12k_mac_assign_vif_to_vdev returns ar and the associated arvif->ar can be NULL on failure). Signals: same function scope with both the local pointer and a struct field of identical pointee type used; maps to [ROOTCAUSE_ANALYSIS]. FP mitigation: require both references to co-occur in the same error path and that the field is read (not just compared) without prior non-NULL validation.

5) Step 5: Treat chained member access beyond the associated pointer (e.g., arvif->ar->ab) as dereferences requiring non-NULL for each link. Signals: multi-level member chains starting from the null-controlled pointer type; maps to [FUNCTION_CONTENT] “arvif->ar->ab”. FP mitigation: only flag if at least one chain element is the null-controlled pointer or its same-type field.

6) Step 6: Recognize safe alternatives using context pointers that are known to be available independent of the failed call (e.g., ah used by ath12k_hw_warn). Signals: calls where arguments are not derived from the null-controlled pointer (e.g., ath12k_hw_warn(ah, ...)); maps to [PATCH_DIFF]/[PATCH_DESCRIPTION]. FP mitigation: do not report branches that exclusively use safe context like ah and avoid any dereference of ar/arvif->ar.

7) Step 7: Exclude cases where the branch only returns an error code or logs using literals/integers without dereferencing the problematic pointer. Signals: no member access or pointer deref within the branch; maps to general error-path patterns. FP mitigation: limit to dereference-based hazards.

8) Step 8: Prioritize logging macro calls that take device context pointers derived from the failed object (e.g., ath12k_warn with ab obtained via ar or arvif->ar). Signals: known pattern from [PATCH_DIFF] replacing ath12k_warn(arvif->ar->ab, ...) with ath12k_hw_warn(ah, ...). FP mitigation: require occurrence within the specific null-checked branch tied to the failed assignment.

3. Target Elements
- Functions where a pointer is assigned from a call and then null-checked.
- Conditional branches governed by “if (!ptr)” or equivalent.
- Member access expressions and dereferences inside these branches (e.g., ptr->field, container->ptrField->field).
- Call sites using dereferenced pointer-derived arguments (especially logging helpers like ath12k_warn).
- Local variables and struct fields with matching pointer types (e.g., ar and arvif->ar).

4. Dataflow / Taint Considerations
- Track the “null-taint” along the control path of the branch triggered by the null-check of the returned pointer.
- Consider alias-like association: a struct field whose type equals the checked pointer’s type is treated as potentially null-tainted in the same error path (e.g., arvif->ar when ar is NULL).
- Propagate hazard through member chains starting from the null-tainted base (e.g., arvif->ar->ab).
- Stop propagation if a subsequent explicit non-NULL check or assignment guarantees safety before dereference.

5. Validation & Test Cases
- Positive: Pre-patch snippet where “ar = ath12k_mac_assign_vif_to_vdev(...); if (!ar) { ath12k_warn(arvif->ar->ab, ...); return -EINVAL; }” is flagged for dereferencing arvif->ar->ab under ar==NULL.
- Negative: Patched snippet “if (!ar) { ath12k_hw_warn(ah, ...); return -EINVAL; }” is not flagged since no deref of ar/arvif->ar occurs.
- Negative: “if (!ar) { if (arvif->ar) ath12k_warn(arvif->ar->ab, ...); }” is not flagged due to the inner non-NULL guard for arvif->ar.
- Test harness notes: Run on ath12k driver sources; ensure the checker recognizes pointer types for ar and arvif->ar and logs only within null branches.

6. Estimated Effort & Priority
Medium-high effort, high priority for kernel drivers where error-path logging can dereference partially initialized objects.

7. Likely False-Positive Sources & Mitigations
- Cases where the associated struct field was independently initialized and guarded, but the checker infers association by type similarity; mitigate by requiring a direct read without a guard in the same branch.
- Complex control flow where the null branch contains assignments making the pointer non-NULL before use; mitigate by checking ordering and dominance of assignments vs uses.
- Functions where naming similarity (e.g., “ar”) is coincidental; mitigate by relying on type matching and flow, not names.

8. Limitations & Assumptions
- The checker infers association between a failed return (ar) and a container field (arvif->ar) by type and co-usage; exact initialization semantics of the field are not determinable from inputs.
- Semantics of logging helpers (ath12k_warn vs ath12k_hw_warn) are inferred from [PATCH_DIFF]/[PATCH_DESCRIPTION]; broader applicability to other helpers may require project-specific knowledge.
- Inter-procedural evidence that the failed call leaves arvif->ar NULL is assumed based on [ROOTCAUSE_ANALYSIS]; the checker uses conservative patterns rather than proving this relation.