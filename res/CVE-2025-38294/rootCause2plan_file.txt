1. Plan Summary
Detect NULL-dereference in failure paths where a pointer-returning function fails (returns NULL) and code subsequently dereferences that pointer or a closely related handle (e.g., a field expected to be set by the function) inside the same error branch.

2. Detection Steps
1) Step 1: Identify call sites where a pointer variable is assigned from a function returning a pointer, then immediately checked with a NULL test (e.g., “ar = ath12k_mac_assign_vif_to_vdev(...); if (!ar) {...}”). Signals: pointer assignment followed by a negated null check on the variable in the next conditional. FP mitigation: require the check to refer to the same variable assigned from the call or its alias within a small statement window.

2) Step 2: Within the body of that “if (!ptr)” branch, find any dereference of the same variable (e.g., ar->ab) or a member chain that conceptually carries that variable (e.g., arvif->ar->ab). Signals: inside the null-handling block, presence of “X->…” where X is the null-checked variable or a field likely holding it. FP mitigation: ensure no intervening explicit null check on that dereferenced expression (e.g., “if (arvif->ar) …”).

3) Step 3: Specialize for the ath12k case from the patch: in function ath12k_mac_op_assign_vif_chanctx(), if the local “ar” is NULL, flag any dereference of arvif->ar->… used in logging (as in pre-patch ath12k_warn(arvif->ar->ab, …)). Signals: function name match; if (!ar) branch; deref of arvif->ar->*. FP mitigation: treat this as high-confidence when both the function and field names match the observed pattern from the pre-patch code.

4) Step 4: Treat dereferences used as logging arguments as equally dangerous if they chain through the null-checked resource (e.g., passing ar->ab or arvif->ar->ab to a warn/helper). Signals: function calls where an argument is a dereference chain containing the null-checked variable or the same field name. FP mitigation: allow calls that use alternative guaranteed-non-NULL handles (e.g., ah in ath12k_hw_warn per [PATCH_DIFF]).

5) Step 5: Recognize “assign/get” semantics as higher risk: if the callee name suggests assignment/mapping (e.g., “assign_vif_to_vdev”), weigh dereferences of fields it is expected to set (like arvif->ar) inside the failure branch as likely unsafe. Signals: callee name contains “assign/get/map” and return type is a pointer. FP mitigation: limit to drivers/subsystems where the field relationship is evident (ath12k/mac.c per [FILE_CONTENT]).

6) Step 6: Require temporal proximity: dereference must occur directly in the “if (!ptr)” block or within a small bounded sequence of statements without a safe re-initialization. Signals: location constraint within the same branch and basic block. FP mitigation: if the field is re-assigned inside the branch before dereference, do not flag.

7) Step 7: Exclude cases with prior proven non-NULL assertions for the dereferenced chain (e.g., an explicit check “if (arvif->ar)” guarding the dereference). Signals: control-flow guard on the dereferenced chain. FP mitigation: path-sensitive honor of guards.

8) Step 8: Exclude uses of alternative context handles known to be safe (e.g., “ah” hardware handle used by ath12k_hw_warn per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). Signals: argument is “ah” or other object not derived from the null-checked pointer. FP mitigation: whitelist known safe logging helpers.

9) Step 9: Flag when the dereferenced expression includes member access beyond one level (e.g., arvif->ar->ab) to catch nested dereferences that increase risk (per [ROOTCAUSE_ANALYSIS]). Signals: multi-level “->” dereference chain containing the null-checked pointer or its likely holder field. FP mitigation: still require no guarding null-check for the intermediate member.

10) Step 10: Prioritize paths marked as failure/error handling (e.g., immediate “return -EINVAL;” inside the branch) to raise confidence. Signals: return of error code or error logging in the block. FP mitigation: only elevate severity, not necessary for detection.

11) Step 11: Consider name correlation heuristics: if the null-checked variable name is “ar” and the dereferenced chain includes “->ar”, treat as likely alias/relationship. Signals: name “ar” appearing as both variable and field. FP mitigation: limit to same function scope and avoid global matches.

12) Step 12: Report with context: include the callee name, the null-checked variable, and the dereferenced expression in the branch (e.g., “ath12k_mac_assign_vif_to_vdev” -> “if (!ar)” -> “arvif->ar->ab”). Signals: assemble evidence for triage. FP mitigation: none; it aids manual review.

3. Target Elements
- Functions with pointer-returning calls followed by NULL checks.
- Conditional branches handling the “NULL-return” case.
- Member dereferences inside error/failure branches (e.g., ar->…, arvif->ar->…).
- Logging/helper call sites using dereferenced arguments (warn/info functions).
- Driver-specific functions: ath12k_mac_op_assign_vif_chanctx and ath12k_mac_assign_vif_to_vdev (from [FILE_CONTENT]).

4. Dataflow / Taint Considerations
- Track the pointer variable assigned from the call and its direct dereferences within the null-check branch.
- Conceptually treat “field likely holding the returned pointer” (e.g., arvif->ar) as tainted-by-null when the function returning the pointer fails; propagate risk to chains (arvif->ar->ab).
- Do path-sensitive reasoning to honor guards that prove non-NULL before dereference.

5. Validation & Test Cases
- Positive: Pre-patch snippet in ath12k_mac_op_assign_vif_chanctx: ar = ath12k_mac_assign_vif_to_vdev(...); if (!ar) { ath12k_warn(arvif->ar->ab, ...); return -EINVAL; } → should be flagged as potential NULL deref (based on [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: Post-patch snippet: if (!ar) { ath12k_hw_warn(ah, ...); return -EINVAL; } → should not be flagged because it uses a safe “ah” handle (based on [PATCH_DIFF]).
- Negative: A branch “if (!ar) { if (arvif->ar) ath12k_warn(arvif->ar->ab, …); }” → should be suppressed due to the guard on arvif->ar.

- Test harness notes: Run on drivers/net/wireless/ath/ath12k/mac.c; ensure function/branch context extraction works and path-sensitive suppression of guarded dereferences.

6. Estimated Effort & Priority
Medium: Requires branch- and expression-level analysis with modest path sensitivity and heuristic alias recognition of related fields.

7. Likely False-Positive Sources & Mitigations
- Cases where the field (e.g., arvif->ar) is guaranteed non-NULL even if the local variable is NULL: mitigate by requiring absence of reassignment/guard and by specializing function/field name patterns.
- Logging APIs masquerading as dereferences but taking opaque handles that are safe: mitigate by whitelisting safe helpers (e.g., ath12k_hw_warn).
- Complex aliasing where the same name “ar” is unrelated: mitigate with scope-based matching and function-specific specialization from [FILE_CONTENT].

8. Limitations & Assumptions
- Assumes that in failure branches of ath12k_mac_assign_vif_to_vdev(), arvif->ar can be NULL (based on [ROOTCAUSE_ANALYSIS]); checker cannot fully prove assignment semantics across all code paths.
- Assumes “ah” is a safe handle in ath12k context (based on [PATCH_DIFF]); rule whitelists this but may not generalize to other drivers.
- Does not infer deep inter-procedural relationships; relies on local function context and naming/struct-field heuristics from [FILE_CONTENT].