1. Plan Summary
Detect NULL-pointer dereferences in error paths where code checks a pointer for NULL after a function call, then dereferences the same pointer (or a closely related/aliased pointer from the same context) inside the failure branch, typically in logging.

2. Detection Steps
1) Step 1: Identify NULL-check branches after a call
- Objective: Find code that assigns a pointer variable V from a call (V = F(...);) and immediately checks V for NULL (if (!V) or V == NULL).
- Signals: Assignment of a pointer from a function call followed by a control-dependent block gated by a negated NULL check on that same variable.

2) Step 2: Gather call context for aliasing
- Objective: Record the call’s argument expressions (A1, A2, …) used to compute V, as potential sources/containers for related state (e.g., a struct whose fields might mirror V).
- Signals: The list of arguments to the call that produced V, including struct pointer arguments (Ai of pointer type).

3) Step 3: Search for dereferences of V inside the NULL branch
- Objective: Within the body of the “V is NULL” branch, flag any dereference of V (e.g., V->field or *V).
- Signals: Member accesses and dereference operators where the base expression is V.

4) Step 4: Search for dereferences of call-argument-derived objects inside the NULL branch
- Objective: Within the same NULL-branch, flag any dereference chains whose base is one of the call’s arguments (Ai) or a field thereof (e.g., Ai->x->y).
- Signals: Member access expressions where the outermost base expression is any Ai passed to the call that produced V.

5) Step 5: Strengthen relation between V and the deref base via simple aliasing
- Objective: Improve precision by recognizing trivial equivalences, e.g., V was earlier assigned from a field of Ai (V = Ai->x or Ai->x = V), or a known getter returning Ai->x; then consider dereferences of (Ai->x) aliases to V.
- Signals: Simple intra-procedural assignments/returns linking V and a field of Ai; treat deref of that field as deref of V.

6) Step 6: Require control dependence on the NULL condition
- Objective: Ensure the dereference happens only under the path where V is NULL, to avoid false positives from other branches.
- Signals: The dereference node is dominated by the true-branch of the if (!V) (or equivalent control flow), with no intervening reassignment guaranteeing non-NULL.

7) Step 7: Heuristic narrowing to error reporting calls
- Objective: Reduce noise by focusing on dereferences used as arguments to logging/error functions/macros in the failure branch.
- Signals: Calls to typical warn/log/err functions (e.g., ath12k_warn, *_warn, dev_warn, pr_warn), where a dereference expression is passed as an argument (notably as first parameter).

8) Step 8: Highlight deref chains ending in known device/context fields
- Objective: Prioritize patterns likely to match this bug class (e.g., dereferencing ->ab off a possibly NULL radio handle).
- Signals: Member chains of the form X->...->ab used as an argument in the NULL branch when X is V or derived from the call’s arguments Ai.

9) Step 9: Exclusion — prior non-NULL checks on the deref base
- Objective: Reduce false positives where the deref base is independently validated in the same branch.
- Signals: Presence of a guarding check (e.g., if (base) …) before the dereference within the same branch that dominates the deref.

10) Step 10: Exclusion — reassignment to a safe value before use
- Objective: Avoid reporting when the base is set to a known non-NULL object prior to the dereference under the NULL branch.
- Signals: In-branch assignments setting the deref base (V or Ai-derived base) to a non-NULL literal/validated value before deref.

11) Step 11: Report with path explanation and safer alternative cue
- Objective: Provide a result that points to the dereference expression, the earlier NULL-check of V, and the call that produced V; suggest using a context-safe handle for logging.
- Signals: Include the dereference site, the if (!V) site, and the call site V = F(...).

12) Step 12: Optional project-specific tuning hooks
- Objective: Allow configuration to add project-specific logging names and known context fields (e.g., ->ab) to rank findings higher.
- Signals: A configurable list of function name patterns and field names to prioritize.

3. Limitations & Assumptions
- The plan assumes intra-procedural reasoning; complex inter-procedural aliasing (e.g., functions that set fields inside Ai) may not be fully captured.
- It assumes the dereference is control-dependent on the NULL-check of the call result; if code reorganizes logging into helpers, analysis may need inter-procedural control-flow.
- “Argument-derived” risk for Ai->… deref inside the NULL-branch is heuristic; while it matches the supplied case, some instances may be benign or require deeper semantic knowledge.
- Identifying logging functions/macros (e.g., ath12k_warn) may require a configurable list; without it, the checker can still flag generic dereferences but with higher false positive risk.
- The checker does not infer driver-specific invariants (e.g., that arvif->ar is NULL when ar is NULL) unless simple aliases are evident within the same function.