1. Plan Summary
Detect NULL-dereference-in-error-path patterns in ath12k where, after ath12k_mac_assign_vif_to_vdev() fails (returns NULL), code dereferences arvif->ar (e.g., arvif->ar->ab) in logging or other statements, as seen pre-patch in CVE-2025-38294.

2. Detection Steps
1) Step 1: Objective — Locate the specific failure pattern site. Signals — Find an assignment “ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx)” followed by a check “if (!ar)” in ath12k_mac_op_assign_vif_chanctx (per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation — Restrict to the ath12k driver and this function to mirror the reported flaw context.

2) Step 2: Objective — Identify unsafe dereferences tied to the failed setup within the failure branch. Signals — Within the if (!ar) block, find any dereference whose base includes arvif->ar (e.g., arvif->ar->ab), especially as an argument to functions/macros (per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation — Ensure no assignment to arvif->ar occurs between the call and the dereference in the same control path.

3) Step 3: Objective — Prioritize logging-related dereferences that match the reported issue. Signals — In the if (!ar) block, detect calls to ath12k_warn where the first argument is a member access chain through arvif->ar (e.g., arvif->ar->ab), as pre-patch used “ath12k_warn(arvif->ar->ab, …)” (per [PATCH_DIFF]). FP mitigation — Require a clear control dependence from “if (!ar)” to the logging call and absence of guards validating arvif->ar.

4) Step 4: Objective — Strengthen confidence with message-context correlation. Signals — Check whether the format string contains “failed to assign chanctx” or closely similar text seen in the patch (per [PATCH_DIFF]). FP mitigation — Treat this as a boosting heuristic, not a hard requirement, to avoid overfitting to a single string.

5) Step 5: Objective — Flag alternative unsafe uses beyond logging. Signals — Still within the if (!ar) block, flag any dereference chain starting from arvif->ar (direct ->, field read, or as a subexpression) regardless of the callee, since arvif->ar is not established on failure (per [ROOTCAUSE_ANALYSIS]). FP mitigation — Suppress if there is an explicit NULL check on arvif->ar guarding the dereference.

6) Step 6: Objective — Confirm the failure-return semantic driving the risk. Signals — Verify that the variable compared to NULL is exactly the LHS of the ath12k_mac_assign_vif_to_vdev call (the pattern “ar = …; if (!ar)”). FP mitigation — Exclude cases where the condition is unrelated to the call’s result (e.g., a different pointer is being checked).

7) Step 7: Objective — Reduce false positives via side-effect awareness heuristics. Signals — Ensure there are no function calls or assignments between the failing call and the dereference that could plausibly initialize arvif->ar (e.g., no writes to arvif->ar or obvious init helpers). FP mitigation — If such writes exist, do not report unless they are also control-dependent on the failure (suggesting non-execution in the failing path).

8) Step 8: Objective — Highlight safer alternative usage patterns for triage. Signals — Note presence of ath12k_hw_warn(ah, …) in sibling code paths, as the patch replaced ath12k_warn with ath12k_hw_warn to avoid NULL (per [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation — Do not flag sites already using ath12k_hw_warn in the failure branch.

3. Target Elements
- Function definitions and bodies (focus: ath12k_mac_op_assign_vif_chanctx).
- Call sites to ath12k_mac_assign_vif_to_vdev.
- Condition checks comparing the call’s result variable to NULL (if (!ar)).
- Uses/dereferences of arvif->ar within the NULL branch (member access chains).
- Logging calls (ath12k_warn, and similar) taking arvif->ar-derived arguments.

4. Dataflow / Taint Considerations
- Control dependence: propagate the “failure” condition from if (!ar) to all statements within that branch.
- Value/alias flow: correlate the LHS variable of the ath12k_mac_assign_vif_to_vdev call (ar) with dereferences rooted in arvif->ar as the object the call would have established; track writes to arvif->ar between the call and the dereference to see if it could have been initialized.
- Field access tracking: detect member chains starting with arvif->ar (e.g., arvif->ar->ab), and treat them as risky in the failure-controlled region.

5. Validation & Test Cases
- Positive: Pre-patch snippet from [PATCH_DIFF] where ar = ath12k_mac_assign_vif_to_vdev(...); if (!ar) { ath12k_warn(arvif->ar->ab, "failed to assign chanctx...", ...); } should be reported.
- Negative: Post-patch snippet where the same failure branch uses ath12k_hw_warn(ah, ...) and does not dereference arvif->ar should not be reported.
- Test harness notes: Include variants where additional statements exist between the call and the failure branch; ensure the checker respects control dependence and suppresses when arvif->ar is explicitly checked for NULL before use.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where arvif->ar is initialized independently of ath12k_mac_assign_vif_to_vdev: mitigate by requiring the specific call-result check and absence of intervening initialization writes.
- Overfitting to message strings: treat string matching as heuristic; core detection relies on control and dereference patterns.
- Name-based heuristics (“arvif->ar”) may miss renamed fields or different contexts: scope to ath12k_mac_op_assign_vif_chanctx and the documented call pattern to balance recall and precision.

8. Limitations & Assumptions
- Assumes ath12k_mac_assign_vif_to_vdev is responsible for establishing arvif->ar and that it remains NULL on failure, as described in [ROOTCAUSE_ANALYSIS]; this is not validated interprocedurally.
- Concurrency/locking effects are not analyzed (per [ROOTCAUSE_ANALYSIS], locking impact is unknown).
- The plan focuses on the reported function and pattern; similar issues elsewhere in the driver may require extending symbol and context matching.