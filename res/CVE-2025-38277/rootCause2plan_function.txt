1. Plan Summary
Detect local variables that are read or returned after a loop when all their assignments occur inside that loop, making zero-iteration paths yield an uninitialized read.

2. Detection Steps
1) Step 1: Identify local variables declared without an initializer inside a function. Signal: variable declarations like “int …, ret;” (based on [FUNCTION_CONTENT]) where the patch later adds “= 0” (based on [PATCH_DIFF]). FP mitigation: exclude variables with any explicit initializer.
2) Step 2: Collect all assignments to each such variable and classify where they occur. Signal: assignments only inside a loop body (e.g., “ret = mxic_ecc_process_data(…)” inside for-loop, per [FUNCTION_CONTENT]). FP mitigation: if there is at least one assignment outside loops on all paths before the use, do not flag.
3) Step 3: Identify loops that control these assignments and evaluate if zero iterations are feasible. Signal: for-loops of the form “for (i = 0; i < bound; i++)” where bound is a variable/field (e.g., ctx->steps per [FUNCTION_CONTENT]) and not proven constant-positive. FP mitigation: if there is an explicit guard ensuring bound > 0 before the loop (e.g., “if (steps <= 0) return …” or “if (steps > 0) { loop }”), do not flag.
4) Step 4: Establish a path from function entry to the loop where the loop may be skipped and the function continues to a read/use of the variable. Signal: no early return that would bypass the later use, and the loop is not enclosed in a branch that guarantees at least one iteration. FP mitigation: path feasibility check that the post-loop use is reachable when bound == 0.
5) Step 5: Detect reads/uses of the variable after the loop. Signal: conditional checks like “if (ret)” and returns “return ret” outside the loop (per [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]). FP mitigation: ignore uses guarded by conditions that also ensure the loop ran (e.g., “if (step > 0 && ret)…”).
6) Step 6: Flag when a variable is used after the loop but has no definite assignment along the zero-iteration path. Mapping rationale: this matches the root cause “ret remains uninitialized when ctx->steps == 0” (per [ROOTCAUSE_ANALYSIS]). FP mitigation: require evidence that all writes to the variable are inside the loop and none occur beforehand.
7) Step 7: Prioritize variables that influence control flow or are propagated out of the function. Signal: variable used in if-conditions or returned (per “if (ret) … return ret;” in [FUNCTION_CONTENT]). FP mitigation: deprioritize variables only used for logging or non-critical diagnostics.
8) Step 8: Check for post-loop assignments that would initialize the variable before its first read. Signal: any assignment to the variable between loop end and the first read. FP mitigation: if such assignment exists, do not flag.
9) Step 9: Exclude loops that are guaranteed to execute at least once by syntax. Signal: do-while loops or for-loops with proven bounds ensuring ≥1 iteration. FP mitigation: conservative assumption that unknown bounds can be zero unless explicitly proven otherwise.
10) Step 10: Highlight fixes where initialization at declaration would resolve the issue. Signal: patterns where adding “= 0” at declaration eliminates the zero-iteration uninitialized read (as done in [PATCH_DIFF]). FP mitigation: only suggest when there is no semantic need for a different sentinel value.
11) Step 11: Optionally detect similar patterns across drivers: status/error variables named “ret” or equivalents. Signal: common naming seen in the affected function (per [FUNCTION_CONTENT]). FP mitigation: name-agnostic core logic; naming used only to rank results.
12) Step 12: Report with context: variable declaration, loop header, assignment site(s), and post-loop use site. Rationale: aids review by matching the exact flaw described (per [ROOTCAUSE_ANALYSIS]).

3. Target Elements
- Function bodies and local variable declarations.
- For/while/do-while loops and their conditions.
- Assignments to local variables within loop bodies.
- If-conditions and return statements that read the variable after the loop.
- Guards/condition checks around the loop that constrain iteration counts.

4. Dataflow / Taint Considerations
- Track definite assignment of the target variable from declaration to post-loop uses.
- Model a feasible path where the loop back-edge is never taken (zero iterations).
- Treat loop bound variables/fields (e.g., ctx->steps per [FUNCTION_CONTENT]) as unconstrained unless guarded (bound may be zero per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]).
- Confirm that the first read of the variable after the loop is reachable on the zero-iteration path.

5. Validation & Test Cases
- Positive: Function with “int ret;” assigned only inside “for (step = 0; step < ctx->steps; step++) { ret = …; }” and used post-loop in “if (ret) return ret;” without a guard; expect a finding (matches [FUNCTION_CONTENT]).
- Negative: Same function with “int ret = 0;” at declaration; expect no finding (matches [PATCH_DIFF]).
- Negative: Function with “if (!ctx->steps) return 0;” guard before the loop, then ret assigned in loop and used after; expect no finding.
- Test harness notes: Include path feasibility with early returns (e.g., raw mode check) ensuring the flagged path remains reachable, as in [FUNCTION_CONTENT].

6. Estimated Effort & Priority
High: generic, impactful bug class with clear structural signals and significant runtime consequences (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Hidden guarantees that loop bounds are > 0 not visible locally; mitigate by detecting explicit local guards.
- Assignments via helper functions/macro expansions not recognized; mitigate by comprehensive assignment collection including macro expansions.
- Reads of the variable only occur on paths where the loop did run; mitigate by path feasibility analysis to ensure a zero-iteration path reaches the read.

8. Limitations & Assumptions
- Assumes loop bounds can be zero unless proven by local guards; global invariants are not modeled (per [PATCH_DESCRIPTION] stating ctx->steps can be zero).
- Does not infer semantic requirements for non-zero sentinel initialization; only flags uninitialized reads.
- Cannot conclusively determine hardware or geometry constraints that force ctx->steps > 0; relies on structural analysis (per [ROOTCAUSE_ANALYSIS]).