1. Plan Summary
Detect local variables that may be read (returned or used in conditions) after a loop even though their only definitions occur inside loops that can execute zero times, leading to use of uninitialized memory.

2. Detection Steps
1) Step 1: Identify candidate variables — local, non-parameter variables declared without an initializer in a function. Signals: declarations like “type v;” (no initializer), exclude globals, statics, and parameters.

2) Step 2: Collect all definite assignments to the candidate within the function. Signals: direct writes (e.g., “v = …”, compound assignments, increments/decrements) and phi-like merges from conditional expressions that produce definite assignments; ignore uncertain alias-based writes.

3) Step 3: Locate all read-uses of the candidate after potential initialization points. Signals: occurrences of the variable in value contexts (RHS expressions), return expressions, and control predicates (if/switch conditions) that occur after the loop(s).

4) Step 4: Classify each assignment by control-flow region relative to loops. Signals: whether the write is inside the body of a loop construct (for/while) versus outside; treat do-while loops separately (since they execute at least once).

5) Step 5: Require that all assignments to the variable are inside loops that are not guaranteed to execute at least once. Signals: every write is in a for/while loop (not a do-while), or in blocks strictly dominated by such a loop’s body; no dominating write outside any loop.

6) Step 6: Approximate zero-iteration feasibility for each relevant loop. Signals: loop is for/while with a non-constant-true condition and no provable pre-condition ensuring entry; examples include conditions comparing a variable bound (e.g., steps, count) that is not statically known to be >0.

7) Step 7: For each post-loop use, check path feasibility of uninitialized read. Signals: existence of a control-flow path from function entry to the use that (a) bypasses all writes by taking zero iterations of each covering loop and (b) reaches a read-use of the variable.

8) Step 8: Exclude guarded-safe patterns that handle the zero-iteration case before the use. Signals: prior checks that either (a) initialize the variable along all zero-iteration paths, or (b) return/exit before the variable is read when the loop bound is zero.

9) Step 9: Prioritize/report when the uninitialized read affects function outputs or control flow. Signals: the variable is (a) returned, (b) used in an if/switch predicate, or (c) used to select error-handling paths immediately after the loop.

10) Step 10: Consolidate findings per variable and location. Signals: report the variable name, the loop header/condition responsible for the zero-iteration path, the first post-loop read-use site, and the absence of any dominating initialization; suggest initializing at declaration.

3. Limitations & Assumptions
- Analysis is intra-procedural; writes through aliases (e.g., via pointers or callees) are not reliably recognized.
- Zero-iteration feasibility is conservatively approximated; the checker assumes for/while loops may run zero times unless provably otherwise, which can yield false positives.
- The checker does not infer semantic invariants (e.g., prior validations guaranteeing steps > 0) unless expressed as explicit guards dominating the use.
- Macros, inline assembly, and complex control flow (gotos, setjmp/longjmp) may reduce precision.
- Focus is on local scalars; structures or arrays partially initialized inside loops may require additional modeling not covered here.