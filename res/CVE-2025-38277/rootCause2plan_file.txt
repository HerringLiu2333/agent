1. Plan Summary
Detect local variables in C functions that are used to control flow or returned without a guaranteed prior initialization because all their assignments occur in loops or conditionals that may be skipped (e.g., steps == 0), as in CVE-2025-38277.

2. Detection Steps
1) Step 1: Objective: Find candidate locals prone to uninitialized use. Signals: Local scalar/integer variables declared without an initializer in a function. FP mitigation: Exclude variables with an explicit initializer at declaration.

2) Step 2: Objective: Collect all assignments to each candidate. Signals: Direct assignments, compound assignments, and assignments through simple macros to the variable; note their enclosing constructs (loop, conditional). FP mitigation: Ignore writes in unreachable code (e.g., return before assignment) by using control-flow reachability.

3) Step 3: Objective: Identify loops that may not execute at least once. Signals: for/while loops with non-constant conditions (e.g., involving fields like ctx->steps) and without guarantees of one iteration; exclude do-while which executes at least once. FP mitigation: Treat any non-constant initial loop condition as possibly false; exclude loops with statically true conditions.

4) Step 4: Objective: Determine if a candidate is assigned only within possibly-skipped loops/branches. Signals: All writes occur inside loops from Step 3 or inside conditionals whose guards are non-constant and may be false initially. FP mitigation: Use dominance/post-dominance to confirm there is no dominating assignment before the use.

5) Step 5: Objective: Detect post-loop/branch uses that influence control flow or are returned. Signals: Uses in if conditions (e.g., if (var), if (var < 0)), return var, or var used to decide return codes after the loop. FP mitigation: Require that the use is reachable after the potentially skipped block and not redefined between the block and the use.

6) Step 6: Objective: Establish a path where the variable can flow uninitialized from function entry to the use. Signals: Path-sensitive check showing an execution path where all loop/conditional assignments are bypassed and no prior assignment exists. FP mitigation: Require at least one such feasible path that does not pass through an assignment.

7) Step 7: Objective: Prioritize kernel-style error propagation patterns. Signals: The variable is named like ret/err or is set from called functions’ return values and tested as if (var) or returned directly. FP mitigation: Use as a ranking signal only; do not rely on names for correctness.

8) Step 8: Objective: Recognize loop bounds tied to counts that can be zero. Signals: Loop conditions of the form idx < count or idx != count where count is derived from struct fields or parameters (e.g., ctx->steps) initialized earlier in the function. Why: Based on ROOTCAUSE_ANALYSIS noting ctx->steps could be zero; this maps to pre-patch flaw. FP mitigation: Do not assume count > 0 unless proven by an explicit prior check (e.g., if (count > 0)) dominating the loop.

9) Step 9: Objective: Exempt cases with safe default assignments. Signals: Any assignment that sets a neutral default (e.g., var = 0) before the loop or in an else path dominating the use. Why: PATCH_DIFF shows initializing ret = 0 fixes the issue. FP mitigation: Confirm dominance of default assignment over the use.

10) Step 10: Objective: Avoid false positives when uses are guarded by a check that implies prior assignment. Signals: Patterns like if (executed_steps > 0) { use var } where executed_steps necessarily implies loop executed and assigned var. FP mitigation: Require that the guarding condition dominates the use and implies loop executed at least once.

11) Step 11: Objective: Exclude cases where all paths to the use must pass through an assignment. Signals: Control-flow analysis showing every path from entry to the use node contains a write to the variable. FP mitigation: Apply must-def-before-use analysis to suppress.

12) Step 12: Objective: Report with context. Signals: Include the variable name, the loop header controlling its assignment (e.g., for (step = 0; step < ctx->steps; ...)), and the post-loop use site (if/return). FP mitigation: Provide evidence of the path that skips all assignments.

3. Target Elements
- Function bodies (C).
- Local variable declarations and initializers.
- Loop constructs: for, while, do-while.
- Conditionals: if, conditional operators used for control flow.
- Assignments and compound assignments to locals.
- Uses in control expressions and return statements.
- Dominance and reachability relationships across basic blocks.

4. Dataflow / Taint Considerations
- Track definite assignments to the candidate variable from declaration to each use.
- Model control-flow paths where loops/conditionals may not execute, allowing “no-assignment” paths.
- Treat loop-guard expressions with non-constant values (e.g., struct fields like ctx->steps) as potentially false to permit skipped-loop paths, unless dominated by explicit checks enforcing positivity.

5. Validation & Test Cases
- Positive: A function declares int ret; assigns ret only inside for (i = 0; i < ctx->steps; i++) { ret = foo(); } and later does if (ret) return ret; with no prior ret initialization; expect a finding (mirrors mxic_ecc_finish_io_req_external pre-patch from ROOTCAUSE_ANALYSIS and PATCH_DIFF).
- Positive: Variable assigned only inside while (count--) loop with possibly zero count; later return var; expect a finding.
- Negative: Same as positive but with int ret = 0; at declaration; expect no finding (as in PATCH_DIFF).
- Negative: ret assigned before loop (ret = 0;) and updated in loop; later if (ret) return ret; expect no finding.
- Test harness notes: Include cases with do-while to confirm suppression, and with an explicit if (steps > 0) guard dominating the use to confirm suppression.

6. Estimated Effort & Priority
High priority; uninitialized variable use affects kernel stability as per ROOTCAUSE_ANALYSIS and is subtle but prevalent near loops and error propagation.

7. Likely False-Positive Sources & Mitigations
- Loops that are guaranteed to execute but not provable statically: mitigate by honoring explicit dominating guards (e.g., if (steps > 0)).
- Assignments via complex macros or inline assembly undetected as writes: mitigate by limiting to syntactic assignments and well-known macro forms.
- Uses in branches that are actually unreachable at runtime: mitigate with reachability analysis but acknowledge limits.

8. Limitations & Assumptions
- The checker assumes non-constant loop guards may evaluate to false; it cannot derive domain-specific invariants beyond explicit checks.
- Macro-heavy assignments or indirect writes via pointers may be missed if not modeled.
- The plan relies on general C control/dataflow; it does not model kernel-specific annotations or side effects beyond what is evident in the AST/CFG.
- Based on PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS, zero steps are plausible; we assume similar edge cases may exist elsewhere without needing to prove them statically.