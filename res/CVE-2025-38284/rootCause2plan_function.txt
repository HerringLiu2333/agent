1. Plan Summary
Detect MMIO/DBI register accesses that depend on a BAR mapping before the mapping is established or validated, focusing on the rtw89 PCI path where rtw89_pci_cfg_dac used MMIO prior to pci_iomap, causing a NULL dereference.

2. Detection Steps
1) Step 1: Objective — identify MMIO/DBI access sites. Signals — calls into rtw89_pci_config_byte_set or functions that resolve to rtw89_pci_ops_write16 (as implicated in the OOPS) are considered MMIO/DBI writes (based on ROOTCAUSE_ANALYSIS and the OOPS trace). FP mitigation — exclude pure PCI config-space APIs (pci_read_config_byte/pci_write_config_byte) since the patch uses them safely (PATCH_DIFF).

2) Step 2: Objective — find BAR mapping initialization. Signals — assignments to a field like rtwpci->mmap from pci_iomap(...) and subsequent NULL checks (FUNCTION_CONTENT shows rtwpci->mmap = pci_iomap(...); if (!rtwpci->mmap) ...). FP mitigation — record these assignments per object/field and treat them as establishing a “mapped” state.

3) Step 3: Objective — detect order-of-operations violations in the same function. Signals — within a function, any MMIO/DBI access that appears along a feasible path before an assignment to rtwpci->mmap via pci_iomap or without a preceding domination by a non-NULL check on rtwpci->mmap (FUNCTION_CONTENT shows rtw89_pci_cfg_dac called before pci_iomap in rtw89_pci_setup_mapping). FP mitigation — require the order violation to be along a path that reaches the MMIO call and does not contain a prior mapping or non-NULL guard on the same field.

4) Step 4: Objective — catch interprocedural early MMIO during probe/setup. Signals — calls from rtw89_pci_setup_mapping (or analogous setup functions) to a callee that performs MMIO/DBI (pre-patch rtw89_pci_cfg_dac), when in the caller the BAR mapping is established only later (FUNCTION_CONTENT). FP mitigation — confirm via control-flow that the call to the MMIO callee occurs strictly before the pci_iomap assignment in the caller and not gated by a verified mapping check.

5) Step 5: Objective — detect resume-path MMIO that lacks mapping guarantees. Signals — calls to a MMIO/DBI-performing function from rtw89_pci_basic_cfg on the resume path (pre-patch rtw89_pci_cfg_dac called when resume is true, FUNCTION_CONTENT), without any demonstrated mapping establishment or non-NULL check dominating the call. FP mitigation — if the callee uses only pci_read_config_byte/pci_write_config_byte (PATCH_DIFF), do not flag; otherwise require a visible mapping guarantee in the calling context.

6) Step 6: Objective — flag unsafe DAC configuration sequence tied to 36-bit DMA mask. Signals — a path where dma_set_mask_and_coherent(...36...) succeeds and then a MMIO-based DAC config is called before mapping (FUNCTION_CONTENT shows this order pre-patch). FP mitigation — only flag when the MMIO-based DAC config occurs pre-mapping and no fallback to PCI config-space API is present (PATCH_DIFF shows safe path).

7) Step 7: Objective — detect reliance on state flags that do not ensure mapping. Signals — MMIO/DBI access guarded only by enable_dac or chip capability checks (rtwpci->enable_dac and rtw89_pci_chip_is_manual_dac, FUNCTION_CONTENT) without any guard that mapping exists; treat these as insufficient guards. FP mitigation — suppress if an explicit non-NULL check on rtwpci->mmap or a prior pci_iomap assignment is present on all paths to the MMIO.

8) Step 8: Objective — suggest safer alternative presence as a suppressing signal. Signals — if the DAC configuration uses pci_read_config_byte/pci_write_config_byte on RTW89_PCIE_L1_CTRL (PATCH_DIFF), do not report, as this removes dependence on an MMIO BAR mapping. FP mitigation — constrain the suppression to the scope where the MMIO sink is replaced entirely by PCI config-space access.

9) Step 9: Objective — ensure path feasibility. Signals — use control-flow dominance/post-dominance to ensure the flagged MMIO call is actually reachable before mapping in at least one path, and not immediately followed by unconditional early returns that prevent execution. FP mitigation — require that error-paths do not trivially skip the MMIO call; ignore paths that are guarded by conditions proven false/true within the function.

3. Target Elements
- Function bodies that perform device setup/probe/resume (e.g., rtw89_pci_setup_mapping, rtw89_pci_basic_cfg).
- Call sites of MMIO/DBI helpers (rtw89_pci_config_byte_set, functions that lead to rtw89_pci_ops_write16 per ROOTCAUSE_ANALYSIS).
- Assignments to BAR mapping fields (rtwpci->mmap = pci_iomap(...)) and associated NULL checks.
- Calls to PCI config-space APIs (pci_read_config_byte/pci_write_config_byte) used for DAC configuration (PATCH_DIFF).
- Order-related constructs: control-flow edges showing relative placement of MMIO calls vs. pci_iomap.
- Condition checks gating DAC configuration (enable_dac, rtw89_pci_chip_is_manual_dac) that might be mistaken for safety but are not mapping guarantees.

4. Dataflow / Taint Considerations
- Track the initialization state of the BAR mapping field (rtwpci->mmap) via assignments from pci_iomap and resets; treat it as a boolean “mapped” state.
- Track interprocedural flows from callers into callees performing MMIO/DBI to determine whether a “mapped” state dominates the call site.
- Model guards: a non-NULL check on rtwpci->mmap or equivalent condition as a sufficient precondition; enable_dac or chip capability checks are not sufficient (per ROOTCAUSE_ANALYSIS).
- Recognize alternative safe sink replacements: if the DAC configuration path uses PCI config-space APIs exclusively, consider the flow safe.

5. Validation & Test Cases
- Positive: In a function mirroring pre-patch rtw89_pci_setup_mapping, call rtw89_pci_cfg_dac (which uses rtw89_pci_config_byte_set) immediately after setting a 36-bit DMA mask but before assigning rtwpci->mmap via pci_iomap; expect a report.
- Positive: In rtw89_pci_basic_cfg with resume=true, call a rtw89_pci_cfg_dac that uses MMIO/DBI without any prior mapping or non-NULL check; expect a report.
- Negative: Patched pattern where rtw89_pci_cfg_dac uses pci_read_config_byte/pci_write_config_byte and mapping is done later (PATCH_DIFF); expect no report.
- Negative: A setup function that calls pci_iomap to initialize rtwpci->mmap, checks it for NULL, and only then calls an MMIO helper under that guard; expect no report.
- Test harness notes: Include interprocedural cases where the MMIO occurs in a callee and the mapping is done only after the call in the caller, to verify order-sensitive analysis.

6. Estimated Effort & Priority
Medium to High: requires interprocedural control-flow ordering and field-initialization state tracking, but focused on clear kernel-driver patterns evidenced in the provided functions.

7. Likely False-Positive Sources & Mitigations
- Drivers that establish mapping in earlier initialization phases not visible to the analyzer; mitigate by requiring a same-function or dominating-path proof of mapping or explicit non-NULL checks.
- Alternative mapping fields or helpers not named rtwpci->mmap/pci_iomap; mitigate by scoping the checker initially to the observed rtw89 patterns from the provided code.
- Wrapper MMIO helpers not directly recognized; mitigate by linking sinks via the known OOPS-implicated rtw89_pci_ops_write16 call chain (ROOTCAUSE_ANALYSIS).

8. Limitations & Assumptions
- Assumes rtwpci->mmap is the sole MMIO mapping guard and pci_iomap is the initializer, as shown in FUNCTION_CONTENT; other mapping mechanisms are not covered.
- Does not verify hardware-specific conditions (e.g., rtw89_pci_chip_is_manual_dac) since they do not guarantee mapping validity (ROOTCAUSE_ANALYSIS).
- Cannot infer runtime success of PCI config-space operations or DMA mask application; focuses only on unsafe MMIO-before-mapping patterns observed in PATCH_DIFF and FUNCTION_CONTENT.