1. Plan Summary
Detect MMIO/DBI register accesses that can occur before a PCI BAR is mapped (mapping pointer still NULL), leading to NULL-pointer dereference during probe/resume paths.

2. Detection Steps
1) Step 1: Identify mapping-pointer fields — signals
- Find struct fields that receive the result of PCI BAR mapping functions (e.g., assignments from pci_iomap or similar).
- Record the field and the enclosing device/driver struct as the “mapping state” for subsequent reasoning.

2) Step 2: Identify MMIO/DBI accessors that rely on the mapping — signals
- Find functions that dereference the mapping field (directly or via base+offset) or pass it to low-level MMIO operations (e.g., iowrite*/ioread*, writel/readl, or driver-specific ops like rtw89_pci_ops_write16).
- Mark such functions as “requires mapped BAR” (they are unsafe if mapping is NULL).

3) Step 3: Model “mapping established” events — signals
- Treat successful assignments of the mapping field from pci_iomap (or analogous mapping calls) as establishing the mapping for that device object.
- Treat explicit NULL assignments or uninitialized states as “mapping not established.”

4) Step 4: Check for MMIO/DBI access before mapping within a function — signals
- In any function that both calls a “requires mapped BAR” accessor and later performs the mapping assignment, flag if the accessor call can execute on a path that occurs before the mapping assignment.
- Consider control-flow: if the accessor is reachable without a dominating mapping assignment, report.

5) Step 5: Check interprocedural calls where mapping may not dominate — signals
- For calls to “requires mapped BAR” accessors, verify that along all incoming paths, a mapping assignment dominates the call for the same device object/field.
- If no dominating mapping assignment or non-NULL check exists, report a potential NULL dereference.

6) Step 6: Recognize explicit NULL-deref risk — signals
- Flag uses where the mapping field is used without any preceding non-NULL check (e.g., !ptr checks) in the same function or dominating caller.
- Elevate confidence if the access is a write (more likely to crash) or occurs in early init/bring-up code paths.

7) Step 7: Prioritize lifecycle-sensitive contexts — signals
- Increase priority when the call chain is reachable from functions typical of device lifecycle (e.g., probe, hotplug handling, resume/basic_cfg/setup paths named similarly to those in the analysis).
- This does not gate detection but helps triage the most crash-prone paths during initialization or resume.

8) Step 8: Distinguish safe PCI config-space accesses — signals
- If the code uses pci_read_config_* or pci_write_config_* to reach the same configuration goal (e.g., toggling bits in PCI config space) and does not dereference the mapping field, do not flag.
- This step helps prevent false positives where early configuration is intentionally done via PCI config API instead of MMIO/DBI.

9) Step 9: Emit result with path and state evidence — signals
- For each finding, include: the accessor call site, the mapping field used, absence of dominating mapping assignment or non-NULL check, and any later mapping call in the same function (ordering evidence).
- This mirrors the pre-patch flaw: MMIO/DBI used in cfg before pci_iomap, causing NULL dereference.

3. Limitations & Assumptions
- Assumes the checker can recognize mapping establishment via common APIs (e.g., pci_iomap); custom mapping helpers may require configuration or pattern extension.
- Cannot prove runtime success of pci_iomap or NULL checks; relies on dominance/flow analysis and syntactic non-NULL checks as proxies.
- Does not attempt to verify whether a given register should be accessed via PCI config space versus MMIO (device-specific knowledge not derivable from inputs).
- Interprocedural reasoning is best-effort; very complex initialization sequences or aliasing of the device struct may reduce precision.
- The plan uses function/name heuristics (probe/resume/setup) only for prioritization, not as hard requirements.