1. Plan Summary
Detect MMIO/DBI register accesses that may dereference an unmapped PCI BAR (NULL driver mmap pointer) during early probe/resume, and improper use of MMIO for PCI config-space registers, which can cause NULL pointer dereference and kernel crashes as seen in CVE-2025-38284.

2. Detection Steps
1) Step 1: Identify mapping-dependent MMIO/DBI accessors — Find functions that ultimately read/use a driver device struct’s BAR mapping field (e.g., rtwpci->mmap) or call lower-level MMIO helpers (like those leading to rtw89_pci_ops_write16) and vendor DBI helpers (e.g., rtw89_pci_config_byte_set) [based on ROOTCAUSE_ANALYSIS and PATCH_DIFF replacing rtw89_pci_config_byte_set]. — Reduce FPs by requiring concrete evidence of dereferencing the mapping field or passing it to ioread/iowrite-like operations.

2) Step 2: Locate mapping establishment — Find assignments to the mapping field via pci_iomap and the length retrieval preceding it (pci_resource_len), and any explicit NULL initializations [based on PATCH_DIFF where pci_iomap assignment occurs after try_dac_done]. — Reduce FPs by requiring a clear dataflow link from pci_iomap return to the mapping field.

3) Step 3: Pre-mapping access within a function — In any function, flag mapping-dependent MMIO/DBI accesses that occur on a path before the mapping field is assigned via pci_iomap within the same function [based on rtw89_pci_setup_mapping ordering in PATCH_DIFF and ROOTCAUSE_ANALYSIS]. — Reduce FPs by path sensitivity: only report if there exists a feasible path from function entry to the access with no intervening assignment to the mapping field.

4) Step 4: Access without prior mapping in calling context — For functions that perform mapping-dependent MMIO/DBI, flag call sites where callers have not established the mapping (no prior pci_iomap on the same device struct in the caller or its dominating initializers) [based on ROOTCAUSE_ANALYSIS stating rtw89_pci_cfg_dac was invoked before pci_iomap during probe/resume]. — Reduce FPs by allowing a guard: if the access function or its callers check the mapping field for non-NULL before use, do not flag.

5) Step 5: Resume-path hazard — Identify “resume” or re-init functions (e.g., rtw89_pci_basic_cfg) that call mapping-dependent accessors and verify within their bodies there is either a mapping establishment or a non-NULL guard [based on PATCH_DIFF changing rtw89_pci_basic_cfg to safe path and ROOTCAUSE_ANALYSIS noting resume trigger]. — Reduce FPs by recognizing a gating flag that ensures the access is skipped when not enabled and that mapping is known available; otherwise, flag.

6) Step 6: Use of MMIO/DBI to modify PCI config registers — Flag code that writes/sets RTW89_PCIE_L1_CTRL (or the corresponding 64-bit enable bit) via MMIO/DBI helpers instead of pci_read_config_byte/pci_write_config_byte [based on PATCH_DIFF explicitly replacing MMIO path by pci_read/write_config_byte]. — Reduce FPs by requiring the constant/symbol for the config register to appear in the MMIO call chain and by not flagging when PCI config APIs are used.

7) Step 7: Missing fallback/error handling when config via PCI API fails — In code enabling DAC/36-bit DMA, verify that if the preferred safe path (PCI config API) fails, there is a fallback to 32-bit DMA and no enable flag is set [based on PATCH_DIFF adding return int and fallback, ROOTCAUSE_ANALYSIS stating previous lack of checks/fallbacks]. — Reduce FPs by focusing on sequences attempting to set 36-bit DMA mask (DMA_BIT_MASK(36)) and a subsequent enable flag set; flag if no error propagation from config attempt or no fallback to 32-bit mask appears on the failure path.

8) Step 8: Report only when access can occur with mapping possibly NULL — For each flagged access, confirm a path where the mapping field is at its default/uninitialized state (e.g., never assigned from pci_iomap in that path) or explicitly NULL [based on ROOTCAUSE_ANALYSIS “rtwpci->mmap still NULL”]. — Reduce FPs by recognizing dominance of successful pci_iomap assignments and null-checks that ensure mapping availability.

3. Target Elements
- Functions that perform MMIO/DBI register access and their call sites.
- Driver private struct fields holding PCI BAR mappings (e.g., rtwpci->mmap) and assignments to them.
- Calls to pci_iomap, pci_resource_len, pci_read_config_byte, pci_write_config_byte.
- Constants/symbols for PCI config registers used in DAC configuration (e.g., RTW89_PCIE_L1_CTRL, RTW89_PCIE_BIT_EN_64BITS).
- Control-flow and ordering within probe/mapping/setup and resume/init functions.
- Feature enable flags (e.g., enable_dac) and their assignments relative to successful configuration.

4. Dataflow / Taint Considerations
- Track dataflow from pci_iomap return values into the mapping field; treat NULL as the initial taint on the mapping field until overwritten by pci_iomap.
- Propagate use of the mapping field through MMIO/DBI accessor calls to identify dereferences.
- Track control/dataflow for error codes from PCI config API reads/writes to ensure they affect enable flags and DMA mask fallbacks.
- Recognize propagation of constants/symbols for PCI config space offsets into MMIO/DBI accessor arguments.

5. Validation & Test Cases
- Positive: Function A calls mapping-dependent accessor (e.g., rtw89_pci_config_byte_set with RTW89_PCIE_L1_CTRL) before any pci_iomap assignment in the same function or caller chain; mapping field is not checked for NULL. Expect a report.
- Positive: Resume function calls a mapping-dependent accessor with no mapping establishment and no NULL guard. Expect a report.
- Positive: Code enabling DMA_BIT_MASK(36) sets an enable flag without checking PCI config API outcome and lacks a fallback to 32-bit mask. Expect a report.
- Negative: Code configures RTW89_PCIE_L1_CTRL using pci_read_config_byte/pci_write_config_byte and only sets enable flag after success, with fallback to 32-bit DMA on failure. Expect no report.
- Negative: MMIO access occurs only after a dominating pci_iomap assigns the mapping field and/or behind a non-NULL guard. Expect no report.
- Test harness notes: Use minimal stubbed driver structs and functions to model pci_iomap, pci_read/write_config_byte, and representative accessors; vary control-flow (if/goto/labels) to exercise path sensitivity.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Complex interprocedural initialization where mapping is established in constructors unseen by the checker; mitigate by requiring a clear intra-module dataflow from pci_iomap to the mapping field or a non-NULL guard in the same function or dominant caller.
- Generic MMIO helpers that may internally guard against NULL; mitigate by verifying actual dereference/use of the mapping field without an internal check (via summary models of known helpers).
- Constants for PCI config registers not resolvable; mitigate by also flagging clear symbol references and by allowing user-configurable symbol lists.

8. Limitations & Assumptions
- Assumes the driver’s MMIO/DBI helpers dereference a mapping field analogous to rtwpci->mmap; exact helper names outside the provided driver are unknown.
- Cannot fully prove kernel call-order across files (e.g., that resume/probe always precedes mapping); relies on intra-function ordering and presence/absence of guards as proxies.
- The checker assumes RTW89_PCIE_L1_CTRL should be accessed via PCI config API in early phases, based on the provided patch; applicability to other registers or drivers may vary.