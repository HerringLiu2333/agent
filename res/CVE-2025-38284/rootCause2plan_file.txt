1. Plan Summary
Detect kernel driver code paths that may perform MMIO/DBI accesses via an unmapped PCI BAR (NULL base pointer) during early initialization, by flagging calls that can dereference the device’s MMIO base before pci_iomap or equivalent mapping is established.

2. Detection Steps
1) Step 1: Identify the MMIO base field and its initialization — look for a struct field used as the MMIO base (e.g., rtwpci->mmap) and assignments from pci_iomap; also note explicit NULL assignments and unmap paths. This maps to the root cause where writew/readl used rtwpci->mmap while it was NULL ([ROOTCAUSE_ANALYSIS], [PATCH_DIFF], [FILE_CONTENT]); reduce FPs by scoping to the same driver file/module.

2) Step 2: Catalog MMIO-dependent functions — mark functions that directly dereference the MMIO base (e.g., rtw89_pci_ops_write8/16/32, rtw89_pci_ops_read8/16/32 using rtwpci->mmap) and DBI helpers that call into those ops (rtw89_dbi_read8/write8) as “unsafe before map.” This corresponds to the dereference of rtwpci->mmap through writeb/writew/writel ([FILE_CONTENT]); reduce FPs by limiting to functions whose bodies reference rtwpci->mmap or call rtw89_write*/read*.

3) Step 3: Flag conditional wrappers that may fallback to MMIO — identify rtw89_pci_config_byte_set/clr and rtw89_pci_read/write_config_byte as “conditionally unsafe” because they can fallback to DBI (rtw89_dbi_*), which uses MMIO ([FILE_CONTENT], [ROOTCAUSE_ANALYSIS]). This maps to the root cause (fallback before mapping); mitigate FPs by only flagging when called before mapping (see next steps).

4) Step 4: Within any function that calls pci_iomap (or assigns the MMIO base), compute intra-procedural control-flow ordering — flag any call to “unsafe before map” or “conditionally unsafe” functions that appears before the mapping assignment along at least one path. This directly targets the faulty ordering in rtw89_pci_setup_mapping pre-patch, where rtw89_pci_cfg_dac (via rtw89_pci_config_byte_set) occurred before pci_iomap ([PATCH_DIFF], [FILE_CONTENT]); reduce FPs by requiring path-sensitivity (i.e., flag only if the call dominates a later mapping or there exists a path where mapping is not yet assigned).

5) Step 5: Track mapping guards — if the call is dominated by an explicit non-NULL check of the MMIO base (e.g., if (rtwpci->mmap) …) or occurs after a mapping assignment on all paths, suppress the alert. This is to avoid flagging post-map valid uses and aligns with “only MMIO via NULL mmap is problematic” ([ROOTCAUSE_ANALYSIS]).

6) Step 6: Recognize high-risk early-init contexts — prioritize calls inside initialization functions that execute before mapping, such as resource/mapping setup (e.g., rtw89_pci_setup_mapping) and probe-time helpers invoked prior to pci_iomap ([FILE_CONTENT]). This maps to the observed probe stack trace and reduces FPs by focusing on pre-map early init functions.

7) Step 7: Detect dangerous call chains via wrappers — if a function F (e.g., rtw89_pci_cfg_dac pre-patch) invokes a “conditionally unsafe” wrapper and F is itself called before mapping is established in the caller (e.g., rtw89_pci_setup_mapping), flag the call site to F. This addresses the case where the immediate call does not look unsafe but resolves to DBI fallback ([ROOTCAUSE_ANALYSIS], [PATCH_DIFF]); reduce FPs by requiring that F contains such a wrapper call in its body.

8) Step 8: Prefer standard PCI config APIs pre-map — for calls that only use pci_read_config_byte/pci_write_config_byte directly (as in the patched rtw89_pci_cfg_dac), do not flag even if pre-map. This reflects the patch’s remedy (“configure DAC only via PCI config API”) and reduces noise ([PATCH_DESCRIPTION], [PATCH_DIFF]).

9) Step 9: Recognize fallbacks to safe defaults — if the code handles failure of PCI config access by returning an error and falling back to 32-bit DMA without invoking DBI/MMIO, treat it as safe. This aligns with the patch’s fallback to 32-bit DMA when PCI config access is not available ([PATCH_DESCRIPTION], [PATCH_DIFF]).

10) Step 10: Record evidence in the alert — include the before-map call site, the unsafe/conditionally unsafe callee, and the later pci_iomap site (or lack thereof) within the same function or caller chain. This improves triage fidelity and directly ties to the ordering flaw ([FILE_CONTENT], [PATCH_DIFF]).

3. Target Elements
- Function definitions and bodies performing device setup and mapping (e.g., rtw89_pci_setup_mapping).
- Calls to pci_iomap and assignments to the MMIO base field (rtwpci->mmap).
- Calls to MMIO-dependent functions (rtw89_pci_ops_read*/write*) and DBI helpers (rtw89_dbi_read8/write8).
- Calls to conditional wrappers (rtw89_pci_config_byte_set/clr, rtw89_pci_read/write_config_byte).
- Calls to higher-level helpers that internally use the above (e.g., rtw89_pci_cfg_dac pre-patch).
- Guards/checks on the MMIO base pointer (NULL checks).
- Control-flow edges establishing ordering between pre-map calls and subsequent pci_iomap.

4. Dataflow / Taint Considerations
- Track dataflow from rtwdev->priv to rtwpci and to its mmap field to recognize the MMIO base.
- Model interprocedural call chains where conditional wrappers may fall back into DBI and then into MMIO ops.
- Path-sensitivity to ensure the “unsafe before map” call precedes any mapping assignment on a feasible path.
- Recognize nullability of the MMIO base (uninitialized/NULL until pci_iomap assigns it).

5. Validation & Test Cases
- Positive: A function that calls rtw89_pci_cfg_dac (pre-patch version using rtw89_pci_config_byte_set) before calling pci_iomap and later assigns rtwpci->mmap; expect a finding. This mirrors pre-patch rtw89_pci_setup_mapping ordering ([FILE_CONTENT]).

- Positive: A function that directly calls rtw89_dbi_write8/read8 (or rtw89_pci_ops_write*/read*) before any assignment to rtwpci->mmap; expect a finding. This represents direct MMIO/DBI use before mapping ([ROOTCAUSE_ANALYSIS]).

- Negative: A function that uses only pci_read_config_byte/pci_write_config_byte pre-map and returns on error without invoking DBI, then later calls pci_iomap; expect no finding. This matches the patched rtw89_pci_cfg_dac and rtw89_pci_setup_mapping flow ([PATCH_DIFF]).

- Negative: A function that checks if (rtwpci->mmap) before any MMIO/DBI call and ensures mapping exists on all paths; expect no finding. This validates the guard suppression rule.

- Test harness notes: Run intra-file interprocedural analysis to connect rtw89_pci_setup_mapping with rtw89_pci_cfg_dac and with rtw89_pci_config_byte_set/rtw89_dbi_*; ensure path feasibility when ordering is assessed.

6. Estimated Effort & Priority
Medium — requires control-flow ordering checks, interprocedural call graph resolution for a small set of known functions, and basic path-sensitivity on mapping assignment.

7. Likely False-Positive Sources & Mitigations
- Mapping established in a different function earlier in the probe sequence not visible to intra-procedural analysis; mitigate by requiring the same function either performs pci_iomap later or no prior mapping write dominates the call.
- Conditional execution that ensures the fallback path never triggers (e.g., pci_read_config_* never fails); mitigate by restricting “conditionally unsafe” alerts to early init functions and by preferring patterns known from [ROOTCAUSE_ANALYSIS].
- Alternate MMIO base fields or multiple mappings; mitigate by focusing on the specific base field referenced by the unsafe functions (rtwpci->mmap) in this driver.

8. Limitations & Assumptions
- Assumes the MMIO base field is identifiable (rtwpci->mmap) and that pci_iomap is the initializer (based on [FILE_CONTENT]); other drivers may use differently named fields or mappers.
- Cannot prove at compile time whether pci_read_config_* will fail; treats wrappers that may fallback to DBI as risky only when called before mapping (per [ROOTCAUSE_ANALYSIS]).
- Does not model global driver lifecycle beyond observed function ordering; may miss ordering guarantees enforced elsewhere.