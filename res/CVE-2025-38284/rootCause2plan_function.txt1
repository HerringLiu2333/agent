1. Plan Summary
Detect MMIO/DBI register accesses performed before the PCI BAR is mapped (e.g., via rtwpci->mmap), specifically calls that reach rtw89_pci_config_byte_set/rtw89_pci_cfg_dac prior to pci_iomap, which can cause NULL-pointer dereferences; prefer uses of PCI config-space APIs instead.

2. Detection Steps
1) Step 1: Identify the MMIO base field initialization — find assignments of a struct field (e.g., rtwpci->mmap) from pci_iomap(...) and the subsequent NULL checks for that field. Conceptual signals: field write rtwpci->mmap = pci_iomap(...), and if (!rtwpci->mmap) error paths.

2) Step 2: Mark “unsafe MMIO/DBI accessors” that rely on the mapped BAR — calls to rtw89_pci_config_byte_set(...) and any dereference/use of rtwpci->mmap for register access. Conceptual signals: call expressions to rtw89_pci_config_byte_set and expressions reading/writing through rtwpci->mmap.

3) Step 3: Model wrapper functions that trigger MMIO indirectly — treat rtw89_pci_cfg_dac(...) (pre-patch form) as an MMIO/DBI writer because it calls rtw89_pci_config_byte_set(...). Conceptual signals: a call graph edge from rtw89_pci_cfg_dac to rtw89_pci_config_byte_set.

4) Step 4: For each call site of an unsafe accessor or its wrapper, test ordering relative to BAR mapping — flag if there is no dominating path where rtwpci->mmap has been assigned by pci_iomap(...) before the call. Conceptual signals: absence of a dominating pci_iomap assignment to rtwpci->mmap in the control-flow leading to the call.

5) Step 5: Recognize early-init contexts to boost confidence — in rtw89_pci_setup_mapping(...), flag any call to rtw89_pci_cfg_dac or rtw89_pci_config_byte_set that appears textually/CFG-wise before the pci_iomap that assigns rtwpci->mmap. Conceptual signals: ordering in the same function where the call precedes the pci_iomap assignment.

6) Step 6: Strengthen the pattern using the DMA enabling sequence — if a successful dma_set_mask_and_coherent(..., DMA_BIT_MASK(36)) is followed by a call to rtw89_pci_cfg_dac/rtw89_pci_config_byte_set before any pci_iomap assignment, report a high-confidence finding. Conceptual signals: success path of dma_set_mask_and_coherent(36-bit) leading directly to MMIO call without intervening pci_iomap of the BAR backing rtwpci->mmap.

7) Step 7: Include resume/hotplug paths — in rtw89_pci_basic_cfg(...), flag calls to rtw89_pci_cfg_dac if the analysis cannot prove that rtwpci->mmap was already assigned via pci_iomap on all paths before this call. Conceptual signals: interprocedural reachability/absence of prior pci_iomap-based assignment dominating the call in the program state.

8) Step 8: Suppress when safe PCI config-space APIs are used — if the reachable implementation of rtw89_pci_cfg_dac uses pci_read_config_byte/pci_write_config_byte and no rtwpci->mmap dereference or rtw89_pci_config_byte_set occurs, do not flag. Conceptual signals: in the callee body, presence of pci_read_config_byte/pci_write_config_byte and absence of MMIO field deref or DBI helper calls.

9) Step 9: Identify missing fallback indicator (optional context) — if rtw89_pci_cfg_dac fails or is unsafe and there is no fallback to 32-bit DMA after a failed 36-bit attempt, elevate severity. Conceptual signals: path where 36-bit DMA success leads to unsafe MMIO and no alternative dma_set_mask_and_coherent(..., DMA_BIT_MASK(32)) recovery.

3. Limitations & Assumptions
- Assumes rtwpci->mmap is the sole BAR-mapped MMIO base; other equivalent fields or aliases are not covered unless they appear explicitly.
- Treats rtw89_pci_config_byte_set as a DBI/MMIO accessor based on the provided description; if its implementation changes, classification may need adjustment.
- Path feasibility, error handling, and platform-specific init order beyond the shown functions may affect actual runtime safety and are not fully inferable statically.
- The checker relies on recognizing pci_iomap assignments and pci_read_config_* calls; atypical wrappers around these APIs may require additional modeling.
- Concurrency and PM state interactions are not modeled; analysis is intra-kernel-driver and primarily path/order-based.