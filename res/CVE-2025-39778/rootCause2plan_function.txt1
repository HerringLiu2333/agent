1. Plan Summary
Detect loops that compute a bitmask index (BIT(i) or 1 << i) from a loop counter and use it to index a fixed-size array where the loop’s upper bound permits indices exceeding the array’s length.

2. Detection Steps
1) Step 1: Identify loops with an integer induction variable (e.g., for/while) that monotonically increases and is used to compute a bitmask value inside the loop. Signals: assignments like state = BIT(i) or expressions 1 << i derived from the loop’s induction variable.

2) Step 2: Trace uses of that bitmask value as an array subscript within the same loop body. Signals: array[index] where index is BIT(i), (1 << i), or a variable assigned from BIT(i), including in pointer checks (e.g., if (array[state])).

3) Step 3: Resolve the target array and determine its compile-time length. Signals: array declarations with fixed size or initializers; treat ARRAY_SIZE(array) as the authoritative size.

4) Step 4: Compute the largest safe i such that BIT(i) ≤ (array_length - 1). Signals: conceptually find the maximum i where 2^i does not exceed the last valid index; derive this threshold from the known array_length.

5) Step 5: Determine the loop’s reachable maximum i. Signals: analyze loop bounds (e.g., i < K), start value, and step to derive the highest i that can execute.

6) Step 6: Flag a potential out-of-bounds read if the loop’s range includes any i where BIT(i) > (array_length - 1). Signals: existence of i in [start, max_i_reachable] that violates the threshold computed in Step 4.

7) Step 7: Do not consider bitmask gating on unrelated variables as a mitigation. Signals: conditions like if (!(mask & state)) continue do not constrain the array index relative to array length.

8) Step 8: Treat pointer truthiness checks on the array element as an access. Signals: patterns like if (array[state]) still read array[state] and must be analyzed for bounds.

9) Step 9: Reduce false positives by exempting loops whose upper bound is derived from ARRAY_SIZE(array) in a way that guarantees indices stay within bounds. Signals: bounds expressed as i < ARRAY_SIZE(array) or guards like if (BIT(i) < ARRAY_SIZE(array)).

10) Step 10: Include dataflow across simple assignments to ensure the index origin is tracked. Signals: index variable assigned from BIT(i) and later used in array subscripts in the same loop, even across intervening statements.

3. Limitations & Assumptions
- Assumes the analyzer can resolve compile-time array lengths, including those inferred from designated initializers; if the array is a pointer or length is unknown, precise validation may not be possible.
- Assumes identification of BIT(i) equivalents via 1 << i; other macros or custom wrappers may require additional normalization not described here.
- Non-canonical loops, complex control flow (breaks/continues dependent on data), or bounds computed from non-constant expressions may lead to missed cases or conservative warnings.
- The plan does not attempt to prove that gating conditions based on external masks limit i; it treats such conditions as non-mitigating for array bounds.