1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds read (stack) due to off-by-one loop bound and sparse array indexing

3. Root Cause Summary
nvmet_ctrl_state_show() iterates seven bits (i < 7) and uses state = BIT(i) to index csts_state_names[state], but csts_state_names[] only defines six sparse entries. This off-by-one loop bound permits an index (BIT(6) == 64) that falls beyond the valid indices covered by the array, causing a potential out-of-bounds stack read when the corresponding bit is set in ctrl->csts. The flaw arises from hard-coding the iteration limit rather than deriving it from the actual array size and its sparse (bitmask) indexing pattern.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet) debugfs interface

2) Pre-Patch Flaw:
In nvmet_ctrl_state_show(), the loop "for (i = 0; i < 7; i++)" computes state = BIT(i) and indexes csts_state_names[state]; csts_state_names[] has only six sparse entries, so accessing index BIT(6) may go beyond the arrayâ€™s allocated bounds. The code path then dereferences csts_state_names[state] to decide whether to print the name, leading to an out-of-bounds read.

3) Trigger Condition:
Reading the debugfs file "state" for a controller when ctrl->csts has the 7th bit (BIT(6)) set, causing the loop body to reach the dereference of csts_state_names[BIT(6)]. Even without the bit set, static analysis (objtool/UBSAN) flags the potential OOB due to the incorrect bound and indexing scheme.

4) Impact Mechanism:
Potential out-of-bounds stack read when accessing csts_state_names[BIT(6)] may fetch memory beyond the array, resulting in undefined behavior, possible kernel warnings (UBSAN), or unintended data exposure through seq_puts/seq_printf paths.

5. Patch Analysis
1) Fix Approach:
Replace the hard-coded loop bound with ARRAY_SIZE(csts_state_names), aligning iteration with the actual array size and avoiding indices beyond defined sparse entries.

2) Key Code Changes:
- In nvmet_ctrl_state_show():
  - Changed "for (i = 0; i < 7; i++)" to "for (i = 0; i < ARRAY_SIZE(csts_state_names); i++)".
This ensures the loop never reaches a bitmask index that exceeds the array bounds.

3) Locking/Concurrency Impact:
None. The patch only adjusts loop bounds and indexing; no synchronization, ordering, or RCU changes are involved.

6. Broader Kernel Security Implications
This highlights the risks of hard-coded iteration limits with sparse, bitmask-indexed arrays in kernel code. Using ARRAY_SIZE or otherwise deriving bounds from data structures avoids off-by-one and index-mismatch bugs that can lead to memory safety issues. Even in debugfs, such errors can trigger undefined behavior or leak information; adopting safer iteration patterns reduces attack surface and improves robustness under sanitizers and static analysis tools.