1. Plan Summary
Detect loops that iterate with a hard-coded bound and index into a fixed-size array where the loop’s iteration space can exceed the array length, risking out-of-bounds reads (as in the pre-patch nvmet_ctrl_state_show() case).

2. Detection Steps
1) Step 1: Identify simple counted loops with an integer induction variable and a numeric literal upper bound (e.g., i < 7), based on the hard-coded bound in [PATCH_DIFF]. Focus on canonical for-loops with initialization, comparison, and increment to keep reasoning precise and reduce false positives.

2) Step 2: Within each such loop, find array element accesses where the loop variable (possibly plus/minus a small constant offset) indexes the same array (e.g., csts_state_names[i]), as implied in [ROOTCAUSE_ANALYSIS]. Require that the index expression’s dominant term is the induction variable to ensure the bound controls the index.

3) Step 3: For each array so accessed, compute its compile-time length from its declaration or initializer, mirroring the fix that uses ARRAY_SIZE in [PATCH_DIFF]. Skip cases where the expression is a pointer or the array size cannot be established at compile time to avoid speculation.

4) Step 4: Compute the loop’s maximum reachable index value under its comparison (e.g., for i = 0; i < K; i++ the max is K-1; for i = 0; i <= K; i++ the max is K), and compare it against the array length, mapping to the K=7 vs length=6 mismatch in [ROOTCAUSE_ANALYSIS]. Flag when the maximum index can be greater than or equal to the array length, indicating a potential out-of-bounds access.

5) Step 5: Confirm that an out-of-bounds value of the index reaches an array dereference inside the loop (i.e., the array access is not provably guarded away), aligning with the “dereferenced when BIT(i) state holds” trigger in [ROOTCAUSE_ANALYSIS]. Treat unrelated guards like bit-mask checks (e.g., BIT(i)) as non-sanitizing because they do not constrain i relative to the array length.

6) Step 6: Suppress alerts if there is an explicit in-loop guard that enforces index validity before the array access (e.g., a check that ensures i < array_length along all paths before dereference). Also suppress if the loop contains a break/continue that ensures out-of-range i never reaches the access.

7) Step 7: Prefer cases where the array is a real array object (local or static) rather than a pointer, consistent with the array-focused root cause in [ROOTCAUSE_ANALYSIS]. This focuses the checker on tangible array bounds and reduces false positives stemming from unknown pointer targets.

8) Step 8: Detect and prioritize patterns where a bitmask enumeration (e.g., computing state = BIT(i)) accompanies array indexing by the same i, since [ROOTCAUSE_ANALYSIS] shows this exact combination leading to an OOB when the loop bound is wrong. This heuristic increases precision for the class of “status-name array indexed by bit position” idioms.

9) Step 9: Exempt loops whose bound is already tied to the array length via an expression equivalent to ARRAY_SIZE(array) or sizeof-based calculations, mirroring the fix in [PATCH_DIFF]. This avoids penalizing correct patterns and matches the intended remediation.

10) Step 10: Account for small constant offsets in the index (e.g., arr[i + c] or arr[i - c]) and adjust the effective maximum index accordingly. Only flag if the adjusted maximum can exceed array_length - 1.

11) Step 11: Exclude non-canonical loops with unclear control flow (e.g., multiple induction updates or data-dependent bounds) unless a conservative analysis still proves the index can exceed the array length. This reduces false positives in complex loops not resembling the straightforward pre-patch pattern.

12) Step 12: When flagging, report the array name, its computed length, the loop bound literal, and the index expression, and suggest aligning the loop bound with array length (as done with ARRAY_SIZE in [PATCH_DIFF]). This maps directly to the fix approach in [ROOTCAUSE_ANALYSIS] and provides actionable guidance.

3. Target Elements
- For-loops with integer induction variables and literal upper bounds.
- Array declarations/initializers with compile-time-known lengths.
- Array indexing expressions using the loop variable.
- Conditional guards related to index validity (comparisons of i vs array length).
- Bitmask computations of the form BIT(i) co-occurring with array indexing.

4. Dataflow / Taint Considerations
- Track the loop induction variable’s value range through the loop header (initialization, comparison, increment).
- Propagate the induction variable into index expressions, including simple affine forms (i ± constant).
- Model path conditions that constrain the index before the array access (e.g., i < array_length) to suppress if enforced on all relevant paths.
- Treat unrelated conditions (e.g., bitmask checks using i) as non-sanitizing, per [ROOTCAUSE_ANALYSIS].

5. Validation & Test Cases
- Positive: Array with 6 elements; loop for (i = 0; i < 7; i++) computes state = BIT(i) and accesses names[i]; expected: flagged (matches [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Positive: Array length L; loop for (i = 1; i <= L; i++) uses arr[i]; expected: flagged (max index equals L, out-of-bounds).
- Negative: Loop bound uses ARRAY_SIZE(arr) or sizeof-based equivalent; expected: not flagged (per [PATCH_DIFF]).
- Negative: Loop with i < 7 but guarded access if (i < 6) seq_printf("%s", arr[i]); expected: not flagged due to explicit guard.
- Test harness notes: Validate on small, self-contained C functions; include cases with pointers (should be skipped) and with offsets (arr[i+1] with adjusted checks).

6. Estimated Effort & Priority
Medium effort and medium-to-high priority, as the pattern is common and the fix is straightforward (per [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Unknown array size (pointer or extern): skip unless length is provable.
- Complex loops with multiple updates: restrict to canonical or provably equivalent loops.
- Paths where indexing is guarded by range checks: require guard awareness and path-sensitive suppression.
- “Sparse initializer” confusion: rely on declared/compiled array length rather than counting initializers.

8. Limitations & Assumptions
- Assumes compile-time array length is recoverable; extern or pointer-based arrays are out of scope.
- Does not verify runtime reachability of the out-of-bounds iteration when unrelated conditions (e.g., BIT(i) checks) are present, consistent with [ROOTCAUSE_ANALYSIS] that such checks don’t sanitize index bounds.
- Assumes simple loop forms; deeply non-linear or data-dependent loops may not be analyzed precisely.
- Cannot infer “sparse entry” semantics beyond the declared array length; the checker only uses the array’s type-level length as suggested by [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].