1. Plan Summary
Detect loops that enumerate bit positions (using BIT(i) or 1<<i) and use the resulting bitmask as an array index with a hard-coded iteration bound, where the mask-derived index can exceed the array’s actual bounds, as in the pre-patch nvmet_ctrl_state_show().

2. Detection Steps
1) Step 1: Objective: Identify candidate arrays to be indexed. Signals: File-scope or local fixed-size arrays (compile-time sized) with constant element count; resolve array length from the declarator or initializers. FP mitigation: Focus on arrays with statically determinable size; skip VLA or pointers.

2) Step 2: Objective: Find loops that iterate over integer indices with a literal or non-ARRAY_SIZE upper bound. Signals: for/while with counter i and condition i < C where C is a literal or not derived from ARRAY_SIZE(array). FP mitigation: Prioritize small literal bounds (e.g., ≤ 64), as in [FILE_CONTENT] and [PATCH_DIFF].

3) Step 3: Objective: Detect bitmask computation from the loop variable. Signals: Assignments or temporaries like state = BIT(i) or state = (1 << i). FP mitigation: Require that i originates from the loop induction variable.

4) Step 4: Objective: Check the bitmask is used to test a bitfield, indicating bit enumeration. Signals: Use of the bitmask in a bitwise AND condition (e.g., if (x & state) ...), as shown in [FILE_CONTENT]. FP mitigation: Treat this as a confidence booster; do not require it strictly, but prefer matches that have it.

5) Step 5: Objective: Detect array indexing with the bitmask value. Signals: Expressions arr[state] or arr[1 << i] in the loop body; consider any use that reads the element (e.g., used in a conditional, printed, dereferenced). FP mitigation: Ensure the access is a read (value is used), since OOB read is the concern in [ROOTCAUSE_ANALYSIS].

6) Step 6: Objective: Reason about potential OOB from mask-derived index vs array length. Signals: Compute maximum possible mask within the loop (max_i from loop bound) and compare to array length; if 1 << max_i ≥ array_length, flag. FP mitigation: Only flag when both loop bound and array length are constant-resolvable; otherwise lower confidence.

7) Step 7: Objective: Catch the specific off-by-one/hard-coded bound pattern from [ROOTCAUSE_ANALYSIS]. Signals: Loop bound is a small constant (e.g., 7) and array length is strictly less than the maximum mask-produced index in the loop (e.g., BIT(6) exceeds array length). FP mitigation: Require that at least one iteration produces an index ≥ array_length that reaches an array read dominator.

8) Step 8: Objective: Suppress when explicit bounds checks protect the access. Signals: A dominating condition like if (state < ARRAY_SIZE(arr)) around the indexing. FP mitigation: Require dominance of the check for all paths to the array access within the loop.

9) Step 9: Objective: Avoid mistaking null-pointer checks for bounds checks. Signals: Patterns like if (arr[state]) ... do not guard bounds (as in [FILE_CONTENT]). FP mitigation: Do not treat null/non-null element tests as a bounds guard.

10) Step 10: Objective: Prefer reporting when the loop bound is not derived from the array’s size, reflecting the fix in [PATCH_DIFF]. Signals: i < literal versus i < ARRAY_SIZE(arr); treat the latter as not reportable per the patch intent. FP mitigation: If the bound is ARRAY_SIZE(arr), suppress to match the fix strategy, even though it is a heuristic.

11) Step 11: Objective: Elevate confidence when the array uses designated initializers mapping states to indices. Signals: Array initialized with designated indices resembling constants from a status domain (e.g., csts_state_names[] in [FILE_CONTENT]). FP mitigation: Use this as a heuristic indicator; still require Steps 3–6 patterns.

12) Step 12: Objective: Report precise locations to aid remediation. Signals: Point to the loop header and the array indexing expression using the mask-derived index. FP mitigation: Aggregate multiple identical findings within the same loop to a single report.

3. Target Elements
- Function bodies containing loops
- Array declarations with compile-time size or static initializers
- Assignments computing bitmasks from loop variables (BIT(i), 1<<i)
- Array indexing expressions that use the bitmask
- Conditions using bitwise AND with the computed bitmask
- Bounds-check conditions comparing the computed index to array size

4. Dataflow / Taint Considerations
- Track the loop induction variable i into the bitmask expression state = BIT(i) or 1<<i.
- Track the flow of state into the array index expression arr[state].
- Track control-flow dominance of any bounds check of state versus ARRAY_SIZE(arr) guarding the array access.
- Treat macro BIT as a pure transformation equivalent to shift for analysis purposes.

5. Validation & Test Cases
- Positive: Pre-patch nvmet_ctrl_state_show() in [FILE_CONTENT]: loop i < 7, compute state = BIT(i), index csts_state_names[state] with no state < ARRAY_SIZE guard; expect a finding (as per [ROOTCAUSE_ANALYSIS]).
- Positive: A minimal example with arr of length 6 and loop i < 7 computing idx = 1<<i and reading arr[idx]; expect a finding.
- Negative: Patched code in [PATCH_DIFF] using i < ARRAY_SIZE(csts_state_names) with the same body; treat as non-reportable per fix intent.
- Negative: A loop with state = 1<<i and explicit if (state < ARRAY_SIZE(arr)) before arr[state]; expect no finding.
- Test harness notes: Ensure the analysis resolves array length and loop bounds as constants and recognizes BIT macro or 1<<i patterns.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Arrays whose size cannot be resolved due to opaque macros: mitigate by requiring constant-resolvable sizes for high-confidence alerts.
- Designated initializers with large indices expanding array size unexpectedly: mitigate by computing actual array length post-initialization rather than counting entries.
- Cases where external invariants limit i; mitigate by requiring explicit guards or conservatively flagging only when the loop bound alone implies OOB.
- Patched patterns using ARRAY_SIZE with bitmask indexing might still be unsafe in theory; suppress per [PATCH_DIFF] intent to reduce noise.

8. Limitations & Assumptions
- Assumes ability to resolve array length and loop bounds at compile time; unresolved macro values may reduce precision.
- Treats BIT(i) equivalently to (1<<i) based on patterns in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS].
- Heuristically suppresses when the loop uses ARRAY_SIZE(arr) as an upper bound following the fix in [PATCH_DIFF], even though this may not mathematically guarantee safety in all codebases.