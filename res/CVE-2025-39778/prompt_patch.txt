1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds stack read (array index out of range), potential information disclosure/UBSAN-triggered undefined behavior

3. Root Cause Summary
nvmet_ctrl_state_show() iterated a fixed seven times while indexing into csts_state_names[], which only has six entries. The hard-coded loop bound “i < 7” allowed i == 6, causing a read past the end of the stack-allocated array when the code dereferenced csts_state_names[i].

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet) control state reporting via seq_file

2) Pre-Patch Flaw:
A mismatched loop bound and array length: the function used a constant upper bound (7) instead of the actual length of csts_state_names[], leading to an out-of-bounds access when i reached 6.

3) Trigger Condition:
When the loop index reaches 6 and the code attempts to use csts_state_names[i]; in practice, this dereference is gated by “if (!(ctrl->csts & state)) continue”, so the out-of-bounds read occurs if ctrl->csts includes the BIT(6) state and the code prints the corresponding name.

4) Impact Mechanism:
Reading beyond the end of a stack array can disclose adjacent stack data via seq_file output or trigger undefined behavior; an UBSAN kernel warns and objtool reports “unexpected end of section,” indicating improper code paths due to the OOB access.

5. Patch Analysis
1) Fix Approach:
Replace the hard-coded loop bound with ARRAY_SIZE(csts_state_names) to align iteration with the actual array length and prevent out-of-bounds indexing.

2) Key Code Changes:
- Pre-patch: “for (i = 0; i < 7; i++) {”
- Post-patch: “for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {”
No other logic changes; BIT(i) state computation remains the same.

3) Locking/Concurrency Impact:
None. This is a local bounds fix in a read-only display function; no locking, ordering, or concurrency primitives were added or modified.

6. Broader Kernel Security Implications
Array-bound mistakes in status-reporting paths can still leak kernel stack contents or cause subtle UB, especially when exposed via seq_file/sysfs. Using ARRAY_SIZE eliminates magic constants and future-proofs the iteration against array changes, improving robustness and reducing the risk of information disclosure or diagnostic tool warnings.