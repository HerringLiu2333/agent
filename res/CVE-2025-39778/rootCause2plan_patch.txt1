1. Plan Summary
Detect loops that index into a fixed-size array using a hard-coded iteration bound that exceeds the array’s length, leading to potential out-of-bounds reads.

2. Detection Steps
1) Step 1: Objective — find candidate arrays with known compile-time length. Signals — array declarations or definitions whose element count is statically determinable (e.g., from a fixed-size declarator or a fixed initializer list).

2) Step 2: Objective — locate loops that drive an integer index over a range. Signals — for/while loops with an index variable initialized to 0 or another small value and a monotonic increment, guarded by a condition of the form “index < constant” or “index <= constant” where the bound is a literal or not derived from the array’s length.

3) Step 3: Objective — confirm the loop index is used to access the array. Signals — array subscripts or pointer arithmetic inside the loop body where the subscript expression is the loop index or a simple affine function of it, applied to the identified array or its aliases.

4) Step 4: Objective — compute the array’s length and the loop’s maximum reachable index. Signals — evaluate the array’s element count and symbolically determine the largest value of the index admitted by the loop guard (e.g., “i < N” implies last i = N-1; “i <= N” implies last i = N).

5) Step 5: Objective — detect a bounds mismatch (potential OOB). Signals — flag when the loop permits index values outside [0, array_length-1], such as “i < 7” with array_length = 6 or “i <= 6” with array_length = 6.

6) Step 6: Objective — suppress cases with explicit in-loop bounds checks tied to array length. Signals — presence of conditions that compare the index to the array’s length proxy (e.g., checks using ARRAY_SIZE(array) or equivalent sizeof(element)-based length) before the array access, with control-flow that prevents the access when i >= length.

7) Step 7: Objective — treat unrelated gating as non-protective. Signals — conditional guards based on bitmask tests or other logic unrelated to array length (e.g., “if (!(ctrl->csts & BIT(i))) continue”) should not be considered sufficient to prevent OOB and should not suppress the finding.

8) Step 8: Objective — highlight classic off-by-one constant errors. Signals — constants that differ from the array length by one (e.g., 7 vs 6) and lead to inclusion of an extra iteration are prioritized as high-confidence findings.

9) Step 9: Objective — reduce false positives from indirect accesses. Signals — if the array access is through a pointer that may not alias the identified array, require a conservative alias tie (e.g., the pointer is directly assigned from the array or its address) to keep the candidate.

10) Step 10: Objective — report precise locations. Signals — point to the loop guard using the hard-coded bound and the array subscript site that can be reached with the out-of-range index.

3. Limitations & Assumptions
- The exact array length may be unavailable for externs or macros that hide size; the checker assumes length is statically recoverable.
- Alias analysis may be imprecise; accesses via pointers could be missed or misattributed.
- The checker does not model complex path conditions; unrelated runtime gating (e.g., bitmask tests) is treated as non-protective even if it might sometimes prevent the access.
- It assumes the array access occurs in iterations where the index meets the loop bound; if the access is conditionally skipped for high indices by logic tied to the array length that the checker doesn’t recognize, false positives may occur.