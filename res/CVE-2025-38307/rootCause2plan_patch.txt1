1. Plan Summary
Detect uses of arrays returned by parse_int_array() where elements beyond index 0 are accessed before validating that the length (stored at index 0) is non-zero (or sufficiently large).

2. Detection Steps
1) Step 1: Identify candidate arrays — calls to parse_int_array() whose return value is assigned to a pointer and subsequently used as an array. Signals: call to parse_int_array(), capture the pointer variable(s) receiving the result, including aliases.

2) Step 2: Identify the length expression — reads of the first element as the “length.” Signals: expressions like array[0] or *array assigned to a variable (e.g., num_elems) or used directly in conditions.

3) Step 3: Collect potentially unsafe element uses — any access beyond index 0. Signals: array[1], array[k] with k ≥ 1, *(array + k) with k ≥ 1, or passing array[1]/(array + 1) to functions.

4) Step 4: Establish control-flow context — for each use from Step 3, compute whether it occurs before any check of the length guarding that use. Signals: dominance/post-dominance relations and path feasibility from function entry to the use.

5) Step 5: Recognize sufficient guards for k ≥ 1 — a condition ensuring the length is non-zero before the use. Signals: checks like if (!len) { bail/return/goto } or if (len > 0) { ... use ... }, where len is the length expression or a variable assigned from array[0]/*array.

6) Step 6: Recognize sufficient guards for general k — for uses with index k (constant or expression), ensure a dominating guard establishes len > k (or len >= k+1). Signals: comparisons between the length and the index expression that hold on all paths reaching the use.

7) Step 7: Flag pre-validation access — report any Step 3 use that is not dominated by a sufficient guard from Steps 5–6. Emphasize cases where array[1] is read before any len != 0 validation, as in the pre-patch pattern.

8) Step 8: Handle partial/path-specific guards — if a guard exists but does not dominate all paths to the use (e.g., only under one branch), still flag. Signals: existence of at least one feasible path from entry to the use without the guard condition enforced.

9) Step 9: Account for simple aliasing — track straightforward aliases of the array pointer and the length variable through assignments. Signals: assignments like p = array; n = len; and subsequent uses via p[k] checked against n.

3. Limitations & Assumptions
- Assumes the “length-in-first-element” convention applies specifically to arrays returned by parse_int_array(), as stated; the checker focuses on that API.
- Assumes the length is obtained via array[0] or *array; complex or indirect encodings of the length may be missed.
- Guards expressed via helper functions or non-local invariants may be missed if not recognizable as dominance-enforcing checks.
- Index expressions that are non-constant or depend on complex arithmetic may yield conservative results (potential false positives/negatives).
- The checker targets OOB risks leading to NULL dereference as described; it does not prove or model the downstream NULL deref itself.