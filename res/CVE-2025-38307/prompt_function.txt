1. CVE Identifier
CVE-2025-38307

2. Vulnerability Type
NULL pointer dereference due to missing bounds validation (out-of-bounds access on zero-length parsed array)

3. Root Cause Summary
trace_control_write() reads array[1] (resource_mask) without validating that the parsed array has at least 2 elements. When parse_int_array_user() returns an array whose first element (array[0]) indicates zero elements, any access beyond index 0 is invalid. The missing check for num_elems == 0 leads to out-of-bounds access and subsequent NULL pointer dereference during further manipulation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA System on Chip): Intel AVS trace control

2) Pre-Patch Flaw:
In trace_control_write(), the code assigns resource_mask = array[1] immediately after num_elems = *array, with no verification that num_elems > 0. This violates the contract described in the patch description that the first element stores the length and that zero length means no valid elements beyond index 0.

3) Trigger Condition:
A user write to the trace_control file with input that parse_int_array_user() parses into an array whose first element equals 0 (zero-length array). This causes the function to read array[1] and potentially manipulate &array[2], despite there being no valid elements.

4) Impact Mechanism:
Accessing array[1] when num_elems == 0 is an out-of-bounds read; subsequent logic may dereference invalid pointers, leading to a NULL pointer dereference and kernel crash/oops (Denial of Service).

5. Patch Analysis
1) Fix Approach:
Input validation was added to guard against zero-length arrays returned by parse_int_array_user(). The assignment of resource_mask was deferred until after validating num_elems is non-zero.

2) Key Code Changes:
- Inserted:
  if (!num_elems) {
      ret = -EINVAL;
      goto free_array;
  }
- Moved resource_mask = array[1]; to occur after the above check.
These changes ensure no access beyond array[0] when num_elems == 0 and return a safe error (-EINVAL) instead.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch strictly adds bounds validation and reorders a read. The functionâ€™s synchronization behavior remains unchanged.

6. Broader Kernel Security Implications
This highlights the need to validate length fields from parser helpers before indexing into arrays, especially in file write handlers exposed to user space. Failing to validate such inputs can allow unprivileged users to trigger kernel crashes via crafted writes, leading to denial of service. Consistent defensive checks on parsed input structures help prevent similar NULL dereferences and memory safety issues across subsystems.