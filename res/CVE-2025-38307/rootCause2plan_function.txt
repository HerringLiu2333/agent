1. Plan Summary
Detect unguarded indexing beyond array[0] when consuming arrays parsed by parse_int_array_user()/parse_int_array(), where array[0] encodes the element count and zero length must prevent access to array[1+] (based on PATCH_DESCRIPTION, FUNCTION_CONTENT, ROOTCAUSE_ANALYSIS, PATCH_DIFF).

2. Detection Steps
1) Step 1: Identify parser outputs — locate calls to parse_int_array_user or parse_int_array that write an array pointer via an out-parameter; bind the pointed-to array variable. This maps to the helper described in PATCH_DESCRIPTION and used in FUNCTION_CONTENT; restrict to these helpers to reduce false positives.

2) Step 2: Identify length extraction — detect assignments reading array[0] (or dereference equivalent) into a local variable (e.g., num_elems). This indicates the length-in-first-element contract (PATCH_DESCRIPTION, FUNCTION_CONTENT); require explicit read from index 0 to reduce false positives.

3) Step 3: Track array pointer flow — track aliases from the out-parameter to subsequent array indexing expressions (array[k] or &array[k]) within the same function. This ensures we analyze accesses to the parsed array instance; confine flow within the function to avoid interprocedural complexities.

4) Step 4: Locate early accesses — find any read or address-take of array[k] where k >= 1 that occurs on some path after the parse call and before any guard that ensures the length variable is sufficient. This targets the exact pre-patch flaw (array[1] read) in FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS.

5) Step 5: Recognize adequate guards — treat a condition that dominates the access and ensures length > 0 (for k=1) or length >= k (for general k) as sufficient (e.g., "!len", "len == 0", "len < 1", "len >= 2"); also accept earlier early-returns on zero. This directly matches the fix in PATCH_DIFF that added "!num_elems" before reading array[1]; reduce false positives by requiring dominance.

6) Step 6: Flag unguarded array[1] — if array[1] is read/assigned or taken by address before any dominating check that length > 0, report. This is the minimal unsafe access per ROOTCAUSE_ANALYSIS and PATCH_DIFF.

7) Step 7: Flag unguarded array[2+] — if &array[2] (or higher indices) are used (e.g., passed to another call) before a dominating check that length >= 2 (or >= k), report. This extends the same contract to later uses like enable_logs(…, &array[2]) seen in FUNCTION_CONTENT.

8) Step 8: Validate parse return handling — ensure the path under analysis includes a non-negative parse return check prior to array indexing (ret < 0 leads to early return in FUNCTION_CONTENT). Excluding paths that already return on parse failure reduces false positives unrelated to the length contract.

9) Step 9: Confirm length semantic use — prefer cases where the length variable is later compared or used in controlling logic (e.g., "if (num_elems == 1)", "num_elems != hweight_long(resource_mask) + 1") to confirm it is treated as a count. This aligns with FUNCTION_CONTENT logic and reduces false positives where array[0] is not a count.

10) Step 10: Exclude known-safe patterns — do not report if the array index expression is inside a branch that syntactically implies the guard (e.g., inside "if (len > 0)" or after an early return on "len == 0"), or if a prior assignment enforces a minimum length via a trusted invariant (not present in provided materials). This focuses results on truly unguarded uses like in the pre-patch code.

3. Target Elements
- Function bodies containing calls to parse_int_array_user or parse_int_array.
- Call sites with out-parameters receiving the parsed array pointer.
- Assignments reading array[0] into a local “length” variable.
- Array indexing expressions on the parsed array with constant index ≥ 1, and address-of expressions &array[k] with k ≥ 1.
- Conditional checks comparing the length variable against 0 or specific thresholds.
- Control-flow structures to evaluate dominance of guards over accesses.
- Function call arguments where &array[k] is passed.

4. Dataflow / Taint Considerations
- Track the array pointer from the parse helper’s out-parameter to subsequent array accesses within the same function.
- Track the length variable as dataflow from array[0] and use it to recognize guarding conditions.
- Path-sensitivity: ensure that on all paths reaching array[k], there is no prior dominating check guaranteeing length > 0 (or >= k).
- Ordering: ensure the flagged access occurs strictly before any such guard and after a non-error parse result check.

5. Validation & Test Cases
- Positive: Pre-patch trace_control_write from FUNCTION_CONTENT where resource_mask = array[1] occurs before any "num_elems == 0" check; expect a finding.
- Positive: A variant that passes &array[2] to a function before any check that num_elems >= 2; expect a finding.
- Negative: Patched version per PATCH_DIFF with "!num_elems" check before reading array[1]; expect no finding.
- Negative: A function that checks "if (num_elems < 1) return -EINVAL;" before using array[1] and checks "if (num_elems < 2) return -EINVAL;" before using &array[2]; expect no finding.
- Test harness notes: Include paths with early returns and goto labels to validate dominance and path-sensitivity; include both parse_int_array_user and parse_int_array.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Arrays where array[0] is not a length: mitigate by requiring explicit assignment from array[0] to a variable used in control flow (comparisons) as in FUNCTION_CONTENT.
- Code relying on undocumented guarantees of minimum length from the parse helper: mitigate by scoping to parse_int_array_user/parse_int_array and requiring absence of dominating checks.
- Complex interprocedural invariants enforcing length: mitigate by staying intraprocedural and using control-flow dominance analysis.
- Non-constant indices: limit to constant indices ≥ 1 to align with the concrete pattern (array[1], &array[2]) in ROOTCAUSE_ANALYSIS/FUNCTION_CONTENT.

8. Limitations & Assumptions
- Assumes parse_int_array_user/parse_int_array return arrays where array[0] encodes the count, per PATCH_DESCRIPTION and ROOTCAUSE_ANALYSIS.
- Cannot prove helper-specific postconditions (e.g., guaranteed minimum length) beyond observed guards in the caller.
- Does not handle interprocedural guards or invariants outside the current function.
- Generalization to other helpers is not attempted due to lack of evidence; detection is scoped to the named helpers.