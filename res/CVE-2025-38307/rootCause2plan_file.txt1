1. Plan Summary
Detect missing non-zero length validation before indexing beyond array[0] on arrays returned by parse_int_array_user/parse_int_array where array[0] encodes the element count.

2. Detection Steps
1) Step 1: Objective — Find producers of length-prefixed arrays. Signals — Calls to parse_int_array_user (and parse_int_array if present) where the third argument is an out-parameter storing a pointer to integers (capture the variable that receives the allocated array, handling casts to (int **)).

2) Step 2: Objective — Identify the length variable. Signals — Assignments or reads taking the first element as length (e.g., num_elems = *array or array[0]); if no dedicated variable exists, treat expressions using *array or array[0] as the length source.

3) Step 3: Objective — Collect candidate unsafe accesses. Signals — Any access to array[i] with i >= 1 (read, write, or use in an expression) and any pointer arithmetic/address-of like &array[i] or array + i with i >= 1 (including casts to other types starting from &array[i]).

4) Step 4: Objective — Ensure the access is on the normal success path from the parse call. Signals — The candidate access must be control/data reachable after a parse call with ret >= 0 (i.e., not in the branch immediately taken when ret < 0).

5) Step 5: Objective — Establish the minimal required bound. Signals — For each candidate access using index i, define the required condition as length >= i (equivalently, length > i-1); for i == 1, the minimal guard is length != 0.

6) Step 6: Objective — Detect absence of a dominating length guard. Signals — Flag when there is no dominating control predicate ensuring the required bound (examples of acceptable guards: early return/goto on length == 0 for i == 1; or an enclosing condition length >= i, length > i-1, or the negation of length <= i-1 before the access).

7) Step 7: Objective — Recognize common unsafe pattern exactly like the CVE. Signals — resource or control variables assigned directly from array[1] (e.g., resource_mask = array[1]) before any check that length != 0 or length >= 1.

8) Step 8: Objective — Handle pointer re-interpretation starting from &array[k]. Signals — Passing &array[k] (k >= 1) as an argument or casting it to another pointer type before a guard proves length >= k should be considered unsafe (even if a separate count argument may be zero).

9) Step 9: Objective — Avoid false positives where the guard truly dominates. Signals — Do not flag if the access is post-dominated by a check that excludes insufficient lengths on all paths (e.g., the access lies in the “then/else” region that is only reachable when length >= i).

10) Step 10: Objective — Correlate multiple accesses per array instance. Signals — For multiple unsafe accesses after the same parse call, report the earliest post-parse access site and summarize other subsequent unsafe indices, if any, to reduce noise.

11) Step 11: Objective — Prioritize high-impact uses. Signals — Elevate severity when the value read from array[i] is immediately used to drive further logic or calculations before validation (e.g., used in conditionals or as arguments to functions like hweight_long()).

12) Step 12: Objective — Provide precise remediation guidance. Signals — In the alert, state the required guard (e.g., “check length > 0 before using array[1]” or “check length >= k before using array[k]/&array[k]”), and reference the parse call site and the length expression identified.

3. Limitations & Assumptions
- Assumes the protocol that array[0] holds the element count for arrays produced by parse_int_array_user/parse_int_array, as implied by the supplied materials; other parsers are out of scope.
- The checker cannot definitively know whether a callee dereferences a pointer built from &array[k]; it conservatively flags pointer formation without prior length checks, which may produce false positives when the length passed is zero and the callee never dereferences it.
- Complex aliasing or reassignment of the array pointer and length variable may reduce precision if they are heavily transformed beyond simple casts and assignments.
- Only signals present in the provided code are considered; additional safe-guard idioms beyond simple relational checks on the length may not be recognized.