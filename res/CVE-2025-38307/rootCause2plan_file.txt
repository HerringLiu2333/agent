1. Plan Summary
Detect missing non-zero length validation when using arrays returned by parse_int_array_user (or similar) where array[0] holds the count of subsequent elements, and code indexes array[1+] before ensuring the count is non-zero.

2. Detection Steps
1) Step 1: Objective — find candidate arrays from user-parsed input. Signals — calls to parse_int_array_user (or parse_int_array) that initialize a pointer via an out-parameter (e.g., (int **)&array) as seen in FILE_CONTENT. FP mitigation — restrict to these known parsers to align with ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION semantics.

2) Step 2: Objective — identify the “length” variable. Signals — assignment reading array[0] into a local (e.g., num_elems = *array or array[0]) immediately after parsing, per FILE_CONTENT. FP mitigation — require the length value is used in subsequent control or size calculations (e.g., compared, used in bytes computations) to confirm it represents a count.

3) Step 3: Objective — find unsafe early dereferences beyond index 0. Signals — reads of array[1] (or array[i] with i ≥ 1) as rvalues, or computing resource_mask = array[1], before any check that length > 0; this matches the pre-patch pattern in PATCH_DIFF/FILE_CONTENT. FP mitigation — require the dereference is used (assigned, compared, or passed) rather than only forming a pointer.

4) Step 4: Objective — check for guarding conditions. Signals — presence of a dominating check like if (!num_elems) { error/return/goto } or a branch condition (num_elems > 0) that encloses the dereference; PATCH_DIFF shows the fix adds such a check. FP mitigation — use control-flow dominance: only accept guards that lead to an early exit from the path that performs array[1+] access when num_elems == 0.

5) Step 5: Objective — report missing guards for index 1. Signals — any path from parse to array[1] read where no dominating check ensures num_elems > 0; this directly maps to the root cause per ROOTCAUSE_ANALYSIS. FP mitigation — limit to constant index 1 for high confidence, since PATCH_DIFF specifically fixes array[1] access.

6) Step 6: Objective — detect higher-index uses that imply stricter requirements. Signals — reads of array[2+] or use of &array[2+] paired with subsequent uses that rely on non-empty data (e.g., passing to enable_logs as in FILE_CONTENT) without prior validation of num_elems ≥ index. FP mitigation — optionally flag only when no earlier logic conclusively prevents num_elems from being too small (e.g., lack of checks that enforce expected counts as in hweight_long(resource_mask)+1).

7) Step 7: Objective — avoid flagging pointer formations without dereference. Signals — cases like desc = (type *)&array[1] followed by calls with element count derived as zero (bytes/sizeof(type) == 0), seen in FILE_CONTENT for probe_points; do not flag unless the pointer is dereferenced or used with a non-zero count on that path. FP mitigation — require evidence of read/use with non-zero length on the same path.

8) Step 8: Objective — account for alternative guard expressions. Signals — guards written as if (*array == 0) { … } or equivalent comparisons against zero before the access, not necessarily via a named variable. FP mitigation — treat any dominance-ensured condition that implies array[0] > 0 as sufficient.

9) Step 9: Objective — ensure error-path dominance is recognized. Signals — guards that goto a free/exit label (e.g., goto free_array) before array[1+] access; PATCH_DIFF shows this pattern. FP mitigation — only accept guards that definitively prevent flow to the dereference site.

10) Step 10: Objective — scope findings to user-controlled debugfs-like paths for prioritization. Signals — functions operating as .write handlers, receiving user buffers (const char __user *from) and invoking parse_int_array_user, as in FILE_CONTENT. FP mitigation — prioritize/flag with higher severity when user input is involved, to reduce noise.

3. Target Elements
- Calls to parse_int_array_user (and parse_int_array), particularly their out-parameters.
- Variables assigned from array[0] (length/count).
- Array indexing expressions on the returned pointer (array[k], k ≥ 1).
- Control-flow checks comparing the length against zero (e.g., if (!num_elems), if (*array == 0)).
- Function return/error paths (return, goto labels) that guard accesses.
- Write handlers or similar user-input processing functions.

4. Dataflow / Taint Considerations
- Track the array pointer produced by parse_int_array_user to subsequent dereferences.
- Track the length value sourced from array[0] into local variables and its use in conditions.
- Path-sensitivity: ensure that along any path to array[1+] usage, a non-zero-length check dominates; otherwise, report.
- Optionally, correlate &array[2+] passed to functions with a derived element count; if the count may be zero on that path, consider lower-confidence warnings only when an actual read is implied.

5. Validation & Test Cases
- Positive: Pre-patch trace_control_write pattern where num_elems = *array; resource_mask = array[1]; occurs before any check of num_elems > 0 (as described in ROOTCAUSE_ANALYSIS and FILE_CONTENT); expect a finding.
- Positive: A synthetic function that reads array[2] immediately after parsing without any prior num_elems ≥ 2 check; expect a finding (higher-index rule).
- Negative: Patched trace_control_write where an if (!num_elems) { return/goto } guard dominates array[1] access (PATCH_DIFF); expect no finding.
- Negative: probe_points_write/probe_points_disconnect_write where &array[1] is formed but used with zero-derived counts and not dereferenced on that path (FILE_CONTENT); expect no finding.
- Test harness notes: Run on the provided FILE_CONTENT before and after applying PATCH_DIFF to confirm detection of the pre-patch flaw and clearance post-patch.

6. Estimated Effort & Priority
Medium effort; high priority for kernel/user-input parsing contexts.

7. Likely False-Positive Sources & Mitigations
- Arrays from other parsers where array[0] does not represent “number of following elements” — mitigate by restricting to parse_int_array_user/parse_int_array idioms evidenced here.
- Pointer arithmetic without dereference — mitigate by requiring actual reads/uses with non-zero count on the path.
- Complex guards inferred indirectly (e.g., via other invariants) — mitigate by requiring clear dominance of an explicit zero-length rejection or >0 check.

8. Limitations & Assumptions
- Assumes, per ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION, that parse_int_array_user returns an array with array[0] equal to the count of subsequent elements; the checker relies on this semantic.
- Does not fully model external function semantics (e.g., whether passing pointer with zero count is safe); focuses on direct dereferences and clear non-zero count requirements.
- Interprocedural reasoning is limited; analysis is intraprocedural around the parse/use pattern.