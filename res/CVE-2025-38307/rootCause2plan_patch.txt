1. Plan Summary
Detect unguarded accesses to array elements beyond index 0 when the array’s first element encodes its length as returned by parse_int_array(), specifically flagging uses like array[1] before validating the length is nonzero.

2. Detection Steps
1) Step 1: Objective: Identify arrays produced by parse_int_array(). Signals: Call sites where a pointer variable is assigned the result of parse_int_array() (based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation: Restrict to the known helper name parse_int_array to avoid overgeneralization.

2) Step 2: Objective: Capture the “length” variable derived from the first element of that array. Signals: An integer variable assigned from *array or array[0] where array is the parse_int_array result (from [PATCH_DIFF]: num_elems = *array). FP mitigation: Require a direct dataflow from the same pointer variable to the dereference of index 0.

3) Step 3: Objective: Find potentially dangerous subscripts beyond index 0. Signals: Subscript expressions array[k] or equivalent pointer derefs with constant k >= 1, occurring after the length read (from [PATCH_DIFF]: resource_mask = array[1]). FP mitigation: Prefer constant indices and the same array variable to reduce alias-related noise.

4) Step 4: Objective: Determine if a guard exists that ensures the length permits the subscript. Signals: Simple conditionals testing the length variable against zero or a minimum bound (e.g., if (!len) bail; if (len > 0); if (len >= k+1) ) that dominate the subscript along all paths (from [PATCH_DIFF] added zero-length check). FP mitigation: Require the guard to syntactically dominate or be in the same basic block with a clear conditional controlling the access.

5) Step 5: Objective: Flag unguarded early accesses. Signals: Any array[k] with k >= 1 that is reachable on a path where no prior guard enforces length >= k+1 (from [ROOTCAUSE_ANALYSIS]: access to array[1] before validating length). FP mitigation: Exclude accesses only executed within a branch whose condition clearly enforces the required bound.

6) Step 6: Objective: Prioritize immediate post-parse misuse. Signals: Subscripts to array[k] appearing before any check of the length variable or occurring right after num_elems = *array; (from [PATCH_DIFF], the pre-patch ordering). FP mitigation: Increase confidence when the first reference beyond index 0 precedes any conditional mentioning the length variable.

7) Step 7: Objective: Recognize bail-out patterns as valid guards. Signals: Branches like if (!len) { set error; goto/return; } that occur before the subscript and ensure no fall-through to the access on !len (from [PATCH_DIFF]). FP mitigation: Treat early returns/gotos to cleanup labels as sufficient guards when they cut all paths to the access for disallowed lengths.

8) Step 8: Objective: Catch “check-after-use” anti-patterns. Signals: A length check exists but appears only after the first access beyond index 0 (from [PATCH_DIFF], resource_mask assignment was moved after the guard). FP mitigation: Require that the first offending access is control-flow earlier than any adequate guard.

9) Step 9: Objective: Track simple aliases of the array and length variables. Signals: Straight-line assignments (e.g., arr2 = array; len2 = len) followed by arr2[k] uses; ensure they map back to the parse_int_array result and its length. FP mitigation: Limit to single-assignment or trivial copies in the same function to avoid complex aliasing guesses.

10) Step 10: Objective: Report only when the subscript’s required minimum length is strictly greater than the guaranteed lower bound. Signals: For index k, require a missing or inadequate guard that guarantees len >= k+1; for k=1, require no guard of len > 0 before use (as in [ROOTCAUSE_ANALYSIS]). FP mitigation: Accept guards like len >= 2 for array[1], and ignore guards unrelated to the captured length variable.

3. Target Elements
- Function call sites to parse_int_array and the receiving pointer variables.
- Assignments reading the first element of the returned array (array[0] or *array) into a length variable.
- Array subscripts or pointer dereferences with constant positive indices (>= 1) on that array.
- Conditional expressions comparing the captured length variable to constants (0, 1, k).
- Control-flow structures: dominance of guards over subscripts; early returns/gotos to cleanup labels.

4. Dataflow / Taint Considerations
- Track dataflow from parse_int_array’s return value into a specific pointer variable representing the array.
- Track dataflow from array[0]/*array into a length variable used in subsequent comparisons.
- Track simple aliasing of the array and length variables via direct assignments within the same function.
- Model path feasibility: identify paths from length read to array[k] access where no guard enforces length >= k+1 before the access.

5. Validation & Test Cases
- Positive: Code where arr = parse_int_array(...); len = *arr; x = arr[1]; if (!len) return -EINVAL; Expected: flagged for accessing arr[1] before checking len > 0.
- Negative: Code where arr = parse_int_array(...); len = *arr; if (!len) return -EINVAL; x = arr[1]; Expected: no finding due to proper dominant guard.
- Negative: Code where len = *arr; if (len >= 3) y = arr[2]; Expected: no finding since guard ensures len >= index+1.
- Test harness notes: Ensure control-flow sensitivity is evaluated; include a variant with goto cleanup on !len before the access to verify recognition of early bail-out.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Arrays not produced by parse_int_array yet coincidentally fit the pattern: mitigate by restricting to parse_int_array origin (from [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).
- Non-trivial aliasing or macro-based guards not recognized: mitigate by focusing on simple, local aliases and canonical comparisons.
- Complex path conditions ensuring safety that the checker cannot prove: mitigate with dominance-based heuristics and require clear guards.

8. Limitations & Assumptions
- Assumes parse_int_array returns an array whose first element encodes the length (from [PATCH_DESCRIPTION]); semantics of other helpers are not modeled.
- Does not prove subsequent NULL dereference; flags the earlier out-of-bounds risk (from [ROOTCAUSE_ANALYSIS]).
- Complex interprocedural aliasing, macro-expanded guards, or non-constant indices may be under-reported or missed.
- The checker focuses on in-function patterns; cross-function lifetime and cleanup semantics are not analyzed.