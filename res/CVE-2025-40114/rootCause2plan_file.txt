1. Plan Summary
Detect array indexing where an index extracted from hardware register bits (e.g., via FIELD_GET on a GENMASK-defined field from regmap_read) can exceed the target array’s compile-time size without prior bounds validation, leading to out-of-bounds reads.

2. Detection Steps
1) Step 1: Identify fixed-size arrays used as look-up tables. Signals: static or const arrays initialized with literal elements (e.g., “static const int veml6075_it_ms[] = { 50, 100, 200, 400, 800 }” from [FILE_CONTENT]); FP mitigation: exclude arrays whose size is dynamic or not determinable from initializers/compile-time constants.

2) Step 2: Find array indexing expressions that access these look-up arrays. Signals: subscripts where the base is one of the arrays from Step 1 (e.g., “veml6075_it_ms[int_index]” or “veml6075_it_ms[FIELD_GET(...)]”); FP mitigation: limit to read accesses (not writes) to align with the out-of-bounds read class described in [ROOTCAUSE_ANALYSIS].

3) Step 3: Trace the index expression back to hardware configuration reads. Signals: index derived from a variable previously populated by regmap_read (e.g., “regmap_read(..., &conf)” then “FIELD_GET(mask, conf)” as in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]); FP mitigation: require the same conf variable to feed into FIELD_GET within the same logical flow or via a small helper function (e.g., veml6075_read_int_time_index).

4) Step 4: Identify bitfield extraction on the hardware value. Signals: usage of FIELD_GET(mask, conf) where mask is a constant defined via GENMASK(high, low) (e.g., VEML6075_CONF_IT = GENMASK(6, 4) per [FILE_CONTENT]); FP mitigation: ensure mask is a compile-time constant; ignore masks computed dynamically.

5) Step 5: Estimate the potential numeric range of the extracted field. Signals: infer field width from GENMASK(high,low) as (high-low+1) bits → possible values 0..(2^width-1) (e.g., width=3→0..7 per [ROOTCAUSE_ANALYSIS]); FP mitigation: only apply when GENMASK arguments are concrete integers; if not resolvable, conservatively flag only when an obvious mismatch exists (see Step 7).

6) Step 6: Compare the array size with the potential index range. Signals: ARRAY_SIZE(array) vs. the maximum FIELD_GET value; if 2^width > ARRAY_SIZE(array), indexing without validation is potentially unsafe (e.g., 8 > 5 in [ROOTCAUSE_ANALYSIS]); FP mitigation: proceed to flag only if no guarding checks are found (Step 7).

7) Step 7: Check for nearby bounds validation guarding the index. Signals: before the array access or within a helper returning the index, look for conditions like “index >= ARRAY_SIZE(array) → error return” (e.g., patch adds this in veml6075_read_int_time_index in [PATCH_DIFF]); FP mitigation: accept patterns that enforce errors for out-of-range values or equivalent guards, including early returns or error codes.

8) Step 8: Detect direct array access using FIELD_GET without validation in the same function. Signals: “array[FIELD_GET(mask, conf)]” with no preceding or surrounding check (e.g., veml6075_request_measurement uses “veml6075_it_ms[FIELD_GET(VEML6075_CONF_IT, conf)]” per [FILE_CONTENT] and noted in [ROOTCAUSE_ANALYSIS]); FP mitigation: if a subsequent control flow guarantees safe ranges (e.g., validated switch coverage before array use), do not flag—otherwise flag.

9) Step 9: Evaluate whether switch-case coverage limits the effective index to safe values before array access. Signals: switch on the index with cases for valid enumerants and a default that errors (e.g., veml6075_get_uvi_micro has a default -EINVAL per [FILE_CONTENT]); FP mitigation: only consider this as a guard if the array is not accessed until after the switch ensures the range.

10) Step 10: Track interprocedural flow where a helper returns the index used later for array access. Signals: functions like veml6075_read_int_time_index returning an int, then used for “array[index]” in another function (e.g., veml6075_read_int_time_ms in [FILE_CONTENT]); FP mitigation: confirm no bounds checks occur in the callee or caller prior to array indexing.

11) Step 11: Preferentially flag patterns where hardware-derived indices come from wider bitfields than the number of array elements. Signals: masks spanning more values than available array entries (evidenced by GENMASK(6,4) vs. 5 entries per [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]); FP mitigation: suppress cases where masks’ effective range matches array size or where a mapping converts to safe enumerants.

12) Step 12: Rank/report findings with context showing source of index, array size, mask width, and presence/absence of validation. Signals: include function names (e.g., veml6075_request_measurement, veml6075_read_int_time_ms) and lines where array access occurs; FP mitigation: de-duplicate reports when multiple accesses share the same unvalidated index.

3. Target Elements
- Array declarations initialized with literals and their indexing expressions.
- Calls to regmap_read producing hardware configuration values (variables like conf).
- Uses of FIELD_GET with a constant mask, especially masks defined via GENMASK.
- Functions that return hardware-derived indices used by callers (e.g., helper functions like veml6075_read_int_time_index).
- Conditional checks comparing indices to ARRAY_SIZE(array) and error returns.
- Switch statements guarding enumerated index values.
- Call sites where array indexing occurs after the index computation.

4. Dataflow / Taint Considerations
- Track dataflow from regmap_read outputs (e.g., conf) through FIELD_GET(mask, conf) into variables used as array indices (including through function returns).
- Treat values derived from FIELD_GET on GENMASK-defined masks as “tainted by hardware” until validated by explicit bounds checks.
- Propagate through simple arithmetic or assignments; stop propagation once a sufficient bounds check is detected (index compared to ARRAY_SIZE and error path followed).

5. Validation & Test Cases
- Positive: A function reads conf via regmap_read, computes idx = FIELD_GET(GENMASK(6,4), conf), then accesses arr[idx] where arr has 5 elements and no prior “idx >= ARRAY_SIZE(arr)” guard (as in pre-patch veml6075_read_int_time_ms and veml6075_request_measurement from [FILE_CONTENT]).
- Negative: A function computes idx similarly but returns -EINVAL if idx >= ARRAY_SIZE(arr) before any array access (as in patched veml6075_read_int_time_index per [PATCH_DIFF]); callers check the return and only index arr when idx >= 0.
- Test harness notes: Include a case with switch guarding index values before array access (like veml6075_get_uvi_micro) and expect no flag when the array is not indexed until after validation; also include a mask whose width matches array size to ensure no false alarms.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Index normalization not recognized (e.g., mapping FIELD_GET to enumerants before use); mitigate by detecting switch-case coverage with default error prior to array access.
- Non-constant masks or arrays where sizes are not statically inferable; mitigate by requiring compile-time constants for both mask width and array size.
- Validation performed in distant callers; mitigate via interprocedural analysis to find upstream checks and suppress flags when validated paths dominate.
- Access occurs only after bounds-checked helper returns verified indices; mitigate by associating the check with the helper and recognizing error-code propagation.

8. Limitations & Assumptions
- Assumes ability to resolve GENMASK high/low to a concrete bit width; if macros are opaque, the range comparison may be conservative.
- Does not verify hardware-specific semantics beyond bit-width (e.g., device guarantees only 0–4 codes); relies on explicit code checks as evidence.
- The plan focuses on out-of-bounds reads from arrays indexed by hardware-derived fields; other OOB scenarios (e.g., pointer arithmetic) are out of scope.
- Based on [ROOTCAUSE_ANALYSIS], there may be unaddressed direct index uses (e.g., in veml6075_request_measurement); detection assumes similar patterns elsewhere.