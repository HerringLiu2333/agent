1. CVE Identifier
CVE-2025-40114

2. Vulnerability Type
Out-of-bounds read due to missing bounds validation (array index bounds violation)

3. Root Cause Summary
The driver extracts the integration time index from the device configuration register using FIELD_GET(VEML6075_CONF_IT, conf), where VEML6075_CONF_IT spans bits [6:4] and can yield values 0–7. It then uses this value directly to index the fixed-size array veml6075_it_ms[] which has only 5 elements [50, 100, 200, 400, 800], without validating that the index is < ARRAY_SIZE(veml6075_it_ms). This flawed logic allows out-of-bounds reads when the hardware reports an integration time code 5–7. The patch adds a bounds check in veml6075_read_int_time_index and returns -EINVAL for out-of-range values, preventing subsequent array overruns.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) subsystem, Vishay VEML6075 UVA/UVB light sensor driver (drivers/iio/light/veml6075)

2) Pre-Patch Flaw:
- In veml6075_read_int_time_index, the function returned FIELD_GET(VEML6075_CONF_IT, conf) directly, with no range checking.
- In veml6075_read_int_time_ms, that unchecked index was used: “*val = veml6075_it_ms[int_index];” causing potential OOB read.
- Additionally, veml6075_request_measurement indexed the same array with “veml6075_it_ms[FIELD_GET(VEML6075_CONF_IT, conf)]” without validation (not addressed by this patch).

3) Trigger Condition:
If regmap_read() returns a VEML6075_CMD_CONF value where VEML6075_CONF_IT bits are 5–7 (e.g., broken/misbehaving hardware), functions that translate the index to milliseconds access veml6075_it_ms[] beyond its bounds.

4) Impact Mechanism:
Out-of-bounds read from a small const array can return undefined values, corrupting logic (e.g., reporting an invalid integration time or computing an invalid sleep duration). Depending on the read value, this can lead to incorrect delays, potential large sleeps, or other unpredictable behavior within the kernel driver.

5. Patch Analysis
1) Fix Approach:
Input validation: introduce bounds checking for the integration time index before it is returned and subsequently used to index veml6075_it_ms[]; return -EINVAL when the index is outside the supported range.

2) Key Code Changes:
- In veml6075_read_int_time_index:
  - Added a local int_index = FIELD_GET(VEML6075_CONF_IT, conf);
  - Added “if (int_index >= ARRAY_SIZE(veml6075_it_ms)) return -EINVAL;”
  - Return int_index on success.
This ensures callers (e.g., veml6075_read_int_time_ms and veml6075_get_uvi_micro) receive an error instead of an unsafe index. No changes were made to veml6075_request_measurement’s direct array indexing.

3) Locking/Concurrency Impact:
No locking changes. Existing guard(mutex) use in callers (e.g., veml6075_read_int_time_ms) remains unchanged; the patch solely adds validation logic and error propagation.

6. Broader Kernel Security Implications
This hardening prevents memory safety issues when device-provided configuration values are out of the expected enumeration range, a common pattern in drivers that map register fields to array lookups. Enforcing bounds checks reduces the risk of subtle kernel misbehavior caused by “broken hardware” or transient read errors. Similar validations should be audited across other drivers that use register-field values as array indices, especially for small lookup tables derived from device configuration bits.