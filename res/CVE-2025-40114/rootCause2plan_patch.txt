1. Plan Summary
Detect unvalidated indices derived from hardware register bitfields (e.g., FIELD_GET after regmap_read) that are used to index fixed-size arrays without proper bounds checks, leading to potential out-of-bounds reads as in CVE-2025-40114.

2. Detection Steps
1) Step 1: Objective — Identify hardware-derived values. Signals — Variables assigned via calls reading device registers (e.g., regmap_read) and holding register contents (as in conf in [PATCH_DIFF]). FP mitigation — Restrict sources to known hardware-read APIs seen in the evidence and mark only values directly or transitively data-dependent on them.

2) Step 2: Objective — Find extraction of bitfield-based indices. Signals — Values obtained by extracting bitfields from hardware-derived registers using FIELD_GET or equivalent bitmask/shift operations (as in FIELD_GET(VEML6075_CONF_IT, conf) in [PATCH_DIFF]). FP mitigation — Require that the extraction targets an index-like use (integer result used later as subscript or returned).

3) Step 3: Objective — Track index candidates interprocedurally. Signals — Functions that return the extracted field without validating range (pre-patch veml6075_read_int_time_index returned FIELD_GET directly per [ROOTCAUSE_ANALYSIS]). FP mitigation — Exclude functions that perform explicit range checks before return (e.g., idx >= ARRAY_SIZE(...) => error as in [PATCH_DIFF]).

4) Step 4: Objective — Identify fixed-size arrays as potential sinks. Signals — Static or const arrays with statically known length (e.g., veml6075_it_ms referenced in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation — Prefer arrays whose size can be computed in the TU (ARRAY_SIZE or explicit initializer length).

5) Step 5: Objective — Detect array indexing with candidate indices. Signals — Subscript expressions where the index expression is dataflow-dependent on the extracted bitfield value or on a function return carrying it (e.g., caller of veml6075_read_int_time_index using result to subscript veml6075_it_ms per [ROOTCAUSE_ANALYSIS]). FP mitigation — Require a clear dataflow path from hardware read → bitfield extract → index use.

6) Step 6: Objective — Check for absence of dominating range validation. Signals — No prior control-flow-dominating conditions ensuring idx < array_length or idx <= max_valid within the execution path to the subscript (pre-patch lacked any such check per [ROOTCAUSE_ANALYSIS]). FP mitigation — Recognize validation via comparisons to ARRAY_SIZE(array), explicit constants matching size, or early error returns on invalid values.

7) Step 7: Objective — Recognize validations implemented in callee functions. Signals — Callee that returns index performs an explicit bounds check and returns an error (e.g., -EINVAL) if idx >= ARRAY_SIZE(...) as added in [PATCH_DIFF]. FP mitigation — In callers, confirm error paths are respected (e.g., check for negative return before indexing) and suppress if enforced.

8) Step 8: Objective — Identify alternative clamping or mapping validations. Signals — Code that clamps index to a valid range (min/max) or guards with switch/if limiting to 0..N-1 before indexing. FP mitigation — Treat such constructs as sufficient validation if they provably constrain the index to array bounds.

9) Step 9: Objective — Flag unsafe paths even with partial checks. Signals — Checks against unrelated constants, off-by-one errors, or checks applied to a different variable than the one used to index (pre-patch had no check at all; this step generalizes). FP mitigation — Require that the exact index variable used in the subscript is the one validated and that the comparison enforces idx < array_size.

10) Step 10: Objective — Prioritize reports where hardware can exceed array size. Signals — Bitfield width or comment names indicate range larger than array (e.g., 0–7 vs 5 elements per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]); when statically deducible, highlight higher risk. FP mitigation — If the index was further masked to fit array length (e.g., & (size-1) where size is a power-of-two and equals array length), suppress.

11) Step 11: Objective — Report with path context. Signals — Construct trace: regmap_read → FIELD_GET (or bit extraction) → function return (optional) → array index with missing validation, matching the flow in [ROOTCAUSE_ANALYSIS]. FP mitigation — Only emit when a full path exists and no adequate guard dominates the sink.

12) Step 12: Objective — Special-case kernel error-code flows. Signals — If helper may return negatives (as after patch) but caller fails to reject negatives before indexing, flag usage; if caller checks for negative, suppress. FP mitigation — Require path feasibility where negative values could reach subscript without checks to avoid over-reporting.

3. Target Elements
- Function bodies performing register reads (e.g., regmap_read) and subsequent bitfield extraction (FIELD_GET/mask-shift).
- Function return values that carry indices derived from hardware fields (e.g., veml6075_read_int_time_index).
- Array declarations with statically known sizes (e.g., static tables like veml6075_it_ms).
- Array subscript expressions using candidate indices.
- Conditional checks comparing indices to array size or constants.
- Call sites where returned indices are consumed, including error-code checks.

4. Dataflow / Taint Considerations
- Track taint from hardware register reads through bitfield extraction into index variables.
- Propagate across assignments, arithmetic that doesn’t reduce range, and function returns.
- Treat range-constraining operations and dominating guards as taint sanitizers (e.g., idx < ARRAY_SIZE(arr), early return on idx >= size, clamping via min/max).
- Ensure path sensitivity so that only unguarded paths to array indexing are reported.

5. Validation & Test Cases
- Positive: Function returns FIELD_GET(conf, …) from a regmap_read-derived conf; caller uses it as arr[idx] where arr has 5 elements; no prior idx < 5 check — should be reported (mirrors pre-patch behavior in [ROOTCAUSE_ANALYSIS]).
- Positive: Helper returns bitfield 0–7; caller directly indexes a 5-element table; no check — report.
- Negative: Helper checks if idx >= ARRAY_SIZE(table) return -EINVAL; caller tests ret < 0 before using idx — suppress (matches [PATCH_DIFF]).
- Negative: Caller does if (idx < ARRAY_SIZE(table)) use table[idx]; else error — suppress.
- Negative: Index is clamped: idx = min(idx, ARRAY_SIZE(table)-1); then used — suppress.

- Test harness notes: Include interprocedural case (helper returns index) and intraprocedural case (direct use), and verify dominance analysis by placing checks on alternate branches.

6. Estimated Effort & Priority
Medium — requires interprocedural dataflow, dominance/guard analysis, and recognition of validation patterns similar to the patch.

7. Likely False-Positive Sources & Mitigations
- Implicit hardware constraints not visible to static analysis (mitigate by requiring explicit software validation).
- Arrays whose effective size is larger than declared (e.g., overlay semantics) not inferable (mitigate by focusing on concrete static arrays).
- Complex validation via indirect helpers not modeled (mitigate by allowing users to configure recognized sanitizer helpers).
- Bitfield extraction that inherently bounds the value to array length (mitigate by detecting masking/clamping aligned with array size).

8. Limitations & Assumptions
- Assumes regmap_read and FIELD_GET-like patterns denote hardware-derived indices based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; other hardware APIs may be missed.
- Cannot always deduce the true value range of a hardware bitfield; relies on explicit software checks as in the fix.
- Availability of ARRAY_SIZE or static array lengths is assumed; dynamic arrays or macros obscuring size may limit precision.
- Error-code semantics (-EINVAL) are assumed conventional as per [PATCH_DIFF]; checker treats any negative return as error unless proven otherwise.