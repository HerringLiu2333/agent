1. Plan Summary
Detect out-of-bounds array indexing where an index derived from a hardware register field (via regmap_read and FIELD_GET) is used to access a fixed-size lookup array without an explicit upper-bound check.

2. Detection Steps
1) Step 1: Objective — Find array lookups into fixed-size/local lookup arrays. Signals — Subscript operations indexing a statically-sized array (global/static/local) such as veml6075_it_ms (per [FUNCTION_CONTENT], [ROOTCAUSE_ANALYSIS]). FP mitigation — Exclude dynamically sized arrays or pointers where size cannot be determined.

2) Step 2: Objective — Identify the index expression variable used in those array accesses. Signals — The index is a local int or a value returned from a function call (e.g., veml6075_read_int_time_index) subsequently used as arr[index] (per [FUNCTION_CONTENT]). FP mitigation — Skip cases where index is a compile-time constant proven in-range.

3) Step 3: Objective — Trace the index’s origin to hardware-derived sources. Signals — Backward dataflow from index to operations involving regmap_read and FIELD_GET extracting a field from a read register (as shown in [PATCH_DIFF] and [FUNCTION_CONTENT]). FP mitigation — Require both signals: a regmap_read on a register and a FIELD_GET-based bit extraction along the dataflow path.

4) Step 4: Objective — Recognize indices supplied via helper functions that forward hardware-derived values. Signals — A function returns an int computed from FIELD_GET on a value read by regmap_read, with no in-function bounds check against the target array size (pre-patch behavior per [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]). FP mitigation — Confirm the helper has at least one path that returns the extracted field directly without any comparison to ARRAY_SIZE(target_array) (per [PATCH_DIFF] fix).

5) Step 5: Objective — Check for missing upper-bound validation at the use site. Signals — Before the array access, absence of a dominating conditional that ensures index < ARRAY_SIZE(the same array) or an equivalent constant bound; presence of only “index < 0” checks (seen in [FUNCTION_CONTENT]) does not satisfy upper-bound validation (per [ROOTCAUSE_ANALYSIS]). FP mitigation — Require control-flow dominance of a proper upper-bound guard at the access point; treat negative-error checks alone as insufficient.

6) Step 6: Objective — Check for missing upper-bound validation in the producer helper (if the index comes from a call). Signals — In the callee, absence of “if (idx >= ARRAY_SIZE(target_array)) return -EINVAL;” or equivalent guard (fix per [PATCH_DIFF]). FP mitigation — If the callee validates against the specific array (post-patch pattern), do not flag callers using that return value.

7) Step 7: Objective — Account for multi-hop dataflow through assignments. Signals — Index value propagates through variable copies, returns, and parameter passing without transformations that constrain the value (per [FUNCTION_CONTENT] pattern). FP mitigation — Treat as safe if a clamp, min() with array length, or an explicit mask/modulo that ensures index < array length is found dominating the use.

8) Step 8: Objective — Flag direct unsanitized FIELD_GET use at indexing sites. Signals — arr[FIELD_GET(...)] where the FIELD_GET’s input is from regmap_read and no dominating upper-bound check exists (analogous to pre-patch semantics inlined). FP mitigation — Require both FIELD_GET and prior regmap_read on the same conf/variable on the path.

9) Step 9: Objective — Differentiate error-handling checks from bound checks. Signals — Patterns like “if (idx < 0) return idx;” appear, but no check against ARRAY_SIZE(arr) follows (per [FUNCTION_CONTENT]). FP mitigation — Explicitly ignore negative-only checks as adequate validation (per [ROOTCAUSE_ANALYSIS] showing they’re insufficient).

10) Step 10: Objective — Correlate the specific array with the validation. Signals — When a bound check exists, ensure it compares the same index to the same array’s size (e.g., ARRAY_SIZE(veml6075_it_ms)), matching the fix in [PATCH_DIFF]. FP mitigation — Do not consider unrelated comparisons (different arrays/limits) as sufficient guards.

11) Step 11: Objective — Prioritize likely lookup tables. Signals — Arrays referenced by a small set of discrete indices derived from bit-field values, used in “read path” functions returning a scalar (pattern shown in [FUNCTION_CONTENT] and described in [ROOTCAUSE_ANALYSIS]). FP mitigation — Deprioritize if the array is not a local/static lookup table and the index is later range-restricted.

12) Step 12: Objective — Report only when both conditions hold: hardware-derived index and missing upper-bound validation before use. Signals — Combined predicate from Steps 3–5/8 shows array access without a dominating upper-bound guard and index tainted by regmap_read + FIELD_GET (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]). FP mitigation — Require a complete path summary from regmap_read to the array access to avoid spurious matches.

3. Target Elements
- Array subscripts into fixed-size arrays (global/static/local lookup arrays).
- Functions that return integers derived from register reads (regmap_read) and FIELD_GET.
- Call sites where such functions’ return values are used as indices.
- Conditionals that compare the index against ARRAY_SIZE(array) or equivalent constants.
- Macro uses: FIELD_GET, ARRAY_SIZE.
- Return-value checks for negative errors (idx < 0) preceding array access.

4. Dataflow / Taint Considerations
- Taint sources: values read via regmap_read; results of FIELD_GET applied to those values.
- Taint propagation: through assignments, returns, and parameters without bounding transformations.
- Sanitizers: dominating checks ensuring index < ARRAY_SIZE(target array) or an equivalent upper bound; value clamps (min with array length), modulo operations constraining below length.
- Non-sanitizers: checks only for negativity (idx < 0), as evidenced in [FUNCTION_CONTENT] and deemed insufficient in [ROOTCAUSE_ANALYSIS].

5. Validation & Test Cases
- Positive: Pre-patch pattern where veml6075_read_int_time_index returns FIELD_GET(...) without checking against ARRAY_SIZE(veml6075_it_ms), and caller does “if (idx < 0) return idx;” then “val = veml6075_it_ms[idx];” (from [FUNCTION_CONTENT]).
- Negative: Post-patch pattern adding “if (idx >= ARRAY_SIZE(veml6075_it_ms)) return -EINVAL;” inside the helper before returning idx (from [PATCH_DIFF]); caller uses idx to index the array.
- Negative: Caller performs “if (idx >= ARRAY_SIZE(veml6075_it_ms)) return -EINVAL;” immediately before indexing.
- Positive: Direct use “val = veml6075_it_ms[FIELD_GET(...regmap_read...)]” with no upper-bound guard.

- Test harness notes: Validate interprocedural flow from regmap_read/FIELD_GET through helper return to array access; verify dominance analysis of bound checks and recognition of negative-only checks as insufficient.

6. Estimated Effort & Priority
High — interprocedural dataflow, dominance analysis for guards, and macro-awareness (FIELD_GET/ARRAY_SIZE) are required; the issue leads to kernel out-of-bounds reads (per [ROOTCAUSE_ANALYSIS], [PATCH_DESCRIPTION]).

7. Likely False-Positive Sources & Mitigations
- Hardware fields guaranteed by spec to be within range but not explicitly checked in code — mitigate by requiring explicit upper-bound validation or accept as intended hardening gap (aligned with [PATCH_DESCRIPTION] “hardening” rationale).
- Bound checks expressed via nonstandard idioms (custom clamp helpers) — mitigate by recognizing common clamp/min patterns as sanitizers.
- Arrays whose effective length is not statically known — mitigate by focusing on statically-sized arrays or those used with ARRAY_SIZE elsewhere.
- Paths where sanitization occurs in distant callers — mitigate with interprocedural dominance/context tracking and require the guard to dominate the access.

8. Limitations & Assumptions
- Assumes availability to identify regmap_read and FIELD_GET semantics; other register-read APIs are not considered because only these are evidenced (per [PATCH_DIFF]/[FUNCTION_CONTENT]).
- Cannot infer true hardware value ranges; flags rely on absence of explicit bound checks as per the fix (per [PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS]).
- Assumes ARRAY_SIZE can be resolved; if macro expansion is unavailable, some safe cases may be misclassified.
- Does not reason about concurrency or locking; the guard(mutex) noted in [FUNCTION_CONTENT] is irrelevant to bounds safety.