1. Plan Summary
Detect patterns where a refcount decrement-and-test on an object occurs while its mutex is held, followed by unlocking that mutex and conditionally freeing the object after the unlock, which matches the use-after-free hazard described for eventpoll.

2. Detection Steps
1) Step 1: Identify mutex-guarded regions on a specific object (e.g., ep) by finding mutex_lock(&obj->mtx) or lockdep_assert_held(&obj->mtx). Signals: calls to mutex_lock or lockdep_assert_held on a field mtx of the same object variable. FP mitigation: require the same base object variable on lock and subsequent operations.

2) Step 2: Within the locked region, find calls to a refcount decrement-and-test function on the same object (e.g., ep_refcount_dec_and_test(ep)). Signals: function calls whose name or semantics indicate refcount dec-and-test and whose argument aliases the locked object. FP mitigation: restrict to functions whose result influences object lifetime (used to decide free), excluding counters like percpu_counter_dec.

3) Step 3: Check the control-flow for a subsequent mutex_unlock(&obj->mtx) that uses the same object’s mutex after the refcount call. Signals: mutex_unlock on the same obj->mtx, post-dominating or following the decrement within the same function. FP mitigation: ensure order (dec inside lock, unlock later) by CFG position, and same object identity.

4) Step 4: Detect if the refcount result computed under the lock is used after unlocking to conditionally free or dispose the object (e.g., if (dispose) ep_free(ep)). Signals: a boolean/flag (dispose) set from the decrement-and-test under lock and checked after unlock for ep_free(obj) or similar destructor. FP mitigation: require that the free function’s argument aliases the decremented object.

5) Step 5: Flag helper functions that assert the mutex is held (lockdep_assert_held(&obj->mtx)) and return the refcount_dec_and_test result (e.g., __ep_remove returning ep_refcount_dec_and_test(ep)). Signals: return statements under lock returning a refcount-dec-and-test call. FP mitigation: only report when callers unlock afterward and use that return to free.

6) Step 6: Connect interprocedural flows where a caller locks, calls the helper returning the refcount decision, unlocks, then frees based on that decision (as in eventpoll_release_file). Signals: call graph path: lock → call helper → unlock → conditional free using callee return. FP mitigation: require unlock and free to be in the caller’s CFG path and object identity alignment.

7) Step 7: In single-function cases, detect patterns like dispose = ep_refcount_dec_and_test(obj) inside lock; later mutex_unlock(&obj->mtx); then if (dispose) free(obj) (pre-patch ep_clear_and_put). Signals: local variable assignment from dec-and-test before unlock, conditional free after unlock. FP mitigation: require the dispose variable not reassigned between dec and free.

8) Step 8: Exclude cases where the refcount decrement occurs after unlocking (post-patch safe pattern in ep_clear_and_put and eventpoll_release_file). Signals: dec-and-test call textually and CFG-wise after mutex_unlock. FP mitigation: CFG check that unlock precedes dec-and-test.

9) Step 9: Exclude cases where free happens within the locked region without an intervening unlock (not the documented hazard). Signals: ep_free(obj) called before unlock in the same function. FP mitigation: ensure the suspicious pattern specifically has unlock before free.

10) Step 10: Optionally flag comments or assertions indicating locked state (lockdep_assert_held), but use them only to strengthen confidence, not as sole signals. Signals: presence of lockdep_assert_held near refcount call. FP mitigation: do not rely exclusively on comments/assertions; require structural lock/unlock evidence.

11) Step 11: Prioritize findings where the refcount function is specific to the object type and known to gate freeing (e.g., ep_refcount_dec_and_test used with ep_free(ep)). Signals: pairing of dec-and-test with a concrete free function of the same object. FP mitigation: require concrete free function usage in the same path.

12) Step 12: Suppress findings if the returned refcount decision is explicitly documented or modeled to delay actual free until after unlock (not shown here), otherwise report as high risk per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]. Signals: absence of delayed-free mechanism in the same function. FP mitigation: only report when no delayed-free wrapper is present in the locked region.

3. Target Elements
- Functions that perform mutex_lock/mutex_unlock on an object’s mutex field (e.g., ep->mtx) or assert lock held.
- Calls to refcount decrement-and-test functions affecting object lifetime (e.g., ep_refcount_dec_and_test(ep)).
- Variables capturing refcount decisions (e.g., dispose) and return values from helpers that encapsulate refcount changes (e.g., __ep_remove’s return).
- Call sites to free/destructor functions for the object (e.g., ep_free(ep)).
- Interprocedural sequences crossing helper functions that operate under lock and callers that unlock and free.

4. Dataflow / Taint Considerations
- Track the flow of the object variable used for locking (obj) through calls to refcount dec-and-test and free; require aliasing to the same base object.
- Track boolean/dataflow from refcount dec-and-test result to post-unlock free decisions (local variable assignment, function return).
- Model lock region boundaries and ensure the dec occurs in the locked region while free occurs after the unlock on the same object.

5. Validation & Test Cases
- Positive: Pre-patch ep_clear_and_put where dispose = ep_refcount_dec_and_test(ep) under ep->mtx, then mutex_unlock(&ep->mtx), then if (dispose) ep_free(ep) (from [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]); expect a report.
- Positive: Pre-patch eventpoll_release_file where dispose = __ep_remove(ep, epi, true) (helper returns dec result under lock), then mutex_unlock(&ep->mtx), then if (dispose) ep_free(ep) (from [FUNCTION_CONTENT]); expect a report.
- Positive: Pre-patch __ep_remove returning ep_refcount_dec_and_test(ep) while lockdep_assert_held(&ep->mtx) (from [FUNCTION_CONTENT]); reported via interprocedural step when a caller unlocks then frees based on return.
- Negative: Post-patch ep_clear_and_put where ep_refcount_dec_and_test(ep) is moved after mutex_unlock(&ep->mtx) and then ep_free(ep) (from [PATCH_DIFF]); expect no report.
- Negative: Post-patch eventpoll_release_file where unlock happens, then condition combines dispose && ep_refcount_dec_and_test(ep) before ep_free(ep) (from [PATCH_DIFF]); expect no report.
- Test harness notes: Build small kernelscope stubs emulating lock/dec/unlock/free sequences and verify interprocedural propagation of the dispose flag and object identity.

6. Estimated Effort & Priority
High: concurrency lifetime bugs are severe (use-after-free), and the checker requires interprocedural control/dataflow plus lock-region modeling.

7. Likely False-Positive Sources & Mitigations
- Refcount-like functions that do not actually control object lifetime; mitigate by requiring their result to gate a destructor on the same object.
- Unlocks on a different mutex than the object’s (alias confusion); mitigate via strict object field matching (same base variable ->mtx).
- Custom delayed-free mechanisms not visible to the checker; mitigate by scanning for known delayed-free wrappers and suppressing when present.
- Macros or inlined abstractions obscuring lock/unlock boundaries; mitigate via expanding common kernel patterns or recognizing lockdep_assert_held.

8. Limitations & Assumptions
- Assumes refcount_dec_and_test naming/semantics similar to ep_refcount_dec_and_test; other projects may use different names not captured here.
- Cannot prove “next-to-last reference” runtime scenario; flags structural risk based on [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].
- Assumes free/destructor functions are identifiable (e.g., ep_free); mapping to object lifetime is based on [FUNCTION_CONTENT]/[PATCH_DIFF].
- Does not model kernel mutex internals beyond the documented hazard; relies on ordering: dec under lock, unlock, free after.