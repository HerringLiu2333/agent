1. Plan Summary
Detect patterns where a refcount on an object is decremented-and-tested while the object's mutex is held, followed by unlocking that mutex, which can lead to use-after-free during mutex_unlock() (as in eventpoll’s ep_refcount_dec_and_test under ep->mtx).

2. Detection Steps
1) Step 1: Identify functions or code blocks that acquire an object-specific mutex (e.g., mutex_lock/mutex_lock_nested with &obj->mtx) and later call mutex_unlock on the same mutex; this sets the critical section scope. Signals: calls to mutex_lock*/mutex_unlock with the same address-of field expression &X->mtx and consistent alias within the function. FP mitigation: require a concrete field dereference (not unknown pointers) and match the exact same object expression between lock and unlock.

2) Step 2: Within such a critical section, find calls that decrement-and-test the object’s refcount, specifically ep_refcount_dec_and_test(ep) or refcount_dec_and_test(&ep->refcount), before the corresponding mutex_unlock. Signals: a call expression to ep_refcount_dec_and_test with the same object whose mtx is held, or a call to refcount_dec_and_test on that object's refcount field. FP mitigation: ensure the callee is the known lifetime-affecting function and the argument is the same object instance as the locked mutex.

3) Step 3: Flag cases where the decrement-and-test result is stored (e.g., “dispose = ep_refcount_dec_and_test(ep)”) or returned from a helper that must be called with mtx held, and the function then executes mutex_unlock(&ep->mtx). Signals: assignment or return of the dec-and-test value in a function with comments/annotations “Must be called with ‘mtx’ held” (as in __ep_remove), followed by unlock. FP mitigation: restrict to functions that either lock ep->mtx locally or assert it is held (lockdep_assert_held(&ep->mtx)) and ensure unlock happens on the same mutex.

4) Step 4: Detect interprocedural pattern where a helper called under lock returns the dec-and-test decision, and the caller unlocks and potentially frees based on that decision. Signals: callee returns boolean from ep_refcount_dec_and_test(ep) while lock is held (e.g., pre-patch __ep_remove), caller subsequently calls mutex_unlock(&ep->mtx). FP mitigation: require that the object passed to the callee is the same one whose mutex is unlocked by the caller.

5) Step 5: Highlight sequences where ep_free(ep) or equivalent destructor is reachable after the unlock, and the dec-and-test affecting the same object happened before the unlock. Signals: control-flow path: [dec-and-test under lock] -> [mutex_unlock(&obj->mtx)] -> [if (dec) free(obj)]. FP mitigation: require that free is gated by the same boolean computed by the earlier dec-and-test, and that boolean is not recomputed after unlock (pre-patch pattern).

6) Step 6: Prioritize matches that occur in functions documented as “Must be called with ‘mtx’ held” performing refcount dec-and-test internally (evidence: __ep_remove in [FILE_CONTENT]), since this shows the problematic lifetime decision is made under lock. Signals: presence of such documentation comments near function definitions. FP mitigation: combine with explicit dec-and-test call detection to avoid flagging unrelated “must hold mtx” functions.

7) Step 7: Exempt safe, patched patterns where ep_refcount_dec_and_test(ep) is moved outside the mutex critical section. Signals: dec-and-test occurs only after mutex_unlock(&ep->mtx) and not within lock-held region (evidence: ep_clear_and_put and eventpoll_release_file changes in [PATCH_DIFF]). FP mitigation: ensure the checker requires dec-and-test to be inside the critical section to flag.

8) Step 8: Exclude cases where the dec-and-test targets a different object than the one protected by the held mutex (e.g., decrementing a peer’s refcount while holding an unrelated mutex). Signals: mismatch between the object in &obj->mtx and the object whose refcount is decremented. FP mitigation: object identity check on both the mutex field and the refcount target.

9) Step 9: Mark additional risk if the dec-and-test value is propagated via a return value used by a caller that unlocks and frees, mirroring the “dispose” propagation (evidence: pre-patch __ep_remove returning dispose, [ROOTCAUSE_ANALYSIS]). Signals: callee returns a boolean directly from dec-and-test; caller uses it after unlocking for freeing or warning. FP mitigation: require direct or simple propagation (no complex transformations) of that boolean.

10) Step 10: Detect WARN_ON/WARN_ON_ONCE patterns reliant on dec-and-test within lock-held contexts (evidence: ep_remove_safe pre-patch and patched patterns in [PATCH_DIFF]) as further indications of refcount lifetime decisions under lock. Signals: WARN_ON_ONCE(ep_refcount_dec_and_test(ep)) occurring while lock is held. FP mitigation: still require the presence of a subsequent unlock to tie to the UAF scenario.

3. Target Elements
- Functions that lock/unlock a field mutex of a struct (e.g., &ep->mtx).
- Call sites of lifetime-affecting refcount operations: ep_refcount_dec_and_test(ep), refcount_dec_and_test(&ep->refcount).
- Boolean variables or return values carrying dec-and-test results (e.g., dispose).
- Calls to ep_free(ep) or equivalent destructor routines.
- Functions annotated or commented as “Must be called with ‘mtx’ held” and those asserting lock held (lockdep_assert_held).

4. Dataflow / Taint Considerations
- Track the flow of the dec-and-test boolean from its origin (ep_refcount_dec_and_test) to uses after unlock (e.g., freeing decisions).
- Model the lock-held region as a CFG slice between mutex_lock and mutex_unlock on the same object to constrain where dec-and-test occurs.
- Correlate object identity across the mutex field (&obj->mtx) and refcount field (&obj->refcount) to ensure the same object is involved.

5. Validation & Test Cases
- Positive: Pre-patch ep_clear_and_put() that assigns dispose = ep_refcount_dec_and_test(ep) while ep->mtx is held, then mutex_unlock(&ep->mtx), then if (dispose) ep_free(ep); expect a finding.
- Positive: Pre-patch __ep_remove() that returns ep_refcount_dec_and_test(ep) under “Must be called with ‘mtx’ held”, with caller later unlocking; expect a finding.
- Negative: Patched ep_clear_and_put() where mutex_unlock(&ep->mtx) precedes ep_refcount_dec_and_test(ep); expect no finding.
- Negative: A function that decrements a refcount of a different object while holding ep->mtx and then unlocks ep->mtx; expect no finding.
- Test harness notes: Run on fs/eventpoll.c before and after [PATCH_DIFF]; ensure only pre-patch sites are flagged.

6. Estimated Effort & Priority
High: requires lock/unlock pairing, object field correlation, and limited interprocedural boolean propagation.

7. Likely False-Positive Sources & Mitigations
- Cases where dec-and-test under lock is benign due to guaranteed last reference: hard to determine; mitigate by focusing on presence of subsequent unlock and potential free decision path.
- Lock aliasing or wrapper functions obscuring lock identity: mitigate by matching exact field expressions (&obj->mtx) or lockdep assertions.
- General refcount operations not tied to object’s own mutex: mitigate via strict object identity matching between mutex and refcount target.

8. Limitations & Assumptions
- Assumes the problematic functions are named ep_refcount_dec_and_test or use refcount_dec_and_test on the same object’s refcount; other lifetime APIs are not covered due to lack of evidence.
- Cannot determine “last vs next-to-last” reference statically; flags all dec-and-test under lock as risky per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].
- Interprocedural analysis is limited to simple return/assignment of the dispose boolean; deeper dataflow across multiple layers may not be captured.