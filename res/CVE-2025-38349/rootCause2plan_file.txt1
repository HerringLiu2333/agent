1. Plan Summary
Detect code paths that decrement an object’s refcount while holding the object’s mutex and then unlock that same mutex afterward, which can cause a use-after-free during mutex_unlock as demonstrated in fs/eventpoll pre-patch flows.

2. Detection Steps
1) Step 1: Identify candidate “lifetime-managed” objects that combine a mutex and a refcount. Signals: struct types containing a mutex field (e.g., mtx) and a refcount field (e.g., refcount_t refcount), and functions using mutex_lock/mutex_unlock on &obj->mtx.

2) Step 2: Model refcount drop-and-test operations for those objects. Signals: calls to refcount_dec_and_test(&obj->refcount) or wrapper functions like ep_refcount_dec_and_test(obj) whose implementation uses refcount_dec_and_test on the same object.

3) Step 3: Find regions where the object’s mutex is held. Signals: code sequences dominated by mutex_lock/mutex_lock_nested on &obj->mtx and eventually followed by mutex_unlock(&obj->mtx) on the same object.

4) Step 4: Within a held-mutex region, detect a refcount drop-and-test executed before the matching mutex_unlock on the same object. Signals: a control-flow-ordered call to refcount_dec_and_test (or wrapper) that occurs strictly prior to mutex_unlock(&obj->mtx) in the same function.

5) Step 5: Detect functions that compute and return the drop-and-test result while the mutex is held (interprocedural source). Signals: a function that asserts or implies ep->mtx is held (e.g., lockdep_assert_held or documentation/usage) and returns ep_refcount_dec_and_test(obj) or stores its result, as seen pre-patch in __ep_remove.

6) Step 6: At call sites of such functions, detect the pattern “boolean result from callee” → unlock → possibly free. Signals: code that assigns dispose = callee(...), then does mutex_unlock(&obj->mtx), and then uses dispose to decide to free the object (e.g., ep_free(obj)), as in eventpoll_release_file and ep_clear_and_put.

7) Step 7: Detect local-variable gating of free computed under the lock and used after unlock. Signals: computing dispose = refcount_dec_and_test(obj) while holding &obj->mtx, then unlocking, then “if (dispose) free(obj)”, as in pre-patch ep_clear_and_put.

8) Step 8: Confirm object identity between refcount and mutex operations. Signals: alias analysis showing the same base pointer (e.g., ep) is passed to both refcount_dec_and_test (or wrapper) and mutex_unlock(&ep->mtx), and governs ep_free(ep).

9) Step 9: Strengthen confidence by recognizing that the free routine destroys the mutex or the object. Signals: free function (e.g., ep_free(ep)) calls mutex_destroy(&ep->mtx) and kfree(ep), indicating mutex_unlock can read freed memory if another thread frees in-between.

10) Step 10: Flag as vulnerable when either the intra-procedural ordering (Step 4) or the inter-procedural return-then-unlock pattern (Step 6/7) is observed for the same object. Signals: presence of any path where refcount drop-and-test occurs while the mutex is held and the unlock happens after that decrement.

11) Step 11: Optionally annotate severity if the returned boolean from the callee is used to trigger free after unlock. Signals: dispose controlling a call to ep_free(obj) post-unlock, matching the documented UAF scenario for the “next-to-last” reference.

12) Step 12: Report the precise source locations for the decrement-under-lock and the subsequent unlock (and free if present), with an explanation that mutexes do not enforce lifetime and mutex_unlock may still access the mutex structure post-release per the described semantics.

3. Limitations & Assumptions
- This plan assumes the refcount drop-and-test is identifiable via refcount_dec_and_test and wrappers like ep_refcount_dec_and_test; other custom lifetime APIs may be missed.
- Proving the “last vs. next-to-last” reference is not feasible statically; the checker warns on the unsafe ordering regardless of reference count state.
- Interprocedural lock-holding knowledge relies on usage patterns (e.g., lockdep_assert_held) or call-context; if absent, the checker approximates based on call ordering and unlock presence.
- Alias resolution must infer that the same object is used for both refcount and mutex operations; complex aliasing may cause false positives or negatives.