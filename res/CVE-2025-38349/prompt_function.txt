1. CVE Identifier
CVE-2025-38349

2. Vulnerability Type
Use-after-free due to refcount/lifetime mismanagement with incorrect mutex usage

3. Root Cause Summary
Pre-patch code decremented the struct eventpoll reference count while ep->mtx was held, then performed mutex_unlock(&ep->mtx). In the “next-to-last reference” case, another thread could acquire the mutex, drop its own reference, and free the eventpoll object while the first thread was still executing mutex_unlock(), which may still access the mutex structure. This creates a use-after-free of the eventpoll object because mutexes cannot be used to protect object lifetime across unlock operations.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fs/eventpoll (epoll)

2) Pre-Patch Flaw:
- __ep_remove() performed ep_refcount_dec_and_test(ep) under ep->mtx and returned its result: “return ep_refcount_dec_and_test(ep);” with lockdep_assert_held(&ep->mtx).
- ep_clear_and_put() dropped the ep refcount before unlocking: “dispose = ep_refcount_dec_and_test(ep); mutex_unlock(&ep->mtx);”.
- eventpoll_release_file() relied on __ep_remove() to decrement the refcount under the mutex, then unlocked and freed based on that result: “dispose = __ep_remove(ep, epi, true); mutex_unlock(&ep->mtx); if (dispose) ep_free(ep);”.
These patterns incorrectly used the mutex to guard object lifetime, violating documented mutex semantics.

3) Trigger Condition:
Concurrent operations on the same eventpoll instance where one thread drops the “next-to-last” reference under ep->mtx and then calls mutex_unlock(), while a second thread acquires the mutex, drops the last reference, and frees the eventpoll object. The first thread’s mutex_unlock() still accesses the freed ep->mtx, leading to UAF.

4) Impact Mechanism:
Use-after-free of struct eventpoll during mutex_unlock(), potentially causing memory corruption, kernel crashes, or other undefined behavior when the freed epoll structure (or its mutex) is touched during unlock cleanup.

5. Patch Analysis
1) Fix Approach:
Move all ep refcount decrement operations out from under ep->mtx and perform them after mutex_unlock(). Remove refcount manipulation from __ep_remove(). Ensure ep_free(ep) is only called after refcount decrement outside the mutex, eliminating the unlock/UAF window.

2) Key Code Changes:
- __ep_remove(): changed from “return ep_refcount_dec_and_test(ep);” to “return true;”, removing refcount decrement under the mutex.
- ep_remove_safe(): now separates removal from refcount handling; it uses “if (__ep_remove(ep, epi, false)) WARN_ON_ONCE(ep_refcount_dec_and_test(ep));” to preserve the warning semantics while no longer tying refcount changes to __ep_remove().
- ep_clear_and_put(): moved ep_refcount_dec_and_test(ep) to after mutex_unlock(&ep->mtx), i.e., “mutex_unlock(&ep->mtx); if (ep_refcount_dec_and_test(ep)) ep_free(ep);”.
- eventpoll_release_file(): after __ep_remove() and mutex_unlock(), it now performs “if (dispose && ep_refcount_dec_and_test(ep)) ep_free(ep);”, ensuring the refcount drop and potential free are outside the mutex.

3) Locking/Concurrency Impact:
- Eliminates the race where ep is freed between refcount decrement and mutex unlock by performing the decrement after unlocking.
- Aligns with mutex design semantics: no reliance on mutexes for object lifetime across unlock; uses atomic refcount for lifetime control.
- Prevents other threads from freeing ep while the current thread is still accessing ep->mtx during mutex_unlock().

6. Broader Kernel Security Implications
This fix underscores that mutexes provide mutual exclusion, not lifetime guarantees; refcount transitions that may enable object freeing must not occur before or during unlock. Similar patterns elsewhere should be audited to avoid subtle UAFs during unlock paths. Correct separation of lifetime management (atomic refcounts) from mutual exclusion (mutexes/spinlocks) reduces complex race conditions and hard-to-reproduce UAF bugs in kernel subsystems.