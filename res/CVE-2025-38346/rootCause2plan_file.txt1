1. Plan Summary
Detect cases where a module-release/cleanup function skips unlinking/freeing RCU-list elements that reference a struct module when a global “disabled” flag is set, while other code later iterates that list and dereferences those elements (e.g., mod->name), leading to a use-after-free.

2. Detection Steps
1) Step 1: Identify RCU list element types that hold a struct module pointer. Signals: a struct with a list_head member and a field of type “struct module *” (e.g., struct ftrace_mod_map { list_head list; struct module *mod; … }).

2) Step 2: Find the corresponding global list head that stores such elements. Signals: a global/list head (e.g., ftrace_mod_maps) used with list_* macros and containing elements of the identified struct type.

3) Step 3: Locate release/cleanup functions that accept “struct module *” and are intended to remove entries for that module from the global list. Signals: function parameters include “struct module *”; iterates the global list; removes matching elements with list_del_rcu and schedules freeing via call_rcu on the element’s rcu field.

4) Step 4: In those cleanup functions, detect an early exit guard on a global “disabled” flag that executes before the unlink loop. Signals: if (disabledFlag) goto/return positioned prior to list_del_rcu/call_rcu block (e.g., ftrace_disabled checked before removing mod_map).

5) Step 5: Confirm that the same file/subsystem contains reader code that traverses the same list under RCU and dereferences the module pointer. Signals: list_for_each_entry_rcu over the same list; dereference patterns like element->mod->name or copying into module_name (e.g., strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN)).

6) Step 6: Correlate the cleanup and reader over the same element type and list. Signals: both reference the same list symbol and element struct type; reader deref implies reliance on a valid module object.

7) Step 7: Check locking and RCU usage surrounding the unlink. Signals: mutex_lock(&ftrace_lock) around list_del_rcu/call_rcu; reader uses RCU traversal (preempt_disable or rcu_read_lock) indicating concurrent access expectations.

8) Step 8: Determine that freeing is only done when the unlink branch executes. Signals: call_rcu is within the unlink block; no alternative path frees the element when the disabled guard triggers, implying a dangling list entry on early exit.

9) Step 9: Raise an alert if both conditions hold: a) early disabled-flag exit before unlink+call_rcu in the release function, and b) reader derefs element->mod fields. Provide locations of the guard and the dereference for remediation.

10) Step 10: Suppress false positives where unlinking is unconditional before the disabled guard. Signals: the disabled guard appears after the list_del_rcu/call_rcu block (post-fix ordering), or unlink happens regardless of the flag.

11) Step 11: Suppress cases where the reader validates the element before deref. Signals: checks ensuring element->mod is non-NULL, or lifetime checks that prevent deref after module unload (none present in the provided reader).

12) Step 12: Suggest remediation pattern for flagged cases. Signals: move list_del_rcu/call_rcu to run unconditionally before the disabled guard; keep text-modification logic gated by the flag but not the resource unlink.

3. Limitations & Assumptions
- Assumes the element struct’s module pointer becomes invalid after module unload; static analysis cannot prove runtime lifetimes.
- Assumes the identified global “disabled” flag (e.g., ftrace_disabled) can be true in cleanup paths; CodeQL will flag the control-flow ordering regardless of runtime state.
- The plan relies on recognizable kernel list/RCU macros and naming; variants using custom data structures may not be detected.
- Cross-file correlations (cleanup and reader) are required; the checker must relate the same list symbol and element type across functions.