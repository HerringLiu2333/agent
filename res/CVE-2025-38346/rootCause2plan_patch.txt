1. Plan Summary
Detect early-return paths in ftrace module-release code that skip unconditional cleanup of mod_map entries, leaving stale pointers that are later dereferenced, causing use-after-free (based on ftrace_release_mod, ftrace_disabled, and ftrace_mod_get_kallsym behavior described).

2. Detection Steps
1) Step 1: Identify the teardown function handling module release (e.g., ftrace_release_mod(struct module *mod)) that acquires ftrace_lock (based on [PATCH_DIFF]). Signals: function with a struct module* parameter and mutex_lock(&ftrace_lock); FP mitigation: constrain to the named function or same locking pattern around module teardown.
2) Step 2: Locate an early-exit branch conditioned on a global disable flag (ftrace_disabled) that jumps to an unlock/return label (out_unlock) before other work (based on [PATCH_DIFF] pre-patch). Signals: if (ftrace_disabled) goto out_unlock or equivalent; FP mitigation: require the condition uses the specific global flag ftrace_disabled.
3) Step 3: Within the same function, identify a cleanup block that iterates ftrace_mod_maps and removes entries where mod_map->mod == mod (based on [PATCH_DIFF]). Signals: list_for_each_entry_safe over ftrace_mod_maps, comparison to the function parameter, and calls to list_del_rcu and kfree_rcu; FP mitigation: require both removal and RCU-free calls in the block.
4) Step 4: Check control-flow ordering to confirm the early-exit condition can bypass the cleanup block (pre-patch placement before list removal) (based on [ROOTCAUSE_ANALYSIS] point 2). Signals: dominance of the ftrace_disabled branch over the cleanup loop; FP mitigation: ensure no equivalent unconditional cleanup occurs earlier on all paths.
5) Step 5: Verify that the cleanup block is intended to release resources “unconditionally” by noting that the fix moves the ftrace_disabled check after the removal (based on [PATCH_DIFF] and comment). Signals: presence of the comment and repositioned check in the patched version; FP mitigation: use this as justification to flag only pre-patch ordering where removal is bypassable.
6) Step 6: Identify readers of ftrace_mod_maps that dereference mod_map->mod fields, specifically dereferencing mod_map->mod->name (based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). Signals: a function like ftrace_mod_get_kallsym iterating the same list and calling strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN); FP mitigation: require at least one such reader exists to establish UAF risk.
7) Step 7: Establish dataflow/linkage between the function parameter mod and mod_map->mod stored in the list (based on [PATCH_DIFF]). Signals: equality check mod_map->mod == mod in removal loop; FP mitigation: ensure the parameter identity is used in the removal check.
8) Step 8: Confirm lock boundaries: both the early-exit check and cleanup loop occur under the same mutex lock, making the bypass of cleanup a single guarded decision (based on [PATCH_DIFF]). Signals: code inside mutex_lock(&ftrace_lock); FP mitigation: exclude cases where cleanup is outside the lock or not atomic with the decision.
9) Step 9: Detect unconditional freeing calls (kfree_rcu(mod_map, rcu)) tied to removal; if these are only reachable when the disabled check is false, flag as risky (based on [PATCH_DIFF]). Signals: kfree_rcu in the cleanup block; FP mitigation: verify no alternative freeing of mod_map exists on the disabled path.
10) Step 10: Report a finding when the function has: (a) early exit on ftrace_disabled before cleanup; (b) cleanup removes mod_map entries referencing mod; and (c) downstream readers dereference mod_map->mod fields (based on [ROOTCAUSE_ANALYSIS]). Rationale: maps directly to the root cause of stale mod_map leading to UAF; FP mitigation: require all three signals.

3. Target Elements
- Functions handling module release: ftrace_release_mod(struct module *mod).
- Global state checks: ftrace_disabled.
- List iteration/removal blocks: list_for_each_entry_safe over ftrace_mod_maps, list_del_rcu, kfree_rcu.
- Locking constructs: mutex_lock(&ftrace_lock)/unlock.
- Readers of ftrace_mod_maps: functions that dereference mod_map->mod (e.g., ftrace_mod_get_kallsym, strscpy on mod_map->mod->name).

4. Dataflow / Taint Considerations
- Track the function parameter mod to equality checks against mod_map->mod inside list removal loops.
- Model control-flow paths where ftrace_disabled leads to bypassing the removal block.
- Track read-side flows that iterate ftrace_mod_maps and dereference mod_map->mod->name, establishing that stale pointers are observed by readers.

5. Validation & Test Cases
- Positive: Pre-patch ftrace_release_mod where if (ftrace_disabled) goto out_unlock appears before the list_for_each_entry_safe over ftrace_mod_maps removing mod_map with list_del_rcu/kfree_rcu; checker should flag.
- Negative: Post-patch ftrace_release_mod where mod_map removal happens unconditionally before the ftrace_disabled check; checker should not flag.
- Test harness notes: Build minimal stubs for ftrace_mod_maps list, a teardown function with the described ordering, and a reader that dereferences mod_map->mod->name; vary the position of the disabled check to test both outcomes.

6. Estimated Effort & Priority
High.

7. Likely False-Positive Sources & Mitigations
- Early returns that do not skip any resource cleanup referencing the function parameter; mitigate by requiring concrete removal/free of mod_map entries tied to mod.
- Alternative cleanup paths executed before/after the early exit; mitigate by scanning for equivalent removal/free elsewhere in the function or called unconditionally.
- Readers that do not dereference mod_map->mod or are guarded by checks preventing UAF; mitigate by requiring a reader that dereferences mod_map->mod->name (or equivalent field access).

8. Limitations & Assumptions
- Assumes availability of symbol names (ftrace_release_mod, ftrace_disabled, ftrace_mod_maps, ftrace_mod_get_kallsym) as in the provided materials; generalization to other subsystems is not covered.
- Does not prove runtime sequences (module unload followed by kallsyms read); relies on structural evidence of skipped cleanup and presence of readers.
- Concurrency and RCU grace-period correctness are inferred from patterns (list_del_rcu/kfree_rcu) but not fully analyzable statically.