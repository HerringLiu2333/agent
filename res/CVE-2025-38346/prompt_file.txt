1. CVE Identifier
CVE-2025-38346

2. Vulnerability Type
Use-after-free (dangling RCU list entry referencing freed module memory)

3. Root Cause Summary
ftrace_release_mod() returned early when ftrace_disabled was set and skipped removing the module’s ftrace mod_map entry from the global ftrace_mod_maps list. As a result, after the module was unloaded and its memory freed, subsequent kallsyms lookups traversed this stale list entry and dereferenced mod_map->mod->name, causing a use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ftrace core and its kallsyms integration (kernel/trace/ftrace.c), specifically module symbol exposure via ftrace_mod_get_kallsym().

2) Pre-Patch Flaw:
- In ftrace_release_mod(struct module *mod), the code performed:
  if (ftrace_disabled) goto out_unlock;
  before removing the corresponding mod_map from ftrace_mod_maps.
- This skipped list_del_rcu(&mod_map->list) and call_rcu() to free the mod_map, leaving a stale pointer to the module in the RCU-protected list.

3) Trigger Condition:
- A module triggers an ftrace anomaly, setting ftrace_disabled.
- The module is then removed (rmmod), freeing module memory.
- Reading /proc/kallsyms invokes the ftrace kallsyms providers; ftrace_mod_get_kallsym() iterates ftrace_mod_maps and accesses the freed module via:
  “strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);”
- This dereference occurs after the module memory has been freed, causing UAF.

4) Impact Mechanism:
- RCU readers in ftrace_mod_get_kallsym() traverse ftrace_mod_maps and copy fields from mod_map->mod, which points into freed module memory, leading to a kernel fault/UAF. Besides faults, this could enable information exposure or further memory corruption depending on timing and contents.

5. Patch Analysis
1) Fix Approach:
- Ensure that mod_map resources are unconditionally removed from ftrace_mod_maps during module release, regardless of ftrace_disabled, while still respecting ftrace’s global disable for text modifications.

2) Key Code Changes:
- In ftrace_release_mod():
  - Removed the early “if (ftrace_disabled) goto out_unlock;”.
  - Added a comment and reordered logic to always run:
    list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
      if (mod_map->mod == mod) {
        list_del_rcu(&mod_map->list);
        call_rcu(&mod_map->rcu, ftrace_free_mod_map);
        break;
      }
    }
  - Reintroduced the “if (ftrace_disabled) goto out_unlock;” after mod_map removal.
- This guarantees the stale RCU list entry is unlinked and safely freed, eliminating the dangling reference.

3) Locking/Concurrency Impact:
- The function holds ftrace_lock during removal, and uses list_del_rcu() plus call_rcu() to defer freeing until after a grace period, matching RCU readers in ftrace_mod_get_kallsym().
- By unconditionally unlinking under the mutex and deferring free via RCU, concurrent kallsyms readers no longer observe a mod_map pointing to freed module memory.

6. Broader Kernel Security Implications
- Cleanup paths must not be short-circuited by global “kill-switch” flags when doing so leaves globally visible references (especially RCU lists) to freed objects; otherwise UAFs ensue.
- This pattern suggests reviewing other ftrace paths (and similar subsystems) for early returns under “disabled” flags that can skip necessary list/RCU cleanup.
- The fix reinforces correct use of RCU discipline: unlink under lock, defer freeing with call_rcu(), and ensure readers never see stale pointers after object lifetime ends.