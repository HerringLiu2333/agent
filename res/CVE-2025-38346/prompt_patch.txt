1. CVE Identifier
CVE-2025-38346

2. Vulnerability Type
Use-after-free (UAF) / dangling pointer dereference

3. Root Cause Summary
ftrace_release_mod() returned early when ftrace_disabled was set, skipping the removal of the module’s mod_map entry from ftrace_mod_maps. This left a stale mod_map pointing to the unloaded module, and later kallsyms lookup (via ftrace_mod_get_kallsym) dereferenced mod_map->mod->name after the module memory had been freed, triggering a UAF.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ftrace module integration with kallsyms (function tracing state associated with modules)

2) Pre-Patch Flaw:
- In ftrace_release_mod(struct module *mod), the code checked ftrace_disabled and immediately jumped to out_unlock before executing the list_for_each_entry_safe() that removes and frees the mod_map for the module.
- Consequently, the mod_map remained on ftrace_mod_maps, retaining a pointer to the now-freed struct module.

3) Trigger Condition:
- A module triggers an ftrace anomaly, causing ftrace_disabled to be set.
- The module is then unloaded (rmmod), which calls ftrace_release_mod() but skips mod_map cleanup due to ftrace_disabled.
- A kallsyms lookup (e.g., cat /proc/kallsyms) invokes ftrace_mod_get_kallsym(), which accesses mod_map->mod for the unloaded module.

4) Impact Mechanism:
- ftrace_mod_get_kallsym() runs strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN) using a dangling mod_map->mod pointer, causing a kernel UAF and page fault (as shown in the provided Oops backtrace).

5. Patch Analysis
1) Fix Approach:
- Ensure mod_map resources are released unconditionally during module release, even when ftrace is disabled, to prevent stale references.
- Only short-circuit the remaining ftrace release steps when ftrace_disabled is set, after mod_map cleanup has been performed.

2) Key Code Changes:
- In ftrace_release_mod():
  - Removed the early:
    if (ftrace_disabled)
        goto out_unlock;
  - Performed list_for_each_entry_safe() over ftrace_mod_maps to find the entry for the module, then list_del_rcu(&mod_map->list) and kfree_rcu(mod_map, rcu) unconditionally.
  - Reintroduced the ftrace_disabled guard after the mod_map removal block:
    if (ftrace_disabled)
        goto out_unlock;
- Added a comment clarifying that mod_map must be released unconditionally to avoid UAF.

3) Locking/Concurrency Impact:
- No new locks introduced; mutex_lock(&ftrace_lock) still protects list operations.
- mod_map removal continues to use list_del_rcu and kfree_rcu, maintaining RCU safety for concurrent readers.
- By moving the ftrace_disabled check, the code guarantees that the stale mod_map is removed under the lock, preventing readers from finding a dangling pointer beyond the RCU grace period.

6. Broader Kernel Security Implications
- “Fail-safe” states like ftrace_disabled must still perform essential teardown to avoid dangling references that cross subsystem boundaries (here, tracing and kallsyms).
- UAFs in tracing paths can be triggered by unprivileged reads (e.g., /proc/kallsyms) after module unload, leading to kernel crashes.
- The fix underscores the need to decouple resource cleanup from operational disablement and to maintain proper RCU/list hygiene to prevent post-unload dereferences.