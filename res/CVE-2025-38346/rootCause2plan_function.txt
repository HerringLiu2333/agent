1. Plan Summary
Detect functions that perform teardown of shared list entries referencing unloaded resources but skip that cleanup due to an early-return on a “disabled” flag, leaving stale pointers that are later dereferenced (UAF).

2. Detection Steps
1) Step 1: Objective: find teardown/release functions with lock-guarded cleanup; Signals: functions calling mutex_lock and unlocking via a unified out label (e.g., out_unlock); Why: matches ftrace_release_mod’s structure in FUNCTION_CONTENT; FP mitigation: restrict to functions whose names or comments indicate release/removal and that hold a lock across cleanup.
2) Step 2: Objective: locate an early-return path gated by a global “disabled”/error flag; Signals: an if-condition on a global like ftrace_disabled that jumps to the unlock/return label before other work; Why: root cause per ROOTCAUSE_ANALYSIS was early exit when ftrace_disabled; FP mitigation: require the flag name to include “disable” or be documented as a stop/abort switch as in PATCH_DESCRIPTION.
3) Step 3: Objective: identify cleanup of a global/shared list of mappings performed in the function; Signals: traversal macros like list_for_each_entry_safe over a global list (e.g., ftrace_mod_maps) plus list_del_rcu and call_rcu on matched entries; Why: the stale mod_map entry retained in ftrace_mod_maps is the UAF source (ROOTCAUSE_ANALYSIS, FUNCTION_CONTENT); FP mitigation: ensure the list is global/static and uses RCU primitives, indicating cross-reader exposure.
4) Step 4: Objective: confirm the list entries hold pointers to the resource being unloaded; Signals: comparisons linking element fields to the function parameter (e.g., if (mod_map->mod == mod)); Why: maps the stored pointer (mod_map->mod) to the freed module memory (ROOTCAUSE_ANALYSIS); FP mitigation: demand a direct equality check to the function’s teardown parameter.
5) Step 5: Objective: check control-flow ordering: does the early-return precede the list-entry deletion; Signals: CF graph shows the disabled-flag branch jumps to unlock before the loop performing list_del_rcu; Why: pre-patch flaw was skipping deletion when disabled (PATCH_DIFF shows moving the check after deletion); FP mitigation: exclude cases where deletion occurs before any early exit or the flag is checked only after cleanup.
6) Step 6: Objective: raise severity when readers dereference the stored pointer field; Signals: elsewhere, expressions like mod_map->mod->name or similar dereferences of the element’s resource pointer; Why: dereferencing stale mod_map->mod caused UAF in ftrace_mod_get_kallsym (PATCH_DESCRIPTION, ROOTCAUSE_ANALYSIS); FP mitigation: require at least one dereference of that field in a different function or file to indicate cross-function use.
7) Step 7: Objective: confirm the cleanup is intended to be unconditional on unload; Signals: comments or structural cues that the mapping is a “resource” to release regardless of state (e.g., PATCH_DIFF comment: “mod_map resource needs to be released unconditionally”); Why: aligns with fix rationale that deletion must always happen to prevent UAF; FP mitigation: if such comments are absent, infer from presence of RCU + global list + pointer to parameter to maintain precision.
8) Step 8: Objective: differentiate between essential cross-subsystem reference cleanup and optional internal resource cleanup; Signals: treat list_del_rcu/call_rcu over global lists as essential, whereas subsequent per-module page/resource handling (e.g., ftrace_pages) can be skipped; Why: PATCH_DIFF preserves skipping page teardown while making map deletion unconditional; FP mitigation: only flag early exits that bypass deletion of shared list entries with external readers.
9) Step 9: Objective: assess lock boundaries to ensure the skipped deletion is within the locked critical section; Signals: the early-return goes directly to out_unlock and there’s no prior deletion under the lock; Why: FUNCTION_CONTENT shows deletion is inside the mutex, and skipping it leaves stale entries visible to readers; FP mitigation: ignore cases where deletion is proven to occur outside the lock unconditionally before any early return.
10) Step 10: Objective: optionally elevate findings when the list is consulted by functions associated with kallsyms/ftrace symbol lookup; Signals: function names like ftrace_mod_get_kallsym call sites reading from the same list; Why: PATCH_DESCRIPTION ties the impact to kallsyms read path; FP mitigation: treat absence of such readers as lower confidence rather than suppressing entirely.
11) Step 11: Objective: report a diagnostic when a function’s disabled-flag early return bypasses deletion of a global list entry that stores a pointer equal to the teardown parameter; Signals: conjunction of Steps 2–5, 8–9; Why: this pattern precisely matches the root cause summarized in ROOTCAUSE_ANALYSIS; FP mitigation: require all signals to hold to minimize spurious matches.
12) Step 12: Objective: suggest remediation pattern; Signals: move the disabled-flag check after the unconditional deletion of the mapping, preserving early exit for other teardown; Why: mirrors PATCH_DIFF’s fix to release mod_map unconditionally; FP mitigation: provide guidance only when the deletion block and flag are present.

3. Target Elements
- Functions performing teardown/removal (e.g., names containing release/remove/unload) with lock/unlock patterns.
- Global flags used for control-flow short-circuit (e.g., ftrace_disabled).
- Global/shared lists and their traversal/removal operations (list_for_each_entry_safe, list_del_rcu, call_rcu).
- Structure fields within list elements that point to resources (e.g., mod_map->mod) and their dereferences.
- Control-flow ordering around condition checks, goto labels, and cleanup blocks.

4. Dataflow / Taint Considerations
- Track from the function parameter representing the resource (mod) to list element fields stored or compared (mod_map->mod == mod).
- Track dereferences of the list element’s resource pointer (e.g., mod_map->mod->...) in other functions to indicate reader exposure.
- Control-flow taint: identify paths where the disabled flag leads to early exit before the cleanup block.

5. Validation & Test Cases
- Positive: Pre-patch ftrace_release_mod in FUNCTION_CONTENT where if (ftrace_disabled) goto out_unlock precedes the list_for_each_entry_safe with list_del_rcu/call_rcu; expect a report.
- Negative: Patched ftrace_release_mod per PATCH_DIFF where mod_map deletion occurs unconditionally before checking ftrace_disabled; expect no report.
- Negative: A teardown function with an early-return on a flag but no global list deletion or no pointer fields tied to the function parameter; expect no report.
- Test harness notes: Run on a small kernel snippet including the provided FUNCTION_CONTENT and PATCH_DIFF variants; verify control-flow ordering and the presence/absence of diagnostics.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Early returns guarding non-essential cleanup: mitigated by focusing on global lists with RCU and parameter-equality checks.
- Flags that do not imply disabled/error state: mitigated by name-based heuristics (“disabled”) and comments indicating stop/abort behavior.
- Lists without external readers: mitigated by seeking dereferences of the element’s resource pointer in other functions and lowering confidence when absent.

8. Limitations & Assumptions
- Assumes flag semantics (e.g., ftrace_disabled) indicate a disabled/error mode based on PATCH_DESCRIPTION; semantic intent may be unclear in other projects.
- Cannot statically confirm the resource is freed by the time readers run; relies on teardown function semantics (ROOTCAUSE_ANALYSIS).
- Reader functions (e.g., ftrace_mod_get_kallsym) may not be present in the analyzed subset; absence reduces certainty.
- Assumes RCU list operations indicate shared-reader exposure; non-RCU lists may still be vulnerable but are out of scope for this pattern.