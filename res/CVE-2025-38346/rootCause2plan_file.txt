1. Plan Summary
Detect release/cleanup functions that can exit early under a global “disabled” condition before unlinking/freeing entries from an RCU-protected global list, while readers still iterate that list and dereference pointers into soon-to-be-freed objects (leading to use-after-free).

2. Detection Steps
1) Step 1: Objective — locate global RCU lists with reader traversal. Signals — identify global list_head variables that readers traverse using RCU iteration (e.g., list_for_each_entry_rcu) and then dereference fields of the list element; based on FILE_CONTENT ftrace_mod_get_kallsym reads ftrace_mod_maps and dereferences mod_map->mod->name. FP mitigation — only consider lists with at least one reader that copies/dereferences nested pointer fields (e.g., elem->mod->name), indicating potential dangling references.
2) Step 2: Objective — map the reader’s element type and dereferenced ownership field. Signals — from the reader, infer the element struct type (e.g., ftrace_mod_map) and the field that references an external object (e.g., mod_map->mod of type struct module*), and note indirect deref (->name) as a sensitive access; supported by FILE_CONTENT and ROOTCAUSE_ANALYSIS (mod_map->mod->name). FP mitigation — require that the deref is not guarded by any check of the global “disabled” state.
3) Step 3: Objective — find release/cleanup functions that take the owning object pointer (e.g., struct module*). Signals — locate functions with signature like ftrace_release_mod(struct module *mod), acquiring a lock and intended to remove list entries associated with the passed object; FILE_CONTENT shows ftrace_release_mod. FP mitigation — restrict to functions that mention the target global list and compare element->owner_field == param.
4) Step 4: Objective — detect cleanup code that unlinks RCU list nodes referencing the param. Signals — within the release function, find a loop over the target global list (list_for_each_entry_safe) that tests node->owner_field == function_param and calls list_del_rcu and call_rcu to schedule free; based on PATCH_DIFF and FILE_CONTENT. FP mitigation — require both unlink (list_del_rcu) and deferred free (call_rcu) or equivalent, to avoid flagging unrelated loops.
5) Step 5: Objective — detect an early-exit path conditioned on a global “disable” flag before the unlink. Signals — identify a global flag read (e.g., ftrace_disabled) and a control-flow branch (if or goto out) that returns or jumps to function exit before the unlink loop; PATCH_DIFF shows if (ftrace_disabled) goto out_unlock; originally before the unlink. FP mitigation — ensure the unlink code is reachable only on the path where the flag is false.
6) Step 6: Objective — verify that the same global list is consumed by an RCU reader independently of the “disabled” flag. Signals — confirm the reader (e.g., ftrace_mod_get_kallsym) iterates the same global list and dereferences element->owner_field->subfield without testing the disable flag; FILE_CONTENT exhibits that behavior. FP mitigation — require the reader to be callable from contexts such as kallsyms providers (e.g., function named *_get_kallsym) to strengthen the case.
7) Step 7: Objective — confirm lock/RCU discipline mismatch that permits stale visibility. Signals — writer acquires a mutex (e.g., ftrace_lock) but skips unlink on the disabled path, while reader uses RCU iteration without the same lock; this matches ROOTCAUSE_ANALYSIS and FILE_CONTENT. FP mitigation — require the writer’s unlink code to use list_del_rcu and call_rcu to validate intended RCU synchronization.
8) Step 8: Objective — prove that the early exit leads to a path where the function returns with no unlink executed. Signals — intra-procedural control flow proving: from entry to return, there exists a path where the disable check is true and no call to list_del_rcu/call_rcu for nodes with node->owner_field == param occurs. FP mitigation — ensure path feasibility by requiring the lock is held on both paths (seen via mutex_lock before the branch).
9) Step 9: Objective — correlate potential UAF by showing that the owner object’s lifetime ends near this release. Signals — heuristically, the release function name hints (e.g., *_release_*), parameter type is the same as the owner_field, and the global reader dereferences owner_field->subfield (e.g., mod->name), indicating post-free deref risk; supported by ROOTCAUSE_ANALYSIS. FP mitigation — only flag when the owner_field type matches the release parameter type.
10) Step 10: Objective — report when the early-exit precedes list unlink but a second identical check appears after unlink (the patched pattern). Signals — if a later check/goto occurs after the unlink loop, do not report; if the first check/return occurs before unlink, report. FP mitigation — compare the relative positions to distinguish pre-patch (buggy) vs post-patch (fixed) layout per PATCH_DIFF.

3. Target Elements
- Global list declarations and uses: list_head variables (e.g., ftrace_mod_maps).
- Reader functions iterating with list_for_each_entry_rcu over target list.
- Reader dereferences of nested pointers from list elements (e.g., elem->mod->name).
- Release/cleanup functions taking owner pointer parameter (e.g., struct module *mod).
- Control-flow branches based on global “disable” flags (e.g., ftrace_disabled).
- Unlink/free operations: list_del_rcu and call_rcu over elements referencing the parameter.
- Locking boundaries: mutex_lock/unlock around release function logic.

4. Dataflow / Taint Considerations
- Track from the release function parameter (owner object) to comparisons inside the unlink loop (node->owner_field == param) to ensure the loop is indeed the cleanup for that object.
- Track the global list variable from reader to writer to correlate the same structure is being read and (supposed to be) cleaned.
- Track dereference chains in readers (element->owner_field->subfield) to recognize use of freed memory if unlink was skipped.

5. Validation & Test Cases
- Positive: A function like ftrace_release_mod(struct module *mod) that mutex_locks, checks if (ftrace_disabled) goto out_unlock; before running a list_for_each_entry_safe over ftrace_mod_maps to list_del_rcu nodes where node->mod == mod, and the reader ftrace_mod_get_kallsym() iterates ftrace_mod_maps via RCU and dereferences mod_map->mod->name. Expect a finding.
- Negative: Same function with the unlink loop executed unconditionally before a later if (ftrace_disabled) goto out_unlock; (as in PATCH_DIFF). Expect no finding.
- Test harness notes: Use minimal stubs for list/RCU APIs and a mock reader that copies element->owner_field->name to simulate kallsyms behavior.

6. Estimated Effort & Priority
Medium — requires cross-function correlation (reader/writer on the same list) and intra-procedural path reasoning to detect early-exit ordering.

7. Likely False-Positive Sources & Mitigations
- Lists that are only ever populated with non-free-owned data (mitigate by requiring deref of owner_field->subfield in reader).
- Early exits that are provably mutually exclusive with reader invocation (mitigate by requiring absence of disable flag checks in the reader).
- Cleanup code distributed across helper functions (mitigate by recognizing list_del_rcu/call_rcu in callees within the same function body).

8. Limitations & Assumptions
- Assumes the reader does not gate traversal on the same disable flag; the inputs show no such guard (FILE_CONTENT).
- Does not prove actual free of the owner object; infers risk from function naming, parameter typing, and reader deref patterns (ROOTCAUSE_ANALYSIS).
- Requires recognition of kernel list/RCU idioms; custom containers may need pattern updates.