1. Plan Summary
Detect cleanup functions that skip removing list entries referencing a module when a global “disabled” flag is set, leaving stale pointers that are later dereferenced by readers, causing a use-after-free.

2. Detection Steps
1) Step 1: Identify the cleanup function responsible for releasing module-related mappings. Signals: a function that takes struct module* (e.g., ftrace_release_mod) and operates under a lock while managing a global list of mod_map entries (e.g., ftrace_mod_maps).

2) Step 2: Locate the primary cleanup loop that removes the per-module mapping. Signals: iteration over the mod_map list (e.g., list_for_each_entry_safe) comparing entry->mod to the function’s mod parameter and performing list_del_rcu and kfree_rcu upon match.

3) Step 3: Detect an early short-circuit/guard on a global disable flag that can bypass the cleanup loop. Signals: a condition using a global flag (e.g., ftrace_disabled) with a branch to return or goto out_unlock that appears before the cleanup loop.

4) Step 4: Confirm the guard actually precedes the cleanup and exits the function path without executing it. Signals: control flow from the guard’s true branch reaches a function exit or unlock label that bypasses the loop block.

5) Step 5: Verify that the cleanup loop is the only place that unlinks and frees the mod_map entry. Signals: within the function, list_del_rcu and kfree_rcu (or equivalent) on the matched mod_map occur only inside the identified loop.

6) Step 6: Find reader functions that traverse the same list and dereference the stored module pointer. Signals: another function (e.g., ftrace_mod_get_kallsym) iterating ftrace_mod_maps and accessing mod_map->mod fields (e.g., mod_map->mod->name) or passing them to string routines (e.g., strscpy/strscpy-like).

7) Step 7: Ensure these readers do not validate the lifetime of the module pointer before dereference. Signals: absence of checks that the mod pointer is alive (no null check/ownership validation) before dereferencing mod_map->mod fields.

8) Step 8: Correlate the shared resource between cleanup and readers. Signals: both the cleanup and reader reference the same global list (ftrace_mod_maps) and the same element type/field (mod_map->mod), establishing the potential dangling reference.

9) Step 9: Report a potential UAF when Steps 3–4 hold (guard before cleanup enabling bypass) and Steps 6–8 hold (reader dereferences the stored pointer). Signals: combine evidence that a stale mod_map can persist and be dereferenced after module unload paths.

10) Step 10: Prioritize findings where locking suggests the cleanup is intended to run under protection but can be skipped. Signals: presence of mutex_lock before the guard and loop, and an out_unlock label, indicating intended atomicity that is undermined by the early exit.

3. Limitations & Assumptions
- Assumes symbol names and structures match the evidence (ftrace_release_mod, ftrace_mod_maps, mod_map->mod, ftrace_disabled, ftrace_mod_get_kallsym); generalizing beyond these exact names may require additional heuristics not provided here.
- Does not prove runtime reachability (e.g., that the guard can actually be true) or real module unload timing; it flags structural risk consistent with the root cause.
- Cannot confirm RCU grace-period correctness; it only checks for skipped list_del_rcu/kfree_rcu due to early exit.
- Reader-side lifetime validation beyond simple null checks may be non-trivial to detect; the plan assumes straightforward dereferences as described.