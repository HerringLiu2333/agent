1. CVE Identifier
CVE-2025-38346

2. Vulnerability Type
Use-after-free (lifetime/cleanup bug causing stale pointer exposure)

3. Root Cause Summary
ftrace_release_mod() returned early when ftrace_disabled was set, skipping removal of the module’s ftrace_mod_map entry from ftrace_mod_maps. This left a stale mod_map->mod pointer referencing freed module memory after module unload. Subsequent kallsyms lookups (via ftrace_mod_get_kallsym) dereferenced mod_map->mod->name, triggering a UAF read and crash. The patch makes the mod_map cleanup unconditional, removing the stale reference even when ftrace is disabled.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ftrace subsystem integration with modules and kallsyms (module symbol preservation for tracing)

2) Pre-Patch Flaw:
- In ftrace_release_mod(), the code did:
  - if (ftrace_disabled) goto out_unlock;
  - This bypassed the list_for_each_entry_safe loop that performs list_del_rcu(&mod_map->list) and schedules ftrace_free_mod_map.
- As a result, ftrace_mod_maps retained entries pointing to modules that had been unloaded.

3) Trigger Condition:
- A module triggers an ftrace anomaly causing ftrace_disable to be set.
- The module is then removed, invoking ftrace_release_mod() which returns early due to ftrace_disabled, leaving its mod_map in ftrace_mod_maps.
- Reading /proc/kallsyms causes ftrace_mod_get_kallsym to access mod_map->mod->name after the module memory has been freed.

4) Impact Mechanism:
- UAF read occurs when ftrace_mod_get_kallsym performs strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN) with mod_map->mod pointing to freed memory.
- This leads to a page fault and kernel oops; potential for crash or information exposure depending on memory reuse patterns.

5. Patch Analysis
1) Fix Approach:
- Ensure mod_map resources are released unconditionally on module removal, regardless of ftrace_disabled, to prevent stale references.
- Preserve the early-exit behavior for the remaining ftrace resource teardown (pages) when disabled.

2) Key Code Changes:
- Moved the ftrace_disabled check to occur after the mod_map removal:
  - Previously: if (ftrace_disabled) goto out_unlock; before list_for_each_entry_safe over ftrace_mod_maps.
  - Now: Always iterate and remove matching mod_map via list_del_rcu(&mod_map->list) and call_rcu(&mod_map->rcu, ftrace_free_mod_map); only then, if (ftrace_disabled) goto out_unlock.
- Added comment clarifying that mod_map must be released unconditionally to avoid UAF after module unload.

3) Locking/Concurrency Impact:
- list manipulation remains under mutex_lock(&ftrace_lock), maintaining mutual exclusion during removal.
- mod_map removal continues to use RCU (list_del_rcu + call_rcu) to protect readers traversing ftrace_mod_maps.
- By guaranteeing deletion even when disabled, readers no longer observe stale mod_map entries; the RCU discipline ensures safe reclamation timing.

6. Broader Kernel Security Implications
- Early-return paths for “disabled” or “error” states must still perform essential cleanup of cross-subsystem references to avoid dangling pointers and UAFs.
- Proper use of RCU for list entries is insufficient if deletion is skipped; correctness depends on ensuring deletion happens in all teardown scenarios.
- The fix reduces kernel crash and potential info-leak vectors during tracing anomalies, reinforcing robustness of tracing/kallsyms interactions under fault conditions.