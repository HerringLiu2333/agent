1. Plan Summary
Template detection plan anchored on patch-derived signals; due to missing materials, the checker describes how to systematically extract and detect the pre-patch flaw once [PATCH_DIFF]/[PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]/[FILE_CONTENT] are available.

2. Detection Steps
1) Step 1: Objective—derive vulnerable pattern from the patch; conceptual signals—identify added guards/validations, new checks, or refactors in [PATCH_DIFF]; FP mitigation—limit all detection to entities (functions, fields, types) explicitly named in [PATCH_DIFF]. 
2) Step 2: Objective—find call sites missing newly introduced preconditions; conceptual signals—calls to functions that gained parameter/return checks in [PATCH_DIFF] but are used without equivalent guarding condition; FP mitigation—require structural similarity to the guard (same variable/field, same comparison/op) described in the patch rather than any arbitrary condition.
3) Step 3: Objective—detect unchecked return-value usage made safe by the patch; conceptual signals—functions whose return is now validated (e.g., null/negative/error code) in [PATCH_DIFF], but prior uses directly dereference or proceed without a check; FP mitigation—confine to exact callee(s)/return types noted in [PATCH_DIFF] and exclude contexts already wrapped by checks semantically equivalent to the patch.
4) Step 4: Objective—catch missing bounds/length validations added by the patch; conceptual signals—operations (copy, index, slicing) that the patch wrapped in size/range checks, pre-patch occurrences that perform the operation without the same predicate; FP mitigation—only flag when the operands/arrays/buffers match the identifiers or fields mentioned in [PATCH_DIFF].
5) Step 5: Objective—identify missing null/None pointer/object checks; conceptual signals—dereferences or method calls on variables that the patch began to null-check; FP mitigation—exclude paths where earlier dominance establishes non-null (e.g., prior check of the same variable).
6) Step 6: Objective—find resource/lock discipline corrected by the patch; conceptual signals—use of shared resource the patch protected by lock/unlock or lifetime checks, but earlier code accesses without those guards; FP mitigation—restrict to the specific mutex/resource names introduced in [PATCH_DIFF] and ignore single-threaded or local-only contexts.
7) Step 7: Objective—detect newly added authorization/permission checks; conceptual signals—sinks (sensitive operations) that the patch now gates behind an auth/permission predicate, but earlier invocations lack any such gating; FP mitigation—only consider sinks exactly called as in [PATCH_DIFF] and recognize equivalent pre-existing auth checks via semantic equivalence of predicate.
8) Step 8: Objective—capture input validation added by the patch; conceptual signals—functions/paths where the patch adds parameter sanitization or type/range enforcement, while pre-patch paths propagate tainted/unvalidated inputs; FP mitigation—limit sources and sinks to those named in [PATCH_DIFF] and require the absence of semantically similar validation.

3. Target Elements
- Function definitions and signatures modified in [PATCH_DIFF].
- Call sites to functions highlighted in the patch.
- Condition checks newly introduced (null, bounds, error-code checks).
- Resource/lock boundaries added in the patch.
- Return-value use sites for functions altered by the patch.
- Sensitive sinks or operations newly protected in the patch.
- Input parameter use sites where the patch adds validation.

4. Dataflow / Taint Considerations
- Track flow from inputs/parameters referenced in [PATCH_DIFF] to operations/sinks that the patch guarded.
- Model return values of patched functions and their downstream uses to find unchecked paths.
- For resource/locking fixes, track accesses to the resource across function boundaries and ensure they occur within newly introduced lock scopes.
- Treat validation predicates from [PATCH_DIFF] as sanitizers; pre-patch paths lacking them are tainted.

5. Validation & Test Cases
- Positive: A pre-patch snippet calling the function named in [PATCH_DIFF] without the added null/bounds/auth check and then dereferencing/operating on the result; expect a finding.
- Negative: The same call wrapped with the exact or semantically equivalent check introduced by the patch (e.g., null-check, length check, permission check); expect no finding.
- Test harness notes: Build minimal examples mirroring identifiers, variables, and predicates as shown in [PATCH_DIFF]; vary control-flow (if/early-return) to ensure dominance analysis correctly suppresses FPs.

6. Estimated Effort & Priority
Medium — finalization depends on access to [PATCH_DIFF]/[PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]/[FILE_CONTENT]; once available, implementing patch-anchored signals is straightforward.

7. Likely False-Positive Sources & Mitigations
- Semantically equivalent validations expressed differently; mitigate by normalizing predicates (e.g., == vs. <= boundary forms).
- Calls occurring under broader guard scopes (earlier checks dominating); mitigate via control-flow dominance analysis.
- Resources accessed in single-threaded or private contexts where locks are unnecessary; mitigate by recognizing thread-model/context if available.
- Functions renamed or aliased; mitigate by resolving to canonical symbols from [PATCH_DIFF] and excluding unrelated overloads.

8. Limitations & Assumptions
- [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS] are unavailable, so no concrete function names, variables, or predicates can be specified.
- The plan assumes the patch introduces checks/guards typical of correctness/security fixes; if the root cause is of a different nature, steps must be adapted once evidence is available.
- Dataflow/locking specifics, sources/sinks, and error semantics cannot be determined without the missing materials.