1. Plan Summary
Insufficient information to design a specific CodeQL checker because [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] are missing; therefore, no vulnerability class, root cause, or code patterns are available to target.

2. Detection Steps
1) Step 1: Establish the precise vulnerability pattern from [ROOTCAUSE_ANALYSIS] and the code changes from [PATCH_DIFF]. Signals to look for would be the specific API usage, control-flow, and dataflow described as the root cause; FP mitigation would rely on exact semantic constraints extracted from the patch and function content.
2) Step 2: Enumerate the functions and modules implicated by the patch in [PATCH_DIFF] and [FUNCTION_CONTENT]. Signals: function names, parameters, and call sites touched by the patch; FP mitigation: restrict the scope to files and functions referenced by the patch.
3) Step 3: Identify precondition violations or missing checks highlighted in [PATCH_DESCRIPTION]. Signals: absent or insufficient condition checks (null checks, bounds checks, capability checks) as explicitly described; FP mitigation: require that the missing check is exactly the one added in the patch and that the context matches.
4) Step 4: Locate the sensitive operation(s) corrected by the patch (e.g., allocation, pointer dereference, authorization, parsing) per [PATCH_DIFF]. Signals: the specific API or operation modified; FP mitigation: ensure the operation occurs under the same control-flow context described in the patch.
5) Step 5: Model the dataflow from inputs to the sensitive operation if [ROOTCAUSE_ANALYSIS] indicates tainted input misuse. Signals: sources and sinks called out in the root cause; FP mitigation: enforce the same sanitization/validation gates added by the patch as required barriers.
6) Step 6: Detect the absence of synchronization or ordering if the patch introduces locks/barriers per [PATCH_DIFF]. Signals: access to shared state without the locking pattern introduced; FP mitigation: confirm the access site matches the same variables/structures as in the patch.
7) Step 7: Flag error-handling gaps if the patch adds return-value checks or early-exit on failure per [PATCH_DIFF]. Signals: calls lacking the new error checks; FP mitigation: require that the same function and error codes are involved as in the patch.
8) Step 8: Identify lifetime or ownership fixes if the patch adds frees, reference counting, or scope adjustments. Signals: resource acquisition without the corresponding release or reference updates; FP mitigation: restrict to the exact resource types and functions identified in the patch.
9) Step 9: Verify boundary/limit handling if the patch introduces bounds or range checks. Signals: array/string/buffer operations without the added bounds check; FP mitigation: match the same variables and indices used in the patch.
10) Step 10: Cross-check for variant call patterns (overloads/wrappers) that mirror the vulnerable path. Signals: indirect calls or wrappers reaching the same sensitive function; FP mitigation: require the same parameter usage and control-flow context as the root cause.
11) Step 11: Exclude contexts where compensating controls exist (e.g., higher-level validation) shown in [FUNCTION_CONTENT]. Signals: surrounding guards or sanitizers; FP mitigation: do not flag when those guards are present and equivalent to the patch’s fix.
12) Step 12: Report only when all core signals of the root cause co-occur as per [ROOTCAUSE_ANALYSIS]. Signals: conjunction of absent check + sensitive operation + data/control context; FP mitigation: require exact match to the patch’s introduced constraints.

3. Target Elements
- Functions and methods modified in the patch (names, parameters, return handling)
- Call sites invoking the patched functions
- Condition checks added by the patch (null, bounds, authorization, error codes)
- Sensitive operations altered by the patch (allocation, dereference, parsing, I/O, auth)
- Lock/unlock boundaries and shared state accesses
- Resource lifetime operations (alloc/free, refcount inc/dec)

4. Dataflow / Taint Considerations
- Track flows from identified sources (as per root cause) into sensitive sinks fixed by the patch.
- Respect sanitization/validation functions introduced or referenced in the patch as barriers.
- Propagate through wrappers if the patch indicates indirect invocation paths.

5. Validation & Test Cases
- Positive: A pre-patch code snippet replicating the exact missing check and sensitive operation described in [ROOTCAUSE_ANALYSIS]/[PATCH_DIFF]; checker should flag it.
- Negative: A post-patch snippet with the added checks/guards/locks; checker should not flag.
- Test harness notes: Scope tests to the functions/files referenced by the patch to ensure signal specificity.

6. Estimated Effort & Priority
High, contingent on receiving [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] to define the concrete vulnerability pattern.

7. Likely False-Positive Sources & Mitigations
- Generic patterns without the exact context from the patch; mitigate by strict matching to patch-identified functions and checks.
- Alternative defenses not visible without full function content; mitigate by verifying presence of equivalent guards.
- Wrapper or indirect call paths that differ semantically; mitigate by requiring parameter and control-flow context equivalence to the root cause.

8. Limitations & Assumptions
- Critical materials are missing: [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS], so the vulnerability class and signals are unknown.
- The checker cannot be concretely designed or validated without these specifics; all steps above depend on details to be supplied.
- No assumptions are made about the vulnerability type to avoid inventing facts beyond the provided materials.