1. CVE Identifier
CVE-2025-38495

2. Vulnerability Type
Memory safety: buffer length miscalculation leading to potential out-of-bounds write/read

3. Root Cause Summary
hid_alloc_report_buf() computed the buffer size as hid_report_len(report) + 7, but did not reserve the extra leading byte required when report->id == 0 (unnumbered reports). Low-level transport drivers expect the first byte of the buffer to contain a 0 “report ID” even when reports are unnumbered; the pre-patch allocation failed to account for this, leaving the buffer one byte too small. This mismatch could result in the first byte being treated as a report-ID slot and body data being shifted or an LL driver prefixing an ID byte and overrunning the allocated buffer, creating a risk of OOB writes/reads and memory corruption.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID core (drivers/hid), specifically hid-core report buffer allocation and request path.

2) Pre-Patch Flaw:
- In hid_alloc_report_buf(struct hid_report *report), len was calculated as “u32 len = hid_report_len(report) + 7;” without accounting for the reserved report ID byte when report->id == 0.
- The comment already acknowledged “7 extra bytes” to support implement() operating on 8-byte chunks, but lacked the additional byte needed to reserve the leading report ID for id==0.
- hid_output_report() writes the report ID only when report->id > 0; however, LL transport drivers expect a leading 0 byte for id==0, creating an allocation/expectation mismatch.

3) Trigger Condition:
- Any code path that allocates a buffer via hid_alloc_report_buf() for a report with report->id == 0 and subsequently uses __hid_request() to send it to hid->ll_driver->raw_request(), where the LL driver expects the first buffer byte to be the report ID (0 for unnumbered reports).
- Typical trigger: HID_REQ_SET_REPORT or HID_REQ_GET_REPORT on an unnumbered report.

4) Impact Mechanism:
- Because the buffer was one byte short, LL drivers that prepend/expect an ID byte may shift payload or insert the ID into the buffer, causing an out-of-bounds write by one byte at the tail or misinterpretation of body data as the ID.
- Combined with implement()’s 8-byte chunk behavior (“7 extra bytes are necessary to achieve proper functionality of implement() working on 8 byte chunks”), the missing extra byte for id==0 reduces the guaranteed slack from 8 to 7, increasing the likelihood of a boundary overrun and memory corruption.

5. Patch Analysis
1) Fix Approach:
Adjust the buffer allocation to include an extra byte when report->id == 0, ensuring the buffer can accommodate a reserved leading 0 report ID expected by LL drivers, in addition to the 7 trailing slack bytes for implement().

2) Key Code Changes:
- In hid_alloc_report_buf():
  - Pre-patch: “u32 len = hid_report_len(report) + 7;”
  - Post-patch: “u32 len = hid_report_len(report) + 7 + (report->id == 0);”
  - Updated comment explicitly notes the need for “1 extra byte for the report ID if it is null (not used) … when sending it to .raw_request()”.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The fix is a pure size calculation adjustment in buffer allocation and does not alter synchronization or ordering.

6. Broader Kernel Security Implications
- Correctly sizing HID report buffers prevents subtle cross-layer mismatches between HID core and transport drivers that can lead to memory corruption in kernel space.
- This change reduces the risk of OOB accesses when dealing with unnumbered reports, improving robustness across diverse HID transports (USB, I2C, BT) that have differing expectations regarding report ID handling.
- Ensuring consistent buffer semantics is critical for safe request construction and processing, especially given implement()’s chunk-based operations and LL drivers’ payload formatting requirements.