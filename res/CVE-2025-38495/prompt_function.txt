1. CVE Identifier
CVE-2025-38495

2. Vulnerability Type
Heap buffer under-allocation leading to out-of-bounds write/read (memory corruption)

3. Root Cause Summary
The HID core allocator hid_alloc_report_buf() miscomputed the buffer length by only adding 7 bytes for 8-byte chunk processing and failed to reserve an extra byte when the report ID is unused (report->id == 0). Low-level transport drivers expect the first byte of such buffers to be 0 (reserved report ID), but the pre-patch buffer length (hid_report_len(report) + 7) did not include this extra byte. This off-by-one under-allocation could cause writes or reads past the end of the allocated buffer when the reserved ID byte is used or when working on 8-byte chunks.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- HID core (buffer allocation for output/raw requests)

2) Pre-Patch Flaw:
- In hid_alloc_report_buf(), the length was computed as "u32 len = hid_report_len(report) + 7;" without accounting for an extra leading byte required when report->id == 0. This omitted reservation for the null report ID that transport drivers place at the first position.

3) Trigger Condition:
- Any path that allocates a report buffer via hid_alloc_report_buf() for a report with report->id == 0 and then uses it with hid_output_report() or .raw_request(), where the first byte is expected to be a reserved 0 and 8-byte chunk operations are performed.

4) Impact Mechanism:
- The buffer is one byte too small; writing the reserved ID at buf[0] and performing 8-byte chunk operations can cause a one-byte out-of-bounds write/read at the buffer end, leading to slab corruption, potential kernel crashes, or information disclosure.

5. Patch Analysis
1) Fix Approach:
- Correct the buffer size calculation by adding one extra byte when report->id == 0, ensuring space for the reserved report ID. This preserves the existing 7-byte padding for 8-byte chunk operations and prevents OOB access.

2) Key Code Changes:
- In hid_alloc_report_buf():
  - Changed "u32 len = hid_report_len(report) + 7;" to "u32 len = hid_report_len(report) + 7 + (report->id == 0);"
  - Added explanatory comments: "1 extra byte for the report ID if it is null (not used) ... when sending it to .raw_request()".

3) Locking/Concurrency Impact:
- None. The change is limited to size computation and allocation; no locks or ordering semantics were modified.

6. Broader Kernel Security Implications
- Ensuring accurate buffer sizing in core subsystems like HID is critical to prevent subtle heap overflows that can be triggered by common I/O paths. This fix reduces the risk of memory corruption and potential exploitation stemming from device- or userspace-controlled HID traffic. It highlights the importance of accounting for protocol-specific fields (e.g., report ID) in buffer allocations to maintain kernel robustness.