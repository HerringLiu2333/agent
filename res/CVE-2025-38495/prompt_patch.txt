1. CVE Identifier
CVE-2025-38495

2. Vulnerability Type
Heap buffer under-allocation leading to out-of-bounds write (off-by-one) due to length miscalculation.

3. Root Cause Summary
hid_alloc_report_buf() miscomputed the buffer size when the HID report has no report ID (report->id == 0). The pre-patch logic allocated hid_report_len(report) + 7 bytes, but low-level transport drivers reserve the first byte for a zero report ID and implement() operates on 8-byte chunks. This left only 7 “extra” bytes instead of the required 8, causing a 1-byte overrun when drivers wrote the reserved ID byte plus an 8-byte chunk.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID core (hid_alloc_report_buf in HID report handling)

2) Pre-Patch Flaw:
Incorrect buffer length calculation: u32 len = hid_report_len(report) + 7; did not include an extra byte for the reserved report ID when report->id == 0, despite drivers expecting the first byte to be 0 in this case.

3) Trigger Condition:
Any path that allocates a report buffer via hid_alloc_report_buf() for a report with report->id == 0 and then sends it to .raw_request() or processes it with implement() working on 8-byte chunks.

4) Impact Mechanism:
The under-sized kzalloc leads to a write past the end of the buffer (by 1 byte) when the driver writes the reserved first byte for the null report ID and then performs 8-byte chunk operations, causing kernel heap memory corruption and potential denial of service.

5. Patch Analysis
1) Fix Approach:
Adjust buffer allocation size to account for the reserved report ID byte when report->id == 0, ensuring the buffer contains hid_report_len(report) + 7 + 1 bytes in that case.

2) Key Code Changes:
- In hid_alloc_report_buf():
  - Change: u32 len = hid_report_len(report) + 7;
  - To: u32 len = hid_report_len(report) + 7 + (report->id == 0);
- Added explanatory comments clarifying the need for an extra byte for a null report ID and the 8-byte chunk expectations of implement().

3) Locking/Concurrency Impact:
None. The change is limited to buffer size calculation and allocation; no locking or synchronization semantics were modified.

6. Broader Kernel Security Implications
This issue highlights the risk of off-by-one allocation errors tied to protocol-specific headers or reserved fields in kernel subsystems. Ensuring buffer sizing correctly accounts for transport expectations (e.g., reserved report ID bytes) is critical to prevent heap corruption. Similar allocation paths in HID and other subsystems should be audited for conditional header/reserved-byte handling to avoid subtle under-allocation bugs that can be triggered by device inputs.