1. Plan Summary
Detect calls to helpers that require netdev_ops locking (e.g., dev_set_group) on a freshly created net_device during rtnetlink link creation, before dev->netdev_ops is initialized, which can cause a NULL dereference under certain configs.

2. Detection Steps
1) Step 1: Identify net_device creation contexts. Signals: functions that allocate a struct net_device via ops->alloc or alloc_netdev_mqs and populate fields without registering the device (as shown in rtnl_create_link in [FILE_CONTENT]). FP mitigation: restrict to functions that return the net_device or pass it to a later registration path (e.g., rtnl_newlink_create), not arbitrary helpers.

2) Step 2: Within such functions, track the newly allocated net_device variable (e.g., “dev” in rtnl_create_link). Signals: assignment from ops->alloc or alloc_netdev_mqs, followed by field initializations like mtu/address/link_mode/group before returning the dev (see [FILE_CONTENT] rtnl_create_link). FP mitigation: ensure the variable is the same pointer passed to the risky helper call.

3) Step 3: Flag calls to dev_set_group on the freshly allocated net_device prior to any evidence of dev->netdev_ops being set. Signals: a call expression dev_set_group(dev, …) gated by tb[IFLA_GROUP] (as in [FILE_CONTENT]/[PATCH_DIFF]) with no assignment to dev->netdev_ops in the function. FP mitigation: require the absence of any write to dev->netdev_ops in the containing function.

4) Step 4: Treat dev_set_group as a risky helper because it uses netdev_lock_ops and dereferences dev->netdev_ops (per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). Signals: presence of #include <net/netdev_lock.h> in the file and the known call stack to netdev_lock_ops (see [PATCH_DESCRIPTION]). FP mitigation: do not rely on call stack; use the specific helper name (dev_set_group) to reduce speculative matches.

5) Step 5: Check the call order to confirm “early init” context. Signals: dev_set_group appears before any registration (no register_netdevice call in the same function; rtnl_create_link only returns dev for later registration per [FILE_CONTENT]). FP mitigation: if register_netdevice/dev->netdev_ops assignment is found earlier in the same function, do not flag.

6) Step 6: Recognize safe alternatives and avoid flagging them. Signals: calls to netif_set_group instead of dev_set_group (as per [PATCH_DIFF] and [FILE_CONTENT] do_setlink using netif_set_group). FP mitigation: explicitly exempt netif_set_group.

7) Step 7: Correlate the call with netlink-controlled attribute handling to prioritize true positives. Signals: the call is predicated by tb[IFLA_GROUP] (see [FILE_CONTENT] “if (tb[IFLA_GROUP]) …”). FP mitigation: require the presence of the IFLA_GROUP attribute guard around the call.

8) Step 8: Highlight conditions increasing risk. Signals: usage resides in rtnetlink’s link creation path (rtnl_create_link) where dev->netdev_ops is NULL (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]). FP mitigation: restrict matches to net/core/rtnetlink.c or functions in the rtnetlink create/change link path identified in [FILE_CONTENT].

9) Step 9: Optionally generalize to other risky setters that lock ops (if known in the repository). Signals: other helpers that are documented to use netdev_lock_ops; since only dev_set_group is evidenced in provided materials, default to that. FP mitigation: only include dev_set_group to avoid speculative reporting.

10) Step 10: Prioritize findings where CONFIG-dependent deref is plausible. Signals: presence of netdev_lock_ops usage (header inclusion) and pre-init context; [PATCH_DESCRIPTION] indicates crash when CONFIG_NET_SHAPER is defined. FP mitigation: annotate as conditional risk in the result, not hard-blocking detection.

3. Target Elements
- Functions that allocate and initialize struct net_device (e.g., rtnl_create_link).
- Call sites of dev_set_group with a freshly allocated net_device argument.
- Control-flow guards using tb[IFLA_GROUP].
- Writes to dev->netdev_ops (absence used as a signal).
- Registration boundaries (absence of register_netdevice in the same function).
- File-level inclusion of netdev_lock facilities (<net/netdev_lock.h>).

4. Dataflow / Taint Considerations
- Track the dataflow of the net_device pointer from allocation (ops->alloc or alloc_netdev_mqs) to the dev_set_group call.
- Ensure no intervening assignment to dev->netdev_ops before the call.
- Model the control dependency from tb[IFLA_GROUP] to the dev_set_group call to confirm netlink-driven execution.

5. Validation & Test Cases
- Positive: In rtnl_create_link, a newly allocated dev (via alloc_netdev_mqs/ops->alloc) has dev_set_group(dev, ...) called under if (tb[IFLA_GROUP]) before any dev->netdev_ops assignment; expect a report (per [FILE_CONTENT]/pre-[PATCH_DIFF]).
- Negative: In do_setlink, netif_set_group(dev, ...) is used; expect no report (per [FILE_CONTENT]).
- Negative: A hypothetical function calling dev_set_group on a dev that has dev->netdev_ops set earlier in the same function; expect no report.
- Test harness notes: Run on net/core/rtnetlink.c; confirm the checker identifies the pre-patch hunk and is silent after the [PATCH_DIFF] change to netif_set_group.

6. Estimated Effort & Priority
Medium — focused API misuse pattern with clear signals from [PATCH_DESCRIPTION]/[PATCH_DIFF]/[FILE_CONTENT].

7. Likely False-Positive Sources & Mitigations
- dev_set_group used on already initialized devices: mitigate by requiring absence of dev->netdev_ops assignment and by early-init context checks.
- Functions where ops->setup indirectly sets netdev_ops via alloc_netdev_mqs: mitigate by limiting to rtnl_create_link and similar rtnetlink creation paths evidenced in [FILE_CONTENT].
- CONFIG-specific behavior (e.g., CONFIG_NET_SHAPER): mitigate by annotating conditional risk rather than suppressing; retain strict context checks.

8. Limitations & Assumptions
- Only dev_set_group is confirmed to use netdev_lock_ops in the provided materials; other risky helpers are not enumerated.
- Whether ops->setup sets dev->netdev_ops is not determinable from the inputs; the checker assumes dev->netdev_ops may be NULL during rtnl_create_link as stated in [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS].
- Compile-time configuration (CONFIG_NET_SHAPER) cannot be inferred statically; detection flags the pattern regardless and notes conditional risk.