1. Plan Summary
Detect calls to helpers that require netdev_ops on a freshly allocated net_device before netdev_ops is initialized, exemplified by dev_set_group being called in rtnl_create_link prior to netdev_ops setup.

2. Detection Steps
1) Step 1: Identify “early” net_device allocations — find variables assigned from alloc_netdev_mqs or returned from ops->alloc (via a function pointer) and treat them as newly created net_device instances within the enclosing function.
2) Step 2: Delimit the early-initialization region — from the allocation site to the first definite write to dev->netdev_ops in the same function (if any); if no such write is found, consider the entire function body after allocation as potentially early.
3) Step 3: Model the unsafe sink(s) — mark dev_set_group as an unsafe helper because it uses netdev_lock_ops (which dereferences dev->netdev_ops under certain builds).
4) Step 4: Generalize unsafe sinks — additionally treat any function as unsafe if a call-graph search from that function reaches netdev_lock_ops or netdev_need_ops_lock and the net_device parameter flows into those dereferences.
5) Step 5: Exclude known safe helpers — do not flag calls to netif_set_group, since it does not require netdev_ops per the fix.
6) Step 6: Track receiver object — for each call to an unsafe sink, check if the net_device argument is the same variable derived from the early allocation in Step 1 (accounting for simple aliases and parameter passing within the same function).
7) Step 7: Order-aware check — flag the call if it occurs within the early-initialization region (Step 2), i.e., prior to any proven write to dev->netdev_ops at the call site.
8) Step 8: Confirm dereference risk — where possible, confirm that along the callee’s path an access to dev->netdev_ops occurs (e.g., field dereference in netdev_lock_ops), to increase confidence and reduce false positives.
9) Step 9: Optional attribute guard context — if the unsafe call is conditionally executed based on a netlink attribute array (e.g., tb[IFLA_GROUP]), record this in diagnostics but do not require it for the finding.
10) Step 10: Suppress on proven initialization — if there is an explicit assignment to dev->netdev_ops prior to the call within the same function, suppress the alert for that path.
11) Step 11: Multi-path handling — treat control-flow paths separately; report only when a path exists from allocation to unsafe call without an intervening write to dev->netdev_ops.
12) Step 12: Reporting — emit a result that includes the allocation site, the unsafe call site, and (if resolved) the downstream netdev_ops dereference site to justify the potential NULL-deref.

3. Limitations & Assumptions
- The exact list of all helpers that require netdev_ops is not provided; only dev_set_group and the netdev_lock_ops/netdev_need_ops_lock path are evidenced, so generalization relies on call-graph reachability to these.
- Whether ops->alloc or ops->setup initializes dev->netdev_ops is unknown from the snippet; the checker assumes no initialization unless a write to dev->netdev_ops is visible in the same function.
- Kernel configuration (e.g., CONFIG_NET_SHAPER) is not known to static analysis; the checker flags potential issues independent of build-time options.
- Interprocedural writes to dev->netdev_ops outside the analyzed function or in unmodeled setup routines may lead to conservative (potential) findings.