1. Plan Summary
Detect calls to dev_set_group on a net_device object before its netdev_ops is initialized (possibly NULL), which under certain configs causes a NULL-deref, and recommend using the safe alternative pattern observed (netif_set_group) in early init paths.

2. Detection Steps
1) Step 1: Objective — Seed on calls to dev_set_group. Signals — Identify all call sites to dev_set_group where the first argument is a struct net_device*. FP mitigation — Ignore non-net_device arguments or unresolved call targets.
2) Step 2: Objective — Resolve the net_device receiver. Signals — Track the variable passed as the dev_set_group first argument through aliases and simple copies to the local net_device symbol used at the call. FP mitigation — Require intra-procedural resolution; if dev cannot be resolved, downgrade confidence.
3) Step 3: Objective — Flag the known vulnerable context. Signals — If the call is inside rtnl_create_link, mark as high-confidence because dev->netdev_ops is NULL at that time (based on ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION). FP mitigation — None; this is directly supported by provided evidence.
4) Step 4: Objective — Determine if netdev_ops may be uninitialized at the call. Signals — In the enclosing function, check for any dominating assignments of the form dev->netdev_ops = <non-NULL> before the call; absence suggests potential NULL. FP mitigation — Treat only dominating assignments with concrete non-NULL values as safe; if any path lacks such assignment, keep the finding.
5) Step 5: Objective — Suppress when there is an explicit non-NULL guard. Signals — Look for control-flow guards dominating the call that check dev->netdev_ops != NULL or equivalent. FP mitigation — Require the guard to dominate the call and be the only feasible path to the call (path-sensitivity approximation).
6) Step 6: Objective — Model explicit NULL evidence. Signals — If there is an earlier write dev->netdev_ops = NULL or a check that detects it is NULL along a path to the call, increase confidence of a warning. FP mitigation — Only use clear, intra-procedural evidence to avoid speculation.
7) Step 7: Objective — Recognize the safe alternative. Signals — If the call uses netif_set_group instead of dev_set_group, treat as safe per PATCH_DIFF. FP mitigation — None; rule only targets dev_set_group.
8) Step 8: Objective — Account for config-dependent deref. Signals — Since dev_set_group may invoke netdev_lock_ops under CONFIG_NET_SHAPER (ROOTCAUSE_ANALYSIS), annotate the finding as “config-dependent risk” when prior steps indicate possible NULL. FP mitigation — Require either Step 3 high-confidence context or Steps 4/6 evidence before reporting.
9) Step 9: Objective — Reduce noise from post-initialization contexts. Signals — If there is evidence the device is fully initialized before the call (e.g., a prior write to netdev_ops with a function table within the same function), suppress. FP mitigation — Require strong intra-procedural evidence of initialization ordering.
10) Step 10: Objective — Prioritize results. Signals — Rank: (a) High for rtnl_create_link; (b) Medium where dev->netdev_ops may be NULL by analysis; (c) Low where uncertainty remains due to unresolved aliases. FP mitigation — Only report Medium/High by default; Low as informational.

3. Target Elements
- Function call sites to dev_set_group and netif_set_group.
- Variables of type struct net_device* used as call arguments.
- Field writes/reads to dev->netdev_ops within the same function.
- Conditional checks involving dev->netdev_ops (e.g., non-NULL guards).
- Function boundaries and dominance relations within a function (order of statements/blocks).
- The specific function rtnl_create_link (as named in ROOTCAUSE_ANALYSIS and PATCH_DIFF).

4. Dataflow / Taint Considerations
- Track intra-procedural dataflow of the net_device pointer passed to dev_set_group through assignments and parameter aliases.
- Track field writes to dev->netdev_ops along paths reaching the call to determine if a non-NULL assignment dominates the call.
- Track simple NULL initializations and conditional tests on dev->netdev_ops to infer “may be NULL” at the call site.
- No external taint is required; focus is on object state (field initialization order).

5. Validation & Test Cases
- Positive: In rtnl_create_link, call dev_set_group(dev, x) before any assignment to dev->netdev_ops; expect a High-severity alert (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).
- Positive: In another function, call dev_set_group(dev, x) with no prior assignment to dev->netdev_ops and a prior dev->netdev_ops = NULL; expect a Medium-severity alert.
- Negative: Call netif_set_group(dev, x) in any context; expect no alert (PATCH_DIFF shows this is the fix).
- Negative: Call dev_set_group(dev, x) after dev->netdev_ops is assigned a non-NULL value in a dominating block; expect no alert.
- Negative: Call dev_set_group(dev, x) under if (dev->netdev_ops) { ... dev_set_group(...); }; expect no alert.
- Test harness notes: Use small kernel-like stubs with struct net_device containing a netdev_ops field to mimic the ordering scenarios; ensure control-flow includes both dominated and non-dominated branches.

6. Estimated Effort & Priority
Medium: Requires call resolution, field-write dominance checks, simple aliasing, and path-sensitive guard analysis; high payoff due to crash potential (DoS) highlighted in ROOTCAUSE_ANALYSIS.

7. Likely False-Positive Sources & Mitigations
- Interprocedural initialization of netdev_ops not visible intra-procedurally; mitigate by requiring dominating local evidence or downgrading severity when unresolved.
- Complex aliasing of dev through pointers or container_of patterns; mitigate by limiting to straightforward aliases and marking uncertain cases as Low.
- Configuration dependency (CONFIG_NET_SHAPER) not known statically; mitigate by clearly marking as config-dependent and prioritizing only when “may be NULL” is established.
- Macro-induced writes to netdev_ops may be missed; mitigate by preprocessing awareness and conservative suppression when uncertain.

8. Limitations & Assumptions
- Assumes that dev_set_group may dereference dev->netdev_ops via netdev_lock_ops under certain configs (based on ROOTCAUSE_ANALYSIS); the checker cannot determine build-time configs.
- Only definitively knows rtnl_create_link is an early-init context with netdev_ops NULL (PATCH_DESCRIPTION, ROOTCAUSE_ANALYSIS); generalization to other contexts relies on intra-procedural evidence of (un)initialized netdev_ops.
- Does not model full device registration lifecycle; relies on field assignment and guards as proxies for initialization order.
- The plan does not identify other APIs with similar ops-lock behavior beyond dev_set_group vs netif_set_group, as no further APIs are specified in the provided materials.