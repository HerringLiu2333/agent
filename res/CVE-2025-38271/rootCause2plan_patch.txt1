1. Plan Summary
Detect unsafe calls to dev_set_group on a net_device during early link creation when dev->netdev_ops may be NULL, which can lead to a NULL dereference under certain configurations.

2. Detection Steps
1) Step 1: Identify all call sites of dev_set_group; record the expression used as the first argument and ensure its static type is struct net_device*.
2) Step 2: Restrict attention to calls within the rtnetlink newlink creation path, especially functions named rtnl_create_link in net/core/rtnetlink.c, as indicated by the patch.
3) Step 3: For each dev_set_group call, perform an intra-procedural scan from function entry to the call site for any write to the same net_device’s netdev_ops field; if no write is found that dominates the call, mark the call as potentially operating on an uninitialized ops pointer.
4) Step 4: As an additional signal of early initialization, check whether the call occurs near handling of IFLA_* attributes (e.g., guarded by tb[IFLA_GROUP]) in rtnl_create_link; if so, strengthen the likelihood that dev->netdev_ops is not yet set.
5) Step 5: Exclude call sites where the same net_device has an earlier dominating assignment dev->netdev_ops = … in the current function or via an obviously inlined helper called before the dev_set_group call.
6) Step 6: Preferentially flag cases where a nearby alternative safe API (netif_set_group) is not used in the same location or file, indicating the expected safe pattern is missing.
7) Step 7: Optionally augment confidence if the file includes or references netdev lock helpers (include/net/netdev_lock.h), since dev_set_group may internally use netdev_lock_ops on certain builds.
8) Step 8: Report findings with the call site location, the net_device variable name, and the absence of a dominating netdev_ops initialization, highlighting the early-creation context and the safer netif_set_group pattern observed in the patch.

3. Limitations & Assumptions
- Compile-time configuration (e.g., CONFIG_NET_SHAPER) cannot be determined; the checker will flag potential issues even if the build may not take the problematic path.
- The plan assumes accurate type resolution for struct net_device and field netdev_ops; if these are obscured by macros or indirect wrappers, results may be incomplete.
- Inter-procedural writes to netdev_ops (e.g., in constructors or helpers called on other paths) may be missed; the dominance check is primarily intra-procedural and path-insensitive.
- The approach focuses on dev_set_group because the materials explicitly tie it to the fault; other APIs with similar ops-dependent behavior are not covered due to lack of evidence.
- Confidence that rtnl_create_link is an “early init” phase is taken from the supplied analysis; broader generalization to other functions is avoided to prevent invented facts.