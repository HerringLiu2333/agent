1. CVE Identifier
CVE-2025-38271

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (denial of service)

3. Root Cause Summary
rtnl_create_link() called dev_set_group() on a freshly allocated net_device while dev->netdev_ops was still NULL. dev_set_group() uses netdev_lock_ops(), which dereferences dev->netdev_ops when CONFIG_NET_SHAPER is enabled, causing a NULL pointer dereference. Pre-patch code: "if (tb[IFLA_GROUP]) dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));". The patch replaces dev_set_group() with netif_set_group(), which does not require netdev_ops and is safe during early device initialization.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking core (rtnetlink device creation path), net/core/rtnetlink.c; dev_api and netdev_lock infrastructure (net/core/dev_api.c, include/net/netdev_lock.h)

2) Pre-Patch Flaw:
Incorrect use of an API that assumes a fully initialized net_device (dev_set_group()) during early initialization when dev->netdev_ops is NULL. This violated the required initialization ordering by invoking ops-based locking (netdev_lock_ops) too early.

3) Trigger Condition:
Supplying IFLA_GROUP in the netlink attributes (tb[IFLA_GROUP]) during link creation so rtnl_create_link() executes dev_set_group(); combined with CONFIG_NET_SHAPER being enabled, which causes netdev_need_ops_lock/netdev_lock_ops to run and dereference dev->netdev_ops. The provided trace shows the failure in netdev_need_ops_lock -> netdev_lock_ops -> dev_set_group at rtnl_create_link.

4) Impact Mechanism:
netdev_lock_ops dereferences a NULL dev->netdev_ops, leading to a kernel oops/panic and denial of service when processing the rtnetlink newlink message.

5. Patch Analysis
1) Fix Approach:
Avoid ops-dependent helper during early initialization by replacing dev_set_group() with netif_set_group(), which sets the group without invoking netdev_lock_ops or dereferencing dev->netdev_ops.

2) Key Code Changes:
Single-line change in rtnl_create_link():
- Before: dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
- After:  netif_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));

3) Locking/Concurrency Impact:
The fix removes use of netdev_lock_ops at this point, eliminating the dependency on dev->netdev_ops and preventing NULL deref under CONFIG_NET_SHAPER. No new locks are introduced; the ordering is made safe by avoiding ops-based locking before netdev_ops is initialized.

6. Broader Kernel Security Implications
Using helpers that implicitly rely on netdev_ops or other initialized state during early net_device setup can introduce kernel crashes, especially when optional features (e.g., NET_SHAPER) add locking hooks. This change reinforces the need to use initialization-safe helpers (netif_* variants) until the deviceâ€™s ops are set, reducing attack surface via crafted rtnetlink messages. Auditing similar initialization paths for ops-dependent helpers can prevent comparable NULL dereferences and improve robustness of network device creation.