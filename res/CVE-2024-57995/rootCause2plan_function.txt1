1. Plan Summary
Detect read-after-free paths where a vif link pointer is freed via ath12k_mac_unassign_link_vif and then dereferenced before being reassigned by ath12k_mac_assign_link_vif.

2. Detection Steps
1) Step 1: Identify candidate pointer variables. Signals: a local or parameter pointer (e.g., struct ath12k_link_vif*) passed as the first argument to ath12k_mac_unassign_link_vif(var).

2) Step 2: Mark the unassign call as a free-like invalidation of the pointee. Signals: treat ath12k_mac_unassign_link_vif(var) as freeing/clearing the object referenced by var and rendering var invalid until a subsequent re-assignment.

3) Step 3: Build a forward control-flow slice from the unassign call site tracking the same pointer variable. Signals: follow the variable var along the same scope/path, respecting control-flow until function exit or a definite re-assignment to var.

4) Step 4: Define what restores validity for the pointer. Signals: an assignment to the same variable var where the right-hand side is a call to ath12k_mac_assign_link_vif(...), e.g., var = ath12k_mac_assign_link_vif(...), marks the pointer as valid again after this point.

5) Step 5: Locate unsafe dereferences of the invalid pointer before restoration. Signals: any use of var in a field access (var->field), indirect dereference (*var), or array-like use, occurring after the unassign call and before any restoring assignment.

6) Step 6: Include condition checks and warnings as dereferences. Signals: usages like if (var->is_created), WARN_ON(var->is_started), or similar reads of fields are treated as dereferences and flagged if they occur in the invalid window.

7) Step 7: Include passing the pointer to functions that likely read it as dereferences. Signals: passing var to ath12k_mac_vif_cache_flush(ar, var) or similar helper calls is considered a dereference use and flagged if it occurs in the invalid window.

8) Step 8: Exclude safe paths where reassignment precedes all dereferences. Signals: if every dereference of var is dominated by a restoring assignment (var = ath12k_mac_assign_link_vif(...)), do not report.

9) Step 9: Ensure path sensitivity across branches that call unassign. Signals: only report dereferences reachable on control-flow paths that pass through a call to ath12k_mac_unassign_link_vif(var) and are not cut off by an early return right after the call.

10) Step 10: Report with a path explanation from the unassign to the dereference. Signals: start at ath12k_mac_unassign_link_vif(var), end at the first dereference or sink (e.g., var->is_created or ath12k_mac_vif_cache_flush(ar, var)), highlighting the absence of a restoring assignment in between.

3. Limitations & Assumptions
- Assumes ath12k_mac_unassign_link_vif frees/invalidates the pointee and ath12k_mac_assign_link_vif returns a valid replacement pointer, based solely on the supplied analysis.
- The checker relies on explicit function names; it will miss analogous patterns with different helper names.
- Path feasibility is approximated; without full interprocedural summaries, some false positives/negatives may occur (e.g., aliasing or hidden reassignment).
- The plan assumes field reads and certain function calls dereference the pointer; it does not model deeper callee behavior beyond the named helpers.