1. Plan Summary
Detect use-after-free/read-after-free caused by dereferencing a pointer after it has been invalidated (freed/cleared) by a function like ath12k_mac_unassign_link_vif(), before being reassigned.

2. Detection Steps
1) Step 1: Identify invalidating functions — Look for functions that free or invalidate the pointed-to object, e.g., functions that call kfree(param), memset(param, 0, sizeof(*param)), or otherwise destroy object state (from FILE_CONTENT: ath12k_mac_unassign_link_vif). Mitigate FPs by building a whitelist of known invalidators from the code (e.g., ath12k_mac_unassign_link_vif) based on direct evidence.

2) Step 2: Locate call sites to invalidators — In each function body, find calls where a variable V is passed as the (potentially) freed/invalidated argument (e.g., ath12k_mac_unassign_link_vif(arvif)). Mitigate FPs by ensuring the same variable identity is used (not a copy of a different pointer) and that the call is on all control-flow paths to the later dereference (or at least on one feasible path).

3) Step 3: Track pointer validity state intraprocedurally — After the invalidator call, mark the variable V as invalid until it is reassigned with a fresh valid object (e.g., V = ath12k_mac_assign_link_vif(...)). Mitigate FPs by recognizing reassignments that re-establish validity (assignment from a function intended to return a new/valid instance per ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION).

4) Step 4: Detect dereferences of invalidated pointers — Search for any dereference or member access of V (e.g., V->field, *V) or passing V to functions expecting a valid object before the next reassignment. This directly maps to the root cause where arvif->is_created was read after ath12k_mac_unassign_link_vif() (ROOTCAUSE_ANALYSIS, PATCH_DIFF).

5) Step 5: Detect control-flow dependent uses — Include dereferences used in conditions or gotos (e.g., if (V->is_created) goto ...) and in logging or warn paths where V fields are read. Mitigate FPs by requiring a feasible control-flow path from the invalidation to the dereference without an intervening reassignment.

6) Step 6: Recognize reassigners — Identify calls that return a valid replacement object and assign it to V (e.g., V = ath12k_mac_assign_link_vif(...)), which revalidates the pointer (PATCH_DESCRIPTION and PACK_DIFF note this reassignment). Treat dereferences after this reassignment as safe.

7) Step 7: Model conditional frees/clears — In invalidator bodies, if the pointer may be kfreed or memset based on conditions (FILE_CONTENT shows kfree(arvif) or memset(arvif, 0, sizeof(*arvif))), treat the pointer as invalid regardless of branch because state is destroyed in either case. Mitigate FPs by limiting to functions that clearly destroy state for the argument along some path.

8) Step 8: Exclude safe uses — If the next use is only a nullness check (e.g., if (!V) return) with no field access, do not flag. This reduces noise by focusing on member reads/writes that require valid object state.

9) Step 9: Handle aliasing conservatively — If V is assigned to another alias or passed through wrappers, track obvious aliases within the same function; otherwise, warn only when deref via V itself is seen. This avoids complex interprocedural aliasing FPs.

10) Step 10: Special-case function ordering bug patterns — Flag cases where a check on V’s fields is performed immediately after an invalidation and before a documented reassign call, matching the pre-patch pattern in ath12k_mac_assign_vif_to_vdev() (ROOTCAUSE_ANALYSIS, PATCH_DIFF). This pinpoints the precise bug class the patch fixed.

11) Step 11: Report with context — For each finding, include the invalidator call site, the dereference location, and any later reassigner call observed (or absence thereof). This helps validate the issue and mirrors the patch rationale (move the check after reassignment).

12) Step 12: Suppress when guarded by reassignment dominance — If the analysis can prove that on all paths from invalidation to dereference the pointer is reassigned first, suppress the alert (matches the fixed code where the check comes after ath12k_mac_assign_link_vif()).

3. Target Elements
- Function bodies (local intraprocedural analysis).
- Call sites to invalidators (e.g., ath12k_mac_unassign_link_vif).
- Pointer variable assignments and reassignments (e.g., arvif = ath12k_mac_assign_link_vif(...)).
- Member accesses and dereferences (e.g., arvif->is_created).
- Control-flow constructs (if/goto) impacting use ordering.

4. Dataflow / Taint Considerations
- Track “invalidated” taint on a pointer variable after passing it to an invalidator; clear the taint upon reassignment from a known constructor/assigner.
- Propagate taint along simple aliases within the same function (assignments to/from V).
- Report when a tainted pointer is dereferenced or used as a non-null, stateful object.

5. Validation & Test Cases
- Positive: In a function, call ath12k_mac_unassign_link_vif(arvif); then immediately check if (arvif->is_created) ... — should be flagged (matches pre-patch pattern in ath12k_mac_assign_vif_to_vdev(), per ROOTCAUSE_ANALYSIS and PATCH_DIFF).
- Negative: Call ath12k_mac_unassign_link_vif(arvif); then arvif = ath12k_mac_assign_link_vif(...); then if (arvif->is_created) ... — should not be flagged (matches fixed code in PATCH_DIFF).
- Test harness notes: Include cases where invalidator conditionally kfree’s or memset’s the object (as in FILE_CONTENT) and ensure both branches are treated as invalidating; also test no-warning when only checking pointer for NULL without deref.

6. Estimated Effort & Priority
Medium — Requires intraprocedural dataflow (invalid/valid states), simple alias tracking, and modeling a small set of invalidators and reassigners.

7. Likely False-Positive Sources & Mitigations
- Functions that don’t actually free/clear the object but have similar names: mitigate by whitelisting invalidators confirmed in code (e.g., ath12k_mac_unassign_link_vif from FILE_CONTENT).
- Complex aliasing across function boundaries: mitigate by limiting to same-function dereferences of the same variable.
- Branch-sensitive validity that is hard to prove: report only when a feasible path exists and no dominating reassignment occurs.

8. Limitations & Assumptions
- Assumes a curated set of invalidators (e.g., ath12k_mac_unassign_link_vif) and reassigners (e.g., ath12k_mac_assign_link_vif) derived from provided code; may miss other lifetime-changing functions not in the supplied materials.
- Focuses on intraprocedural analysis; interprocedural alias flows are not fully analyzed.
- Does not reason about concurrency/RCU beyond recognizing synchronize_rcu; treats kfree/memset-zero as invalidation based on FILE_CONTENT and ROOTCAUSE_ANALYSIS.