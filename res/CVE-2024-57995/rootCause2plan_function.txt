1. Plan Summary
Detect intra-procedural use-after-free (read-after-free) where a pointer is dereferenced or used after a call that unassigns/frees it and before it is reassigned/revalidated, as exemplified by arvif use after ath12k_mac_unassign_link_vif() and before ath12k_mac_assign_link_vif() in ath12k_mac_assign_vif_to_vdev().

2. Detection Steps
1) Step 1: Objective — Identify candidate functions where a pointer may be unassigned/freed and later reassigned. Signals — In a single function, see a call resembling an unassign/free (e.g., ath12k_mac_unassign_link_vif(arvif)), and a later call to a reassign function returning the same type/variable (e.g., arvif = ath12k_mac_assign_link_vif(...)). FP mitigation — Prefer functions with comments or names indicating “unassign/assign” and where post-unassign comments suggest the pointer was cleared (based on FUNCTION_CONTENT comment).

2) Step 2: Objective — Model pointer invalidation. Signals — Upon a call that unassigns/frees with the pointer passed as an argument (arvif), mark that variable as invalid on paths following the call. FP mitigation — Require that the call is control-flow reachable and not immediately followed by a guaranteed reassign on all paths (path feasibility).

3) Step 3: Objective — Model pointer revalidation. Signals — Detect assignments where the same pointer variable is assigned from a function call that semantically “assigns” it (e.g., arvif = ath12k_mac_assign_link_vif(...)). FP mitigation — Treat only explicit assignments to the same variable name as revalidation; ignore unrelated writes.

4) Step 4: Objective — Detect dereference-use on invalidated pointer. Signals — Any field access or dereference of the invalidated pointer (e.g., arvif->is_created) before a reassign/revalidation on the same path. FP mitigation — Ensure dominance: the unassign call must dominate the dereference along at least one feasible path, and there must be no intervening reassign on that path.

5) Step 5: Objective — Detect invalid pointer being passed to function calls. Signals — Invalidated pointer used as an argument (e.g., ath12k_mac_vif_cache_flush(ar, arvif)) before revalidation, including after gotos. FP mitigation — Confirm that the callee expects a live object pointer (e.g., same pointer type used pre-patch) and that the call site is reachable from the unassign without reassign (based on PATCH_DIFF and FUNCTION_CONTENT flush path).

6) Step 6: Objective — Account for control-flow transfers (goto/labels) that defer dereferences. Signals — A goto jump (e.g., goto flush) that leads to a label where the invalid pointer is used, and the goto condition itself may dereference the invalid pointer (e.g., if (arvif->is_created)). FP mitigation — Do path-sensitive analysis to ensure that, for the jumping path, the unassign occurred and reassign did not yet happen.

7) Step 7: Objective — Detect invalid pointer used in return expressions. Signals — Use of invalidated pointer in return expressions (e.g., return arvif->ar) before revalidation. FP mitigation — Require a dereference or field access on the invalid pointer in the return expression (not just returning the pointer itself).

8) Step 8: Objective — Prioritize patterns matching the documented root cause ordering flaw. Signals — Unassign followed by immediate checks/uses of pointer state (is_created) prior to reassignment; relocation of the check post-reassign in PATCH_DIFF confirms the anti-pattern. FP mitigation — Restrict findings to cases where the same pointer variable is both invalidated and subsequently used without a write, mirroring the pre-patch pattern.

9) Step 9: Objective — Reduce false positives by excluding safe paths. Signals — If the unassign call is guarded by a condition and the use is only reachable when the guard is false, suppress; if a reassign dominates the use on all paths, suppress. FP mitigation — Require existence of at least one feasible path where unassign executes and the use occurs before any reassign.

10) Step 10: Objective — Highlight compounded risks via shared labels/flush blocks. Signals — Uses in shared cleanup/flush blocks that are reachable both when vdev was already created and after unassign (as in flush: ath12k_mac_vif_cache_flush(ar, arvif)). FP mitigation — Report only when path from unassign to label use is feasible without intervening reassign (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS).

11) Step 11: Objective — Prefer findings in ath12k MAC assignment logic per evidence. Signals — Functions in drivers/net/wireless/ath/ath12k/mac.c that handle link/vdev assign/unassign (ath12k_mac_assign_vif_to_vdev, ath12k_mac_unassign_link_vif, ath12k_mac_assign_link_vif). FP mitigation — Rank/report these higher due to explicit evidence in PATCH_DESCRIPTION and PATCH_DIFF.

12) Step 12: Objective — Provide remediation context in results. Signals — Suggest moving pointer state checks/uses after reassign, consistent with PATCH_DIFF (moving if (arvif->is_created) after reassignment). FP mitigation — Only include this suggestion when both unassign and assign calls are present in the same function on relevant paths.

3. Target Elements
- Functions containing both unassign/free-like calls and later reassign/assign calls for the same pointer.
- Call sites of ath12k_mac_unassign_link_vif(arvif) and ath12k_mac_assign_link_vif(...).
- Pointer variable dereferences/field accesses (e.g., arvif->is_created, arvif->ar).
- Function calls using the pointer as an argument (e.g., ath12k_mac_vif_cache_flush(ar, arvif)).
- Control-flow statements and labels (if/goto/labels) that affect reachability of uses post-unassign.
- Return statements involving fields of the pointer.

4. Dataflow / Taint Considerations
- Mark the pointer as “invalid” after calls that unassign/free it (arvif after ath12k_mac_unassign_link_vif(arvif)).
- Clear the invalid state when the pointer is reassigned from an assign function returning it (arvif = ath12k_mac_assign_link_vif(...)).
- Track uses while invalid: field dereferences, argument passing, and return field accesses, including inside labeled blocks reached via goto.
- Path sensitivity: only flag when there exists a path from invalidation to use without an intervening revalidation.

5. Validation & Test Cases
- Positive: Pre-patch fragment where ath12k_mac_unassign_link_vif(arvif) is called, followed by if (arvif->is_created) goto flush; and flush: ath12k_mac_vif_cache_flush(ar, arvif) before calling ath12k_mac_assign_link_vif(...); expect a hit.
- Negative: Patched fragment where the is_created check appears only after arvif is reassigned via ath12k_mac_assign_link_vif(...); expect no hit.
- Negative: Paths where unassign is not taken (e.g., single-radio paths or early returns) and uses occur; expect no hit.
- Test harness notes: Include goto-based control flow to ensure the analyzer follows jumps to labels and accounts for use in shared blocks.

6. Estimated Effort & Priority
High priority; medium effort (needs path-sensitive lifetime modeling and recognition of assign/unassign pairs).

7. Likely False-Positive Sources & Mitigations
- Unassign-like functions that do not actually free/invalidate: mitigate by focusing on known ath12k functions and comments indicating “unassigned and cleared” (FUNCTION_CONTENT).
- Reassign through aliases or helper wrappers not recognized: mitigate by requiring explicit assignment to the same variable.
- Complex control flow where all paths reassign before use: mitigate with dominance/path feasibility checks.

8. Limitations & Assumptions
- We assume ath12k_mac_unassign_link_vif(arvif) frees/clears the pointer and ath12k_mac_assign_link_vif(...) revalidates it, based on ROOTCAUSE_ANALYSIS and FUNCTION_CONTENT comments; the exact implementations are not provided.
- We cannot generally know other unassign/assign functions outside those evidenced; broader generalization may require a manual model or naming heuristics.
- Concurrency aspects and locking are not modeled; the fix is ordering-based per ROOTCAUSE_ANALYSIS, not synchronization-related.