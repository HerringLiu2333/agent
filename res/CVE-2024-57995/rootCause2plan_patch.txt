1. Plan Summary
Detect read-after-free bugs caused by dereferencing a pointer in the window after a function frees/unassigns it and before a later function reassigns/validates it, as exemplified by arvif dereferenced between ath12k_mac_unassign_link_vif() and ath12k_mac_assign_link_vif().

2. Detection Steps
1) Step 1: Objective — identify candidate pointer variables that may be freed then re-assigned. Signals — in a function body, find a call where a variable is passed to ath12k_mac_unassign_link_vif (known to free the pointer per ROOTCAUSE_ANALYSIS) and later the same variable is involved with ath12k_mac_assign_link_vif (reassignment/validation per PATCH_DESCRIPTION and PATCH_DIFF). FP mitigation — restrict initial scope to drivers/net/wireless/ath/ath12k/mac.c and these exact API names to avoid overgeneralization.

2) Step 2: Objective — mark the unassign/free event. Signals — model the argument passed as the “potentially freed” pointer beginning at the ath12k_mac_unassign_link_vif() call site; treat this as a lifetime end for that variable along successor paths. FP mitigation — require that the argument is a non-const pointer expression and the same symbol is used later (no trivially different objects).

3) Step 3: Objective — define the “revalidation barrier.” Signals — identify the earliest subsequent call to ath12k_mac_assign_link_vif in the same function that takes or updates the same pointer, and treat program points before this call as the “invalid window” (PATCH_DESCRIPTION and PATCH_DIFF move the check after this call). FP mitigation — only consider dereferences occurring strictly before this barrier in control-flow.

4) Step 4: Objective — detect dereferences in the invalid window. Signals — within the invalid window, find member access or dereference of the pointer (e.g., ptr->field), especially in conditionals like if (ptr->is_created) as in ROOTCAUSE_ANALYSIS. FP mitigation — exclude uses that only take the address of the variable itself without dereferencing its pointee, and ensure there is no intervening reassignment to that variable.

5) Step 5: Objective — ensure path feasibility from unassign to dereference. Signals — require a control-flow path where the unassign call post-dominates entry to the path segment and reaches the dereference without revalidation; honor gotos and labels (e.g., goto flush) as seen in PATCH_DIFF. FP mitigation — demand reachability with no intervening kill/assignment of the pointer or early returns that prevent the dereference.

6) Step 6: Objective — avoid flagging code where the pointer is proven still valid. Signals — check for immediate reassignment/initialization of the pointer (new allocation or assign-link) before the deref along all paths; if such a reassignment dominates the deref, suppress the alert. FP mitigation — consider simple aliasing (ptr2 = ptr) and treat updates to aliases as potential reassignments only if they overwrite the original pointer.

7) Step 7: Objective — prioritize read-after-free (not just any use). Signals — classify the dereference as a read (e.g., used in a comparison or branch like arvif->is_created) per ROOTCAUSE_ANALYSIS. FP mitigation — exclude pure writes that initialize memory unless evidence shows the pointer could be freed (to focus on the documented read-after-free class).

8) Step 8: Objective — strengthen evidence of the specific buggy pattern. Signals — optionally require that both ath12k_mac_unassign_link_vif and ath12k_mac_assign_link_vif occur in the same function and that at least one dereference of the pointer appears between them (PATCH_DIFF shows moving if (arvif->is_created) after assign). FP mitigation — suppress findings if the function never calls the reassign API, since the pattern may not be the same lifetime management scenario.

9) Step 9: Objective — reduce noise from unrelated variables. Signals — track the exact variable identity passed to unassign and used in deref (same SSA value if available), not just matching types or names. FP mitigation — exclude cases where the dereferenced variable is different from the one passed to unassign due to shadowing or parameter rebinding.

10) Step 10: Objective — provide clear reporting context. Signals — when a violation is found, report the unassign call site, the dereference location (e.g., condition using ->is_created), and the subsequent reassign call site that was intended to fix validity (as per PATCH_DESCRIPTION). FP mitigation — include the discovered path snippet to aid triage and avoid confusion with unreachable paths.

3. Target Elements
- Function bodies in drivers/net/wireless/ath/ath12k/mac.c.
- Call sites to ath12k_mac_unassign_link_vif() and ath12k_mac_assign_link_vif().
- Pointer variables passed to these calls (e.g., arvif).
- Member-access and pointer dereference expressions on these variables.
- Control-flow edges including gotos/labels between these calls (e.g., goto flush).
- Assignments and reassignments to the pointer variable and its aliases.

4. Dataflow / Taint Considerations
- Treat the argument to ath12k_mac_unassign_link_vif() as tainted with “freed” state starting at that call.
- Propagate this “freed” state along forward control-flow until a revalidation event at ath12k_mac_assign_link_vif() on the same variable.
- Flag any dereference/read of the tainted pointer state before revalidation; kill the taint on confirmed reassignment.
- Track simple aliases (assignments between variables) and ensure consistency for the same logical pointer.

5. Validation & Test Cases
- Positive: A function calls ath12k_mac_unassign_link_vif(arvif); then evaluates if (arvif->is_created) before any call to ath12k_mac_assign_link_vif; later calls ath12k_mac_assign_link_vif(arvif). Expect a read-after-free alert on the conditional dereference (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).
- Negative: The same check if (arvif->is_created) appears only after a successful ath12k_mac_assign_link_vif(arvif) call. Expect no alert (matches PATCH_DESCRIPTION fix).
- Negative: After unassign, the code immediately reinitializes arvif to a new, provably valid object before dereferencing. Expect no alert.

- Test harness notes: Run on pre-patch ath12k/mac.c to confirm a hit in ath12k_mac_assign_vif_to_vdev(); verify no hit on the patched version where the check is moved past ath12k_mac_assign_link_vif().

6. Estimated Effort & Priority
Medium: requires path-sensitive intraprocedural dataflow with simple alias tracking and API modeling for two functions.

7. Likely False-Positive Sources & Mitigations
- Unknown semantics of “unassign” functions in other contexts; mitigate by limiting to ath12k_mac_unassign_link_vif per ROOTCAUSE_ANALYSIS.
- Aliasing and reassignment not fully captured (e.g., reassignment via callee side effects); mitigate by focusing on explicit in-function calls to ath12k_mac_assign_link_vif as the revalidation barrier.
- Infeasible paths due to complex control-flow (gotos, early returns); mitigate by requiring reachability and no dominating reassignment before deref.

8. Limitations & Assumptions
- Assumes ath12k_mac_unassign_link_vif frees/invalidates the pointer and ath12k_mac_assign_link_vif revalidates it (per ROOTCAUSE_ANALYSIS and PATCH_DESCRIPTION); other functions with similar semantics are not modeled.
- Interprocedural side effects on the pointer (e.g., callee reassignments) are not accounted for; analysis is intraprocedural.
- The plan focuses on read-after-free; write-after-free cases are not the primary target though they may be incidentally caught.
- Exact reassignment mechanics are not shown in the diff; we assume the presence of ath12k_mac_assign_link_vif indicates the intended validity restoration window (PATCH_DIFF and ROOTCAUSE_ANALYSIS).