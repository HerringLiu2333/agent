1. Plan Summary
Detect functions that rely on array_index_nospec to clamp an index and then use the clamped index to fetch and return a vCPU from an xarray without first performing a semantic bounds check against online_vcpus.

2. Detection Steps
1) Step 1: Identify functions that compute a vCPU bound by reading atomic_read(&kvm->online_vcpus) into a local variable; signal is a call to atomic_read on kvm->online_vcpus assigned to a variable (e.g., num_vcpus).
2) Step 2: In the same function, locate use of array_index_nospec with the index and the bound; signal is a call to array_index_nospec where the first argument is the index variable and the second argument is the bound from Step 1, with the result stored back into the index or a variable later used as the index.
3) Step 3: Check for absence of a semantic bounds check prior to the array_index_nospec call; signal is no dominating conditional that tests index >= bound (or index < bound) leading to an immediate NULL/error return before the clamping call.
4) Step 4: Confirm that the clamped index is used to access the vCPU xarray; signal is a call to xa_load(&kvm->vcpu_array, index_var) where index_var is the same variable updated by array_index_nospec.
5) Step 5: Verify the function returns the pointer obtained from xa_load; signal is a return statement that directly or indirectly returns the xa_load result (e.g., return xa_load(..., index_var) or return tmp where tmp was set from xa_load).
6) Step 6: Optionally tighten scope to KVM vCPU getters; signals include function name or return type being struct kvm_vcpu*, presence of smp_rmb(), and comments referencing kvm_vm_ioctl_create_vcpu or online vCPUs.
7) Step 7: Ensure there is no subsequent check that converts an out-of-range index to a NULL after clamping; signal is lack of any conditional returning NULL based on index vs. bound or based on xa_load result prior to returning the pointer.
8) Step 8: Report a finding when Steps 1–5 hold and Steps 3 and 7 confirm missing pre-clamp bounds validation, explaining that invalid indices can map to 0 via array_index_nospec and return vCPU0 instead of NULL.

3. Limitations & Assumptions
- The checker assumes the bound from atomic_read(&kvm->online_vcpus) is the authoritative “online” limit; alternative sources of bounds or validation in callers are not analyzed.
- It cannot prove at compile-time that caller-level preconditions make the index always valid; false positives may arise if the index is validated elsewhere.
- It focuses on xarray access via xa_load and use of array_index_nospec; similar flaws using different containers or anti-speculation helpers may be missed.
- It does not determine runtime UAF feasibility; it flags the missing semantic bounds check that can lead to returning vCPU0 for invalid indices.