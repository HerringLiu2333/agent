1. Plan Summary
Detect functions that use anti-speculation index clamping (array_index_nospec) without a preceding functional bounds/“online” check, and then return or dereference an object based on the clamped index (risk: returning element 0 instead of signaling invalid access, leading to use-after-free).

2. Detection Steps
1) Step 1: Identify candidate functions that perform vCPU lookup by index. Signals: functions returning a struct kvm_vcpu pointer and taking a kvm object plus an integer index parameter.
2) Step 2: Locate reads of the “online” count used as a bound. Signals: atomic_read of kvm->online_vcpus captured into a local (e.g., num_vcpus) within the function.
3) Step 3: Find calls to array_index_nospec that use the index and the online count. Signals: array_index_nospec called with (index, bound) where bound originates from the online_vcpus read.
4) Step 4: Check for the presence of a functional bounds/online guard before clamping. Signals: an explicit conditional that tests the index against the bound (e.g., index >= bound) with an early return of NULL or an equivalent bailout; if absent, mark as missing.
5) Step 5: Confirm use of the clamped index to access or return a vCPU object. Signals: subsequent use of the adjusted index to look up into a vCPU collection (array/xarray) or compute/return a struct kvm_vcpu pointer.
6) Step 6: Ensure the function’s error signaling does not occur when the index is out-of-range. Signals: no path returning NULL or error when index ≥ bound; instead, the function proceeds with the clamped index to produce a non-NULL pointer.
7) Step 7: Strengthen confidence by tying the bound variable to “online” semantics. Signals: variable/read named online_vcpus (or a local derived from it) is the only gating value used prior to nospec and not enforced via a real guard.
8) Step 8: Report findings where array_index_nospec is used as the sole index “validation” before object access/return. Signals: the anti-speculation gadget appears, but there is no explicit bounds/online check, implying potential return of vCPU0 for invalid indices.

3. Limitations & Assumptions
- Assumes the bound used with array_index_nospec is derived from kvm->online_vcpus; other naming or indirect derivations may need additional heuristics not specified here.
- Does not infer concurrency or lifecycle ordering; it flags logic misuse (returning an object without enforcing online bounds), not whether a use-after-free will concretely occur.
- Cannot determine container type (array vs. xarray) or publication order; the checker focuses on missing functional bounds checks before using clamped indices.
- If guards are implemented in inlined helpers or macros not visible to the analysis, false positives/negatives may occur.