1. Plan Summary
Detect functions that use anti-speculation index clamping (array_index_nospec) to access an array/xarray without first doing an explicit upper-bound validity check, which can return a valid element (e.g., element 0) instead of NULL for out-of-range indices.

2. Detection Steps
1) Step 1: Identify candidate functions that compute a bound from an “online count.” Signals: a local variable assigned from atomic_read(&someKvm->online_vcpus) or a directly equivalent expression in the same function.
2) Step 2: In such functions, find calls to array_index_nospec(indexVar, boundVar). Signals: boundVar is the variable from Step 1; indexVar is the lookup index (often a function parameter).
3) Step 3: Confirm that the clamped index flows to an array/xarray access. Signals: xa_load(&sameKvm->vcpu_array, clampedIndex) or equivalent use of clampedIndex to select an element from a container in the same function.
4) Step 4: Verify that the result of the array/xarray access is exposed. Signals: the xa_load result flows to the function return, or is dereferenced or otherwise used as a valid object pointer.
5) Step 5: Check for the absence of a dominating explicit bounds check before clamping. Signals: no control-flow prior to array_index_nospec where (indexVar >= boundVar) leads to an immediate NULL/error return or otherwise prevents the subsequent container access.
6) Step 6: Treat “post-access” pointer-null checks as insufficient. Signals: even if there is a check like “if (!ptr) return …” after xa_load, still flag because it doesn’t validate index < boundVar before clamping.
7) Step 7: Correlate the container and bound to increase confidence. Signals: the container is a field named vcpu_array on the same struct kvm that provided online_vcpus, i.e., both accessed through the same kvm object in the function.
8) Step 8: Generalize (optional broader coverage): Flag any function where array_index_nospec is immediately followed by indexing/xa_load with the clamped index and there is no explicit pre-bound check, even if names differ from online_vcpus/vcpu_array.
9) Step 9: Exclude safe patterns. Signals: do not flag if there is a dominating “if (indexVar >= boundVar) return NULL/error;” (or equivalent guard) before array_index_nospec and the access.
10) Step 10: Report with context. Signals: include locations of (a) atomic_read of online_vcpus, (b) array_index_nospec call, and (c) the container access, and note the missing pre-bound NULL-return guard.

3. Limitations & Assumptions
- The checker assumes array_index_nospec is used for anti-speculation and not as a correctness check; it flags patterns where correctness relies solely on clamping.
- It cannot prove use-after-free; it flags the missing “index < bound” guard that can lead to returning an unintended element (e.g., element 0) instead of NULL.
- It assumes the boundVar originates from atomic_read(&kvm->online_vcpus) and the container is kvm->vcpu_array for the high-confidence KVM case; other subsystems with different naming may require the generalized step.
- It only analyzes intra-procedural guards; if a caller enforces the bound before calling, the checker may report a false positive.