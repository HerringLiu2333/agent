1. Plan Summary
Insufficient data to define a vulnerability-specific detector; provide a generic, patch-driven detection strategy that mirrors pre-patch flaws by inferring missing checks, unsafe flows, or misuse patterns from the (currently unavailable) patch materials.

2. Detection Steps
1) Step 1: Objective — establish scope; signals — identify functions, methods, or files modified in PATCH_DIFF to determine the affected code region and APIs involved.
2) Step 2: Objective — extract the fix pattern; signals — enumerate added/removed conditionals, validation logic, type or bounds checks, permission/state checks, or substitutions of safer APIs mentioned in PATCH_DESCRIPTION/PATCH_DIFF.
3) Step 3: Objective — infer sensitive operations; signals — locate calls or operations altered by the patch (e.g., memory, I/O, deserialization, crypto, auth, file/network APIs) and mark them as sinks the fix aims to protect.
4) Step 4: Objective — infer sources of untrusted or unsafe data; signals — identify parameters, fields, environment inputs, IPC/network/file reads, or user-provided data referenced in the patched areas, especially those newly validated in the patch.
5) Step 5: Objective — model the missing pre-patch guard; signals — capture the exact guard conditions added by the patch (null checks, range checks, type checks, permission checks, format checks) and define their conceptual predicates.
6) Step 6: Objective — detect pre-patch flaws; signals — flag paths where a sink is reachable from a source without the guard predicate present before the sink or at entry (absence of the patch’s added checks).
7) Step 7: Objective — capture unsafe API usage patterns; signals — identify pre-patch use of deprecated/unsafe APIs replaced in the patch and flag usages lacking the replacement or required wrappers.
8) Step 8: Objective — enforce state/permission preconditions; signals — detect calls to sensitive operations without the state/permission preconditions introduced by the patch (e.g., missing feature flags, role checks, initialization).
9) Step 9: Objective — confirm data structure integrity checks; signals — if the patch adds structure field validations or invariant assertions, flag updates/reads of those fields without equivalent validations in pre-patch code.
10) Step 10: Objective — limit false positives via patch context; signals — constrain findings to functions/modules touched by the patch or call chains that include them, and require that the exact guard or API change introduced by the patch is absent.
11) Step 11: Objective — handle intra/inter-procedural flows; signals — propagate source-to-sink flows across function calls within the patched component, respecting the presence/absence of added validations at call boundaries.
12) Step 12: Objective — report actionable locations; signals — surface the earliest point in the path where the guard is missing (closest to sink) and reference the corresponding fix pattern from the patch as remediation guidance.

3. Limitations & Assumptions
- PATCH_DESCRIPTION, PATCH_DIFF, FUNCTION_CONTENT, and ROOTCAUSE_ANALYSIS are missing, so the vulnerability type, specific APIs, and exact guard patterns cannot be enumerated.
- The plan assumes the patch introduces explicit validations, safer API substitutions, or state/permission checks that can be mirrored as preconditions; if the fix is architectural or non-local, additional context would be needed.
- Without code samples, language, and framework details, the checker cannot define concrete sources, sinks, or guards and must await the actual patch materials to specialize the signals.