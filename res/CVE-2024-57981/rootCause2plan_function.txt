1. Plan Summary
Detect kernel driver paths where a possibly-NULL command/context pointer is stored into a driver state field and a timer/handler is invoked that dereferences that state without a preceding NULL validation, as exemplified by xhci_handle_stopped_cmd_ring calling xhci_mod_cmd_timer with cur_cmd potentially NULL.

2. Detection Steps
1) Step 1: Objective — Scope to the affected code region. Signals — Focus on functions in the xHCI host controller driver that manipulate command ring state (e.g., xhci_handle_stopped_cmd_ring), based on the routine and file context shown. FP mitigation — Limit initial search to functions referencing cmd_ring, current_cmd, and command abort/restart logic per [FUNCTION_CONTENT].

2) Step 2: Objective — Find blocks that (re)start the command ring based on ring pointer state. Signals — Identify if-statements with conditions combining “cmd_ring->dequeue != cmd_ring->enqueue” and a negative check on a dying state bit (e.g., !(xhc_state & XHCI_STATE_DYING)). FP mitigation — Require both ring pointer inequality and the state bitmask check to co-occur as in [FUNCTION_CONTENT] and [PATCH_DESCRIPTION].

3) Step 3: Objective — Capture assignments that propagate a possibly-NULL command pointer into driver state. Signals — Within the block from Step 2, find assignments of the form state->current_cmd = cur_cmd (or equivalent parameter-to-field copy) as in [FUNCTION_CONTENT]. FP mitigation — Ensure the source of the assignment is a pointer parameter or variable named consistently with a “current command” concept (e.g., cur_cmd) and not locally proven non-NULL.

4) Step 4: Objective — Identify the subsequent invocation that assumes non-NULL state. Signals — Detect a call to the routine that operates on the state field and is known to dereference it (e.g., xhci_mod_cmd_timer(xhci) as per [ROOTCAUSE_ANALYSIS]). FP mitigation — Require the call to occur post-assignment in the same basic block or control region and be closely ordered before or alongside xhci_ring_cmd_db (per [FUNCTION_CONTENT]).

5) Step 5: Objective — Determine absence of a guard ensuring non-NULL command before the call. Signals — Check that no dominating null-check exists on either cur_cmd or the state field (current_cmd), such as an “if (cur_cmd)” or equivalent, guarding the call site; this is the specific guard added in [PATCH_DIFF]. FP mitigation — Only flag when the call is not guarded by a straightforward null-check and there is no earlier return or goto that enforces non-NULL along all paths to the call.

6) Step 6: Objective — Strengthen confidence that cur_cmd may be NULL on some feasible path. Signals — Look for comments or surrounding logic indicating abort/cancellation or “no pending command” scenarios (e.g., turning aborted commands into no-ops and then restarting), as in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation — Prefer blocks that include abort handling or command list iteration with status transitions indicative of no active command.

7) Step 7: Objective — Confirm the callee’s sensitivity to NULL state to reduce false positives. Signals — Use a model that xhci_mod_cmd_timer dereferences xhci->current_cmd without internal null-check (as explicitly stated in [ROOTCAUSE_ANALYSIS]). FP mitigation — Restrict this rule to known pairs where evidence exists (state assignment to current_cmd followed by xhci_mod_cmd_timer).

8) Step 8: Objective — Exclude cases where a later instruction would re-validate before dereference. Signals — Ensure there is no reassignment to current_cmd or intervening guard between the assignment and the sensitive call that would make current_cmd non-NULL. FP mitigation — Require the call to occur immediately after or within the same guarded block with no intervening non-NULL assurance.

9) Step 9: Objective — Identify equivalent patterns under different state checks. Signals — Accept variants where the ring pointer/state check exists but with reordered or slightly different conjuncts, provided the essential semantics match [FUNCTION_CONTENT] (restart path after abort with doorbell ring). FP mitigation — Still require both the assignment to current_cmd from cur_cmd and the unguarded call to the sensitive routine.

10) Step 10: Objective — Prioritize issues that can lead to a crash/NULL deref. Signals — Flag findings as high severity when the only thing preventing a NULL deref is the value of cur_cmd, and the call is known to dereference the state pointer (as per [ROOTCAUSE_ANALYSIS]). FP mitigation — Downgrade or suppress if an inlining/summary of the callee indicates it handles NULL internally (not applicable for xhci_mod_cmd_timer per [ROOTCAUSE_ANALYSIS]).

3. Target Elements
- Functions handling xHCI command ring abort/restart paths (e.g., xhci_handle_stopped_cmd_ring).
- If-conditions checking cmd_ring->dequeue vs cmd_ring->enqueue and XHCI_STATE_DYING.
- Assignments from function parameters (cur_cmd) to driver state fields (current_cmd).
- Calls to timer/modification routines that act on the state (xhci_mod_cmd_timer).
- Proximity calls indicating ring restart (xhci_ring_cmd_db).

4. Dataflow / Taint Considerations
- Track flow from a pointer parameter (cur_cmd) that is not definitively non-NULL to a state field (xhci->current_cmd).
- Propagate this state into the callee context (xhci_mod_cmd_timer) where it is dereferenced.
- Verify absence of dominating null-checks on either the parameter or the state field along the path to the call.

5. Validation & Test Cases
- Positive: Pre-patch pattern where inside an if with ring pointer inequality and not DYING, code does “xhci->current_cmd = cur_cmd; xhci_mod_cmd_timer(xhci); xhci_ring_cmd_db(xhci);” with no “if (cur_cmd)” guard (matches [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]).
- Negative: Post-patch pattern where the same block includes “if (cur_cmd) xhci_mod_cmd_timer(xhci);” (matches [PATCH_DIFF]).
- Test harness notes: Include a mock callee summary for xhci_mod_cmd_timer as dereferencing xhci->current_cmd to ensure the checker recognizes sensitivity; run on both versions to confirm only the pre-patch site is flagged.

6. Estimated Effort & Priority
Medium effort; high priority for kernel robustness due to clear NULL deref path induced by device behavior (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Cases where cur_cmd is implicitly guaranteed non-NULL by protocol/state not visible to the analyzer; mitigate with dominance analysis for prior checks and path feasibility.
- Callee actually guards against NULL; mitigate by restricting to the evidenced callee (xhci_mod_cmd_timer) or requiring a callee summary indicating dereference.
- Non-xHCI code with similar naming but different semantics; mitigate by requiring the combined ring pointer/state condition and doorbell usage pattern.

8. Limitations & Assumptions
- Assumes xhci_mod_cmd_timer dereferences xhci->current_cmd without internal NULL checks, based solely on [ROOTCAUSE_ANALYSIS]; callee body is not provided.
- Call-site data proving cur_cmd can be NULL is not included; the checker infers potential nullability from absence of guards, as evidenced by [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].
- The plan is tailored to xHCI patterns (ring pointers, doorbell) per [FUNCTION_CONTENT]; generalization to other subsystems is not covered by the provided evidence.