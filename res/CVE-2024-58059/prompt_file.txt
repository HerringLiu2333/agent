1. CVE Identifier
CVE-2024-58059

2. Vulnerability Type
Deadlock due to improper lifecycle/state handling (use of uninitialized mutex), resulting in denial-of-service during device probe/unregister paths.

3. Root Cause Summary
uvc_status_unregister() unconditionally called uvc_status_suspend() even when uvc_status_init() had not run. This caused uvc_status_suspend() to acquire dev->status_lock, which is initialized only in uvc_status_init() (mutex_init(&dev->status_lock)), leading to locking an uninitialized mutex and deadlock if uvc_probe() failed before initialization.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Media subsystem, USB Video Class (uvcvideo), status endpoint handling (drivers/media/usb/uvc/uvc_status.c).

2) Pre-Patch Flaw:
uvc_status_unregister() lacked a guard to ensure the status subsystem was initialized; it contained:
"void uvc_status_unregister(struct uvc_device *dev) { uvc_status_suspend(dev); uvc_input_unregister(dev); }"
This invoked uvc_status_suspend() regardless of whether dev->status and dev->status_lock had been set up.

3) Trigger Condition:
Failure in uvc_probe() that results in the error path calling uvc_status_unregister() before uvc_status_init() is invoked, leaving dev->status_lock uninitialized.

4) Impact Mechanism:
uvc_status_suspend() uses guard(mutex)(&dev->status_lock) to acquire an uninitialized mutex, causing a deadlock in the probe/unregister path and effectively hanging device enumeration or cleanup (DoS).

5. Patch Analysis
1) Fix Approach:
Add an early return in uvc_status_unregister() if dev->status is NULL, preventing suspend/unregister operations when the status subsystem hasn’t been initialized.

2) Key Code Changes:
In uvc_status_unregister(struct uvc_device *dev):
- Inserted:
  if (!dev->status)
      return;
This ensures the subsequent calls to uvc_status_suspend(dev) and uvc_input_unregister(dev) occur only after successful initialization.

3) Locking/Concurrency Impact:
Prevents taking dev->status_lock (via uvc_status_suspend()) before it is initialized, thereby eliminating the deadlock. No changes to lock ordering or additional locks; the fix constrains the call path based on initialization state.

6. Broader Kernel Security Implications
Error-paths must guard operations on subsystem state with initialization checks to avoid deadlocks and hangs, especially in probe/unregister sequences. This fix strengthens robustness against malformed or failing devices that trigger early probe failures, reducing the risk of system-level denial-of-service. Similar lifecycle guards should be audited across other media/USB paths to ensure mutexes and resources aren’t used before initialization.