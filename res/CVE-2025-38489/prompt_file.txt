1. CVE Identifier
CVE-2025-38489

2. Vulnerability Type
Race condition in live text patching leading to invalid control-flow (NULL branch) and kernel panic

3. Root Cause Summary
When disabling a hotpatched BPF call on s390 (new_addr == NULL), the PLT entry generated by bpf_jit_plt set plt->target = NULL. If a CPU branched into this PLT during the patching window, the PLT code (“br %r1”) would branch to a NULL target, causing an exception and panic. The correct behavior is to make the PLT entry a no-op in this case by redirecting target to the PLT’s return label, eliminating the crash window.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
s390 BPF JIT hotpatching (PLT entries) and bpf_arch_text_poke()

2) Pre-Patch Flaw:
- In bpf_jit_plt(struct bpf_plt *plt, void *ret, void *target), the code set “plt->target = target;” unconditionally.
- The PLT template executes “br %r1” to jump to the target (see rodata bpf_plt: lgrl %r0,bpf_plt_ret; lgrl %r1,bpf_plt_target; br %r1).
- bpf_arch_text_poke() updates the PLT’s target field before masking out the branch in the caller; with new_addr == NULL this makes plt->target NULL, leaving a transient but dangerous state if any CPU executes the PLT in that window.

3) Trigger Condition:
- bpf_arch_text_poke() called with new_addr == NULL (e.g., turning a call into a no-op via brcl mask 0).
- Concurrent execution where another CPU has already fetched/branches into the PLT before the branch is masked or while the PLT target is being updated to NULL.

4) Impact Mechanism:
- A CPU executing the PLT will perform “br %r1” with %r1 == NULL, resulting in an invalid branch to address 0, triggering an exception and intermittent kernel panics (observed in perf’s on_switch() program).

5. Patch Analysis
1) Fix Approach:
Ensure PLT entries are safe no-ops when disabling a call by redirecting the PLT target to the return label instead of NULL. This makes any stale jump into the PLT harmless (it immediately returns).

2) Key Code Changes:
- In bpf_jit_plt():
  - Pre-patch: “plt->target = target;”
  - Post-patch: “plt->target = target ?: ret;”
  - Added comment explaining that target == NULL should make the PLT entry a no-op since CPUs might still execute it during patching.

3) Locking/Concurrency Impact:
- No new locking; the race is neutralized by making the transient state benign (PLT target never becomes NULL).
- bpf_arch_text_poke() still uses s390_kernel_write and text_poke_sync_lock() to publish changes; ordering is no longer critical for safety because jumps into the PLT now return instead of branching to NULL.

6. Broader Kernel Security Implications
The change hardens live patching on s390 by removing a race-induced crash vector in BPF hotpatch PLTs. It prevents denial-of-service style panics during code updates and emphasizes designing patching primitives whose intermediate states are safe under concurrent execution. This improves robustness of perf/BPF infrastructure and reduces exposure to crash-inducing transient control-flow anomalies in multi-CPU environments.