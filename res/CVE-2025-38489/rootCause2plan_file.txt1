1. Plan Summary
Detect cases where a hotpatch PLT/trampoline initializer assigns a branch target field directly from a possibly NULL input, and a live patch routine writes that NULL into executable PLT before masking the caller branch, creating a transient NULL indirect jump.

2. Detection Steps
1) Step 1: Identify live text patch routines that modify branch instructions and take a “new_addr” pointer (e.g., bpf_arch_text_poke). Signals: function reads/validates an encoded branch (opc/disp), uses old_addr/new_addr in opcode selection, and updates instruction bytes.

2) Step 2: Within such routines, find construction of a PLT/trampoline struct via a helper (e.g., bpf_jit_plt) that sets “ret” and “target” fields. Signals: call that passes a return address and the same new_addr as the target, followed by use of the constructed struct.

3) Step 3: In the PLT initializer function, check the assignment to the “target” field. Signals: direct assignment “plt->target = target” (or equivalent) with no null check or fallback to “ret.”

4) Step 4: Confirm that the patch routine writes the new PLT’s “target” into the live PLT in text (code) memory before changing the caller’s branch mask. Signals: call to s390_kernel_write with &plt->target using new_plt.target, and later a write that sets branch mask/opcode based on new_addr.

5) Step 5: Determine whether the branch masking depends on new_addr and can disable the branch when new_addr == NULL. Signals: opcode recomputation like “insn.opc = 0xc004 | (new_addr ? 0xf0 : 0)” or equivalent ternary using new_addr.

6) Step 6: Flag the unsafe sequence: a path where new_addr is allowed to be NULL, the PLT initializer assigns “target” from the NULL input unconditionally, and the patch routine writes that NULL target before masking the branch. Signals: data-flow from new_addr to new_plt.target to s390_kernel_write(&plt->target, …) preceding branch mask update.

7) Step 7: Strengthen confidence by recognizing PLT/trampoline semantics. Signals: struct with fields named “ret” and “target,” memcpy from a template (e.g., bpf_plt) and comments or surrounding code indicating an indirect branch to the “target” (e.g., “br %r1” reference in comments/asm).

8) Step 8: Report both the initializer assignment site and the call chain from the patch routine showing new_addr → new_plt.target → kernel write, with ordering (PLT write first, branch mask later) and the NULL-conditioned opcode logic.

3. Limitations & Assumptions
- Assembly semantics (“br %r1”) are inferred from comments/structure names; the checker does not parse inline asm to prove indirect branch behavior.
- The plan assumes field names like “target”/“ret” and helper patterns like memcpy from a template; different naming or abstractions may reduce precision.
- Concurrency and timing windows cannot be proven statically; the checker flags the hazardous sequence under the assumption that live PLT entries can be executed concurrently.
- It assumes “new_addr” can be NULL based on ternary usage in opcode selection; if callers ensure non-NULL elsewhere, that is not visible here.