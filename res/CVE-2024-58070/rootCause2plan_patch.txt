1. Plan Summary
No vulnerability-specific plan can be derived because [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS] contain no usable details; outline a diff-driven strategy to derive a CodeQL checker once the patch/root cause is known.

2. Detection Steps
1) Step 1: Objective — Identify the concrete semantic change introduced by the fix; Conceptual signals — guard additions, new validations, changed error handling, or control-flow/locking updates as shown in the patch; FP mitigation — anchor the pattern strictly to constructs and APIs touched by the patch.
2) Step 2: Objective — Classify the vulnerability mechanism (e.g., missing check, misuse of API) from the patch/root cause; Conceptual signals — the exact precondition/postcondition newly enforced or the API usage constraints documented in the fix; FP mitigation — require equivalence of contextual preconditions (same callee, arguments, and surrounding state).
3) Step 3: Objective — Formulate “bad pattern = pre-patch state”; Conceptual signals — code paths that reach sensitive operations without the new guard/validation/ordering present in the fix; FP mitigation — verify the same data/control dependencies as in the patched site (same variables/resources).
4) Step 4: Objective — Map sources/sinks per the fix; Conceptual signals — variables/inputs validated in the patch (sources) and operations protected by the patch (sinks) with the intervening condition added; FP mitigation — restrict to flows within the same module or API family changed in the patch.
5) Step 5: Objective — Encode control-flow predicates introduced by the patch; Conceptual signals — added condition types (null check, bounds check, state flag check, error-code handling) and their precise operands; FP mitigation — require the exact operand relationships (same pointer/index/state flag) before reporting.
6) Step 6: Objective — Capture resource/state invariants established by the patch; Conceptual signals — added lock/unlock pairs, reference/ownership checks, lifetime assertions; FP mitigation — report only when the same resource is used without the invariant and within comparable lifetime scope.
7) Step 7: Objective — Detect unsafe API usage sequences corrected by the patch; Conceptual signals — reordered calls, added return-value checks, or changed argument constraints; FP mitigation — insist on the same API sequence and argument roles as in the patch context.
8) Step 8: Objective — Incorporate dataflow from sources to sinks lacking the new guard; Conceptual signals — value/taint propagation from inputs or state to the protected operation; FP mitigation — require path feasibility and absence of the exact guard pattern, not just any guard.
9) Step 9: Objective — Exclude code already fixed or equivalent; Conceptual signals — presence of the same/stronger guard predicates or validated wrappers introduced in the patch; FP mitigation — treat these as suppressors to avoid duplicate/benign findings.
10) Step 10: Objective — Bound the search to relevant versions/areas; Conceptual signals — files/functions changed in the patch and their transitive call sites; FP mitigation — deprioritize matches outside the affected subsystems unless they match all identified features.
11) Step 11: Objective — Validate with interprocedural context; Conceptual signals — guards implemented in callers/callees as in the patch; FP mitigation — consider summaries to avoid flagging when the guard is present but non-local.
12) Step 12: Objective — Rank results by similarity to patched sites; Conceptual signals — structural and lexical similarity (same API names, variable roles, and control patterns); FP mitigation — raise threshold to report only high-similarity matches.

3. Target Elements
- Functions modified by the patch and their transitive callers/callees.
- Call sites to APIs guarded or reordered by the patch.
- Condition checks added in the patch (null, bounds, state, error handling).
- Resource management boundaries (allocation/free, lock/unlock, refcount inc/dec).
- Function return-value uses newly validated by the patch.
- Argument constraints added by the fix (range, non-null, size, format).

4. Dataflow / Taint Considerations
- Track flows from inputs/state variables that the patch validates to the operations that it protects.
- Model interprocedural propagation where guards may occur in callers while sinks occur in callees.
- Treat the presence of the new guard predicate as a sanitizer; report flows reaching sinks without passing the predicate.
- If the patch adds sequencing constraints, model order-sensitive flows between API calls.

5. Validation & Test Cases
- Positive: Pre-patch snippet replicating the exact missing guard/ordering/API misuse identified from the patch; expect a finding pointing to the sink and explaining the absent guard/constraint.
- Negative: Post-patch snippet with the added guard/ordering present; expect no findings.
- Test harness notes: Include intra- and interprocedural variants (guard in caller/callee), multiple paths where only some are guarded, and semantically equivalent guards to verify suppressors.

6. Estimated Effort & Priority
Medium to high, contingent on obtaining [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] to concretize the pattern.

7. Likely False-Positive Sources & Mitigations
- Superficial pattern matches lacking semantic equivalence; mitigate by requiring identical operands/resources and API roles as in the patch.
- Guards implemented via helper wrappers rather than inline; mitigate with interprocedural guard recognition and sanitizer modeling.
- Alternative but equivalent validations; mitigate by recognizing stronger/equivalent predicates and suppressing such cases.

8. Limitations & Assumptions
- [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS] are missing, so the vulnerability class, APIs, and exact guard predicates are unknown.
- The plan assumes a patch exists that adds observable checks, orderings, or state invariants; if the fix is non-local or architectural, additional modeling will be required.
- Specific signals, sources/sinks, and suppressors must be derived from the actual patch/root cause once available; without them, a concrete checker cannot be finalized.