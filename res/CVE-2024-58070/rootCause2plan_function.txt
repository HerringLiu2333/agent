1. Plan Summary
Template detection plan driven by patch-differential cues to flag pre-patch misuse patterns; concrete signals cannot be specified because [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS] are not provided.

2. Detection Steps
1) Step 1: Objective — identify scope of impact; conceptual signals — enumerate functions, files, and symbols modified or introduced in [PATCH_DIFF]; FP mitigation — restrict all subsequent checks to these functions and their direct callers to avoid broad matches.
2) Step 2: Objective — detect missing null/validity guards added by the patch; conceptual signals — look for pre-guard dereference/use of pointers or objects that the patch later guards with null/validity checks; FP mitigation — require control-flow dominance of the use over any equivalent check and ensure no prior guard on all paths.
3) Step 3: Objective — detect missing bounds/range validation introduced by the patch; conceptual signals — locate array indexing, pointer arithmetic, memcpy/memmove/read/write operations where indices/lengths are derived from parameters or external inputs that the patch compares against size/limits; FP mitigation — confirm absence of a bounds check on the same variable earlier in the dominating control flow and exclude uses with statically provable safe sizes.
4) Step 4: Objective — detect ignored or misinterpreted error/return codes the patch starts checking; conceptual signals — find calls to the specific functions whose return is newly checked where, pre-patch, the return value is unused or only checked for success incorrectly; FP mitigation — require a subsequent use that assumes success (e.g., deref, size use) and no intervening error-path handling.
5) Step 5: Objective — detect missing authorization/permission checks added by the patch; conceptual signals — identify privileged operations (e.g., state changes, file/network actions) in the changed functions that, post-patch, are guarded by role/permission checks; FP mitigation — constrain to the same entry points/APIs and require absence of any equivalent authorization predicate in dominating control flow.
6) Step 6: Objective — detect missing synchronization/locking added by the patch; conceptual signals — find reads/writes to shared state (globals, struct fields) that the patch wraps with lock/unlock or atomic ops; FP mitigation — ensure there is no lock held on the same lock variable along the path and exclude thread-local or function-local state.
7) Step 7: Objective — detect refcount/lifetime fixes added by the patch; conceptual signals — track allocations/refs that the patch increments/decrements or adds get/put calls around, and flag paths with use-after-release or missing ref increments; FP mitigation — require a feasible path from release to use or from acquisition to escape without increment, ignoring paths with clear ownership transfer semantics.
8) Step 8: Objective — detect initialization/zeroing added by the patch; conceptual signals — identify variables/buffers/struct fields newly initialized or zeroed and flag uses or outward flows (returns, memcpy, logging) before definite assignment; FP mitigation — require that no dominating assignment fully covers the used range and exclude constants or read-only data.
9) Step 9: Objective — detect sanitization/escaping added by the patch; conceptual signals — find sinks (format strings, SQL, shell, path joins) that the patch starts sanitizing/escaping and flag flows from parameters or external inputs into those sinks without passing through the same sanitizer; FP mitigation — restrict sources to the modified function parameters and known external inputs, and recognize equivalent sanitizers.
10) Step 10: Objective — detect integer overflow/underflow checks added by the patch; conceptual signals — locate arithmetic used for size/offset/memory allocation that the patch bounds-checks, and flag uses without such guards; FP mitigation — require the arithmetic feeds into allocation, copy length, or pointer arithmetic and exclude cases with compile-time provably safe ranges.
11) Step 11: Objective — correlate added early returns/error paths with missing preconditions; conceptual signals — where the patch inserts early returns on invalid state, find pre-patch paths that continue execution without those preconditions; FP mitigation — require that subsequent operations rely on the preconditioned state (e.g., non-empty, non-negative, open handle).
12) Step 12: Objective — reduce noise via equivalence and dominance; conceptual signals — treat semantically equivalent checks (macros/helpers) as satisfying guards and ensure check-to-use dominance along all feasible paths; FP mitigation — model common wrappers and short-circuit logical conditions to avoid double-reporting.

3. Target Elements
- Functions and methods modified/added per [PATCH_DIFF].
- Call sites to functions whose return values/side effects are newly validated.
- Condition checks introduced by the patch (null, bounds, auth, error codes).
- Memory operations (allocation, memcpy/memmove/read/write, pointer arithmetic).
- Lock/unlock regions and shared state accesses.
- Reference count and lifetime management calls.
- Sinks for output/logging/command/SQL/path usage affected by the patch.

4. Dataflow / Taint Considerations
- Track flows from function parameters and external inputs into memory sizes, indices, dereferenced pointers, and security-sensitive sinks mentioned in the patch.
- Track nullness/validity, numeric range, and lock state as path predicates to enforce “guard-before-use” dominance.
- Track error codes/return values from specific callees that the patch starts checking, and propagate their success/failure semantics to subsequent uses.
- Track object lifetime/refcount along acquire/use/release edges to find UAF or leak patterns corrected by the patch.

5. Validation & Test Cases
- Positive: A function using a parameter as a buffer length in memcpy without prior bounds check that the patch would add; a pointer dereferenced without null check where the patch introduces one; a call whose return value is ignored pre-patch but checked post-patch.
- Negative: Same patterns but with a dominating, equivalent bounds/null/auth check already present; return value checked correctly with proper error handling; shared state accessed under the correct lock.
- Test harness notes: Build minimal examples mirroring each guarded pattern introduced by the patch and ensure the checker reports only the unguarded variants and suppresses guarded ones.

6. Estimated Effort & Priority
Medium — effort depends on extracting concrete callee/guard/sink identities from [PATCH_DIFF]; without them, only a generic template can be prepared.

7. Likely False-Positive Sources & Mitigations
- Implicit invariants established by callers or construction routines not visible intra-procedurally — mitigate via inter-procedural dominance and contracts if available.
- Equivalent checks hidden behind macros/helpers — mitigate by modeling known wrappers.
- Feasibility issues on complex conditionals — mitigate via path pruning and requiring check-to-use dominance.
- Shared state that is effectively thread-local — mitigate by excluding locals and thread-confined structures when identifiable.

8. Limitations & Assumptions
- No [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], or [ROOTCAUSE_ANALYSIS] were provided, so concrete vulnerability class, sources, sinks, and guard identities cannot be specified.
- Assumes the patch adds explicit checks/locking/sanitization that can be mirrored as negative patterns pre-patch; if the fix is architectural or involves protocol changes, static detection may be impractical.
- Assumes availability of inter-procedural control/dataflow to model dominance and guard propagation; precision depends on project language and CodeQL library support.