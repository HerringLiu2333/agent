1. Plan Summary
Detect verifier code and BPF subprogram definitions that fail to model tail-call helpers as invalidating packet pointers, and BPF program patterns that use packet pointers after a tail call.

2. Detection Steps
1) Step 1: Identify the verifier function(s) that classify whether a helper “changes/invalidates packet data.” Signals: functions like bpf_helper_changes_pkt_data or equivalent switch/mapping over helper IDs returning a boolean/flag for packet-data changes.

2) Step 2: Identify helper IDs/functions representing tail-call helpers. Signals: helper identifiers or callee names containing “tail_call” (e.g., bpf_tail_call_static) or comments/enum entries explicitly denoting tail calls.

3) Step 3: Check the classifier from Step 1 for handling of tail-call helpers. Signals: absence of cases/entries for tail-call helpers, or cases that return “does not change packet data” for them; if so, report missing invalidation.

4) Step 4: Verify that the “changes packet data” decision feeds into the verifier’s inter-procedural/subprogram propagation logic. Signals: callers such as check_cfg (or similarly named CFG/summary computation) invoking the classifier; if tail-call helpers are not considered in this propagation, flag potential lack of invalidation across global sub-programs.

5) Step 5: Find BPF-to-BPF subprogram or stub functions that perform a tail call. Signals: functions whose bodies invoke a tail-call helper identified in Step 2, including wrappers used for tc programs or freplace entry points.

6) Step 6: For functions from Step 5, check for explicit marking/metadata that they can invalidate packet pointers. Signals: associated annotations/flags/registration fields indicating “changes packet data” (the same concept used by the verifier); if a tail-calling function lacks such marking, flag it.

7) Step 7: Cross-check consistency between Steps 1/2/6: if a tail-call helper is correctly classified as invalidating packet data, ensure the subprograms that call it are treated as packet-data-changing by the same mechanism. Signals: missing linkage between function-level metadata and helper-effect classification leading to non-propagation; flag inconsistencies.

8) Step 8: Optionally, detect vulnerable BPF program patterns that rely on the unsound verifier. Signals: in eBPF C sources, a pointer derived from sk->data (or sk->data_end) is computed and later dereferenced after a call to a tail-call helper, with the pointer created before the tail call and used after it.

9) Step 9: For Step 8, ensure the pointer is made “valid” before the tail call and then used after it. Signals: bounds/validity checks or arithmetic on the sk->data-derived pointer before the tail call, followed by a write/read through the same pointer after the tail call.

10) Step 10: Prioritize reports where the verifier code lacks tail-call invalidation (Steps 3–4) and there exist subprograms or examples that perform tail calls without proper marking (Step 6), as these are the core pre-patch flaws. Signals: co-occurrence of these conditions to reduce false positives.

3. Limitations & Assumptions
- Exact helper ID names and the concrete form of the “changes packet data” flag/metadata are not specified; detection relies on identifying classifier functions and tail-call helpers by conceptual signals (names/comments/enums).
- The specific propagation function name (e.g., check_cfg) and how it consumes the classifier is not fully detailed; the checker assumes there is a call chain from CFG/summary computation to the classifier.
- The mechanism to “mark a function as invalidating packet pointers” for subprograms (e.g., attributes, flags in registration structs) is not described; the checker must generalize across likely annotations.
- Availability of eBPF program sources (for Steps 8–9) is project-dependent; absence of such sources limits program-level pattern detection.
- The mailbox driver diff provided is unrelated to this CVE and should be ignored for this checker.