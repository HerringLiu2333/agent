1. Plan Summary
Detect functions that call devm_ioremap (which returns NULL on failure) but check the result with IS_ERR and/or propagate a possible NULL while otherwise using ERR_PTR-based error signaling.

2. Detection Steps
1) Step 1: Identify candidate functions that use ERR_PTR-based error signaling â€” look for functions returning a pointer type that have at least one return of ERR_PTR(...) anywhere in the body.
2) Step 2: Within those functions, find local pointer variables assigned from a call to devm_ioremap(...) (the callee known here to return NULL on failure, not ERR_PTR).
3) Step 3: For each such variable, search for conditions that test IS_ERR(var) or IS_ERR_VALUE(var) as the primary/only error check on that variable.
4) Step 4: Verify absence of a null-check on that variable (e.g., !var or var == NULL) that leads to an explicit ERR_PTR(...) return or equivalent error handling before the value is returned or used.
5) Step 5: Trace dataflow from the devm_ioremap(...) result to any return statement; if the variable can reach a return as-is (returned directly or via simple passthrough) without a preceding NULL-to-ERR_PTR conversion, record this path.
6) Step 6: If an IS_ERR(var) branch exists but does not return or otherwise prevent later return/use of var (e.g., it only logs with dev_err(...) and falls through), mark this as unhandled error path likely to propagate NULL.
7) Step 7: Corroborate mixed signaling by confirming the same function returns ERR_PTR(...) in any other error path (e.g., after platform_get_resource_byname failure), indicating callers expect ERR_PTR-based errors rather than NULL.
8) Step 8: Report findings when both conditions hold: misuse of IS_ERR on a devm_ioremap(...) result and potential propagation of a NULL value in a function that otherwise returns ERR_PTR on errors; optionally downgrade to a weaker warning if only the IS_ERR misuse is present without proven NULL propagation to return.

3. Limitations & Assumptions
- The API knowledge used is limited to devm_ioremap returning NULL on failure; other NULL-on-failure APIs are not modeled due to lack of information.
- The plan assumes ERR_PTR(...) and IS_ERR(...) can be recognized as macro-like constructs; macro expansion details may affect detection.
- Control- and dataflow checks rely on intra-procedural analysis; cross-function propagation or aliasing through wrappers is not covered.
- The checker infers an ERR_PTR contract from the presence of ERR_PTR(...) returns; if a function intentionally mixes NULL and ERR_PTR returns, the tool may flag false positives.