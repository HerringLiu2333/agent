1. Plan Summary
Detect Linux kernel functions that call devm_ioremap(), incorrectly use IS_ERR() to test its result, and propagate a NULL pointer while the function otherwise follows an ERR_PTR-based error-return convention.

2. Detection Steps
1) Step 1: Objective: Locate candidate functions using devm_ioremap(). Signals: A call to devm_ioremap() with result assigned to a local pointer variable. FP mitigation: Restrict to functions where this result variable flows to a return statement.
2) Step 2: Objective: Identify misuse of error check on the devm_ioremap() result. Signals: Presence of an IS_ERR(var) condition applied to the variable holding the devm_ioremap() result. FP mitigation: Ensure the IS_ERR check is control-flow reachable from the devm_ioremap() assignment (same function, same variable).
3) Step 3: Objective: Establish the function’s ERR_PTR-based error convention. Signals: Any return statement in the same function that returns ERR_PTR(some_negative_errno). FP mitigation: Require at least one explicit ERR_PTR(...) return path to confirm mixed error signaling risk (based on ROOTCAUSE_ANALYSIS and FUNCTION_CONTENT).
4) Step 4: Objective: Find potential NULL propagation despite the IS_ERR check. Signals: A return path that returns the mapping variable directly (or an alias) without any preceding explicit !var check along that path. FP mitigation: Use control-flow reasoning to confirm no dominating !var check leads to an ERR_PTR return before the final return.
5) Step 5: Objective: Confirm lack of NULL-to-ERR_PTR conversion for devm_ioremap() failure. Signals: Absence of a branch testing !var that returns ERR_PTR(...) after the devm_ioremap() call site; the only error guard around the mapping is IS_ERR(var). FP mitigation: Exclude functions that do have an explicit !var check converting to ERR_PTR(-ENOMEM) or similar (as in PATCH_DIFF).
6) Step 6: Objective: Strengthen confidence by checking for logging-only behavior on the IS_ERR branch. Signals: A dev_err(...) (or similar) inside the IS_ERR(var) branch that does not alter the return value or perform conversion. FP mitigation: Treat this as supporting evidence; do not require its presence to avoid missing minimal code variants.
7) Step 7: Objective: Identify mixed NULL vs ERR_PTR returns as an independent red flag. Signals: The function has at least one return of ERR_PTR(...) and at least one return that could be NULL (e.g., returns the devm_ioremap result without a null guard). FP mitigation: Confirm the potential NULL originates from the devm_ioremap() result to avoid flagging unrelated returns.
8) Step 8: Objective: Reduce FPs from alternative error conventions. Signals: If the function never returns ERR_PTR(...) anywhere, do not report (it may legitimately use NULL to signal errors). FP mitigation: Enforce Step 3 prerequisite; only report mixed-convention cases.
9) Step 9: Objective: Scope to the exact API semantics stated in the analysis. Signals: Treat only devm_ioremap() as a “NULL-on-failure” API (based on ROOTCAUSE_ANALYSIS). FP mitigation: Do not generalize to other mapping helpers unless explicitly listed (not provided here).

3. Target Elements
- Functions that call devm_ioremap().
- Local variables assigned the result of devm_ioremap().
- Condition checks using IS_ERR(var) on that result.
- Return statements returning the mapping variable or ERR_PTR(...).
- Error logging calls (e.g., dev_err) near the error-check sites.

4. Dataflow / Taint Considerations
- Track the value produced by devm_ioremap() through direct assignments and simple aliases to returns.
- Model control-flow from the call site to condition checks (IS_ERR and !var) and to return statements.
- Identify dominating null checks vs. IS_ERR checks to determine whether a NULL-to-ERR_PTR conversion occurs before return.

5. Validation & Test Cases
- Positive: The pre-patch th1520_map_mmio() that calls devm_ioremap(), checks IS_ERR(mapped), logs, and returns mapped; elsewhere returns ERR_PTR(-EINVAL). Expected: Report.
- Positive: Variant without logging where IS_ERR(mapped) is checked, but function still returns mapped and has another ERR_PTR return path. Expected: Report.
- Negative: The patched version that checks !mapped, logs, and returns ERR_PTR(-ENOMEM), and also returns ERR_PTR on other errors. Expected: No report.
- Negative: A function that calls devm_ioremap(), checks !mapped, returns NULL on failure, and never returns ERR_PTR anywhere. Expected: No report.
- Test harness notes: Run intra-procedural analysis over kernel driver files; ensure control-flow paths and returns are correctly modeled.

6. Estimated Effort & Priority
Medium effort, high priority for kernel code using devm_ioremap() due to crash risk from NULL dereference (based on ROOTCAUSE_ANALYSIS and PATCH_DIFF).

7. Likely False-Positive Sources & Mitigations
- Functions intentionally mixing NULL and ERR_PTR conventions for distinct semantics: mitigate by requiring explicit ERR_PTR returns and direct propagation of the devm_ioremap() result without a null guard.
- Paths pruned by macros or build-time conditionals: mitigate by focusing on structurally present checks and returns; acknowledge potential over-approximation.
- Complex aliasing where the mapping variable is sanitized before return: mitigate by tracking simple aliases and excluding paths where a !var check dominates and converts to ERR_PTR.

8. Limitations & Assumptions
- Assumes devm_ioremap() returns NULL on failure (per ROOTCAUSE_ANALYSIS); no generalization to other helpers due to lack of evidence.
- Does not verify caller-side expectations; relies on intra-function evidence of ERR_PTR returns to infer intended error convention.
- Path feasibility is approximated; the checker may not fully resolve all macro-conditional flows common in kernel code.