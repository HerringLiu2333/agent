1. CVE Identifier
CVE-2024-58022

2. Vulnerability Type
Improper state tracking in the eBPF verifier leading to unsafe use of packet pointers after tail calls (logic/verifier unsoundness; effectively a TOCTOU on pointer validity across tail-call boundaries)

3. Root Cause Summary
The eBPF verifier did not model that a tail-called program can execute helpers which invalidate packet pointers, so it failed to conservatively invalidate packet pointer state at tail-call sites. As a result, the verifier allowed programs to take a packet data pointer, perform a tail call, and then continue using the stale pointer, despite the callee being able to invalidate it. This unsoundness enabled unsafe memory access to packet data after tail calls.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- eBPF verifier and tc eBPF program infrastructure

2) Pre-Patch Flaw:
- The verifier’s changes_pkt_data tracking did not treat tail calls as potentially invalidating packet pointers. Specifically, bpf_helper_changes_pkt_data() did not consider tail call helpers, and check_cfg() did not propagate invalidation across global sub-program tail-call edges.

3) Trigger Condition:
- A tc eBPF program obtains a pointer to sk->data, makes it valid, performs a tail call to another program (which may run helpers that change/invalidate packet data/pointers), and then attempts to use the original pointer after the tail call (e.g., “*p = 42”).

4) Impact Mechanism:
- Continued use of a stale/invalid packet pointer after a tail call leads to unsafe memory access to packet data, with potential out-of-bounds or invalid writes/reads, resulting in memory corruption or kernel instability.

5. Patch Analysis
1) Fix Approach:
- The patch conservatively assumes each tail call invalidates packet pointers by updating bpf_helper_changes_pkt_data(). It leverages check_cfg() so that the invalidation effect is computed for global sub-programs, causing unsafe patterns to be rejected. Additionally, tc_bpf2bpf.c:subprog_tc() is explicitly marked as a function that can invalidate packet pointers to align with tail-call behavior.

2) Key Code Changes:
- In bpf_helper_changes_pkt_data(): tail-call helpers are treated as changing packet data, thereby invalidating packet pointers at tail-call sites.
- The verifier’s check_cfg() logic automatically applies changes_pkt_data across global sub-programs, resulting in rejection of programs that use packet pointers after tail calls.
- tc_bpf2bpf.c:subprog_tc() updated to be recognized as a function that can invalidate packet pointers, enabling safe freplace with entry_freplace() that performs a tail call.

3) Locking/Concurrency Impact:
- No locking or concurrency changes; the patch strictly adjusts verifier state modeling and function annotations related to packet pointer invalidation.

6. Broader Kernel Security Implications
- Strengthening the verifier’s state tracking across tail-call boundaries prevents unsafe packet pointer reuse, reducing avenues for memory corruption in tc eBPF programs. The conservative invalidation model improves the soundness of eBPF program verification, decreasing the attack surface for verifier-bypass techniques and enhancing overall kernel robustness when running untrusted eBPF code.