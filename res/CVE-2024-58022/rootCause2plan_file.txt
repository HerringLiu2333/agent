1. Plan Summary
Detect kernel drivers that call a NULL-on-failure API (e.g., devm_ioremap), but (a) use ERR_PTR/IS_ERR error semantics inside the wrapper and/or (b) return the raw pointer without converting NULL to ERR_PTR, while callers rely on IS_ERR to detect errors, allowing NULL to propagate to MMIO dereferences.

2. Detection Steps
1) Step 1: Identify wrapper functions that call devm_ioremap and return a pointer — signals: a function that assigns the result of devm_ioremap to a local pointer variable and returns a pointer value to the caller — FP mitigation: restrict to functions returning pointer types (e.g., void __iomem *) and actually returning the assigned value or a close alias.
2) Step 2: Find incorrect failure checks in the wrapper — signals: the wrapper checks IS_ERR or PTR_ERR on the devm_ioremap result, or does not check for NULL before returning — why: devm_ioremap returns NULL on failure per [ROOTCAUSE_ANALYSIS], so IS_ERR is semantically wrong; lack of NULL check enables NULL propagation — FP mitigation: exclude wrappers that also check !ptr or convert NULL into ERR_PTR prior to return (as in [PATCH_DIFF]).
3) Step 3: Flag wrappers that log an error but still return the unmodified pointer — signals: presence of dev_err in an if (IS_ERR(ptr)) branch followed by returning the original pointer — why: matches the pre-patch flaw in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS] — FP mitigation: only flag if no subsequent return of an ERR_PTR is present on that path.
4) Step 4: Link wrapper return values to callers and detect ERR-semantics-only checks — signals: call sites that immediately test IS_ERR on the wrapper’s return value and, on success, proceed without an explicit NULL check — why: matches the caller pattern shown in [FILE_CONTENT] (e.g., if (IS_ERR(...)) return PTR_ERR(...);) and the expectation in [ROOTCAUSE_ANALYSIS] — FP mitigation: exclude call sites that also check for NULL or guard dereferences with !ptr checks.
5) Step 5: Confirm hazardous use of potentially NULL values — signals: dataflow from the wrapper’s returned value into MMIO dereference operations (ioread32/iowrite32), pointer arithmetic (base + offset), or storage into fields later used for MMIO access — why: [ROOTCAUSE_ANALYSIS] shows NULL could be dereferenced in ioread32/iowrite32 paths — FP mitigation: require at least one feasible path from call to dereference without intervening NULL checks.
6) Step 6: Elevate severity when the returned value is stored in long-lived state — signals: assignment into struct fields (e.g., priv->local_icu[...] or priv->remote_icu[...]) used across functions — why: mirrors [FILE_CONTENT] patterns where values populate driver state and are later dereferenced — FP mitigation: ensure paths to later deref are in the same module/file to avoid speculative cross-module flows.
7) Step 7: Recognize safe, patched behavior — signals: wrapper mapping NULL to ERR_PTR on failure (if (!mapped) return ERR_PTR(-ENOMEM)) as in [PATCH_DIFF] — why: aligns FAILURE semantics between callee and callers using IS_ERR, preventing NULL propagation — FP mitigation: do not flag wrappers that implement this conversion.
8) Step 8: Detect mixed or inconsistent checks — signals: functions that both use IS_ERR and NULL checks inconsistently on the same variable derived from devm_ioremap — why: partial fixes can still miss some paths; inconsistent semantics can re-introduce the issue — FP mitigation: only report if at least one return path can return raw NULL while callers rely solely on IS_ERR.

3. Target Elements
- Functions that call devm_ioremap and return pointer values (wrapper/utility allocators like th1520_map_mmio per [FILE_CONTENT]).
- Condition checks using IS_ERR/PTR_ERR versus NULL checks inside these wrappers.
- Return statements returning the mapped pointer or aliases.
- Call sites that test IS_ERR on the wrapper result (e.g., in probe functions) and then use the value.
- Assignments of returned pointers into struct fields (e.g., priv->local_icu/remote_icu in [FILE_CONTENT]).
- MMIO dereference operations (ioread32/iowrite32) and pointer arithmetic on these returned pointers.

4. Dataflow / Taint Considerations
- Track the value from devm_ioremap call result through local variables to the function return.
- Interprocedural flow: from the wrapper’s return to caller variables, then into struct fields or direct uses.
- Sink patterns: ioread32/iowrite32 calls using the value (or its derived base + offset), or comparisons/arithmetics implying deref context.
- Guard recognition: treat explicit NULL checks as sanitizers; IS_ERR checks are not sanitizers for NULL in this context.

5. Validation & Test Cases
- Positive: Pre-patch th1520_map_mmio in [FILE_CONTENT]: devm_ioremap result checked with IS_ERR, error logged, and returned as-is; callers in th1520_mbox_probe use IS_ERR on return, then later use pointers in ioread32/iowrite32 paths; should be flagged.
- Negative: Patched version in [PATCH_DIFF]: if (!mapped) { dev_err; return ERR_PTR(-ENOMEM); } and callers using IS_ERR; should not be flagged.
- Negative: A wrapper that calls devm_ioremap and correctly checks both IS_ERR and !ptr, returning ERR_PTR on failure, with callers checking IS_ERR and/or NULL; should not be flagged.
- Test harness notes: Run on a small kernel subset containing drivers/mailbox/mailbox-th1520.c to ensure the positive case fires pre-patch and clears post-patch.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Wrappers that later convert NULL to ERR_PTR along some but not all paths: mitigate by path-sensitive analysis requiring a NULL-returning path to callers relying solely on IS_ERR.
- Call sites that have implicit runtime guarantees preventing NULL (not statically provable): mitigate by requiring reachability to deref sinks without intervening NULL checks.
- Alternate APIs with different failure conventions: mitigate by restricting to devm_ioremap per [ROOTCAUSE_ANALYSIS].

8. Limitations & Assumptions
- Assumes devm_ioremap returns NULL on failure (from [ROOTCAUSE_ANALYSIS]); other mapping APIs are not considered unless specified similarly.
- Assumes ioread32/iowrite32 represent dereference sinks; other MMIO helpers are not enumerated in the provided materials.
- Does not infer runtime device-tree correctness; focuses purely on static semantic mismatch between NULL-returning API and ERR_PTR-based error handling.
- Cross-file/module dataflow beyond the analyzed compilation unit may be incomplete, potentially missing some dereference paths.