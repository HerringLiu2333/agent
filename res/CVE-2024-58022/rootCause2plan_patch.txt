1. Plan Summary
Detect eBPF tc programs that obtain packet data pointers from sk->data, perform a tail call, and then dereference or use the original packet pointer after the tail call.

2. Detection Steps
1) Step 1: Objective — focus analysis on eBPF tc programs; Signals — functions annotated with SEC("tc") as in the example; FP mitigation — ignore non-eBPF sections to reduce noise. (Based on [PATCH_DESCRIPTION] code sample)
2) Step 2: Objective — identify packet pointer acquisition; Signals — variables initialized from sk->data or casts of sk->data to pointer types; FP mitigation — constrain to struct __sk_buff parameters named sk or equivalent and track only pointers derived from sk->data. (Based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS] trigger pattern)
3) Step 3: Objective — mark tail-call sites; Signals — calls to bpf_tail_call_static or wrapper functions whose body calls bpf_tail_call_static (i.e., tail_call(sk) in the sample); FP mitigation — require the callee to contain a tail-call helper invocation, not just name-based heuristics. (Based on [PATCH_DESCRIPTION] example and [ROOTCAUSE_ANALYSIS] tail-call helpers)
4) Step 4: Objective — propagate tail-call effect through wrappers; Signals — if a function contains a tail-call helper call, treat calls to that function as tail-call sites; FP mitigation — ensure interprocedural analysis is limited to local/global sub-program calls within the same compilation unit. (Based on [ROOTCAUSE_ANALYSIS] check_cfg propagation over global sub-programs)
5) Step 5: Objective — detect use-after-tail-call of packet pointer; Signals — any dereference, write, or pointer arithmetic on the variable derived from sk->data occurring after a tail-call site in the same function; FP mitigation — require an explicit dataflow path from the original sk->data-derived pointer to the post-tail-call use. (Based on [ROOTCAUSE_ANALYSIS] unsafe pattern “*p = 42” after tail call)
6) Step 6: Objective — exclude safe re-derivation; Signals — if the pointer is reassigned to a fresh value from sk->data after the tail call and before use, do not flag; FP mitigation — ensure reassignment kills the earlier taint. (Based on [ROOTCAUSE_ANALYSIS] need to invalidate/recompute packet pointers)
7) Step 7: Objective — exclude cases with no post-call usage; Signals — if the pointer is not used after the tail-call site, do not flag; FP mitigation — confirm there is at least one dereference or use after the call. (Maps to avoiding false alarms)
8) Step 8: Objective — capture global sub-program edges; Signals — calls to local helper/subprograms within tc programs that perform tail calls; FP mitigation — only mark functions whose bodies include tail-call helpers, not arbitrary helpers. (Based on [ROOTCAUSE_ANALYSIS] check_cfg logic computing changes_pkt_data for global sub-programs)
9) Step 9: Objective — surface missing conservative modeling in verifier-side code; Signals — in kernel verifier code, functions enumerating helpers that “change packet data” (e.g., bpf_helper_changes_pkt_data()) lacking tail-call helper coverage; FP mitigation — restrict to that specific classification function to minimize unrelated matches. (Based on [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION] noting tail calls must be treated as invalidating)
10) Step 10: Objective — identify tc subprograms intended for freplace that perform tail calls but aren’t marked as invalidating; Signals — functions like subprog_tc used in tc_bpf2bpf.c performing tail calls yet lacking an explicit “can invalidate packet pointers” marker; FP mitigation — limit to files/contexts associated with tc_bpf2bpf and tailcall freplace flows. (Based on [PATCH_DESCRIPTION] note on subprog_tc needing the invalidation mark)
11) Step 11: Objective — prioritize writes/unsafe operations post-tail call; Signals — post-tail-call memory stores via the sk->data-derived pointer (e.g., *p = value) to emphasize risk; FP mitigation — rank reports higher when a store occurs, lower for reads only. (Based on [ROOTCAUSE_ANALYSIS] memory corruption risk)
12) Step 12: Objective — avoid non-eBPF kernel driver patterns; Signals — ignore unrelated subsystems like mailbox-th1520.c changes; FP mitigation — scope to bpf/verifier and tc program directories and functions with SEC annotations. (Based on [PATCH_DIFF] being unrelated and [ROOTCAUSE_ANALYSIS] focusing on eBPF)

3. Target Elements
- Functions annotated with SEC("tc")
- Function bodies containing calls to bpf_tail_call_static or wrapper functions that call it
- Variables derived from struct __sk_buff->data
- Pointer dereferences and memory writes/reads after tail-call sites
- Verifier-side classification functions that enumerate helpers changing packet data (e.g., bpf_helper_changes_pkt_data())
- tc subprograms used for freplace paths that perform tail calls

4. Dataflow / Taint Considerations
- Track taint from sk->data to derived pointers (casts, assignments, address arithmetic).
- Model a tail-call site as a barrier that invalidates taint; report if tainted pointers are used after this barrier without re-derivation.
- Kill taint on reassignment from fresh sk->data post-tail call; retain taint through non-reassigning operations.

5. Validation & Test Cases
- Positive: The sample “SEC("tc") int not_safe(struct __sk_buff *sk) { int *p = (void *)(long)sk->data; ... tail_call(sk); *p = 42; }” should be flagged for using p after a tail call. (Based on [PATCH_DESCRIPTION])
- Negative: A tc program that tail-calls and then reassigns p from sk->data before using it should not be flagged.
- Test harness notes: Include wrapper function tail_call() that calls bpf_tail_call_static to verify interprocedural propagation, and a case with no post-call usage to confirm non-reporting.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Functions misidentified as eBPF programs: mitigate by requiring SEC("tc") annotation.
- Calls falsely identified as tail calls: mitigate by confirming presence of bpf_tail_call_static in the callee’s body.
- Benign reads after tail call without real risk: prioritize writes; allow configuration to filter read-only uses.
- Uncertain verifier-side markers in kernel code: mitigate by scoping to known helper classification functions.

8. Limitations & Assumptions
- Exact list of tail-call helpers is unknown; the plan relies on bpf_tail_call_static and wrapper detection from [PATCH_DESCRIPTION].
- The mechanism to “mark functions that can invalidate packet pointers” (e.g., annotations/flags) is not specified; detection of missing marks is heuristic. (Based on [PATCH_DESCRIPTION] note about subprog_tc)
- Details of bpf_helper_changes_pkt_data() implementation are not provided; checker can only flag potential omission conceptually. (Based on [ROOTCAUSE_ANALYSIS])
- The unrelated [PATCH_DIFF] for mailbox-th1520.c is not used in detection logic.