1. Plan Summary
Detect functions that wrap devm_ioremap (which returns NULL on failure) but use IS_ERR-based error handling and return the raw pointer, while callers expect ERR_PTR semantics and check with IS_ERR, allowing NULL to propagate and be dereferenced.

2. Detection Steps
1) Step 1: Identify candidate wrapper functions that return a pointer (e.g., void __iomem *) and contain a call to devm_ioremap; record the local variable receiving the devm_ioremap result and any return statements that return it unchanged.
2) Step 2: Within such functions, look for error handling that calls IS_ERR on the devm_ioremap result variable; this indicates a semantic mismatch because devm_ioremap fails with NULL rather than ERR_PTR.
3) Step 3: Check whether the function lacks a NULL check on the devm_ioremap result (e.g., no “if (!mapped)” handling) and does not convert a failure into ERR_PTR; the signal is the absence of a path that returns ERR_PTR tied to the devm_ioremap result.
4) Step 4: Detect mixed error conventions in the wrapper: the function returns ERR_PTR in some branches (e.g., missing resource) but returns the raw devm_ioremap result in the normal path; this inconsistency increases the likelihood of callers assuming ERR_PTR semantics uniformly.
5) Step 5: Find call sites of the wrapper where the returned value is checked with IS_ERR (and optionally used with PTR_ERR); this shows the caller expects ERR_PTR on failure.
6) Step 6: Confirm at least one “success” path at the caller proceeds after the IS_ERR check and uses the returned pointer (e.g., assigns to a field or array element for later use), indicating a potential for NULL to be treated as valid.
7) Step 7: Track the dataflow from the returned pointer into MMIO operations or pointer arithmetic (e.g., used in ioread32/iowrite32, or as a base plus an offset); this establishes the risk of NULL dereference if mapping failed.
8) Step 8: Emit a finding when all of the following hold: wrapper calls devm_ioremap, uses IS_ERR on its result without proper NULL-to-ERR_PTR conversion, returns the raw result; and a caller checks IS_ERR on that result and later uses it in IO or pointer arithmetic.

3. Limitations & Assumptions
- Assumes devm_ioremap returns NULL on failure (as described) and not ERR_PTR; other APIs are out of scope.
- The checker focuses on devm_ioremap and may miss similar issues with other APIs lacking explicit documentation here.
- Dataflow to dereference is approximated; the checker may flag potential issues even when a runtime NULL cannot occur or is guarded elsewhere.
- The plan relies on recognizing IS_ERR/PTR_ERR usage as indicating ERR_PTR expectations; code using alternative patterns may not be detected.