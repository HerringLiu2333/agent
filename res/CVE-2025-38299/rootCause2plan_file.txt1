1. Plan Summary
Detect ASoC machine driver code where codec components are declared as empty in DAI links, yet later code performs string comparisons on dai_link->codecs->dai_name without a preceding NULL check, leading to potential NULL dereferences when no codec is bound.

2. Detection Steps
1) Step 1: Identify DAI link definitions that specify an empty codec component. Conceptually match SND_SOC_DAILINK_DEFS invocations where the codec component array uses COMP_EMPTY() (as seen for ETDM2_IN_BE and ETDM1_OUT_BE before the patch) and record the link identifiers/names.

2) Step 2: Exclude safe dummy codec setups. From the same macro contexts, note links that use COMP_DUMMY() for the codec component (safe default with non-NULL "snd-soc-dummy-dai") and exclude them from further consideration.

3) Step 3: Locate code paths that operate on the identified DAI links by name. Find branches that compare dai_link->name against string literals matching those DAI link names (e.g., "ETDM1_OUT_BE", "ETDM2_IN_BE") to determine handling blocks for those links.

4) Step 4: Within those handling blocks, find string-comparison calls that dereference dai_link->codecs->dai_name. Conceptually match calls to strcmp/strncmp-style APIs (including logical negation patterns like !strcmp) where one argument is dai_link->codecs->dai_name (possibly via local variables or aliases).

5) Step 5: Check for insufficient guarding before the string compare. Verify there is no control-flow-dominating check ensuring dai_link->codecs is non-NULL and dai_link->codecs->dai_name is non-NULL prior to the string comparison; a guard only on dai_link->num_codecs (e.g., if (!dai_link->num_codecs) continue;) does not satisfy this condition.

6) Step 6: Confirm the risk persists despite “dummy dai” filtering logic. If the code relies on comparing against "snd-soc-dummy-dai" to short-circuit behavior, still flag when the string compare is executed unconditionally without a preceding NULL test on dai_link->codecs->dai_name.

7) Step 7: Widen to generic unsafe uses outside name-guarded blocks. Independently of Step 3, also flag any call to strcmp-like functions on dai_link->codecs->dai_name anywhere in the file when no dominating NULL check on that field exists, because a DAI link with COMP_EMPTY() implies dai_name can be NULL until later binding.

8) Step 8: Reduce false positives by recognizing explicit assignments to dai_link->codecs->dai_name along the same path. If the analysis can confirm that, along all paths reaching the strcmp call, dai_link->codecs->dai_name is assigned a non-NULL string (e.g., set to "i2s-hifi" in mt8195_mt6359_legacy_probe), suppress the alert for that call.

9) Step 9: Correlate hazards to specific DAI links for actionable reporting. When possible, include the DAI link name (from dai_link->name comparisons) and the macro definition site using COMP_EMPTY() to show the cause (empty codec) and effect (unsafe strcmp on dai_name).

3. Limitations & Assumptions
- Macro expansion details (SND_SOC_DAILINK_DEFS/REG) may be opaque; the checker assumes it can conceptually detect uses of COMP_EMPTY() and COMP_DUMMY() in codec component arrays and correlate them to link names.
- Device tree bindings and runtime codec attachments are not visible to static analysis; the checker assumes that COMP_EMPTY() implies dai_link->codecs->dai_name can be NULL at probe time.
- The set of string-compare functions is assumed to include strcmp/strncmp-style APIs; architecture-specific aliases (e.g., __pi_strcmp) may not be recognized without a mapping.
- Path feasibility and dominance of NULL checks are approximated; in complex control flow, proving that all paths assign a non-NULL dai_name before strcmp may be conservative.