1. Plan Summary
Detect kernel ASoC machine-driver patterns where a DAI link’s codec component is defined as empty (COMP_EMPTY), yet later code performs string comparisons on dai_link->codecs->dai_name without a NULL check, leading to NULL pointer dereference when a device tree does not assign a codec.

2. Detection Steps
1) Step 1: Identify DAI link definitions with codec components set to COMP_EMPTY — look for SND_SOC_DAILINK_DEFS blocks whose second component array (codec slot) uses COMP_EMPTY (e.g., ETDM2_IN_BE and ETDM1_OUT_BE per [PATCH_DIFF]/[FILE_CONTENT]) — restrict to links that are referenced later by name in probe logic to reduce false positives.
2) Step 2: Record the link names from Step 1 — extract the textual names specified in SND_SOC_DAILINK_DEFS and corresponding SND_SOC_DAILINK_REG usage — this maps link names to potentially NULL dai_name due to COMP_EMPTY as per [ROOTCAUSE_ANALYSIS].
3) Step 3: Locate probe/setup functions iterating DAI links — find functions traversing card prelinks (e.g., for_each_card_prelinks) and branching on dai_link->name (matching recorded link names) — focusing on mt8195_mt6359_soc_card_probe and mt8195_mt6359_legacy_probe per [FILE_CONTENT].
4) Step 4: Within matched branches, detect calls to string comparison functions on dai_link->codecs->dai_name — look for strcmp/strstr/etc. with lhs/rhs referencing dai_link->codecs->dai_name — this corresponds to the crash shown in the call trace (__pi_strcmp) in [PATCH_DESCRIPTION].
5) Step 5: Verify absence of local NULL guards — within the control-flow region leading to the string compare, check that neither dai_link->codecs nor dai_link->codecs->dai_name is asserted non-NULL (e.g., no explicit pointer checks) — this directly maps to the unsafe use described in [ROOTCAUSE_ANALYSIS].
6) Step 6: Check for misleading “num_codecs” guard only — flag when the only guard is dai_link->num_codecs (non-zero) but no validation of dai_link->codecs->dai_name — per [ROOTCAUSE_ANALYSIS], COMP_EMPTY yields num_codecs > 0 while dai_name is NULL; this reduces false positives by focusing on the problematic guard pattern.
7) Step 7: Highlight comparisons against "snd-soc-dummy-dai" — detect strcmp of dai_link->codecs->dai_name with "snd-soc-dummy-dai" without prior NULL checks — this specific pattern appears in mt8195_mt6359_soc_card_probe and is central to the crash per [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS].
8) Step 8: Correlate definition and use across the same TU — ensure that the COMP_EMPTY DAI link and the unsafe strcmp on that link’s dai_name both exist in the same translation unit/file (mt8195-mt6359.c) — this reduces noise from unrelated modules.
9) Step 9: Exclude cases where the codec dai_name is set unconditionally before compare — in the same branch, if code assigns dai_link->codecs->dai_name based on a non-NULL codec_node prior to string comparisons, treat as safe for this path — mitigates false positives in legacy probe where assignment occurs inside the branch per [FILE_CONTENT].
10) Step 10: Prefer ETDMx links as high-risk — prioritize ETDM1_OUT_BE and ETDM2_IN_BE branches since they were impacted pre-patch per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — reduces false positives by focusing on links commonly involved in codec selection logic.
11) Step 11: Flag lack of fallback to COMP_DUMMY — if a link with COMP_EMPTY is compared against "snd-soc-dummy-dai" later, and no path ensures COMP_DUMMY replacement, report — this aligns with the fix approach in [PATCH_DIFF].
12) Step 12: Rank findings higher when a device-tree-dependent assignment is optional — if branches handle missing codec_node (e.g., dev_err without setting dai_name) and still perform string compares elsewhere, prioritize — matches the trigger condition in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Macro-initialized DAI link definitions (SND_SOC_DAILINK_DEFS, SND_SOC_DAILINK_REG) and component arrays.
- Struct field accesses: snd_soc_dai_link->codecs and ->codecs->dai_name.
- Functions iterating/processing dai_links (e.g., mt8195_mt6359_soc_card_probe, mt8195_mt6359_legacy_probe).
- Call sites of string comparison functions (strcmp/strstr) using dai_link->codecs->dai_name.
- Conditional checks involving dai_link->name and dai_link->num_codecs.

4. Dataflow / Taint Considerations
- Track DAI link names from definitions with COMP_EMPTY through to probe functions that branch on dai_link->name and then reach string comparisons.
- Model potential NULL for dai_link->codecs->dai_name when the link’s codec component was COMP_EMPTY and no assignment is guaranteed in the path.
- Treat dai_link->num_codecs as an unreliable non-NULL indicator for dai_name per [ROOTCAUSE_ANALYSIS], avoiding it as a safety proof.

5. Validation & Test Cases
- Positive: Pre-patch mt8195-mt6359.c where ETDM2_IN_BE and ETDM1_OUT_BE use COMP_EMPTY in SND_SOC_DAILINK_DEFS, and mt8195_mt6359_soc_card_probe compares dai_link->codecs->dai_name (e.g., against "snd-soc-dummy-dai") without NULL checks; expect detection.
- Negative: Post-patch with COMP_DUMMY in those links (per [PATCH_DIFF]) or code that explicitly checks dai_link->codecs and dai_link->codecs->dai_name for NULL before strcmp; expect no detection.
- Test harness notes: Run on the provided file and similar ASoC machine drivers; ensure macro-expanded analysis captures struct initializations and follows control-flow into probe functions.

6. Estimated Effort & Priority
High — kernel boot-time crashes due to NULL deref warrant prioritization; analysis requires correlating macro-based initialization with later probe logic.

7. Likely False-Positive Sources & Mitigations
- Cases where dai_name is guaranteed non-NULL via earlier initialization not visible in local scope; mitigate by requiring local assignment or NULL checks in the same control-flow path.
- String compares inside branches that are dominated by checks ensuring dai_link->codecs->dai_name is set (e.g., codec_node-backed assignment); mitigate by recognizing such assignments.
- DAI links with COMP_EMPTY that are never branched upon in probe logic; mitigate by cross-referencing link names used in code.

8. Limitations & Assumptions
- Assumes that COMP_EMPTY yields dai_link->codecs->dai_name == NULL, based on [ROOTCAUSE_ANALYSIS]; the exact macro expansion is not shown.
- Device tree bindings and runtime conditions are not statically determinable; the checker focuses on code patterns that are unsafe regardless of DT.
- The checker relies on recognition of common string comparison functions (e.g., strcmp); variants or wrappers may need manual extension.