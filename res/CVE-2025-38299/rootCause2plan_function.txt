1. Plan Summary
Detect ASoC machine drivers that define back-end DAI links with codec components initialized via COMP_EMPTY(), leaving dai_name NULL and later passed to strcmp-like comparisons in probe paths, causing a NULL dereference.

2. Detection Steps
1) Step 1: Identify SND_SOC_DAILINK_DEFS macro invocations whose codec component uses COMP_EMPTY(). Signals: macro with three component arrays where the second (codec) array contains COMP_EMPTY(); this maps to the root cause per [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION]. FP mitigation: restrict to links named with a “_BE” suffix (back-end), as shown in [FUNCTION_CONTENT].

2) Step 2: Highlight inconsistent usage within the same file where most links use COMP_DUMMY() but specific links use COMP_EMPTY(). Signals: in the same compilation unit, count codec arrays using COMP_DUMMY() vs COMP_EMPTY(); affected links (ETDM2_IN_BE, ETDM1_OUT_BE) differ from the prevailing pattern in [FUNCTION_CONTENT]. FP mitigation: only flag if there exists at least one other DAI link in the file using COMP_DUMMY() for a codec component.

3) Step 3: Determine whether the flagged link name is referenced by runtime connection tables, increasing likelihood it is exercised. Signals: presence of the flagged DAI link name string (e.g., "ETDM2_IN_BE", "ETDM1_OUT_BE") in arrays like g_sof_conn_streams, as shown in [FUNCTION_CONTENT]. FP mitigation: require at least one reference in such tables to raise confidence.

4) Step 4: Locate probe-related functions likely to perform name matching (e.g., functions named *probe) and find calls to strcmp-like routines. Signals: calls to strcmp or __pi_strcmp within functions whose names end with "probe", consistent with the call trace in [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]. FP mitigation: restrict to calls within probe paths or ASoC setup helpers (e.g., mtk_soundcard_common_probe).

5) Step 5: Trace dataflow from the DAI link’s codec dai_name field (produced by COMP_EMPTY(), which yields NULL) to arguments of strcmp-like calls. Signals: conceptual flow from a dailink codec’s dai_name to strcmp parameters (call trace shows x0 = 0, i.e., NULL passed) per [PATCH_DESCRIPTION]. FP mitigation: require the flow to be unconditionally reachable without intervening non-NULL assignments.

6) Step 6: Check for defensive null checks along the path to strcmp on the same variable. Signals: preceding tests comparing the variable to NULL before the strcmp call; this directly addresses the dereference risk per [ROOTCAUSE_ANALYSIS]. FP mitigation: suppress if a null-check or a guaranteed non-NULL assignment exists on all paths.

7) Step 7: Prioritize flagged cases where the codec is optional (absence of COMP_CODEC(...) entries) and the macro explicitly uses COMP_EMPTY(). Signals: codec array consists solely of COMP_EMPTY() with no real codec provided, as in ETDM2_IN_BE and ETDM1_OUT_BE before patch ([FUNCTION_CONTENT]). FP mitigation: do not flag when a real codec is present via COMP_CODEC(...).

8) Step 8: Elevate severity when the same driver exhibits a fix pattern elsewhere (uses COMP_DUMMY() for other similar links). Signals: nearby DAI links (e.g., ETDM1_IN_BE, ETDM2_OUT_BE) using COMP_DUMMY() in [FUNCTION_CONTENT] and the precise corrections in [PATCH_DIFF]. FP mitigation: require the presence of this fix pattern to confirm intended safe initialization.

3. Target Elements
- Macro invocations: SND_SOC_DAILINK_DEFS and DAILINK_COMP_ARRAY arguments.
- Codec component initializers: COMP_EMPTY(), COMP_DUMMY(), COMP_CODEC(...).
- String literal link names referenced in connection arrays (e.g., g_sof_conn_streams).
- Probe functions and initialization routines (e.g., mt8195_mt6359_soc_card_probe, mtk_soundcard_common_probe).
- Calls to strcmp-like functions (__pi_strcmp/strcmp) and their arguments.
- Null-check conditions on variables used in string comparisons.

4. Dataflow / Taint Considerations
- Track initialization of dai_name via macro patterns: COMP_EMPTY() implies dai_name = NULL; COMP_DUMMY() implies a non-NULL dummy name.
- Propagate the dai_name pointer through structures and helper calls into probe paths.
- Identify flows into strcmp-like call arguments and verify absence of null-guarding along all reachable paths.

5. Validation & Test Cases
- Positive: A file defining ETDM2_IN_BE and ETDM1_OUT_BE with COMP_EMPTY() in the codec array, link names used in g_sof_conn_streams, and a probe function calling strcmp on the codec dai_name without a prior NULL check; expect a report (based on [FUNCTION_CONTENT], [PATCH_DESCRIPTION], [ROOTCAUSE_ANALYSIS]).
- Negative: Same links defined with COMP_DUMMY() (as in [PATCH_DIFF]), or links using COMP_CODEC(...), or code performing a NULL check before strcmp; expect no report.
- Test harness notes: Include variations where some links use COMP_DUMMY() and only a subset use COMP_EMPTY() to exercise the inconsistency heuristic and ensure the checker suppresses when defensive checks exist.

6. Estimated Effort & Priority
High

7. Likely False-Positive Sources & Mitigations
- Macro resolution and structure field mapping ambiguities; mitigate by combining syntactic macro detection with name reference checks (g_sof_conn_streams).
- Paths where dai_name is later assigned non-NULL via platform data; mitigate with path-sensitive null-check/assignment analysis.
- Cases where strcmp arguments are not derived from dai_name; mitigate by requiring dataflow correlation from the flagged DAI link’s codec component to the call site.

8. Limitations & Assumptions
- The exact field names and macro expansions for dai_name are not provided; the checker assumes COMP_EMPTY() yields a NULL dai_name based on [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION].
- Device tree configuration is not analyzable statically; the checker assumes optional codecs may be absent, consistent with the crash scenario.
- Full bodies of probe functions are not shown; the plan relies on conceptual matching of strcmp-like calls in probe paths and dataflow from DAI link codec fields.