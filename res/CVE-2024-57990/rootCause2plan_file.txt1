1. Plan Summary
Detect off-by-one upper-bound array access where the index is checked with a strict greater-than against ARRAY_SIZE(array) and then used to index the same array, allowing idx == ARRAY_SIZE(array) to proceed and cause out-of-bounds read/write.

2. Detection Steps
1) Step 1: Identify array element accesses A[I] where A is a known array and a nearby (same function) guard compares I against ARRAY_SIZE(A). Signals: an indexing expression on A with subscript I; a control-flow predecessor has a condition involving ARRAY_SIZE(A) and the same I.
2) Step 2: Check the comparison operator used in the guard and the guarded branch outcome. Signals: conditions of the form “I > ARRAY_SIZE(A)” used to break/return/continue; note that the non-taken path allows I <= ARRAY_SIZE(A).
3) Step 3: Confirm the index I is subsequently used to access A along a path where the “I > ARRAY_SIZE(A)” guard is false. Signals: control-flow path from the guard to A[I] with no intervening stronger bound excluding I == ARRAY_SIZE(A).
4) Step 4: Ensure no other dominating check tightens the upper bound correctly. Signals: absence (on all paths leading to A[I]) of checks “I >= ARRAY_SIZE(A)” or “I >= size_of(A)” that exit, or checks equivalent to “I < ARRAY_SIZE(A)” guarding the access.
5) Step 5: Determine whether the access can result in both read and write beyond bounds. Signals: presence of both read-like use (e.g., in a condition “if (A[I])”) and write-like assignment “A[I] = …” after the flawed guard.
6) Step 6: Increase confidence when I originates from externally sourced/parsed data. Signals: I is a field read from a struct whose pointer is derived from a raw buffer (e.g., firmware blob or skb data), cast from byte data before use, then I = struct_field; dataflow from fw->data/clc_base to clc->idx.
7) Step 7: Verify the guard and access refer to the same array A instance. Signals: same array symbol (including qualified field access like phy->clc) appears both in ARRAY_SIZE(A) and in A[I] on the flagged path.
8) Step 8: Report a finding when the pattern “guard: I > ARRAY_SIZE(A) causes early exit; else path uses A[I]” is present. Signals: explicit control-flow constructs (break/return/continue) on the “I > …” branch and A[I] reachable in the fall-through.
9) Step 9: Exclude safe variants where the guard uses “I >= ARRAY_SIZE(A)” or where access is guarded by “I < ARRAY_SIZE(A)”. Signals: exact operator check; presence of correctly bounded conditions dominating the access.
10) Step 10: Capture multiple occurrences within loops that iterate over parsed entries. Signals: loop structure where I is evaluated per iteration and A[I] accessed in the loop body with only the flawed “> ARRAY_SIZE(A)” upper-bound guard.
11) Step 11: Prioritize kernel driver code paths that process firmware regions. Signals: functions that call request_firmware, parse regions, compute offsets, and cast buffers to structs; then use struct fields as indices into arrays.
12) Step 12: Provide remediation guidance in findings: suggest switching to “>= ARRAY_SIZE(A)” or guarding the access with “I < ARRAY_SIZE(A)”. Signals: constructing the message based on the missing equality in the upper-bound check.

3. Limitations & Assumptions
- Assumes ARRAY_SIZE(A) is available and correctly refers to the same array being indexed; if size derives from other sources, the checker may miss or misclassify cases.
- Path sensitivity is limited: complex interprocedural guards or macro-generated conditions may not be fully resolved.
- Does not verify lower-bound checks (e.g., I >= 0) or signedness; focuses only on the off-by-one upper bound.
- Identification of “externally sourced” data relies on heuristic recognition of buffer-to-struct casts (firmware/skb parsing) present in this code; broader sources may require additional dataflow modeling.