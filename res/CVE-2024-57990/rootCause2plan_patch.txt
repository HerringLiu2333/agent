1. Plan Summary
Detect off-by-one upper-bound validation errors where an index is guarded by a strict greater-than comparison against an array’s capacity (e.g., ARRAY_SIZE(array)) and then used to index that same array, allowing index == size to proceed.

2. Detection Steps
1) Step 1: Objective: Find candidate array accesses at arr[idx] that may be protected by an upper-bound check; Signals: array subscript expressions and their array operand identity; Mapping: the vulnerability arises when arr[idx] uses an out-of-range index per [ROOTCAUSE_ANALYSIS]; FP mitigation: restrict arr to arrays with statically knowable capacity or when a bound macro (e.g., ARRAY_SIZE(arr)) is present nearby.

2) Step 2: Objective: Locate a dominating conditional that compares idx to the array’s capacity using a strict greater-than; Signals: if-conditions of the form (idx > capacity) where capacity equals ARRAY_SIZE(arr) or the array’s compile-time length; Mapping: this reproduces the flawed “>” check from [PATCH_DIFF] and [PATCH_DESCRIPTION]; FP mitigation: require that the true branch performs an early exit (break/return/goto error) consistent with guard behavior.

3) Step 3: Objective: Establish control-flow reachability from the false branch of the guard to the arr[idx] use; Signals: the subscript must be post-dominated by the guard’s evaluation with no intervening checks that would further constrain idx; Mapping: mirrors mt7925_load_clc(), where arr[idx] is reachable when (idx > size) is false, allowing idx == size per [ROOTCAUSE_ANALYSIS]; FP mitigation: require the guard to dominate the subscript and the use to be on the non-exiting path.

4) Step 4: Objective: Verify the capacity in the guard is that of the same array being indexed; Signals: structural equivalence between the array in ARRAY_SIZE(array) (or equivalent length expression) and the array operand in arr[idx]; Mapping: ensures we are validating the same array boundary that later gets indexed, as in phy->clc per [PATCH_DIFF]; FP mitigation: suppress if the bound is not tied to the same array instance.

5) Step 5: Objective: Exclude cases where a correct >= guard (or equivalent) also dominates the use; Signals: presence of an idx >= capacity check (or logic equivalent) on all paths reaching the subscript; Mapping: the root cause is specifically a missing equality in the upper-bound check per [PATCH_DESCRIPTION]; FP mitigation: if any dominating check enforces idx < capacity, do not report.

6) Step 6: Objective: Ensure idx is not clamped or decremented to be within range before use; Signals: absence of transformations like idx = min(idx, capacity - 1), idx--, or idx %= capacity on all paths from guard to subscript; Mapping: the bug requires that idx can remain equal to capacity when used per [ROOTCAUSE_ANALYSIS]; FP mitigation: suppress when a transformation guarantees idx <= capacity - 1.

7) Step 7: Objective: Confirm the subscripted access could affect memory (read or write) to reflect security impact; Signals: uses of arr[idx] as an rvalue or lvalue in assignments, copies, or calls; Mapping: OOB read/write is the impact mechanism per [ROOTCAUSE_ANALYSIS]; FP mitigation: deprioritize purely diagnostic/logging-only uses and prioritize writes.

8) Step 8: Objective: Prioritize cases where idx originates from parsed or external data in the same function; Signals: idx derived from struct field loads or buffer reads (e.g., clc->idx) without prior range normalization; Mapping: matches firmware parsing path described for clc->idx in [ROOTCAUSE_ANALYSIS]; FP mitigation: increase confidence when idx flows from inputs, but do not require it to avoid missing internal logic bugs.

9) Step 9: Objective: Recognize loop-and-break parsing patterns common in firmware handlers; Signals: loop bodies with offset/len iterations and early exits via break on bad indices; Mapping: reflects the mt7925_load_clc() loop context in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; FP mitigation: do not require loops, but boost confidence when found.

3. Target Elements
- Array subscript expressions and their array operands.
- If-conditions that compare an index to a capacity (particularly with >).
- Capacity expressions tied to arrays (ARRAY_SIZE(array) or compile-time array lengths).
- Early-exit statements in guards (break, return, goto to error labels, continue).
- Def-use chains for the index variable/expression (including field accesses like clc->idx).
- Dominance/post-dominance relationships between guards and array accesses.
- Simple transformations on idx between guard and use (casts, increments/decrements, min/max).

4. Dataflow / Taint Considerations
- Track value-equivalence of the index expression from the guard comparison to the array subscript along the non-exiting path.
- Track array identity from capacity expression (e.g., ARRAY_SIZE(arr)) to the subscripted array to ensure they match.
- Allow trivial expression changes (casts, parentheses, copies) but stop if idx is clamped or recomputed to be within range.
- Optionally taint sources: fields read from parsed structures or buffers used as indices to prioritize likely external influence.

5. Validation & Test Cases
- Positive: if (idx > ARRAY_SIZE(a)) break; a[idx] = 1; — should be flagged since idx == ARRAY_SIZE(a) is allowed to index.
- Positive: if (x > ARRAY_SIZE(buf)) return; y = buf[x]; — should be flagged for the same off-by-one risk.
- Negative: if (idx >= ARRAY_SIZE(a)) break; a[idx] = 1; — should not be flagged (correct bound).
- Negative: if (idx > ARRAY_SIZE(a)) return; idx--; a[idx] = 1; — should not be flagged (idx forced into range).
- Test harness notes: Include cases with reads and writes, array identity mismatches (guard on b, access on a), and macro ARRAY_SIZE usage to confirm matching.

6. Estimated Effort & Priority
Medium effort, high priority (kernel-driver class off-by-one leading to OOB per [ROOTCAUSE_ANALYSIS] and [PATCH_DESCRIPTION]).

7. Likely False-Positive Sources & Mitigations
- Capacity not actually tied to the indexed array (mitigate by strict array identity matching).
- Additional unseen checks on merged paths (mitigate using dominance analysis for >= checks).
- Index normalization before use that the analysis misses (mitigate by tracking simple transformations and suppress when clamped).
- Dynamic arrays or pointers where ARRAY_SIZE is not applicable (mitigate by focusing on compile-time arrays or explicit ARRAY_SIZE macro).

8. Limitations & Assumptions
- Assumes the capacity can be recognized as ARRAY_SIZE(array) or a compile-time array length; other capacity conventions may be missed.
- Does not reason about complex arithmetic that implies idx < capacity indirectly.
- Relies on control-flow dominance; highly indirect or macro-heavy control paths may evade precise dominance modeling.
- Based solely on the provided materials referencing ARRAY_SIZE and a “> vs >=” off-by-one in mt7925_load_clc() ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS]).