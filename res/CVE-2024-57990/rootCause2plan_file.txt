1. Plan Summary
Detect off-by-one upper-bound index checks against ARRAY_SIZE that allow idx == size and lead to out-of-bounds array access, as in mt7925_load_clc() before the patch.

2. Detection Steps
1) Step 1: Identify array subscripting expressions of the form A[I] in C code. Signals: AST array access where A is an array field (e.g., phy->clc) and I is an index variable. FP mitigation: Restrict to arrays whose size is referenced via ARRAY_SIZE(A) in the same function.

2) Step 2: Find an immediately preceding guard that compares I to ARRAY_SIZE(A) using a strict greater-than (I > ARRAY_SIZE(A) or ARRAY_SIZE(A) < I). Signals: Conditional with relational operator ‘>’ where one side is the index and the other is ARRAY_SIZE of the same array. FP mitigation: Exclude cases using >=, <, <=, or equality checks on the same operands.

3) Step 3: Confirm the guard’s “true” branch exits the loop/flow (e.g., break/return) and the “false” path continues. Signals: The guarded statement is break/return as in [PATCH_DIFF]/[FILE_CONTENT]. FP mitigation: Require a control-flow path from the false branch to the subsequent A[I] usage without intervening revalidation.

4) Step 4: Ensure A[I] is used after the guard on the false path. Signals: A[I] read (e.g., if (phy->clc[clc->idx])) and/or write (e.g., phy->clc[clc->idx] = ...) appear post-guard in the same function as shown in [FILE_CONTENT]. FP mitigation: Limit to same basic block region or immediate successor blocks with no additional index checks.

5) Step 5: Verify the compared ARRAY_SIZE operand corresponds to the same array A used in A[I]. Signals: Symbol equivalence between the ARRAY_SIZE argument and the array in the subscript (phy->clc in both places). FP mitigation: Exclude if ARRAY_SIZE references a different array or alias cannot be proven.

6) Step 6: Detect the exact off-by-one pattern: only a strict ‘> size’ check with no separate check for I == size. Signals: Absence of any other condition handling I == ARRAY_SIZE(A) before A[I] access. FP mitigation: If any equality or >= check exists on the same index and size before the access, do not flag.

7) Step 7: Optionally increase confidence by tainting I if derived from externally sourced data. Signals: Dataflow from firmware->data or similar buffers to struct fields used as I (clc->idx set from fw->data as in [FILE_CONTENT]). FP mitigation: If taint cannot be established, still report but mark as lower confidence.

8) Step 8: Confirm the guard intent is bounds enforcement, not a different semantic (e.g., sentinel handling). Signals: The guard uses ARRAY_SIZE and exits early (break/return), matching bounds validation intent per [ROOTCAUSE_ANALYSIS]. FP mitigation: Exclude contexts where a sentinel index equal to size is documented/handled separately.

9) Step 9: Prefer cases with both read and write to A[I] to highlight memory corruption risk. Signals: Both a read check and an assignment to A[I] in the same region (as in [FILE_CONTENT]). FP mitigation: If only read or only write exists, still flag but lower severity.

10) Step 10: Aggregate the findings into a warning: “Index check uses ‘>’ against ARRAY_SIZE(A) and then accesses A[I]” and annotate with function name and file path. Signals: Function mt7925_load_clc in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c per [FILE_CONTENT]. FP mitigation: Only report once per index/access pair.

3. Target Elements
- Array subscripts (A[I]) in C.
- Conditions comparing an index to ARRAY_SIZE(A).
- Control-flow constructs (if-then with break/return, loop contexts).
- Data sources from firmware buffers (fw->data) and structs mapped onto them (clc->idx).
- Read/write uses of array elements following guards.

4. Dataflow / Taint Considerations
- Track taint from firmware-loaded buffers (request_firmware → fw->data) through casts to structs (clc) to fields used as indices (clc->idx).
- Propagate taint through simple assignments to index variables used in A[I].
- Use taint only to raise confidence; detection does not rely on taint to flag the core off-by-one pattern.

5. Validation & Test Cases
- Positive: Code with “if (idx > ARRAY_SIZE(arr)) break; … arr[idx] = …; if (arr[idx]) …” as in pre-patch mt7925_load_clc; expect a finding.
- Negative: “if (idx >= ARRAY_SIZE(arr)) break; … arr[idx] …” as in [PATCH_DIFF]; expect no finding.
- Negative: “if (idx < ARRAY_SIZE(arr)) … arr[idx] …” or explicit “if (idx == ARRAY_SIZE(arr)) continue;” before access; expect no finding.
- Test harness notes: Run on the provided mt7925/mcu.c, verifying one alert on the pre-patch hunk and zero alerts post-patch.

6. Estimated Effort & Priority
High priority; medium implementation effort (requires matching ARRAY_SIZE patterns and control-flow association).

7. Likely False-Positive Sources & Mitigations
- Sentinel designs where index == size is intentionally allowed; mitigate by requiring early-exit intent and same-array matching.
- Cases where additional checks exist but are non-local; mitigate by scanning intervening blocks for any equality/upper-bound validations.
- Macros obscuring ARRAY_SIZE or array aliases; mitigate by symbol matching and conservative reporting when uncertain.

8. Limitations & Assumptions
- Assumes the analyzer can conceptually associate ARRAY_SIZE(A) with the same array A in subscripts; macro expansion details may be opaque.
- Cannot always prove taint from firmware; treats the off-by-one pattern as sufficient.
- Does not validate lower-bound (negative) checks or signedness issues.
- Does not account for concurrency or lifetime nuances of arrays beyond syntactic access.