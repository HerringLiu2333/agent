1. Plan Summary
Detect off-by-one upper-bound checks that use a strict “> ARRAY_SIZE(array)” guard before accessing array[index], thereby allowing index == ARRAY_SIZE(array) and enabling out-of-bounds access.

2. Detection Steps
1) Step 1: Identify candidate array element accesses — array indexing expressions of the form base[index] where base denotes a fixed-size array (e.g., a struct field that is an array) and index is an integral expression used directly or via a simple alias.
2) Step 2: For each candidate access, find a dominating guard in the same function that compares the same index expression to the compile-time length of the same array using ARRAY_SIZE(base) on the right-hand side and a strict greater-than comparison (index > ARRAY_SIZE(base)).
3) Step 3: Confirm the guard’s taken branch prevents execution from reaching the access (e.g., via break, return, goto, or continue), and the non-taken path proceeds to the access, meaning equality (index == ARRAY_SIZE(base)) is permitted.
4) Step 4: Match the “same array” in both the guard and the access by ensuring the ARRAY_SIZE() argument semantically refers to the same base array as the one indexed (accounting for field dereferences and simple aliases).
5) Step 5: Also flag equivalent acceptance forms that explicitly allow equality, such as a guard that passes when index <= ARRAY_SIZE(base) and then proceeds to base[index] on that accepted path.
6) Step 6: Normalize logically equivalent conditions (e.g., negation of index > ARRAY_SIZE(base)) to catch variants where an else-branch or a negated condition still allows equality.
7) Step 7: Exclude cases where a tighter check (e.g., index >= ARRAY_SIZE(base)) dominates the access on all feasible paths, ensuring the report only fires when no subsequent guard prevents index == ARRAY_SIZE(base).
8) Step 8: Record whether the post-guard access is a read (e.g., used in a condition) and/or a write (e.g., assigned to), and report either case since both can cause OOB; increase confidence if both occur on the same path.
9) Step 9: Handle loop bodies by ensuring the guard appears in the same iteration’s control-flow region as the access and the break/continue semantics indeed prevent reaching the access on the taken branch.

3. Limitations & Assumptions
- Assumes the upper bound is expressed via ARRAY_SIZE(array); the plan does not cover custom size macros or sizeof-based idioms unless mapped to the same array.
- Does not prove non-negativity of index; it focuses solely on the off-by-one upper-bound error.
- Requires reliable dominance and path feasibility analysis; complex control-flow with multiple exits may need conservative approximation.
- Assumes the analysis can resolve that the ARRAY_SIZE() argument and the indexed base refer to the same underlying array despite field/aliasing; deeply indirect aliasing may reduce accuracy.
- Does not require taint provenance of index (e.g., firmware-derived); it flags the unsafe pattern regardless of data source.