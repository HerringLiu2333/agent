1. Plan Summary
Detect off-by-one upper-bound checks against ARRAY_SIZE that allow index == ARRAY_SIZE to reach an array access, causing one-past-the-end read/write (as in mt7925_load_clc).

2. Detection Steps
1) Step 1: Objective: find array index operations that use an index variable to access an array. Signals: occurrences of arr[idx] where arr is a C array and idx is a variable. FP mitigation: exclude pointer-like arrays (unknown size) and require arr is the same symbol used with ARRAY_SIZE elsewhere.
2) Step 2: Objective: locate a dominating condition that compares the same idx against ARRAY_SIZE(arr) using a strict “>”. Signals: an if-condition of the form idx > ARRAY_SIZE(arr) on a control-flow path prior to the array access. FP mitigation: require the array symbol inside ARRAY_SIZE matches the one being indexed.
3) Step 3: Objective: confirm that the guarded path permits idx == ARRAY_SIZE(arr) to reach the array access. Signals: the false branch (idx <= ARRAY_SIZE) continues and leads to arr[idx] with no intervening upper-bound tightening. FP mitigation: use control-flow dominance/post-dominance to ensure the access is reachable when the “>” check fails.
4) Step 4: Objective: ensure no proper upper-bound check exists. Signals: absence of a condition of the form idx >= ARRAY_SIZE(arr) or idx < ARRAY_SIZE(arr) that dominates the access, and absence of an equivalent bound like idx > ARRAY_SIZE(arr) - 1. FP mitigation: if any dominating check ensures idx < ARRAY_SIZE(arr), do not flag.
5) Step 5: Objective: detect potential OOB read sites. Signals: use of arr[idx] in rvalue contexts (e.g., reading or testing arr[idx]) on the path described. FP mitigation: still flag even if only read occurs, but record the access kind to tune severity.
6) Step 6: Objective: detect potential OOB write sites. Signals: assignments to arr[idx] (e.g., arr[idx] = …) on the same path after the faulty check. FP mitigation: raise severity when both read and write occur (based on [ROOTCAUSE_ANALYSIS] impact mechanism).
7) Step 7: Objective: identify indices derived from untrusted firmware parsing to prioritize findings. Signals: dataflow from structures parsed from fw->data (e.g., a pointer cast into a struct, then field read clc->idx) within functions calling request_firmware, as in mt7925_load_clc (based on [FUNCTION_CONTENT]). FP mitigation: elevate results where idx taints from fw->data; deprioritize indices computed purely from local constants.
8) Step 8: Objective: handle loop contexts where the faulty check uses break/continue. Signals: if (idx > ARRAY_SIZE(arr)) break/return/continue guarding a loop that later accesses arr[idx] in the same iteration (based on [PATCH_DIFF]/[FUNCTION_CONTENT]). FP mitigation: ensure the array access remains in the code path when the condition is false, i.e., within the same iteration’s fall-through.
9) Step 9: Objective: exclude equivalent safe checks. Signals: comparisons to ARRAY_SIZE(arr) - 1 or otherwise clearly ensuring idx <= size-1. FP mitigation: do not flag when RHS is size-1 or when compound conditions collectively enforce idx < ARRAY_SIZE(arr).
10) Step 10: Objective: reduce aliasing-related FPs. Signals: confirm that the arr in ARRAY_SIZE and the arr in arr[idx] are syntactically the same or a straightforward alias (same field/member path). FP mitigation: skip cases where macro references a different symbol than the indexed one.

3. Target Elements
- Functions containing: array index expressions arr[idx], conditions comparing idx to ARRAY_SIZE(arr), and control-flow constructs (if/break/return/continue).
- Condition checks acting as bounds validation.
- Data sources from firmware parsing (e.g., request_firmware, fw->data-derived structs/fields).
- Assignments to arr[idx] and reads of arr[idx].

4. Dataflow / Taint Considerations
- Track idx taint from firmware-derived structures: values read from memory originating at fw->data and fields like clc->idx (based on [FUNCTION_CONTENT]).
- Propagate through simple assignments and casts to the variable used in the comparison and the array index.
- Use taint to prioritize cases where external input drives the index; do not require taint to flag the pattern, but use it for severity ranking.

5. Validation & Test Cases
- Positive: Pre-patch pattern “if (clc->idx > ARRAY_SIZE(phy->clc)) break; … if (phy->clc[clc->idx]) … phy->clc[clc->idx] = …” in mt7925_load_clc should be flagged (based on [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: Patched pattern “if (clc->idx >= ARRAY_SIZE(phy->clc)) break; … arr[clc->idx] …” should not be flagged.
- Negative: Code using “if (idx > ARRAY_SIZE(arr) - 1) … arr[idx] …” should not be flagged.
- Test harness notes: Validate dominance/path analysis across loops with break, and ensure the macro’s array symbol matches the indexed array.

6. Estimated Effort & Priority
Medium effort; High priority for kernel/driver code parsing untrusted firmware blobs (based on [ROOTCAUSE_ANALYSIS] emphasis on firmware-derived indices).

7. Likely False-Positive Sources & Mitigations
- Sentinel or intentional off-by-one uses where idx == ARRAY_SIZE is never reachable: mitigate via reachability/dominance and additional bound checks detection.
- Misidentification of array vs pointer: mitigate by requiring ARRAY_SIZE usage on the same symbol.
- Complex multi-condition guards that effectively enforce idx < ARRAY_SIZE: mitigate by recognizing equivalent upper-bound checks (e.g., size-1).
- Cases where idx is clamped elsewhere: mitigate by scanning for prior normalization assignments to idx.

8. Limitations & Assumptions
- Assumes ARRAY_SIZE is the standard compile-time macro for true arrays; cannot determine bounds for dynamically allocated pointers.
- Limited knowledge of broader codebase; the plan is anchored to the specific pattern shown in mt7925_load_clc (based on [PATCH_DIFF]/[FUNCTION_CONTENT]).
- Does not prove exploitability; detects the off-by-one guard allowing idx == ARRAY_SIZE to reach an access.
- Concurrency and memory layout effects are out of scope, as patch only adjusts a validation check (based on [ROOTCAUSE_ANALYSIS]).