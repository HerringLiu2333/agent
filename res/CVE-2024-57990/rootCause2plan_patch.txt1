1. Plan Summary
Detect off-by-one upper-bound validations that use a strict greater-than check against ARRAY_SIZE before indexing the same array, allowing index == ARRAY_SIZE to pass and causing out-of-bounds access.

2. Detection Steps
1) Step 1: Identify array subscripts A[X] where A is an array (including struct fields like phy->clc) and X is the index expression — focus on places where A is a named array and not a dynamically sized pointer.
2) Step 2: For each A[X], locate a preceding guard in the same function/coarse block that compares X against ARRAY_SIZE(A) using the operator “>” (strict greater-than) — e.g., an if condition whose true branch aborts flow (return, break, goto, continue).
3) Step 3: Confirm control-flow: the path that reaches A[X] is the “not-taken” branch of the guard (i.e., execution proceeds when X <= ARRAY_SIZE(A)) and the guard syntactically dominates the indexing (appears earlier in the same loop/statement sequence).
4) Step 4: Check dataflow: ensure the same index variable/expression X used in the guard is used in A[X] without being re-assigned or transformed in-between (no writes to X or redefinitions along the path).
5) Step 5: Verify the array bound used in the guard is exactly ARRAY_SIZE(A) of the same array A that is later indexed — reject cases where the bound refers to a different array or alias unless equivalence is syntactically clear.
6) Step 6: Exclude safe cases: if there exists any dominating check that enforces X < ARRAY_SIZE(A) or X >= ARRAY_SIZE(A) leading to an abort before A[X], do not flag (i.e., a correct inclusive upper-bound check already shields the index).
7) Step 7: Exclude alternative correct validations: if the guard enforces an equivalent safe bound (e.g., X > ARRAY_SIZE(A) - 1 leading to abort), do not flag; the target pattern is specifically “X > ARRAY_SIZE(A)” guarding A[X].
8) Step 8: Strengthen confidence by requiring the guard’s true branch to clearly prevent the subsequent indexing in the same iteration or scope (e.g., break from the loop that performs A[X], return from the function, or goto a label that skips A[X]).
9) Step 9: Optionally prioritize cases where X originates from parsing/structured input within the same function (e.g., fields of a struct read from a buffer) to highlight higher-risk scenarios, but do not require it for detection.
10) Step 10: Report findings when the only upper-bound check prior to indexing is “X > ARRAY_SIZE(A)” and A[X] is reachable afterward, describing that X == ARRAY_SIZE(A) can pass and cause out-of-bounds read/write.

3. Limitations & Assumptions
- Assumes ARRAY_SIZE(A) refers to the actual bound of A and that A[X] uses the same A; aliasing or macro indirection may obscure this.
- Does not prove the absence of other runtime checks outside the local scope or path-sensitive contracts; may produce false positives if other guards exist non-dominantly.
- Does not determine whether X is attacker-controlled or firmware-derived; focuses purely on the off-by-one validation pattern.
- Path feasibility beyond simple dominance and obvious abort statements is not guaranteed; complex control-flow, gotos, or macro-expanded logic may affect accuracy.