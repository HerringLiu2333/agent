1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Off-by-one bounds check error causing out-of-bounds array access (read and write)

3. Root Cause Summary
The function mt7925_load_clc() validated clc->idx with a strict greater-than check against ARRAY_SIZE(phy->clc) instead of a greater-than-or-equal check. This allowed clc->idx == ARRAY_SIZE(phy->clc) to pass validation and be used as an array index, which is one past the last valid element. As a result, subsequent accesses to phy->clc[clc->idx] could read from or write to memory beyond the allocated array bounds.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver: MediaTek mt76 mt7925 (drivers/net/wireless/mediatek/mt76/mt7925)

2) Pre-Patch Flaw:
- In mt7925_load_clc(), the code used "if (clc->idx > ARRAY_SIZE(phy->clc))" to guard array indexing.
- This off-by-one check failed to reject the boundary case where clc->idx equals the array size, enabling an invalid index.

3) Trigger Condition:
- While parsing CLC entries from firmware in the loop over offset < len, if any CLC entry supplies clc->idx == ARRAY_SIZE(phy->clc), the code proceeds and uses that index.
- The clc structure is obtained from clc_base + offset and its fields (idx, len) are used to control parsing and indexing.

4) Impact Mechanism:
- Using index == ARRAY_SIZE(phy->clc) results in out-of-bounds access to phy->clc, causing both potential reads and writes past the end of the array.
- This can lead to kernel memory corruption, crashes (e.g., Oops), and possible information disclosure.

5. Patch Analysis
1) Fix Approach:
- Tighten the upper-bound validation for clc->idx by changing the comparison to reject indices equal to the array size.

2) Key Code Changes:
- In mt7925_load_clc() (mcu.c around line 638), the condition was changed from:
  "if (clc->idx > ARRAY_SIZE(phy->clc))"
  to:
  "if (clc->idx >= ARRAY_SIZE(phy->clc))"
- This ensures only indices in the valid range [0, ARRAY_SIZE(phy->clc) - 1] are accepted before using them to index phy->clc.

3) Locking/Concurrency Impact:
- No locking or concurrency logic was changed; the fix solely corrects the bounds check.

6. Broader Kernel Security Implications
- Off-by-one errors in array bounds checks during firmware or descriptor parsing can introduce severe memory safety vulnerabilities in kernel drivers.
- Similar patterns should be audited across driver code to ensure inclusive upper-bound checks (>=) are used when comparing indices against ARRAY_SIZE.
- Proper validation of data derived from firmware or external inputs is critical to prevent OOB accesses that can compromise kernel stability and security.