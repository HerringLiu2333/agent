1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Out-of-bounds read/write (off-by-one array index validation bug)

3. Root Cause Summary
mt7925_load_clc() incorrectly validated the CLC index from firmware using a strict greater-than comparison instead of greater-than-or-equal, allowing clc->idx == ARRAY_SIZE(phy->clc) to pass. Subsequent access to phy->clc[clc->idx] performed both an out-of-bounds read and write on the clc pointer array, leading to kernel memory corruption. The patch changes the comparison to >= to ensure indices are within [0, ARRAY_SIZE(phy->clc) - 1].

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 wireless driver (mt7925), MCU/firmware interaction; file drivers/net/wireless/mediatek/mt76/mt7925/mcu.c

2) Pre-Patch Flaw:
In mt7925_load_clc(), the index bounds check used:
"if (clc->idx > ARRAY_SIZE(phy->clc))"
which failed to reject clc->idx equal to ARRAY_SIZE(phy->clc). The code then accesses phy->clc[clc->idx], causing off-by-one out-of-bounds memory access.

3) Trigger Condition:
A malformed or unexpected CLC entry in the loaded firmware region where clc->idx equals ARRAY_SIZE(phy->clc). This occurs during iteration over the CLC region: for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) { clc = (const struct mt7925_clc *)(clc_base + offset); ... }.

4) Impact Mechanism:
- Out-of-bounds read: "if (phy->clc[clc->idx])" dereferences beyond the end of the phy->clc array.
- Out-of-bounds write: "phy->clc[clc->idx] = devm_kmemdup(...)" writes a pointer past the array boundary, corrupting adjacent kernel memory fields in mt792x_phy, potentially leading to crashes, undefined behavior, or further exploitable conditions.

5. Patch Analysis
1) Fix Approach:
Strengthen the index bounds check to properly reject an index equal to the array size, eliminating the off-by-one window that enabled OOB access.

2) Key Code Changes:
- In mt7925_load_clc():
  - Changed "if (clc->idx > ARRAY_SIZE(phy->clc))" to "if (clc->idx >= ARRAY_SIZE(phy->clc))".
This ensures only indices 0..ARRAY_SIZE(phy->clc)-1 are processed, preventing subsequent OOB read/write to phy->clc[clc->idx].

3) Locking/Concurrency Impact:
None. The change is a bounds check adjustment with no locking or ordering modifications.

6. Broader Kernel Security Implications
Off-by-one index validation errors are a common, high-impact class of bugs that can lead to kernel memory corruption, especially when processing externally sourced data (e.g., firmware contents). Robust bounds checking (using >= against ARRAY_SIZE for upper bounds) is essential. Drivers parsing firmware should treat inputs as untrusted and validate all indices and lengths. This fix highlights the importance of careful reviews of recent “fixes” to avoid introducing new off-by-one errors in security-critical paths.