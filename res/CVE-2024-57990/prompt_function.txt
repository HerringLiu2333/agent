1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Out-of-bounds array access (read and write) due to off-by-one bounds check

3. Root Cause Summary
The function mt7925_load_clc in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c incorrectly validated the firmware-provided index clc->idx using “> ARRAY_SIZE(phy->clc)”. This off-by-one check allowed clc->idx == ARRAY_SIZE(phy->clc) to pass, causing one-past-the-end access to phy->clc[clc->idx]. As a result, the code could read and then write beyond the clc pointer array, leading to memory corruption.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 Wi-Fi driver (mt7925), firmware parsing/CLC loading logic in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c.

2) Pre-Patch Flaw:
An off-by-one bounds check in mt7925_load_clc used “if (clc->idx > ARRAY_SIZE(phy->clc))” instead of “>=”, failing to reject index equal to the array size. Subsequent lines accessed phy->clc[clc->idx] for both read (“if (phy->clc[clc->idx])”) and write (“phy->clc[clc->idx] = …”), enabling one-past-the-end access.

3) Trigger Condition:
A CLC entry in the firmware with clc->idx equal to ARRAY_SIZE(phy->clc) during the loop “for (offset = 0; offset < len; offset += le32_to_cpu(clc->len))”.

4) Impact Mechanism:
OOB read occurs when evaluating “if (phy->clc[clc->idx])”; OOB write occurs when assigning “phy->clc[clc->idx] = devm_kmemdup(…)”. This can corrupt adjacent kernel memory, potentially leading to crashes or arbitrary memory modification depending on layout.

5. Patch Analysis
1) Fix Approach:
Tighten the bounds check to correctly disallow indices equal to the array size, eliminating the off-by-one error that enabled OOB accesses.

2) Key Code Changes:
Changed in mt7925_load_clc: “if (clc->idx > ARRAY_SIZE(phy->clc))” to “if (clc->idx >= ARRAY_SIZE(phy->clc))”, ensuring clc->idx is strictly within [0, ARRAY_SIZE(phy->clc) - 1].

3) Locking/Concurrency Impact:
None. The patch solely adjusts a validation check; no locking or ordering changes are involved.

6. Broader Kernel Security Implications
Firmware-derived indices and lengths must be rigorously validated to prevent memory safety violations in drivers parsing untrusted blobs. Off-by-one mistakes are common and can turn otherwise protective checks into exploitable conditions, especially in pointer arrays. Ensuring consistent use of “>= ARRAY_SIZE()” for upper-bound checks is a defensive coding standard that helps prevent both OOB reads and writes in kernel-space parsers.