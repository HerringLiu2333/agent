1. Plan Summary
Detect early-return paths that skip required cleanup (finish_mount_kattr) after a successful wants_mount_setattr call when an intermediate operation (do_mount_setattr) fails, causing leaks of mnt_userns/mnt_idmap as described.

2. Detection Steps
1) Step 1: Objective — Locate functions that call wants_mount_setattr and capture its integer return into a local variable. Signals — An assignment of the form ret = wants_mount_setattr(..., &kattr) where a struct-like “kattr” is passed by address; Why — Based on [PATCH_DIFF], this return value gates resource allocation; FP mitigation — Require that the same “kattr” object is subsequently passed to finish_mount_kattr somewhere in the function (programmer intent to clean).
2) Step 2: Objective — Determine the control split for negative vs positive retval from wants_mount_setattr. Signals — Either an immediate early return on ret < 0 or an if (ret) block that is post-dominated by a prior ret < 0 return; Why — [PATCH_DIFF] shows pre-patch code returns on ret < 0 and treats the if (ret) block as ret > 0; FP mitigation — Only treat the if (ret) block as the “ret > 0” branch when there exists a distinct ret < 0 early-exit check in the same function.
3) Step 3: Objective — Confirm the “positive” branch performs an intermediate operation that can fail. Signals — Within the ret > 0 branch, find ret = do_mount_setattr(..., &kattr); Why — [PATCH_DIFF] shows do_mount_setattr is the intermediate step whose failure led to leak; FP mitigation — Require that ret is reassigned from the do_* call and that &kattr is passed to it (ties the resource to the subsequent operation).
4) Step 4: Objective — Identify early returns after the intermediate operation that bypass cleanup. Signals — In the same ret > 0 branch, find a control path where a check on ret (non-zero/error) leads to return/bailout (return ret; goto out_return; etc.) without first calling finish_mount_kattr(&kattr); Why — [PATCH_DESCRIPTION] states that failing do_mount_setattr must still call finish_mount_kattr; FP mitigation — Require that no finish_mount_kattr(&kattr) occurs on the path before the exit.
5) Step 5: Objective — Verify that cleanup is present only on the success subpath, indicating the asymmetry. Signals — Presence of finish_mount_kattr(&kattr) after do_mount_setattr, but only executed when ret is zero/success; Why — [PATCH_DIFF] shows fix moves finish_mount_kattr to always run when wants_… returned >0, even if do_mount_setattr fails; FP mitigation — Require that finish_mount_kattr is control-dependent on do_mount_setattr success in the buggy pattern.
6) Step 6: Objective — Ensure the analysis ties cleanup obligation to the wants_mount_setattr outcome, not to do_mount_setattr. Signals — The cleanup function finish_mount_kattr consumes the same kattr instance produced/updated by wants_mount_setattr and does not depend on do_mount_setattr’s return to be necessary; Why — [PATCH_DESCRIPTION] says “Once wants_mount_setattr() has returned a positive, it does require finish_mount_kattr()… Failing do_mount_setattr() does not change that”; FP mitigation — Confirm that the only producer of kattr state in scope before cleanup is wants_mount_setattr.
7) Step 7: Objective — Check for alternative structured error paths that might perform cleanup. Signals — Look for gotos/labels/free/cleanup sections that call finish_mount_kattr(&kattr) reachable from the ret > 0 and do_mount_setattr-failure path; Why — Avoid flagging code that uses centralized cleanup; FP mitigation — Model inter-block control flow to ensure finish_mount_kattr is not reachable prior to function exit on the failing path.
8) Step 8: Objective — Distinguish zero return from wants_mount_setattr (no cleanup needed). Signals — A path where ret == 0 from wants_mount_setattr leads to neither do_mount_setattr nor finish_mount_kattr; Why — [PATCH_DIFF] and [PATCH_DESCRIPTION] imply cleanup is only required when wants_* returns positive; FP mitigation — Do not flag paths where the positive branch was never entered.
9) Step 9: Objective — Ensure matching of the specific resource instance. Signals — The address passed to finish_mount_kattr matches the exact local “kattr” instance passed to wants_mount_setattr; Why — Prevent mismatched-resource false positives; FP mitigation — Track the concrete variable identity and disallow aliasing to a different kattr-like object.
10) Step 10: Objective — Report only when all conditions hold: wants_mount_setattr > 0 taken, do_mount_setattr may fail, early return on failure without prior finish_mount_kattr. Signals — A feasible path meeting Steps 1–4 with no cleanup before exit; Why — This corresponds exactly to the leak root cause; FP mitigation — Require feasibility under standard intraprocedural control flow without infeasible-branch assumptions.
11) Step 11: Objective — Prioritize high-confidence findings. Signals — The function is open_tree_attr or a syscall-like function controlling mount attributes (as in [PATCH_DIFF]); Why — Scope to known context of the bug; FP mitigation — Rank higher when function name matches SYSCALL_DEFINE* open_tree_attr.
12) Step 12: Objective — Suggest remediation pattern. Signals — Presence of post-fix pattern: finish_mount_kattr executed before checking ret from do_mount_setattr and a trailing if (ret) return ret; Why — [PATCH_DIFF] shows the safe order; FP mitigation — Use as a whitelist to suppress findings when the fixed pattern is present.

3. Target Elements
- Call sites to wants_mount_setattr and finish_mount_kattr.
- Local variables receiving return codes (e.g., ret) and the kattr-like struct passed by address.
- Conditional checks on ret (< 0, > 0, != 0) that split control flow.
- Calls to do_mount_setattr that consume the same &kattr and assign to ret.
- Return statements, gotos to exit labels, and other exits between do_mount_setattr and finish_mount_kattr.
- Dominator/post-dominator relationships between the above to reason about skipped cleanup.

4. Dataflow / Taint Considerations
- Track the def-use of the ret variable from wants_mount_setattr through reassignment by do_mount_setattr and into return conditions.
- Track the specific kattr object identity via address-of usage in calls to wants_mount_setattr, do_mount_setattr, and finish_mount_kattr.
- Model control dependence: the positive path of wants_mount_setattr leading to the do_mount_setattr call, and error-dependent early returns from do_mount_setattr that bypass finish_mount_kattr.
- Recognize centralized cleanup paths (labels) reachable from the failing path to avoid false positives.

5. Validation & Test Cases
- Positive: Pre-patch snippet from [PATCH_DIFF], where ret < 0 returns early; in the ret > 0 block, do_mount_setattr failure returns before finish_mount_kattr — should be flagged.
- Negative: Post-patch snippet from [PATCH_DIFF], where finish_mount_kattr is called when ret > 0 regardless of do_mount_setattr outcome, and only then return on ret — should not be flagged.
- Test harness notes: Include variants using goto error labels versus direct return; include cases where wants_mount_setattr returns 0 and neither do_mount_setattr nor finish_mount_kattr is invoked.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Code that performs cleanup via a shared error label not recognized by naive path analysis — mitigate by modeling gotos/labels to confirm reachability of finish_mount_kattr.
- Functions with similarly named APIs but different semantics — mitigate by restricting to the exact function names from [PATCH_DIFF] and matching the shared kattr object.
- Paths that are syntactically present but semantically infeasible — mitigate by requiring the canonical pattern (ret < 0 early return, ret > 0 branch) and consistent variable/object matching.

8. Limitations & Assumptions
- Assumes cleanup is always required when wants_mount_setattr returns positive, per [PATCH_DESCRIPTION]; other APIs with different rules are out of scope.
- Interprocedural effects on kattr are not considered; the plan is intraprocedural.
- The root-cause analysis file is missing; the plan relies solely on [PATCH_DESCRIPTION] and [PATCH_DIFF] and cannot generalize beyond the shown API trio.