1. Plan Summary
Detect early-return error paths that bypass required cleanup after wants_mount_setattr() signals resources were acquired, leading to leaks of mnt_userns/mnt_idmap in open_tree_attr().

2. Detection Steps
1) Step 1: Objective: Find functions that call wants_mount_setattr() and capture its integer result. Signals: A variable (e.g., ret) assigned from wants_mount_setattr(uattr, usize, &kattr). FP mitigation: Restrict to functions that also reference finish_mount_kattr().
2) Step 2: Objective: Interpret the result semantics to locate the “resources prepared” branch. Signals: A conditional that checks the wants_mount_setattr() result for positivity (ret > 0 or a generic if (ret) following a prior ret < 0 check). FP mitigation: Require an explicit negative-path check (ret < 0 return) to distinguish “error” vs “work to do,” as in [FUNCTION_CONTENT].
3) Step 3: Objective: Identify the operational step that can fail after resources are prepared. Signals: A call to do_mount_setattr(&file->f_path, &kattr) inside the ret > 0 branch. FP mitigation: Ensure the call sits syntactically within the same branch guarded by the wants_mount_setattr() positivity check.
4) Step 4: Objective: Detect an immediate error return path that can bypass cleanup. Signals: An if (ret) return ret; (or equivalent immediate return) that tests the result from do_mount_setattr() inside the ret > 0 branch. FP mitigation: Confirm the return is control-flow reachable before any finish_mount_kattr() call.
5) Step 5: Objective: Confirm the cleanup is conditional on success only, which is the leak root cause. Signals: finish_mount_kattr(&kattr) is placed after the error-return check or only executed when do_mount_setattr() succeeds. FP mitigation: Require that there exists at least one path where wants_mount_setattr() > 0 and do_mount_setattr() fails that reaches a return without any preceding finish_mount_kattr() in that path.
6) Step 6: Objective: Differentiate valid early returns (before any resource acquisition) from leak-prone returns. Signals: Early return strictly under ret < 0 should be considered safe; returns under ret > 0 but before finish_mount_kattr() are suspect. FP mitigation: Model control-flow dominance to ensure the wants_mount_setattr() positivity check dominates the failing return.
7) Step 7: Objective: Recognize the corrected pattern to avoid false positives. Signals: finish_mount_kattr(&kattr) is executed unconditionally within the ret > 0 branch, with any final “if (ret) return ret;” placed after finish_mount_kattr(), as shown in [PATCH_DIFF]. FP mitigation: Do not flag functions where cleanup post-dominates the do_mount_setattr() call within the ret > 0 branch.
8) Step 8: Objective: Check for alternative cleanup paths that might handle failure. Signals: Presence of finish_mount_kattr() in a common exit block executed regardless of do_mount_setattr() outcome. FP mitigation: Use control-flow/post-dominance to verify cleanup is always reached when wants_mount_setattr() > 0.
9) Step 9: Objective: Validate that the same “ret” tested for failure corresponds to do_mount_setattr() and not overwritten by unrelated operations. Signals: Assignment ret = do_mount_setattr(...) followed by if (ret) return ret; prior to any reassignments. FP mitigation: Track intraprocedural dataflow of the ret variable between assignment and the error test.
10) Step 10: Objective: Confirm the pattern targets the mount/userns/idmap resource context. Signals: Presence of mount_kattr kattr, MOUNT_KATTR_IDMAP_REPLACE flag, and calls to finish_mount_kattr() as per [FUNCTION_CONTENT]. FP mitigation: Require the kattr-type variable and flags context to reduce scope.

3. Target Elements
- Functions that call wants_mount_setattr(), do_mount_setattr(), and finish_mount_kattr() (e.g., open_tree_attr()).
- Conditional checks on the return value from wants_mount_setattr() (ret < 0 vs ret > 0) and from do_mount_setattr().
- Early returns within the ret > 0 branch prior to finish_mount_kattr().
- Control-flow post-dominance relationships ensuring cleanup is or is not reached.
- Variables representing mount_kattr and flags (e.g., MOUNT_KATTR_IDMAP_REPLACE, MOUNT_KATTR_RECURSE).

4. Dataflow / Taint Considerations
- Track the integer result from wants_mount_setattr() to the positivity check indicating resource acquisition.
- Track the ret reassignment from do_mount_setattr() to the immediate error-return test.
- Ensure finish_mount_kattr() is on all paths that flow from wants_mount_setattr() > 0, including failure paths, otherwise flag.

5. Validation & Test Cases
- Positive: Pre-patch open_tree_attr() where if (ret) return ret; occurs inside the ret > 0 block before finish_mount_kattr(), causing a leak (based on [FUNCTION_CONTENT]).
- Negative: Patched open_tree_attr() where finish_mount_kattr() is called unconditionally within the ret > 0 branch, and error return happens after cleanup (based on [PATCH_DIFF]).
- Negative: A function where wants_mount_setattr() returns <= 0 (ret <= 0) and cleanup is not needed or not present; the checker should not flag.
- Test harness notes: Stub wants_mount_setattr(), do_mount_setattr(), finish_mount_kattr(), and mount_kattr types; compile two variants (pre-patch and post-patch) to verify detection vs non-detection.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Cases where finish_mount_kattr() is executed via indirect paths (e.g., common error labels) the analysis fails to recognize; mitigate with control-flow/post-dominance checks.
- Situations where ret > 0 does not actually imply resource acquisition; mitigate by requiring the specific function pair and kattr context found in [FUNCTION_CONTENT].
- Cleanup performed in callees not visible intraprocedurally; mitigate by documenting limitation and optionally enabling interprocedural exploration if available.

8. Limitations & Assumptions
- Assumes wants_mount_setattr() > 0 indicates resources that must be cleaned by finish_mount_kattr(), per [ROOTCAUSE_ANALYSIS]; this semantic may not generalize beyond this API.
- Assumes cleanup is not performed implicitly elsewhere; the inputs do not provide global cleanup semantics.
- Focuses on intraprocedural paths within the function; interprocedural cleanup is not detected.
- The checker is tailored to the specific API trio (wants_mount_setattr/do_mount_setattr/finish_mount_kattr) evidenced in [FUNCTION_CONTENT] and [PATCH_DIFF].