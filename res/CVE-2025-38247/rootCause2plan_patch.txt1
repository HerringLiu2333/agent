1. Plan Summary
Detect early-return paths in open_tree_attr(2) that bypass finish_mount_kattr() after wants_mount_setattr() has indicated setup occurred, causing mnt_userns/mnt_idmap reference leaks.

2. Detection Steps
1) Step 1: Scope to SYSCALL_DEFINE5(open_tree_attr, ...) and locate the sequence involving wants_mount_setattr(), do_mount_setattr(), and finish_mount_kattr(). Signals: function definition of open_tree_attr and calls to the three named functions with a kattr struct.

2) Step 2: Identify the assignment of wants_mount_setattr(...) to a local integer (e.g., ret) and the kattr address being passed. Signals: a call returning an int stored in a variable; &kattr passed as an argument.

3) Step 3: Find a conditional block whose guard depends on that return variable (e.g., “if (ret)” or “if (ret > 0)”). Signals: condition using the same return variable from wants_mount_setattr.

4) Step 4: Within that guarded block, confirm there is a call to do_mount_setattr(...) followed by a call to finish_mount_kattr(&kattr). Signals: ordered presence of do_mount_setattr then finish_mount_kattr in the same block.

5) Step 5: Detect any return or function-exit statement located between the do_mount_setattr call and the finish_mount_kattr call. Signals: return ret; returns; early exits (including goto to a return path) placed before finish_mount_kattr.

6) Step 6: Model the error path: the early return is guarded by checking the result of do_mount_setattr (e.g., “if (ret) return ret;”). Signals: the same variable assigned from do_mount_setattr is used in the guard controlling the early return.

7) Step 7: Compute a path predicate indicating wants_mount_setattr returned positive, entered the block, do_mount_setattr returned non-zero, and the function exits without executing finish_mount_kattr. Signals: control-flow path from the setup call through the guarded block to an exit that does not pass through finish_mount_kattr.

8) Step 8: Require that finish_mount_kattr is reachable on some other path (e.g., success path) to confirm that cleanup is expected and missing only on errors. Signals: presence of finish_mount_kattr in the block after do_mount_setattr.

9) Step 9: Report a finding if such an early-exit path exists, attributing sources (wants_mount_setattr return), the failure point (do_mount_setattr), and the missing cleanup (finish_mount_kattr). Signals: path summary tying these calls and the return together.

3. Limitations & Assumptions
- Only the specific call pair wants_mount_setattr()/finish_mount_kattr() and their semantics are known; the checker does not generalize to other setup/cleanup pairs.
- The checker assumes “ret > 0” means resources were acquired, but static analysis may only observe “if (ret)” without sign; paths are conservatively treated as potentially positive.
- Runtime success/failure of do_mount_setattr() cannot be known; the checker infers error paths from guards like “if (ret) return ret;”.
- Complex control-flow (macros, multi-level gotos) may obscure early exits; analysis focuses on detectable returns or exits between do_mount_setattr and finish_mount_kattr.
- The specific leaked resources (mnt_userns, mnt_idmap) are inferred from the analysis but not directly validated by the checker.