1. CVE Identifier
CVE-2025-38247

2. Vulnerability Type
Resource/reference leak (lifetime/refcount bug)

3. Root Cause Summary
open_tree_attr() failed to call finish_mount_kattr() on the error path when do_mount_setattr() failed after wants_mount_setattr() had returned a positive value. wants_mount_setattr() sets up kattr and acquires references (e.g., ->mnt_userns and possibly mnt_idmap) that must be released by finish_mount_kattr() regardless of subsequent failures. The pre-patch code returned early on do_mount_setattr() error (“if (ret) return ret;”) inside the block, skipping the required cleanup, leaking references.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFS mount attribute handling in the open_tree_attr(2) syscall (fs/open_tree_attr path)

2) Pre-Patch Flaw:
- In SYSCALL_DEFINE5(open_tree_attr, ...), after:
  ret = wants_mount_setattr(uattr, usize, &kattr);
  if (ret) { ret = do_mount_setattr(...); if (ret) return ret; finish_mount_kattr(&kattr); }
- If do_mount_setattr() failed, the function returned immediately without invoking finish_mount_kattr(), leaving acquired references (->mnt_userns, possibly mnt_idmap) unreleased.

3) Trigger Condition:
- wants_mount_setattr() returns >0 (indicating attributes to apply and resources acquired), followed by do_mount_setattr() returning an error. Any scenario that makes do_mount_setattr() fail (invalid attributes, permission checks, etc.) after a positive wants_mount_setattr() result triggers the leak.

4) Impact Mechanism:
- Leaked references to mnt_userns and potentially mnt_idmap prevent their reference counts from being decremented, leading to persistent objects and memory/resource consumption. Repeated triggers can cause resource exhaustion (DoS) due to accumulating unreleased references.

5. Patch Analysis
1) Fix Approach:
- Ensure finish_mount_kattr() is always called when wants_mount_setattr() returned >0, regardless of do_mount_setattr()’s success or failure. Reorder returns so cleanup occurs before propagating errors.

2) Key Code Changes:
- Change conditional from “if (ret)” to “if (ret > 0)” to enter the block only when wants_mount_setattr() indicated setup occurred.
- Move finish_mount_kattr(&kattr) to execute unconditionally within that block, after do_mount_setattr(), removing the early return on do_mount_setattr() failure.
- Add a unified “if (ret) return ret;” after the block to propagate any error after cleanup.
  Diff evidence:
  - Pre-patch: inside the block:
    ret = do_mount_setattr(...);
    if (ret) return ret;
    finish_mount_kattr(&kattr);
  - Post-patch:
    if (ret > 0) {
      ret = do_mount_setattr(...);
      finish_mount_kattr(&kattr);
    }
    if (ret) return ret;

3) Locking/Concurrency Impact:
- No locking or ordering semantics changed. The patch strictly fixes resource lifetime management by ensuring reference releases on all paths; no changes to locks, RCU, or atomic operations.

6. Broader Kernel Security Implications
- Highlights the need for robust error-path cleanup in VFS mount attribute flows, especially when preparatory functions acquire references requiring paired “finish/put” calls. Similar patterns elsewhere should be audited to ensure that cleanup is executed even when subsequent operations fail. Preventing such reference leaks mitigates potential denial-of-service vectors via resource exhaustion in user namespace and idmap objects.