1. Plan Summary
Detect missing cleanup calls to finish_mount_kattr when wants_mount_setattr indicates attributes should be applied (>0), but an error path (e.g., from do_mount_setattr) returns before cleanup, leading to userns/mnt_idmap leaks.

2. Detection Steps
1) Step 1: Identify prepare/finalize pair usage — locate call sites of wants_mount_setattr(…, struct mount_kattr* kattr) and collect the local kattr variable passed by address; find the corresponding finalize function finish_mount_kattr(&kattr). Signals: direct calls to these named functions in the same enclosing function. FP mitigation: restrict to same function scope and same kattr variable instance.

2) Step 2: Classify the wants_mount_setattr return handling — capture the variable receiving the return (e.g., ret) and the control guard that follows. Signals: either an explicit “ret > 0” branch, or the pattern “if (ret < 0) return …; if (ret) { … }” indicating positive case; this matches pre-patch logic described in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure the branch indeed denotes “positive requested” semantics by verifying that the negative case is handled separately or the guard is “> 0”.

3) Step 3: Build the “positive-case region” — model the control-flow region dominated by the positive-case guard where mount attributes are to be applied. Signals: the block guarded by “ret > 0” (or equivalent two-step handling). FP mitigation: require that this region post-dominates the do_mount_setattr call site or contains the subsequent mount-attribute application flow as seen in [FILE_CONTENT] open_tree_attr.

4) Step 4: Require eventual finish in the positive-case region — verify that every path exiting the positive-case region to any function return or error exit passes through finish_mount_kattr(&kattr). Signals: control-flow/post-dominance check that finish_mount_kattr is executed along all outgoing paths from the positive-case region before any return/goto that leaves the function. FP mitigation: allow finish to appear immediately after the region (as in the fixed pattern in [PATCH_DIFF]) or within it; exclude paths where ret collapses to 0/negative before return and finish is still executed.

5) Step 5: Detect early return before finish — within the positive-case region, detect any return (or tail exit) reachable after assigning ret from do_mount_setattr (or other checks) that occurs before a call to finish_mount_kattr(&kattr). Signals: a call to do_mount_setattr(&…, &kattr) followed by “if (ret) return ret;” prior to finish, matching the buggy pattern in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure the return returns the same ret computed in-region, and no intervening finish is called.

6) Step 6: Account for the patched pattern — accept as safe the fixed shape where finish_mount_kattr(&kattr) executes unconditionally when the positive-case was entered, and only after that “if (ret) return ret;” is checked (as per [PATCH_DIFF]). Signals: finish appears in the positive-case region or immediately after, and any subsequent return is outside the region.

7) Step 7: Distinguish zero/no-op case — if wants_mount_setattr returns 0 (no attributes requested), do not require finish_mount_kattr. Signals: explicit guard that bypasses positive-case when ret == 0; consistent with [FILE_CONTENT] wants_mount_setattr contract and [ROOTCAUSE_ANALYSIS]. FP mitigation: only enforce finish when positive-case is taken.

8) Step 8: Exclude negative immediate-return case — if the only returns after wants_mount_setattr are for ret < 0 before entering the positive-case region, do not flag. Signals: early return strictly under ret < 0 without any resource-producing path taken. FP mitigation: dataflow guard that the positive-case region was not entered.

9) Step 9: Match the same kattr instance — ensure that the kattr passed to finish_mount_kattr is the same variable passed to wants_mount_setattr and (optionally) do_mount_setattr. Signals: identity of the address-of argument &kattr; track assignments/aliases if any. FP mitigation: ignore if kattr escapes to other functions that may clean it up (unless the same function also returns without any cleanup evidence).

10) Step 10: Recognize alternate cleanup placement — accept as safe if finish_mount_kattr is invoked in a unified epilogue executed from all exits of the positive-case (e.g., via goto to a common label). Signals: presence of a common post-dominator block containing finish; CFG-based post-dominance. FP mitigation: ensure all exits from positive-case reach that label.

11) Step 11: Prioritize known trio pattern — flag specifically when wants_mount_setattr, do_mount_setattr, and finish_mount_kattr co-occur and the early return is based on the ret from do_mount_setattr, since that maps exactly to the reported leak ([PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). Signals: the do_mount_setattr call occurs between wants and finish and sets ret used by the early return. FP mitigation: ignore unrelated early returns not conditioned on ret from do_mount_setattr.

12) Step 12: Report only once per function — if multiple early-returns exist in the same region violating cleanup, aggregate into a single alert for the enclosing function to reduce noise. Signals: per-function aggregation keyed by the kattr variable.

3. Target Elements
- Function bodies invoking wants_mount_setattr and finish_mount_kattr.
- Call sites and return-value uses of wants_mount_setattr and do_mount_setattr.
- Condition checks on return variables (e.g., ret > 0, ret < 0, if (ret)).
- Calls to finish_mount_kattr and their position in control flow.
- Return statements and goto-based exits reachable from the positive-case region.
- The struct mount_kattr local variable passed by address.

4. Dataflow / Taint Considerations
- Track the integer return from wants_mount_setattr into the guard that defines the positive-case region (ret > 0).
- Track the same ret variable updated by do_mount_setattr inside the positive-case region and used in conditional returns before finish.
- Track the kattr variable by address-of use into wants_mount_setattr, do_mount_setattr, and finish_mount_kattr to ensure it is the same instance.
- Post-dominance requirement: finish_mount_kattr must post-dominate all exits from the positive-case region.

5. Validation & Test Cases
- Positive: Pre-patch open_tree_attr snippet where wants_mount_setattr returns >0, do_mount_setattr is called, and the code returns on error before calling finish_mount_kattr (matches [PATCH_DIFF] removed lines); expect a finding.
- Negative: Patched open_tree_attr where finish_mount_kattr is called unconditionally when ret > 0, and only after that a return on ret occurs (matches [PATCH_DIFF] new lines); expect no finding.
- Negative: mount_setattr syscall implementation that always calls finish_mount_kattr after do_mount_setattr or on any exit from the wants positive-case (see [FILE_CONTENT] SYSCALL_DEFINE5(mount_setattr)); expect no finding.
- Test harness notes: Use small mock functions mirroring the patterns with the exact function names to ensure the checker locks onto the known pair; add a variant with wants returning 0 to ensure no false alarm.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Complex control flow with gotos to shared epilogues: mitigate via post-dominance analysis to recognize common cleanup blocks.
- Cleanup performed in a helper callee: hard to prove; mitigate by limiting to intra-procedural evidence (same function) and known function name finish_mount_kattr.
- Reassigned variables or multiple kattr instances: mitigate by matching the same address-of argument instance across calls.

8. Limitations & Assumptions
- Assumes the semantics that finish_mount_kattr must run whenever wants_mount_setattr returned >0, as described in [ROOTCAUSE_ANALYSIS] and [FILE_CONTENT]; the checker is tailored to this specific pair.
- Does not attempt to infer other prepare/finalize pairs beyond wants_mount_setattr/finish_mount_kattr because only these are evidenced in the supplied materials.
- Interprocedural cleanup (cleanup via callee) is not reliably detected; the plan focuses on same-function cleanup presence.
- The checker does not verify whether wants_mount_setattr allocates resources in all >0 cases; it trusts the documented contract from [ROOTCAUSE_ANALYSIS].