1. Plan Summary
Detect missing cleanup of mount_kattr resources: when wants_mount_setattr() returns positive (resources acquired), verify finish_mount_kattr() is executed along all error and success paths before returning.

2. Detection Steps
1) Step 1: Identify obligation-creating calls.
- Objective: Find places that may acquire resources in mount_kattr.
- Signals: A call to wants_mount_setattr(uattr, usize, &kattrVar) whose return is stored in an integer variable retVar, with the third argument being the address of a mount_kattr object (typically a local).

2) Step 2: Determine the “ret > 0” obligation region.
- Objective: Decide where finish_mount_kattr(&kattrVar) becomes mandatory.
- Signals: Either (a) an explicit conditional if (retVar > 0) or (b) the common pattern “if (retVar < 0) return …; if (retVar) …” where the second condition implies retVar > 0; treat the dominated block(s) as the obligation region.

3) Step 3: Track the specific kattr object that must be finished.
- Objective: Make sure we enforce cleanup on the exact mount_kattr instance initialized by wants_mount_setattr().
- Signals: Use the same address-taken mount_kattr variable (&kattrVar) used in wants_mount_setattr(), and require finish_mount_kattr() be called with that exact variable.

4) Step 4: Require finish before any exit from the obligation region.
- Objective: Ensure there is no path leaving the function (e.g., return, tail return via labels) from within the “ret > 0” obligation region that skips finish_mount_kattr(&kattrVar).
- Signals: Path analysis from the start of the obligation region to any function exit; flag if no intervening finish_mount_kattr(&kattrVar) call occurs on some path.

5) Step 5: Specifically catch the “error-after-work” early-return pattern.
- Objective: Detect the exact pre-patch flaw: performing work and then returning on error without cleanup.
- Signals: Inside the obligation region, a call to do_mount_setattr(…, &kattrVar) whose result is stored in retVar (or a temp used to update retVar), followed by a branch like if (retVar) return retVar (or equivalent error return) before any finish_mount_kattr(&kattrVar).

6) Step 6: Accept correct “cleanup-then-return” sequences.
- Objective: Avoid false positives where cleanup is performed before returning.
- Signals: If the error branch after do_mount_setattr invokes finish_mount_kattr(&kattrVar) prior to returning (directly or via a common cleanup label), do not flag.

7) Step 7: Accept unconditional cleanup after the obligation block.
- Objective: Allow the fixed pattern where finish is always called once retVar > 0, regardless of do_mount_setattr() success.
- Signals: A finish_mount_kattr(&kattrVar) executed unconditionally at the end of the retVar > 0 block, and only after that an if (retVar) return retVar; do not flag.

8) Step 8: Ensure path coverage beyond immediate blocks.
- Objective: Catch leaks through complex control flow (multiple nested ifs/gotos).
- Signals: Perform intra-procedural path analysis from the obligation region entry to all returns; ensure every path includes a finish_mount_kattr(&kattrVar) call.

9) Step 9: Avoid false positives when there is no obligation.
- Objective: Do not require cleanup if wants_mount_setattr() returns 0 or negative.
- Signals: If code paths can return before conclusively establishing retVar > 0 (or after a retVar == 0 path), do not enforce finish; errors from wants_mount_setattr() (retVar < 0) are fine without cleanup.

10) Step 10: Match the exact API pair.
- Objective: Scope the checker to this vulnerability class.
- Signals: Limit to the specific API pair and types from the file: wants_mount_setattr() and finish_mount_kattr() operating on struct mount_kattr; only flag when both appear in the same function and the same kattr instance is involved.

3. Limitations & Assumptions
- The plan focuses on the specific API contract established in the provided code: wants_mount_setattr() (>0) implies a must-call to finish_mount_kattr() for that mount_kattr instance.
- Interprocedural cleanup (e.g., finish called in a helper) is not considered unless clearly analyzable intra-procedurally; this may cause false positives if cleanup is delegated.
- Precise value-range reasoning is approximated by control-flow patterns (e.g., ret < 0 check followed by if (ret)); code using non-standard idioms may be missed.
- The plan assumes function names and signatures as shown; renamed or wrapped variants are out of scope.