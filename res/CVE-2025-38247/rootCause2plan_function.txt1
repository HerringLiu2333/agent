1. Plan Summary
Detect error paths in open_tree_attr-like code where finish_mount_kattr is skipped after wants_mount_setattr indicates resources were acquired and do_mount_setattr subsequently fails.

2. Detection Steps
1) Step 1: Identify functions that call wants_mount_setattr(uattr, usize, &kattr) and store the return value in an integer (e.g., ret). Signals: a mount_kattr variable’s address (&kattr) passed to wants_mount_setattr and the result assigned to a local int.
2) Step 2: Confirm the same function also calls finish_mount_kattr(&kattr), implying cleanup is expected for the kattr resources. Signals: presence of finish_mount_kattr using the same kattr variable.
3) Step 3: Locate an immediate error check for negative returns from wants_mount_setattr (ret < 0) that exits the function. Signals: a conditional comparing ret < 0 followed by a return or equivalent error propagation.
4) Step 4: Find a subsequent conditional branch that is entered when ret is non-zero (truthy), not strictly ret > 0. Signals: an “if (ret)” style guard wrapping follow-up operations.
5) Step 5: Inside that truthy branch, detect a call to do_mount_setattr(&file->f_path, &kattr) with its result stored back into ret. Signals: assignment of ret from do_mount_setattr and &kattr passed to it.
6) Step 6: Within the same branch, identify an error-handling statement that returns when ret is non-zero before any call to finish_mount_kattr executes. Signals: “if (ret) return ret;” or equivalent early return positioned prior to any finish_mount_kattr call.
7) Step 7: Perform control-flow reachability to confirm a path where:
   - wants_mount_setattr’s return leads into the truthy branch (i.e., positive/“work to do”),
   - do_mount_setattr fails (ret != 0),
   - the function returns from that branch,
   - and finish_mount_kattr is not executed on that path. Signals: path-sensitive check that the early return dominates exit without a preceding finish_mount_kattr.
8) Step 8: Verify argument aliasing: the same kattr variable instance is passed to wants_mount_setattr, do_mount_setattr, and finish_mount_kattr. Signals: identical variable or address used across all three calls to tie the resource life cycle.
9) Step 9: Report the issue when such a path exists, describing that finish_mount_kattr is skipped after wants_mount_setattr signaled resource acquisition and do_mount_setattr errored. Signals: diagnostic tied to the specific calls and the early return location.

3. Limitations & Assumptions
- Assumes the semantic contract that a positive (non-zero) return from wants_mount_setattr indicates resources requiring finish_mount_kattr, per the provided analysis; CodeQL cannot infer this without the domain knowledge.
- The checker is tailored to the specific function names wants_mount_setattr, do_mount_setattr, and finish_mount_kattr; it may miss analogous patterns with different APIs.
- It relies on local control-flow; interprocedural effects or atypical cleanup paths (e.g., deferred cleanup via error handlers not shown) are not considered.
- Distinguishing “ret > 0” vs “ret != 0” is structural; the checker assumes the truthy branch corresponds to the resource-acquired case as described.