1. CVE Identifier
CVE-2025-38247

2. Vulnerability Type
Resource/Refcount leak (user_namespace and mount idmap reference leak) leading to potential denial of service

3. Root Cause Summary
open_tree_attr(2) failed to release resources when wants_mount_setattr() indicated attributes should be applied (>0) but do_mount_setattr() returned an error. Specifically, finish_mount_kattr(), which drops references to kattr->mnt_userns and kattr->mnt_idmap, was only called on the success path. This caused leaked references to the user namespace (->mnt_userns) and possibly to the allocated mnt_idmap, resulting in persistent resource leaks.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- VFS mount namespace handling in fs/namespace.c, particularly the open_tree_attr(2) syscall path.

2) Pre-Patch Flaw:
- In SYSCALL_DEFINE5(open_tree_attr, ...), after wants_mount_setattr(uattr, usize, &kattr) returned >0, the code did:
  - ret = do_mount_setattr(&file->f_path, &kattr);
  - if (ret) return ret;  // early return on error
  - finish_mount_kattr(&kattr);  // only executed on success
- As shown in FILE_CONTENT, finish_mount_kattr() releases kattr->mnt_userns (put_user_ns()) and kattr->mnt_idmap (mnt_idmap_put()). Not invoking it on the error path leaked references.

3) Trigger Condition:
- Call open_tree_attr() with non-NULL uattr such that wants_mount_setattr() returns >0 (attributes requested), and do_mount_setattr() fails (e.g., due to validation or allocation failure). In this case, the pre-patch code returned without calling finish_mount_kattr().

4) Impact Mechanism:
- Leaked references to user namespace objects and possibly mnt_idmap objects accumulate, leading to unbounded refcount/memory growth. This can cause resource exhaustion (denial of service) within the kernel due to leaked userns and mount idmap references.

5. Patch Analysis
1) Fix Approach:
- Ensure finish_mount_kattr(&kattr) is always called whenever wants_mount_setattr() returned a positive value, regardless of do_mount_setattr() success or failure.
- Defer returning the error code until after finish_mount_kattr() has been invoked to guarantee cleanup.

2) Key Code Changes:
- In open_tree_attr():
  - Change condition from “if (ret) { … finish_mount_kattr(&kattr); }” to “if (ret > 0) { ret = do_mount_setattr(...); finish_mount_kattr(&kattr); }”.
  - Add a subsequent “if (ret) return ret;” to handle both negative ret from wants_mount_setattr() and errors from do_mount_setattr() after cleanup.
- This directly addresses the leak by calling finish_mount_kattr() on both success and error outcomes of do_mount_setattr().

3) Locking/Concurrency Impact:
- No changes to locking primitives or ordering. The fix is purely control-flow and lifetime management of kattr resources, ensuring proper release independent of error paths.

6. Broader Kernel Security Implications
- Reference leaks in core namespace/mount handling can be abused to deplete kernel memory or ucounts, leading to denial-of-service conditions. Ensuring all error paths release acquired references is critical in syscall implementations that manipulate namespaces/idmaps. This patch reduces the attack surface by enforcing consistent cleanup semantics and prevents userns/mnt_idmap object leaks that could otherwise accumulate over repeated syscall failures.