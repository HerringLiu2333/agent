1. CVE Identifier
CVE-2025-38247

2. Vulnerability Type
Refcount/resource leak (missing cleanup on error path) leading to potential denial-of-service via leaked user namespace and mount idmap references.

3. Root Cause Summary
In open_tree_attr(), when wants_mount_setattr() returns a positive value, it allocates/acquires resources (e.g., mnt_userns and possibly mnt_idmap) that must be released by finish_mount_kattr(). The pre-patch logic returned early on error from do_mount_setattr() without calling finish_mount_kattr(), leaving those resources leaked. Specifically, inside the “if (ret)” block, the code executed “if (ret) return ret;” before invoking finish_mount_kattr(), so failures bypassed cleanup. This is a lifetime/refcount management bug in the error path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFS mount/namespace handling, open_tree_attr(2) syscall, mount attribute/idmap handling.

2) Pre-Patch Flaw:
The syscall’s error path failed to call finish_mount_kattr() after wants_mount_setattr() had indicated work (ret > 0) and resources were acquired, if do_mount_setattr() returned an error. Cleanup was conditional on success, resulting in leaked mnt_userns and potentially mnt_idmap.

3) Trigger Condition:
- uattr is provided and wants_mount_setattr(uattr, usize, &kattr) returns > 0 (resources prepared).
- do_mount_setattr(&file->f_path, &kattr) returns an error.
- The function returns immediately without calling finish_mount_kattr().

4) Impact Mechanism:
Leaked references to ->mnt_userns and possibly mnt_idmap cause refcount/resource leaks, pinning user namespaces/idmaps and consuming kernel memory. Repeated invocations can accumulate leaked references, potentially leading to resource exhaustion and denial-of-service.

5. Patch Analysis
1) Fix Approach:
Ensure finish_mount_kattr() is called whenever wants_mount_setattr() returned positive, irrespective of do_mount_setattr() success. Move the error return to occur after finish_mount_kattr() and adjust conditionals to distinguish positive from negative returns.

2) Key Code Changes:
- Change check to “if (ret > 0) { ret = do_mount_setattr(...); finish_mount_kattr(&kattr); }”.
- Remove the early “if (ret) return ret;” from inside the block that previously guarded finish_mount_kattr().
- Add a unified “if (ret) return ret;” after the cleanup, ensuring resources are released before returning on both success and failure paths.

3) Locking/Concurrency Impact:
No locking changes; the patch addresses lifetime/refcount correctness by guaranteeing the matching release (finish_mount_kattr) for resources acquired when wants_mount_setattr() is positive. Concurrency semantics remain unchanged.

6. Broader Kernel Security Implications
Correct refcount/lifetime management in mount and user namespace handling is critical to prevent resource pinning and memory leaks. Such leaks can enable unprivileged users to trigger persistent resource consumption, leading to denial-of-service conditions in multi-tenant or containerized environments. The fix strengthens reliability of namespace/idmap management and reduces the risk of system instability due to leaked kernel objects.