1. Plan Summary
Detect mismatches where a length field (length_bytes) is overridden to a larger value after allocations sized using an original/template length, leading to potential out-of-bounds reads.

2. Detection Steps
1) Step 1: Objective: Find candidate “length field” writes implicated in the root cause. Signals: Assignments to a struct field named length_bytes within a function (evidence: def.length_bytes = 8 in [PATCH_DIFF]). FP mitigation: Restrict to cases where the field belongs to a descriptor-like object subsequently used (passed to another function) rather than dead code.

2) Step 2: Objective: Identify earlier size sources used for allocation. Signals: In the same function, detect allocations or buffer initializations whose size expression depends on either a template’s length (e.g., mock_coeff_template.length_bytes = 4 per [ROOTCAUSE_ANALYSIS]) or an earlier value of the same descriptor’s length_bytes. FP mitigation: Require clear dataflow from the template or earlier length field to the allocation size.

3) Step 3: Objective: Correlate the allocation with the descriptor that later has its length_bytes overridden. Signals: Establish that the descriptor variable written (length_bytes = …) is initialized from or associated with the template or the allocation context (e.g., copied from template or used to describe buffers sized via template, per [ROOTCAUSE_ANALYSIS]). FP mitigation: Require either a copy/assignment from a known template object in the same function or shared identifiers/dataflow linking template length to the descriptor setup.

4) Step 4: Objective: Determine if the override increases the length beyond the allocation size. Signals: Compare the post-override length_bytes value with the earlier allocation size driver; prioritize constant vs constant cases (8 vs 4 per [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF]). FP mitigation: Only flag when the new value can be proven greater than the allocation-size-derived value (strict inequality), preferably for literal constants.

5) Step 5: Objective: Check that the override occurs after the allocation sizing decision. Signals: Enforce program order: allocation (or its size computation) precedes the assignment to length_bytes (mirrors: allocation based on 4, then def.length_bytes = 8 per [ROOTCAUSE_ANALYSIS]/[PATCH_DIFF]). FP mitigation: Ignore cases where override precedes allocation or where allocation is recomputed afterward.

6) Step 6: Objective: Verify probable use of the overridden descriptor. Signals: The descriptor is passed by pointer/reference/value to a downstream function after the override (e.g., builder/add-coeff APIs such as cs_dsp_mock_wmfw_add_coeff_desc per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]). FP mitigation: Prefer calls whose names or argument roles suggest operating on coefficient/control descriptors; require the descriptor object appears as an argument.

7) Step 7: Objective: Ensure there is no compensating reallocation for the larger size. Signals: Between the override and the first downstream use, absence of a new allocation/resizing that uses the larger length_bytes. FP mitigation: Recognize common allocation/realloc patterns; if any size expression uses the new (larger) length_bytes prior to use, do not flag.

8) Step 8: Objective: Strengthen evidence of potential OOB read. Signals: If visible intra-procedurally, detect any read/copy operation sized by the overridden length_bytes that targets buffers allocated with the smaller size; otherwise rely on Step 6 as a proxy since downstream code will consume the descriptor (per [ROOTCAUSE_ANALYSIS] impact). FP mitigation: Only add this as optional confirmation; absence of visible direct read should not be mandatory given test encapsulation.

9) Step 9: Objective: De-duplicate and rank findings. Signals: Group multiple writes to the same descriptor; prefer the last increasing write before first use. FP mitigation: Report once per descriptor per function and include the compared sizes to aid triage.

3. Target Elements
- Struct field assignments to length_bytes.
- Allocation and buffer sizing sites (stack arrays, kmalloc/vmalloc/new, size computations).
- Variable initializations/copies from template descriptor objects.
- Function call sites that consume the descriptor after override (e.g., add/construct/initialize APIs).
- Intra-procedural order relations (dominance and sequencing within the same function).
- Optional: read/copy/memaccess operations sized by length_bytes.

4. Dataflow / Taint Considerations
- Track dataflow of size values from template.length_bytes (evidence: mock_coeff_template.length_bytes = 4 in [ROOTCAUSE_ANALYSIS]) into allocation-size expressions.
- Track subsequent assignments to the same descriptor’s length_bytes and their values (prefer constants).
- Track the descriptor variable from initialization through modifications to its first downstream call use.
- Optionally, track size arguments in memory access operations that reference length_bytes and target buffers allocated with the earlier size.

5. Validation & Test Cases
- Positive: A function allocates a buffer sized using template.length_bytes = 4, then sets def.length_bytes = 8, then passes def to a builder/consumer; expect a report (mirrors [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Negative: The code sets def.length_bytes = 8 before allocation and the allocation uses 8; expect no report.
- Negative: The code reallocates/resizes buffers using the new def.length_bytes after the override and before use; expect no report.
- Negative: The code sets def.length_bytes to 4 (equal) or smaller than the allocation size; expect no report.
- Test harness notes: Include a KUnit-like function named similarly to cs_dsp_ctl_cache_init_multiple_offsets to mirror context, plus generic functions to ensure generalization beyond naming.

6. Estimated Effort & Priority
Medium

7. Likely False-Positive Sources & Mitigations
- Descriptor length overrides used only for metadata without impacting buffer access; mitigate by requiring downstream use of the descriptor after override.
- Inference failures when sizes are computed through complex expressions; mitigate by focusing on constant or provably greater-than cases.
- Unmodeled interprocedural allocations/resizes; mitigate by limiting to intra-procedural evidence and permitting a “no-reallocation-between-override-and-use” check.
- Fields named length_bytes in unrelated contexts; mitigate by additionally requiring nearby allocation based on a template length and subsequent descriptor use.

8. Limitations & Assumptions
- Assumes the length field of interest is named length_bytes (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]); other naming patterns are not covered.
- Cannot always prove OOB read without modeling downstream consumers; relies on the proxy of “descriptor passed to a consumer after an increasing override.”
- Assumes intra-procedural visibility of the allocation and the override; interprocedural flows may be missed.
- Exact allocation APIs and builder/consumer functions beyond those shown (cs_dsp_mock_wmfw_add_coeff_desc) are not enumerated in the materials, so detection uses generic allocation/use patterns.