1. Plan Summary
Detect cases where a buffer is allocated using a size variable/field and, before the buffer is used, that size variable is modified and then reused as the length for memory or I/O operations on the same buffer, leading to potential out-of-bounds access.

2. Detection Steps
1) Step 1: Identify allocation-sized variables — find buffer allocations whose size argument references a variable/field (e.g., def.length_bytes) as in the KUnit code (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). Record the buffer pointer, the size variable/field, and the allocation site.
2) Step 2: Track subsequent assignments to the size variable/field — locate writes that update the same variable/field after the allocation (e.g., “def.length_bytes = 8;” removed in PATCH_DIFF). This signals potential inconsistency between allocated size and later usage (maps directly to root cause in ROOTCAUSE_ANALYSIS).
3) Step 3: Identify length-parameterized uses — locate calls that take the allocated buffer pointer and a length argument referencing the same size variable/field (e.g., regmap_raw_write/read, cs_dsp_coeff_lock_and_read_ctrl, KUNIT_EXPECT_MEMEQ; seen in FILE_CONTENT). These calls model reads/writes/memcmp-like operations that can overrun the buffer if the length has changed.
4) Step 4: Ensure ordering — require that the size-variable assignment occurs strictly between the allocation and the buffer-using call in the same control flow path. This matches the temporal mismatch observed: allocation with 4 bytes then later use with 8 bytes (ROOTCAUSE_ANALYSIS).
5) Step 5: Confirm buffer identity — ensure the same pointer object allocated earlier is passed to the later call (no intervening reassignments to a different pointer). This reduces false positives from unrelated buffers.
6) Step 6: Check for reallocation — if the buffer is reallocated (or freed and reallocated) after the size-variable update and before the use, suppress the report. This avoids flagging safe updates where capacity was adjusted to the new length.
7) Step 7: Prefer stronger evidence with constant growth — when both the allocation size and later assigned size are compile-time constants, flag when the later size is greater than or equal to the earlier one (as in 4 → 8 from ROOTCAUSE_ANALYSIS). This aligns with the concrete KASAN-reported OOB read and reduces noise.
8) Step 8: Recognize bounding guards — suppress when the use-site length is explicitly bounded by the known allocated size (e.g., min(new_len, alloc_size) or equivalent clamp), even if the size variable changed. This mitigates false positives in code that clamps accesses (no such guard existed in FILE_CONTENT).
9) Step 9: Support struct-field based sizing — treat field updates (e.g., def.length_bytes) and initializers from templates (mock_coeff_template.length_bytes) as the same “size authority” when used for allocation and later calls. This directly models the defect pattern in cs_dsp_ctl_cache_init_multiple_offsets (FILE_CONTENT).
10) Step 10: Include multi-buffer comparisons — detect when two buffers, both allocated under the original size, are later compared/copied using the updated (larger) size variable (e.g., KUNIT_EXPECT_MEMEQ(readback, reg_vals, def.length_bytes) in FILE_CONTENT). This captures additional OOB access patterns described in ROOTCAUSE_ANALYSIS.
11) Step 11: Exclude benign reductions — if static evaluation shows the updated size is a strict decrease relative to the allocation size, downgrade or suppress. This avoids false alarms for safe shortening of lengths.
12) Step 12: Report with path context — include the allocation site, the size-variable update site, and the first unsafe call site using the updated length. Explain that the size variable changed after allocation, mirroring the fix that removed the override (PATCH_DIFF and PATCH_DESCRIPTION).

3. Target Elements
- Allocation sites: kmalloc/kzalloc/kunit_kmalloc/kunit_kzalloc (and similar).
- Variable/field writes: assignments to size variables/fields (e.g., def.length_bytes).
- Call sites: functions that take (buffer pointer, length) for memory I/O or comparisons (e.g., regmap_raw_write/read, cs_dsp_coeff_lock_and_read_ctrl, KUNIT_EXPECT_MEMEQ).
- Control-flow ordering between allocation, size-variable mutation, and use.
- Reallocation/free sites and bounds-check patterns (min/clamp idioms).
- Struct field initializers and template-derived fields used for sizes.

4. Dataflow / Taint Considerations
- Track dataflow from a size variable/field into an allocation size and later into call length parameters.
- Track the identity of the buffer pointer from allocation to use (intra-procedural with inter-procedural where straightforward).
- Track assignments to the size authority variable/field between allocation and use.
- Detect whether the buffer is reallocated after the size change, which would neutralize the risk.

5. Validation & Test Cases
- Positive: A function allocates reg_vals = kunit_kmalloc(test, def.length_bytes, ...); later sets def.length_bytes = 8; then calls regmap_raw_write(..., reg_vals, def.length_bytes) and cs_dsp_coeff_lock_and_read_ctrl(..., readback, def.length_bytes). Expect a finding highlighting size change after allocation (mirrors FILE_CONTENT and ROOTCAUSE_ANALYSIS).
- Negative: Same as above but do not change def.length_bytes, or reallocate reg_vals with the new def.length_bytes before use. Expect no finding (mirrors the fix in PATCH_DIFF/PATCH_DESCRIPTION).
- Test harness notes: Include a variant with KUNIT_EXPECT_MEMEQ(readback, reg_vals, def.length_bytes) after the size change to validate multi-buffer comparisons are flagged.

6. Estimated Effort & Priority
Medium: requires moderate dataflow and control-flow ordering, struct-field tracking, and basic constant evaluation; high value due to direct mapping to KASAN-detected OOB conditions.

7. Likely False-Positive Sources & Mitigations
- Size decreases (mitigate by checking for constant decreases and downgrading).
- Defensive clamping not recognized (mitigate by recognizing common min/clamp patterns).
- Reallocations via less common APIs not recognized (mitigate by maintaining an extendable list of allocation/reallocation APIs).
- Macro-wrapped calls obscuring buffer/length pairing (mitigate with argument unwrapping heuristics and looking through simple macros).

8. Limitations & Assumptions
- The checker assumes an analyzable mapping between buffer pointers and their allocations; complex aliasing may reduce precision.
- Exact runtime sizes are not always computable; the checker relies on detecting any post-allocation size-variable mutation as a risk, which may over-approximate.
- The set of “buffer + length” APIs is assumed to include known kernel/test functions seen in FILE_CONTENT (regmap_raw_write/read, cs_dsp_coeff_lock_and_read_ctrl, KUNIT_EXPECT_MEMEQ); coverage beyond these requires configurable API lists.
- The plan is based on the specific pattern described in PATCH_DESCRIPTION, PATCH_DIFF, FILE_CONTENT, and ROOTCAUSE_ANALYSIS and does not infer broader kernel behaviors not present in these materials.