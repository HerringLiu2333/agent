1. Plan Summary
Detect mismatches where buffers are allocated using a size field/variable and, later, that size is overridden and used for read/compare operations on those buffers, causing out-of-bounds reads.

2. Detection Steps
1) Step 1: Identify size providers used for allocation — find calls that allocate buffers (e.g., kunit_kmalloc, kunit_kzalloc) where the size argument dataflows from a variable/field (e.g., def.length_bytes); record the allocated pointer(s) and the size provider expression used at allocation time.
2) Step 2: Confirm allocation order — ensure these allocations occur before any assignment to the same size provider variable/field within the function (e.g., a later “def.length_bytes = …”).
3) Step 3: Detect size override — locate subsequent assignments to the size provider (the same variable/field), and capture the new value (preferably constant if available) to indicate the size has changed after allocation.
4) Step 4: Track pointer usage in read/compare sinks — find calls that read or compare memory using a length argument that dataflows from the overridden size provider and that also take the previously allocated pointer(s) as a buffer argument (e.g., regmap_raw_write with reg_vals[i] as source and def.length_bytes as length; KUNIT_EXPECT_MEMEQ with readback/reg_vals[i] and def.length_bytes).
5) Step 5: Enforce ordering — ensure the sink calls occur after the size override but before any reallocation/resizing of the involved pointers.
6) Step 6: Exclude safe cases — if the pointer is reallocated or resized to the new (overridden) size after the override and before the sink, suppress the finding for that pointer.
7) Step 7: Strengthen evidence with constants — when both the initial size (at allocation) and the overridden size are resolvable constants, flag as definite if the overridden size is greater than the initial size; otherwise, flag as potential mismatch.
8) Step 8: Multi-buffer awareness — apply the same tracking to each element of pointer arrays (e.g., reg_vals[i]) to catch per-element allocations followed by collective use of the larger size.
9) Step 9: Destination-buffer read-through — for destinations like readback populated by intermediate functions (e.g., cs_dsp_coeff_lock_and_read_ctrl) and later compared via KUNIT_EXPECT_MEMEQ with the larger size, treat the compare as a read sink for OOB detection.
10) Step 10: Report path — for each finding, produce a path summary: allocation site using size provider, assignment overriding the size, and sink call using the overridden size on the originally-sized buffer.

3. Limitations & Assumptions
- Exact initial value of mock_coeff_template.length_bytes (e.g., 4) may not be statically available; detection flags any post-allocation size override, with stronger confidence when constants are comparable.
- Function semantics (which arguments are read vs. written) are inferred from provided analysis; the checker assumes regmap_raw_write reads from its buffer argument and KUNIT_EXPECT_MEMEQ reads from both buffers by the given length.
- The plan does not model complex aliasing beyond straightforward pointer identity and simple array elements; deeply aliased buffers may be missed.
- The checker assumes no hidden resizing helpers; it looks for explicit (re)allocation calls and direct assignments to pointer variables to determine resizing.