1. Plan Summary
Detect cases where a buffer is allocated based on a variable/field “size carrier,” that carrier is later reassigned to a larger/different value, and the original buffer is then used in calls with the modified size, causing potential out-of-bounds reads/writes.

2. Detection Steps
1) Step 1: Identify buffer allocations. Find calls to allocator APIs (e.g., kunit_kmalloc/kunit_kzalloc/kzalloc/kmalloc) where the size argument syntactically depends on a specific l-value “size carrier” (e.g., a struct field like def.length_bytes or a variable used to compute the size).

2) Step 2: Record the size carrier. For each such allocation, bind the exact l-value (field/variable) referenced by the size expression and the pointer(s) allocated (including array elements like reg_vals[i]).

3) Step 3: Locate post-allocation mutations. In the same function, find assignments that write a new value to the same size carrier l-value after the allocation site (e.g., def.length_bytes = 8).

4) Step 4: Find length-using call sites. After the mutation, locate calls that take both a buffer pointer and an explicit length argument where the length expression again references the mutated size carrier (e.g., regmap_raw_write/read, cs_dsp_coeff_lock_and_read_ctrl/write_ctrl, and mem-equality checks taking a length).

5) Step 5: Establish ordering. Ensure control-flow ordering: allocation occurs first, then the size carrier mutation, then the length-using call; and the pointer has not been resized/reallocated in-between.

6) Step 6: Pair pointer and length. Verify that the buffer argument in the call is the previously allocated pointer (or an element thereof) and the call’s length argument is derived from the mutated size carrier (same l-value).

7) Step 7: Flag proven growth. If both the original allocation size and the post-mutation size are compile-time constants or constant-propagated values, flag when the post-mutation size is greater than the allocation size.

8) Step 8: Flag uncertain but risky changes. If the size carrier is reassigned to a different value not provably ≤ the original (e.g., assigned from another variable or non-constant expression), and the buffer is used with that new size without reallocation, flag as potential OOB.

9) Step 9: Handle pointer arrays and loops. Treat buffers allocated inside loops (e.g., reg_vals[i]) as a set of allocated pointers associated with the same size carrier; apply Steps 3–8 to any later calls using any of these elements with the mutated size.

10) Step 10: Exclude safe cases. Do not report if: the buffer is reallocated after the size carrier change; the length argument is provably bounded by the original allocation size; or the buffer used is different from the one allocated under the original size carrier.

11) Step 11: Prioritize kernel I/O-style APIs. Increase confidence when the sink is a known read/write API or comparison using a length (e.g., regmap_raw_write/read, cs_dsp_coeff_lock_and_read_ctrl/write_ctrl, KUNIT_EXPECT_MEMEQ with a length), since these imply memory access proportional to the length.

12) Step 12: Report with trace. For each finding, report the allocation site (size expression), the mutation of the size carrier (assignment), and the hazardous call site (buffer + mutated length), naming the size carrier (e.g., def.length_bytes).

3. Limitations & Assumptions
- The checker assumes a known set of allocator functions and common length-using APIs; additional sinks may need to be configured for broader coverage.
- It assumes intra-procedural analysis; mutations across function boundaries or via aliases may be missed.
- It may conservatively flag uncertain changes (when growth can’t be proven) as potential issues.
- The plan relies on identifying the same l-value for the “size carrier”; complex aliasing of struct copies or pointers to the carrier may reduce precision.