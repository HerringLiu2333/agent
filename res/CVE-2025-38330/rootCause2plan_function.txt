1. Plan Summary
Detect cases where a buffer is allocated based on a struct “length” field, that length field is later increased, and the updated length is used in read/write/compare operations on the originally allocated buffer, causing out-of-bounds access (as in the KUnit test def.length_bytes override).

2. Detection Steps
1) Step 1: Objective: Identify size-bearing struct fields used for allocation. Signals: Calls to kernel allocators (e.g., kmalloc/kzalloc and their KUnit variants) whose size argument is a direct field access like obj.length_bytes or an expression derived solely from it; map buffer variable(s) to the owner struct and field. FP mitigation: Require the field read to dominate the allocation in control flow and be the primary contributor to the size expression (no unrelated additions).
2) Step 2: Objective: Record the allocation context for each buffer. Signals: Capture (buffer var, owner struct var, length field, allocation site, initial length value if literal) and note families allocated in loops (e.g., reg_vals[i]) as in the provided function. FP mitigation: Exclude allocations whose size is not traceably tied to a single struct length field.
3) Step 3: Objective: Detect post-allocation mutations to the same length field. Signals: Assignments like owner.length_bytes = <expr> appearing after the allocation along a feasible path (based on [PATCH_DIFF] removing “def.length_bytes = 8;”). FP mitigation: Ignore assignments that occur strictly before all relevant allocations.
4) Step 4: Objective: Find memory-access sinks that use the buffer with the (possibly modified) length field. Signals: Calls where a recorded buffer variable is passed as a data pointer and the length/count argument originates from the same owner.length_bytes used at allocation; examples from [FUNCTION_CONTENT] include regmap_raw_write(..., buf, length), cs_dsp_coeff_lock_and_read_ctrl(..., buf, length), and mem-equality checks using that length (based on [ROOTCAUSE_ANALYSIS]). FP mitigation: Restrict to known “length-bounded memory access” APIs or macro wrappers that conceptually read/write ‘length’ bytes.
5) Step 5: Objective: Ensure the field update can impact the sink. Signals: Control-flow path where (a) allocation happens, (b) owner.length_bytes is assigned a new value, and (c) the sink is reached, with no intervening reassignment back to the original value. FP mitigation: Require path feasibility and that the buffer variable is not reallocated or resized after the length field change.
6) Step 6: Objective: Prefer high-confidence constant-mismatch cases. Signals: Original allocation length resolves to a constant C and the later assignment sets a constant D where D > C (e.g., 4 -> 8 per [ROOTCAUSE_ANALYSIS]). FP mitigation: Only elevate to “defect” when a strict increase is statically provable; otherwise, mark as “warning.”
7) Step 7: Objective: Flag non-constant cases lacking safety checks. Signals: When the updated length is non-constant or unknown but there is no guard ensuring new length ≤ allocated size (no conditional comparing owner.length_bytes against stored alloc-size or fixed bound). FP mitigation: Suppress if there is any branch conditioning the sink on owner.length_bytes ≤ alloc_size or capping the length used at the sink.
8) Step 8: Objective: Handle loop-allocated buffer families. Signals: Loop allocations of arrays of pointers using the length field (e.g., reg_vals[i]) and subsequent per-element uses at sinks with the updated length, as shown in [FUNCTION_CONTENT]. FP mitigation: Require that the same array element flows to the sink on the same path where the length field update occurs.
9) Step 9: Objective: Avoid aliasing-induced over-tainting. Signals: Limit to the same syntactic owner variable (e.g., def.length_bytes) within the function; if the struct is copied, only propagate when the copy and update can be proven to affect the same instance used at allocation. FP mitigation: Do not propagate through uncertain aliases or across calls without clear by-reference modification.
10) Step 10: Objective: Increase confidence when multiple sinks use the updated length. Signals: The same (buffer, owner.length_bytes) pair is used in two or more sinks after the update (e.g., regmap_raw_write and KUNIT_EXPECT_MEMEQ per [FUNCTION_CONTENT]). FP mitigation: Prioritize such cases; de-prioritize single, ambiguous sink usages.

3. Target Elements
- Function bodies (local control/data flow).
- Allocation sites using a struct length field (kunit_kmalloc, kunit_kzalloc, kmalloc, kzalloc).
- Assignments to struct length fields (e.g., def.length_bytes = ...).
- Call sites of length-bounded memory operations (e.g., regmap_raw_write, cs_dsp_coeff_lock_and_read_ctrl, memcmp/memeq-like macros).
- Loops allocating arrays of buffers (e.g., reg_vals[i]) and subsequent uses.
- Conditional checks comparing length to bounds (guards).

4. Dataflow / Taint Considerations
- Track value flow from a struct length field into allocation-size arguments to bind buffers to their size source.
- Track subsequent assignments to that same field and propagate the “updated length” to sink call sites within the same function and along feasible paths.
- Track buffer variables from allocation to sink; invalidate if any reallocation/resizing occurs after the length update.
- Recognize guards that cap or validate the updated length against allocated size to suppress alerts.

5. Validation & Test Cases
- Positive: Replicate [FUNCTION_CONTENT]: allocate reg_vals[i] and readback using def.length_bytes from mock_coeff_template (4), then assign def.length_bytes = 8 and use in regmap_raw_write and KUNIT_EXPECT_MEMEQ; expect a high-confidence alert (matches [ROOTCAUSE_ANALYSIS]).
- Negative: Same as above but remove the override (as in [PATCH_DIFF]); expect no alert.
- Negative: Change def.length_bytes to 8 before allocations so buffers are allocated with 8; expect no alert.
- Negative: After increasing def.length_bytes, reallocate buffers with the new length or add a guard ensuring new length ≤ allocated size; expect no alert.
- Test harness notes: Include loop-allocated arrays (reg_vals[i]) and multiple sinks to verify multi-sink prioritization.

6. Estimated Effort & Priority
Medium. Prioritize due to clear security impact of OOB reads and straightforward static signals (based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Unknown semantics of custom sink APIs (may not actually read/write the buffer): mitigate by curating a list of known length-bounded APIs used in the codebase (e.g., those observed in [FUNCTION_CONTENT]).
- Non-constant lengths where updated value is not actually larger: mitigate by requiring absence of guards and by path-sensitive ordering checks.
- Struct aliasing or copies obscuring ownership of the length field: mitigate by restricting to the same local owner variable unless proven aliasing.
- Conditional paths where reallocation occurs in some branches: mitigate by requiring no reallocation along the flagged path.

8. Limitations & Assumptions
- Assumes the analysis can identify which APIs read/write “length” bytes from/to the given buffer; exact semantics for regmap_raw_write and KUnit macros are inferred from [ROOTCAUSE_ANALYSIS], not formally modeled.
- Cannot always prove numerical relationships when lengths are non-constant; such cases may be downgraded or require manual review.
- Focused on intra-procedural patterns as exemplified in [FUNCTION_CONTENT]; inter-procedural updates to the length field are not addressed.
- Assumes the “allocation size” is solely determined by the struct length field, as described in [ROOTCAUSE_ANALYSIS]; mixed-size expressions may reduce precision.