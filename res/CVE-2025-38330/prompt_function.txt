1. CVE Identifier
CVE-2025-38330

2. Vulnerability Type
Out-of-bounds read due to size/length mismatch

3. Root Cause Summary
Inside the KUnit test function cs_dsp_ctl_cache_init_multiple_offsets, buffers (reg_vals[i] and readback) are allocated using mock_coeff_template.length_bytes (4 bytes), but the test then overrides def.length_bytes to 8 and proceeds to read/write and compare using this larger length. This creates a mismatch between allocated buffer sizes (4) and the number of bytes accessed (8), leading to out-of-bounds reads detected by KASAN. The flawed logic is the length override “def.length_bytes = 8;” without re-allocating buffers or validating sizes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test for control cache initialization)

2) Pre-Patch Flaw:
The test allocates memory based on def.length_bytes from mock_coeff_template (4 bytes) and later changes def.length_bytes to 8, causing accesses to exceed the allocated buffer sizes. There is no validation ensuring that the new length matches previously allocated sizes.

3) Trigger Condition:
Running cs_dsp_ctl_cache_init_multiple_offsets when mock_coeff_template.length_bytes is 4 and the code sets “def.length_bytes = 8;” before calling regmap_raw_write, cs_dsp_coeff_lock_and_read_ctrl, and KUNIT_EXPECT_MEMEQ with def.length_bytes.

4) Impact Mechanism:
- regmap_raw_write(dsp->regmap, ..., reg_vals[x], def.length_bytes) reads 8 bytes from reg_vals[x] allocated for 4 bytes (source OOB read).
- cs_dsp_coeff_lock_and_read_ctrl(..., readback, def.length_bytes) followed by KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[x], def.length_bytes) causes 8-byte comparisons against 4-byte buffers (OOB read by the test comparison).
KASAN reports out-of-bounds memory read during these operations.

5. Patch Analysis
1) Fix Approach:
Ensure consistent length usage by removing the erroneous override so all operations use the original 4-byte length that matches buffer allocations.

2) Key Code Changes:
- Single-line removal within cs_dsp_ctl_cache_init_multiple_offsets:
  “- def.length_bytes = 8;”
This prevents subsequent read/write/comparison operations from using a larger length than the allocated buffers.

3) Locking/Concurrency Impact:
None. The change is confined to test code and does not alter locking, concurrency, or ordering; it only corrects the length used for memory operations.

6. Broader Kernel Security Implications
Maintaining consistency between allocation sizes and I/O lengths is essential to avoid OOB accesses; this patch eliminates false positives and KASAN noise in the test harness, improving test reliability. Although limited to KUnit test code, it underscores a general principle critical to production code paths in firmware/control cache handling: do not change operational lengths without corresponding buffer management or validation.