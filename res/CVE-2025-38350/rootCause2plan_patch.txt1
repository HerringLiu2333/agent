1. Plan Summary
Detect functions that conditionally notify parent qdiscs when a child becomes empty but suppress notification based on backlog/offload checks or early returns, which can leave stale parent state and cause use-after-free.

2. Detection Steps
1) Step 1: Identify candidate functions that traverse to a parent qdisc and may issue qlen_notify. Signals: a loop using sch->parent, calls to qdisc_lookup_rcu, use of Qdisc_class_ops (cops), and a conditional call to cops->qlen_notify.

2) Step 2: Detect an early return that depends solely on backlog update parameters being zero, placed before the parent traversal/notification. Signals: a guard like “if (n == 0 && len == 0) return;” where n and len are integer parameters/locals representing backlog deltas.

3) Step 3: Locate checks for child qdisc emptiness. Signals: a condition or variable assignment referencing sch->q.qlen compared to zero (e.g., !sch->q.qlen).

4) Step 4: Extract the exact condition controlling whether qlen_notify is invoked. Signals: a boolean “notify” variable or inline conditional guarding cops->qlen_notify(sch, cl), and record all operands in that condition.

5) Step 5: Flag cases where emptiness notification is gated by backlog/offload state beyond qlen==0. Signals: notify defined as a conjunction of !sch->q.qlen with additional predicates referencing n or len (e.g., !n, n==0) and/or sch->flags & TCQ_F_OFFLOADED (possibly via an alias like qdisc_is_offloaded).

6) Step 6: Specifically detect WARN_ON_ONCE-based gating tied to backlog/offload. Signals: notify includes or is impacted by WARN_ON_ONCE(!n && !qdisc_is_offloaded) (or equivalent), where the WARN_ON_ONCE value participates in suppressing notification when !n is true.

7) Step 7: Correlate the early return (Step 2) with the notification gating (Steps 5–6). Signals: the function both returns early on (n==0 && len==0) and also requires nonzero n or offload status for notify, indicating missed notification paths when the queue is empty without backlog updates.

8) Step 8: Confirm that the code reaches cops->qlen_notify only under the gated condition and there is no separate unconditional notification on emptiness. Signals: single call site to cops->qlen_notify guarded by the notify condition; absence of any other path invoking qlen_notify when sch->q.qlen==0.

9) Step 9: Exclude safe implementations. Signals: implementations where notify is solely “!sch->q.qlen” (or equivalent emptiness check) and no early return on (n==0 && len==0).

10) Step 10: Highlight reliance on backlog counters that does not account for reset/purge paths. Signals: presence of drops = max_t(int, n, 0) or similar accounting adjustments combined with Steps 2, 5, or 6; use as supporting evidence, not a standalone trigger.

3. Limitations & Assumptions
- Assumes backlog parameters are named or used similarly to “n” and “len”; variations in naming may require broader matching.
- Does not prove runtime emptiness can occur without backlog updates; flags based on structural patterns that suppress notification in such cases.
- Cannot infer idempotency of qlen_notify handlers or guarantee UAF; the checker reports potential missed notifications when child emptiness occurs.
- Scope is focused on classful qdisc parent-notification logic; other subsystems with analogous patterns may not be covered without adapting signals.