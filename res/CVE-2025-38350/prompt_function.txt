1. CVE Identifier
CVE-2025-38350

2. Vulnerability Type
Use-after-free due to missed state notification in classful qdisc hierarchy

3. Root Cause Summary
qdisc_tree_reduce_backlog() suppressed parent notifications when a child qdisc became empty if no packet count/length deltas were provided (n == 0 && len == 0) and the qdisc was not offloaded. Specifically, the function returned early on (n == 0 && len == 0) and computed notify as “!sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)”, thereby skipping cops->qlen_notify() in common cases where qlen transitioned to 0 without explicit n/len updates. This left parent classes unaware that the child emptied/reset, allowing them to keep or re-activate classes that had been deleted, leading to use-after-free on stale class pointers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking traffic-control scheduler (net/sched), classful qdisc hierarchy handling

2) Pre-Patch Flaw:
- In qdisc_tree_reduce_backlog(), parent notification was tied to n/len updates and offload state instead of the actual empty state of the child qdisc:
  - Early exit: “if (n == 0 && len == 0) return;”
  - notify gating: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
- As a result, when a child became empty via qdisc_reset()/qdisc_purge_queue() or dequeue-during-enqueue paths, parents were not notified, desynchronizing class state.

3) Trigger Condition:
- Classful qdisc stacks where a child qdisc becomes empty without nonzero n/len, e.g., during class deletion or when enqueue invokes a dequeue handler that empties the child. The provided reproducer (DRR -> HFSC -> netem -> blackhole, then delete class and send another packet) triggers the missed notification and subsequent stale class handling.

4) Impact Mechanism:
- Without qlen_notify() propagation, the parent (and potentially its parent) may re-activate or continue referencing a class whose child qdisc has been reset/deleted. Subsequent scheduling accesses freed class structures, resulting in a use-after-free.

5. Patch Analysis
1) Fix Approach:
- Decouple notification from n/len changes and offload status; always notify when the child qdisc is empty. Ensure notification is propagated up the hierarchy even when n == 0 && len == 0.

2) Key Code Changes:
- Removed the early return on zero deltas:
  - Deleted: “if (n == 0 && len == 0) return;”
- Simplified and strengthened the notify condition:
  - Replaced: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
  - With: “notify = !sch->q.qlen;”
- Removed qdisc_is_offloaded logic entirely and added a note that qlen_notify must be idempotent since it may be called multiple times.
- No functional change to the RCU traversal; the loop continues to walk parents and call cops->qlen_notify() whenever sch->q.qlen == 0.

3) Locking/Concurrency Impact:
- RCU read-side locking remains unchanged (rcu_read_lock()/rcu_read_unlock()).
- The change increases the frequency of qlen_notify() calls (including multiple notifications on passive classes), but the code and recent series ensure handlers are idempotent, avoiding concurrency hazards.
- No new locks or ordering changes; the fix removes a race window created by conditional notification by guaranteeing timely state propagation based solely on qlen.

6. Broader Kernel Security Implications
- Hierarchical scheduler correctness depends on precise, unconditional state propagation; conditioning notifications on accounting deltas is brittle and can cause lifetime bugs. This fix reduces reliance on fragile backlog accounting and prevents cascaded desynchronization across parent levels. The approach underscores the need for idempotent notifications and may guide similar robustness improvements in other classful qdisc handlers and hierarchical subsystems.