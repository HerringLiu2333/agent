1. CVE Identifier
CVE-2025-38350

2. Vulnerability Type
Use-after-free due to incorrect lifecycle/notification logic in classful qdisc handling

3. Root Cause Summary
The pre-patch qdisc_tree_reduce_backlog() suppressed notifications to the parent qdisc when the child qdisc became empty under certain conditions (e.g., when n == 0 and len == 0, or when the child was already empty and not offloaded). This resulted in missed qlen_notify() calls, leaving parent classes in an inconsistent active/passive state. When a child qdisc was emptied (including during enqueue-triggered dequeue or deletion/reset), the parent might later re-activate a stale class pointer, leading to a use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
net/sched (packet scheduler API), specifically sch_api.c and classful qdisc parent-child notifications via qdisc_tree_reduce_backlog()

2) Pre-Patch Flaw:
In qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len), notification to the parent was gated by two checks:
- An early exit if (n == 0 && len == 0), skipping all processing.
- notify computed as "!sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)", which suppressed notifications when the child was empty but there was no decrement (n == 0) and the child wasn’t offloaded.
These conditions prevented qlen_notify() propagation when the child became empty without explicit backlog decrements, allowing the parent to retain stale class state.

3) Trigger Condition:
Situations where a child qdisc becomes empty unexpectedly, including:
- Classful qdiscs invoking a class’ dequeue handler during enqueue, causing immediate emptying.
- Qdisc deletion paths calling qdisc_reset()/qdisc_purge_queue(), which set qlen to 0 without necessarily producing (n,len) changes.
The provided reproducer (DRR parent, HFSC child with nested qdiscs, then class deletion and subsequent traffic) demonstrates the sequence that leads to missed notifications and UAF.

4) Impact Mechanism:
Without notifying the parent that the child’s qlen reached zero, the parent’s class remains perceived as active or is later re-activated despite the child being reset/deleted. Subsequent scheduling decisions dereference freed class structures, resulting in use-after-free of stale class pointers. This is exacerbated by qdiscs not expecting dequeue-on-enqueue behavior at that time and re-activating classes anyway.

5. Patch Analysis
1) Fix Approach:
Ensure notifications are always sent when the child qdisc becomes empty, irrespective of n/len changes or offload status. The fix makes qlen_notify() idempotent in expectation and removes conditions that previously suppressed notification.

2) Key Code Changes:
- Removed early return: “if (n == 0 && len == 0) return;” to avoid skipping empty-child processing.
- Removed offload gating and WARN_ON logic: eliminated qdisc_is_offloaded and the notify suppression based on “!n && !qdisc_is_offloaded”.
- Simplified notify condition to “notify = !sch->q.qlen;”, so parent is always notified when child’s qlen is zero.
- Comment added noting qlen_notify must be idempotent because it may be invoked multiple times.
These changes directly address the missed notification root cause.

3) Locking/Concurrency Impact:
RCU read-side protection (rcu_read_lock()) remains unchanged, and parent lookup still occurs under RCU. By removing conditional skips, the patch reduces the race window where parent state could diverge from child emptiness, preventing re-activation of freed classes. No new locks were introduced; correctness relies on idempotent qlen_notify handlers (as noted in the patch description), allowing safe repeated notifications under concurrent conditions.

6. Broader Kernel Security Implications
This change hardens the classful qdisc lifecycle management by ensuring parent awareness of child emptiness, preventing stale references and UAFs during complex enqueue/dequeue and deletion flows. It avoids relying on fragile backlog accounting heuristics that vary across qdisc implementations and offload states. The approach promotes consistent state transitions and reduces the risk of memory corruption in the networking stack, particularly in environments with nested qdiscs and dynamic class manipulation.