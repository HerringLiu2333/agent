1. Plan Summary
Detect pre-patch logic in qdisc_tree_reduce_backlog that suppresses parent notifications when a child qdisc becomes empty if no backlog counters change or the child isn’t offloaded, which can lead to stale class state and use-after-free.

2. Detection Steps
1) Step 1: Locate the function definition of qdisc_tree_reduce_backlog with parameters (struct Qdisc* sch, int n, int len). Signals: function name match and parameter types/names matching sch, n, len in net/sched/sch_api.c.

2) Step 2: Identify an early return that skips all processing when both counters are zero. Signals: an if-statement with condition (n == 0 && len == 0) directly followed by return;.

3) Step 3: Detect computation of an “offloaded” boolean derived from sch->flags. Signals: a local variable initialized from (sch->flags & TCQ_F_OFFLOADED).

4) Step 4: Find the boolean ‘notify’ assignment that ties child-emptiness to additional gating on “no decrement” and offload status. Signals: notify assigned as a conjunction/disjunction involving !sch->q.qlen and a condition referencing !n and the offloaded flag (and optionally wrapped in WARN_ON_ONCE).

5) Step 5: Confirm that qlen_notify is only invoked under the gated ‘notify’ condition. Signals: an if (notify && cops->qlen_notify) block containing cops->find(...) and cops->qlen_notify(...).

6) Step 6: Flag the pattern where child emptiness notification depends on “no update” counters (n == 0) or offload gating, rather than unconditionally on q->qlen == 0. Signals: the presence of !n and offload-dependent clauses in the notify assignment.

7) Step 7: Corroborate that the early return (Step 2) prevents any notification path, including qlen_notify, when n == 0 && len == 0. Signals: control-flow showing return executed before the loop and notify checks.

8) Step 8: Identify any WARN_ON_ONCE used in the notify logic that suppresses notification when !n and not offloaded. Signals: WARN_ON_ONCE call embedded in the notify expression.

9) Step 9: Report a finding if either the early-return pattern (Step 2) exists or the gated notify pattern (Steps 4–6, 8) exists. Signals: presence of any one of these suppressors should be sufficient to flag the potential missed notification.

10) Step 10: Optionally, strengthen confidence by confirming the function is responsible for parent notification and backlog updates. Signals: presence of rcu_read_lock, while ((parentid = sch->parent)) loop, decrementing sch->q.qlen and sch->qstats.backlog, and calling __qdisc_qstats_drop.

3. Limitations & Assumptions
- The plan relies on naming and structure as in net/sched/sch_api.c; deviations in other kernels or backports may require adapting identifiers.
- It does not prove a runtime UAF; it flags logic that can miss qlen_notify when child qdisc becomes empty.
- We assume qlen_notify should be called whenever sch->q.qlen == 0; the checker cannot validate idempotency or broader subsystem expectations beyond the provided materials.