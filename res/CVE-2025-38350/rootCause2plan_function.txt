1. Plan Summary
Detect pre-patch patterns where parent notification (qlen_notify) in classful qdisc hierarchy is suppressed by zero-delta checks or offload gating, causing missed empty-state propagation and potential use-after-free.

2. Detection Steps
1) Step 1: Identify candidate functions that traverse a qdisc parent chain under RCU and potentially notify parents. Signals: loop over sch->parent within rcu_read_lock()/rcu_read_unlock(), calls to qdisc_lookup_rcu and use of TC_H_MAJ; maps to net/sched hierarchy per [FUNCTION_CONTENT]. FP mitigation: restrict to functions that also reference cops->qlen_notify via sch->ops->cl_ops.

2) Step 2: Find an early return conditioned on zero packet/length deltas that precedes the parent traversal. Signals: a guard like “if (n == 0 && len == 0) return;” at function start; this matches the flawed gating in [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: require that the same function later adjusts backlog (sch->q.qlen -= n; qstats.backlog -= len) to confirm it is a backlog reduction path.

3) Step 3: Detect notification conditions that combine child empty state with additional gating tied to deltas/offload status. Signals: notify computed as conjunction of “!sch->q.qlen” with terms involving n/len (e.g., !n) and TCQ_F_OFFLOADED or WARN_ON_ONCE; matches [PATCH_DIFF] and [FUNCTION_CONTENT]. FP mitigation: only flag if such notify condition directly controls a cops->qlen_notify call in the same loop.

4) Step 4: Identify use of offload flags influencing notification. Signals: local variable or expression like “qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED” used in notify gating; aligns with [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]. FP mitigation: ensure offload gating is part of the condition that suppresses notification when n/len are zero, not merely informational.

5) Step 5: Confirm presence of parent notification call sites. Signals: sequence “cops = sch->ops->cl_ops; cl = cops->find(sch, parentid); cops->qlen_notify(sch, cl);” under the notify predicate; derived from [FUNCTION_CONTENT] and [PATCH_DIFF]. FP mitigation: ensure qlen_notify is the target callback and that the notify predicate controls its execution.

6) Step 6: Flag the exact risk pattern: early return on zero deltas combined with notify condition that can be false when sch->q.qlen == 0 but n/len == 0 and qdisc not offloaded. Signals: both Step 2 and Step 3 patterns present in the same function; maps directly to the root cause described in [ROOTCAUSE_ANALYSIS]. FP mitigation: require both components co-exist to avoid flagging functions lacking either.

7) Step 7: Check that the function is part of net/sched scheduler code and manipulates backlog counters. Signals: references to sch->qstats.backlog, __qdisc_qstats_drop, and comments or names matching qdisc_tree_reduce_backlog; reflects [FUNCTION_CONTENT] and [PATCH_DIFF]. FP mitigation: exclude functions that do not adjust qdisc backlog or are outside qdisc parent traversal.

8) Step 8: Detect WARN_ON_ONCE use within notify gating that depends on !n (or zero-delta). Signals: WARN_ON_ONCE condition with !n and !qdisc_is_offloaded influencing notify; corresponds to [FUNCTION_CONTENT]. FP mitigation: only report if WARN_ON_ONCE is coupled to suppression of qlen_notify.

9) Step 9: Verify that sch->flags & TCQ_F_NOPARENT and TC_H_ROOT checks exist, indicating hierarchical traversal context. Signals: presence of these breaks inside the loop; matches [FUNCTION_CONTENT]. FP mitigation: avoid flagging unrelated functions that do not manage parent-child qdisc relationships.

10) Step 10: Provide remediation hint by contrasting with fixed logic. Signals: absence of early return on (n == 0 && len == 0) and notify simplified to check only “!sch->q.qlen”; based on [PATCH_DIFF]. FP mitigation: classify as non-issue if the function uses the simplified notify and no zero-delta early return.

3. Target Elements
- Functions that traverse qdisc parent hierarchy (e.g., containing sch->parent loop under RCU).
- Condition checks guarding early return on zero n/len.
- Notify predicate expressions involving sch->q.qlen, n/len, TCQ_F_OFFLOADED, WARN_ON_ONCE.
- Calls to cops->qlen_notify and associated cops->find.
- Backlog adjustments: sch->q.qlen -= n; sch->qstats.backlog -= len; __qdisc_qstats_drop().
- Flag checks: sch->flags & TCQ_F_NOPARENT, TC_H_ROOT.

4. Dataflow / Taint Considerations
- Track control dependence from the zero-delta early return to the presence/absence of qlen_notify execution in the parent traversal loop.
- Track predicate dataflow from variables n, len, qdisc_is_offloaded, and sch->q.qlen into the notify condition controlling qlen_notify calls.
- Follow the loop over sch->parent to ensure the notify predicate is evaluated per parent, confirming suppression can propagate up the hierarchy.

5. Validation & Test Cases
- Positive: Pre-patch qdisc_tree_reduce_backlog with “if (n == 0 && len == 0) return;” and “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);” leading to conditional cops->qlen_notify; expect a detection.
- Negative: Post-patch qdisc_tree_reduce_backlog where the early return is removed and “notify = !sch->q.qlen;” is used; expect no detection.
- Negative: A function that adjusts backlog but does not traverse sch->parent or call cops->qlen_notify; expect no detection.
- Test harness notes: Run the checker on net/sched codebase or a minimal mock containing the pre- and post-patch variants; validate that only the pre-patch variant is flagged.

6. Estimated Effort & Priority
High: The pattern is localized but critical (use-after-free risk per [ROOTCAUSE_ANALYSIS]) and requires precise control-predicate analysis.

7. Likely False-Positive Sources & Mitigations
- Functions with zero-delta early returns that do not manage parent notifications; mitigate by requiring presence of cops->qlen_notify and parent traversal.
- Offload flag checks used for unrelated logic; mitigate by ensuring they appear in the notify predicate that guards qlen_notify.
- Similar code in non-qdisc subsystems; mitigate by requiring qdisc-specific APIs (qdisc_lookup_rcu, TC_H_MAJ, sch->qstats).

8. Limitations & Assumptions
- Assumes function/variable names (n, len, qdisc_is_offloaded, sch->q.qlen) are identifiable; variations may reduce coverage.
- Cannot infer dynamic events like qdisc_reset()/qdisc_purge_queue() presence; relies on structural suppression patterns per [ROOTCAUSE_ANALYSIS].
- Scope limited to patterns evidenced in qdisc_tree_reduce_backlog; other subsystems with analogous issues may not be detected without similar structural cues.