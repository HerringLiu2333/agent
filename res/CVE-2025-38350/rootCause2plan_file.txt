1. Plan Summary
Detect pre-patch logic in classful qdisc code that suppresses qlen_notify() when a child qdisc becomes empty, leading to parent classes retaining stale state and potential use-after-free.

2. Detection Steps
1) Step 1: Locate functions that propagate backlog changes to parent qdiscs. Signals: functions in net/sched addressing parent-child relations and taking parameters (struct Qdisc *sch, int n, int len), notably qdisc_tree_reduce_backlog (from [FILE_CONTENT]). FP mitigation: restrict to sch_api.c and functions that reference sch->parent and cops->qlen_notify.

2) Step 2: Identify early-return checks that skip processing when no explicit decrement is reported. Signals: a conditional "if (n == 0 && len == 0) return;" before any parent notification logic (from [FILE_CONTENT]). Why: per [ROOTCAUSE_ANALYSIS], this blocks notifications when a child becomes empty via reset/purge or dequeue-on-enqueue. FP mitigation: only flag if the function later references sch->q.qlen and attempts to notify the parent.

3) Step 3: Detect computation of a notification guard that depends on child emptiness plus additional gating based on n and offload state. Signals: a boolean like "notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);" or equivalent combining !sch->q.qlen with checks on n and TCQ_F_OFFLOADED (from [FILE_CONTENT]). Why: per [ROOTCAUSE_ANALYSIS], this suppresses qlen_notify when the child is empty but there’s no decrement or offload. FP mitigation: require that notify directly guards a cops->qlen_notify(sch, cl) call.

4) Step 4: Confirm that qlen_notify() is only invoked conditionally via the gated notify variable. Signals: code pattern "if (notify && cops->qlen_notify) { cl = cops->find(...); cops->qlen_notify(...); }" within the parent-walk loop (from [FILE_CONTENT]). Why: missed notification is the root cause; a gated call means parent may not be informed when qlen becomes 0. FP mitigation: ensure there are no alternative unconditional calls to qlen_notify in the same function.

5) Step 5: Tie the gating to backlog accounting reliance that can be inconsistent with actual emptiness. Signals: presence of adjustments "sch->q.qlen -= n;" and "sch->qstats.backlog -= len;" after the notify block (from [FILE_CONTENT]). Why: per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS], relying on n/len rather than actual qlen==0 causes stale parent state. FP mitigation: only flag when the qlen==0 condition is combined with checks on n/offload.

6) Step 6: Detect usage of a qdisc_is_offloaded flag to allow notification in offloaded cases but suppress it otherwise. Signals: local variable initialized from "sch->flags & TCQ_F_OFFLOADED" and used in notify gating (from [FILE_CONTENT]). Why: per [ROOTCAUSE_ANALYSIS], offload gating contributed to skipped notifications for non-offloaded children. FP mitigation: require that this offload-dependent gating appears together with a check on n in the notify expression.

7) Step 7: Highlight the parent traversal context to ensure we are analyzing the correct notification pathway. Signals: a while-loop walking "while ((parentid = sch->parent)) { ... cops = sch->ops->cl_ops; ... qlen_notify(...); }" (from [FILE_CONTENT]). Why: per [PATCH_DESCRIPTION], missed notifications must propagate up the parent chain. FP mitigation: restrict matches to code inside the parent-walk loop.

8) Step 8: Mark as vulnerable when both the early-return-on-(n==0 && len==0) and notify gating suppressing empty-child notifications are present. Signals: coexistence of Step 2 and Step 3 patterns in the same function (from [FILE_CONTENT]). Why: per [ROOTCAUSE_ANALYSIS], this combination is the precise pre-patch flaw leading to UAF. FP mitigation: require both signals to reduce noise.

9) Step 9: Treat as fixed when notify is simplified to solely depend on emptiness and early return is removed. Signals: "notify = !sch->q.qlen;" and absence of "if (n == 0 && len == 0) return;" (from [PATCH_DIFF]). Why: per [PATCH_DESCRIPTION], the fix ensures idempotent, unconditional notification when qlen reaches zero. FP mitigation: use this as a negative pattern to validate suppression of alerts in patched code.

10) Step 10: Optionally flag similar constructs in other functions that call qlen_notify() with conditions tied to n/len or offload state. Signals: any function computing a condition for calling cops->qlen_notify that conjoins qlen==0 with n or offload checks. Why: per [ROOTCAUSE_ANALYSIS], “recurring pattern” of backlog-accounting-driven suppression suggests generalization. FP mitigation: restrict scope to net/sched, require presence of sch->parent traversal or class ops context.

3. Target Elements
- Function definitions in net/sched/sch_api.c that manipulate parent-child qdisc state (e.g., qdisc_tree_reduce_backlog).
- Conditional statements guarding early returns and parent notifications.
- Boolean computations of notify involving sch->q.qlen, n, len, and TCQ_F_OFFLOADED-derived flags.
- Call sites invoking cops->qlen_notify and cops->find within parent traversal.
- Statements adjusting sch->q.qlen and qstats.backlog after notification.

4. Dataflow / Taint Considerations
- Track flow from sch->q.qlen into a boolean notify that gates qlen_notify calls.
- Track influence of parameters n and len (and offload flag derived from sch->flags) on the notify condition.
- Ensure that early-return on (n==0 && len==0) precedes any opportunity to notify when qlen==0.

5. Validation & Test Cases
- Positive: Pre-patch qdisc_tree_reduce_backlog containing "if (n == 0 && len == 0) return;" and "notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);" leading to conditional qlen_notify (from [FILE_CONTENT]).
- Negative: Patched code where the early return is removed and "notify = !sch->q.qlen;" is used unconditionally (from [PATCH_DIFF]).
- Test harness notes: Build a CodeQL DB of the kernel tree including sch_api.c; run checker and verify one alert on pre-patch and no alert on patched version.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Functions outside net/sched that use similar names or patterns but don’t manage classful qdisc notifications; mitigate by scoping to sch_api.c and presence of cops->qlen_notify.
- Benign checks involving offload/n that don’t gate qlen_notify; mitigate by requiring conjunction with !sch->q.qlen and parent traversal context.
- Codebases where qlen_notify is invoked through alternative unconditional paths; mitigate by ensuring no alternative call bypasses the gated condition in the same function.

8. Limitations & Assumptions
- The checker infers risk from structural patterns; it cannot prove runtime UAF without dynamic context (as noted in [ROOTCAUSE_ANALYSIS]).
- Assumes that missed qlen_notify on qlen==0 is a flaw in this subsystem based on [PATCH_DESCRIPTION] and [PATCH_DIFF]; may not generalize beyond net/sched.
- Does not model idempotency of qlen_notify handlers or lifecycles outside sch_api.c; relies on patterns observed in the provided code.