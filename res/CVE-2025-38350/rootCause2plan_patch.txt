1. Plan Summary
Detect functions that conditionally notify a parent when a child queue becomes empty but suppress the notification based on unrelated backlog/offload conditions or early-return when update counters are zero, leading to stale state and potential use-after-free.

2. Detection Steps
1) Step 1: Identify candidate functions that walk parent relationships and perform queue-length notifications — signals: presence of struct Qdisc variables, traversal via sch->parent, and a call to a class-ops notification like cops->qlen_notify — FP mitigation: restrict to code that accesses sch->q.qlen and invokes cops->find and cops->qlen_notify as in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

2) Step 2: Flag early returns that bypass notification when update counters are zero — signals: function parameters resembling backlog deltas (e.g., n, len) and an early return conditioned on both being zero — FP mitigation: require that the same function later reads sch->q.qlen and/or calls cops->qlen_notify, mapping to the pre-patch flaw “if (n == 0 && len == 0) return” in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

3) Step 3: Analyze the condition guarding qlen_notify — signals: a boolean (e.g., notify) or direct conditional that combines emptiness check (!sch->q.qlen) with other conjuncts referencing counters (n/len/“drops”) or flags (TCQ_F_OFFLOADED) — FP mitigation: report only if emptiness is conjuncted with at least one additional term beyond !sch->q.qlen, reflecting the flawed gating in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

4) Step 4: Detect gating by offload state — signals: expression using sch->flags & TCQ_F_OFFLOADED (or derived variable like qdisc_is_offloaded) used to decide whether to notify when the child is empty — FP mitigation: require co-occurrence with a qlen-based emptiness check and a qlen_notify call, matching the removed offload-specific gating in [PATCH_DIFF].

5) Step 5: Detect gating by counter zeros on emptiness — signals: condition that includes terms like !n or n == 0 (or len variants) combined with !sch->q.qlen or equivalent emptiness check to suppress notification — FP mitigation: ensure those counter terms are not directly testing sch->q.qlen or a parent’s qlen; this aligns with the “!WARN_ON_ONCE(!n …)” part criticized in [ROOTCAUSE_ANALYSIS].

6) Step 6: Recognize in-loop parent traversal with conditional notification — signals: a loop that reassigns sch via qdisc_lookup_rcu or similar while carrying a notify decision that may be false if unrelated conditions fail — FP mitigation: require the loop to continue until sch->parent is false or TCQ_F_NOPARENT is set, as seen in [PATCH_DIFF], to focus on parent-notification paths.

7) Step 7: Highlight use of WARN macros in notification conditions — signals: WARN_ON_ONCE (or similar) embedded in the notify predicate, especially alongside counter/offload checks — FP mitigation: only flag when WARN usage participates in gating qlen_notify, reflecting the removed WARN_ON_ONCE gating in [PATCH_DIFF] and the flawed logic in [ROOTCAUSE_ANALYSIS].

8) Step 8: Correlate with deletion/reset/purge contexts indirectly — signals: comments or nearby calls referencing qdisc_reset/qdisc_purge_queue or follow-up qlen==0 semantics are unlikely to be present; instead, assert risk when notification can be skipped despite qlen==0 — FP mitigation: restrict alerts to functions that read sch->q.qlen and have any path that can exit without attempting qlen_notify while emptiness is required for correctness per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].

9) Step 9: Prefer findings where notification condition is stricter than plain emptiness — signals: the minimal safe condition post-patch is notify iff !sch->q.qlen; flag cases where notify implies additional unrelated predicates — FP mitigation: suppress if the only additional predicate ensures idempotency or null-check of ops pointers, which is benign per [PATCH_DESCRIPTION] mentioning idempotent handlers.

10) Step 10: Rank findings higher when both early return on counters and extra gating exist — signals: combination of Step 2 and Steps 3–5 in the same function — FP mitigation: prioritize as most similar to the exact pre-patch pattern in [PATCH_DIFF] and impact discussed in [ROOTCAUSE_ANALYSIS].

3. Target Elements
- Functions that:
  - Traverse parent relationships using sch->parent and qdisc_lookup_rcu.
  - Access struct Qdisc fields, particularly sch->q.qlen and sch->flags.
  - Call cops->find and cops->qlen_notify via ops->cl_ops.
- Conditional statements guarding calls to qlen_notify.
- Early-return statements based on parameters named like n and len (or analogous backlog counters).
- Expressions referencing TCQ_F_OFFLOADED and WARN_ON_ONCE macros in notify logic.
- Loops handling qdisc parent traversal and notification.

4. Dataflow / Taint Considerations
- Track the variable representing the current Qdisc (sch) through the function and loop iterations.
- Track the computation of the notify predicate (or equivalent boolean) from its inputs: sch->q.qlen, counters (n/len), and flag checks (TCQ_F_OFFLOADED).
- Track control flow from notify predicate to the call site of cops->qlen_notify to determine gating.
- Track early returns conditioned on counter values that occur before any potential qlen_notify call.

5. Validation & Test Cases
- Positive: A function like pre-patch qdisc_tree_reduce_backlog with “if (n == 0 && len == 0) return;” and notify computed as “!sch->q.qlen && … (!n … offloaded … WARN_ON_ONCE …)”; expect a high-severity alert (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).
- Negative: Post-patch qdisc_tree_reduce_backlog where the early return is removed and notify is exactly “!sch->q.qlen”; expect no alert (based on [PATCH_DIFF]).
- Positive: A similar parent-notification function that gates emptiness with any backlog delta or offload flag; expect an alert (generalization per [ROOTCAUSE_ANALYSIS]).
- Negative: A function that calls qlen_notify whenever !sch->q.qlen, possibly multiple times, with only null-checks on ops pointers; expect no alert (per idempotent-safe behavior in [PATCH_DESCRIPTION]).
- Test harness notes: Run against net/sched sources; ensure type resolution finds struct Qdisc, ops->cl_ops, and field accesses; validate ranking increases when both early return and extra gating are present.

6. Estimated Effort & Priority
High — precise control/AST analysis plus boolean-condition inspection is needed, and the impact is a use-after-free in kernel networking (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Non-qdisc modules using similarly named fields or functions; mitigate by requiring struct Qdisc types and cops->qlen_notify pattern.
- Legitimate additional predicates that are strictly safety checks (e.g., null ops) rather than gating emptiness; mitigate by excluding null-check-only conjuncts.
- Offload-specific code paths where gating is semantically required; mitigate by limiting to functions that traverse sch->parent and are intended to normalize parent state (as in [PATCH_DIFF]).

8. Limitations & Assumptions
- Assumes availability of kernel type information to recognize struct Qdisc and ops->cl_ops relationships; not provided here but required for accurate matching.
- Does not prove runtime paths where qlen becomes zero without counter updates; it flags structural patterns shown unsafe per [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS].
- Cannot automatically verify idempotency of qlen_notify handlers; the checker assumes multiple notifications are acceptable as per [PATCH_DESCRIPTION].
- Naming of counters (n, len) may vary; detection relies on their use in early returns or notify conditions alongside qlen and qlen_notify.