1. Plan Summary
Detect premature freeing of shared PCIe link-state objects in device-removal paths when the removal is not for function 0 (link->downstream), which can leave subordinate links with dangling parent pointers, as in CVE-2024-58093.

2. Detection Steps
1) Step 1: Identify candidate device-removal handlers that free a PCIe link state — look for functions that acquire pci_bus_sem/aspm_lock and operate on parent->link_state, e.g., pcie_aspm_exit_link_state (based on FILE_CONTENT and ROOTCAUSE_ANALYSIS). Reduce FPs by restricting to functions that call free_link_state and list_del on link->sibling.

2) Step 2: Determine the freed object is the upstream port link state — look for link = parent->link_state, then free_link_state(link) (based on FILE_CONTENT). This maps to the root cause where the upstream link state may be parent_link of subordinate ones; mitigate FPs by requiring link derive from pdev->bus->self->link_state.

3) Step 3: Check for a guard that ensures free occurs only when removing function 0 — require a control predicate equivalent to “pdev == link->downstream” before free, matching the patch (based on PATCH_DIFF comments and guard). Flag when free_link_state(link) can execute even if pdev != link->downstream; mitigate FPs by accepting alternative explicit checks of function 0 (e.g., comparing to link->downstream or PCI_FUNC==0) if present.

4) Step 4: Confirm the context is a multi-function upstream device — look for presence of link->downstream semantics and comments/logic indicating multi-function handling (e.g., “switch upstream port,” “function 0,” PCIe r6.0 sec 7.5.3.7 references) in the same function/file (based on PATCH_DESCRIPTION and FILE_CONTENT). Reduce FPs by requiring that link->downstream was set via pci_function_0 earlier in the file and is non-null.

5) Step 5: Detect subsequent operations that imply subordinate links remain after free — look for uses of root and parent_link variables and calls such as pcie_update_aspm_capable(root) or pcie_config_aspm_path(parent_link) after freeing link (based on FILE_CONTENT). This maps to the root cause of dangling parent pointers; reduce FPs by requiring at least one such call post-free.

6) Step 6: Identify unconditional ASPM disable/config before free that affects all functions — locate pcie_config_aspm_link(link, 0) immediately preceding free_link_state(link) (based on FILE_CONTENT). This supports the “disable on any function removal” behavior in ROOTCAUSE_ANALYSIS; reduce FPs by ensuring this path exists without function-0 gating.

7) Step 7: Verify the function mentions or enforces “programming same ASPM Control for all functions” without distinguishing function 0 — detect comments or logic indicating non-0 function removal still triggers disabling and free (based on FILE_CONTENT pre-patch comment). Use this as a heuristic to further narrow to the problematic pattern.

8) Step 8: Ensure the vulnerable free is reachable regardless of which function is removed — analyze control flow to ensure there is no early return/goto that skips free when pdev != link->downstream (absence of the guard added in PATCH_DIFF). Reduce FPs by checking that free_link_state is not dominated by a condition comparing pdev to link->downstream.

9) Step 9: Flag if the function uses parent_link and root from link prior to free but frees link regardless of which function is removed — this demonstrates a chain context where link serves as parent_link for subordinate links (based on FILE_CONTENT). Reduce FPs by requiring parent_link or root variables to be set from link and used after free.

10) Step 10: Optional robustness check — confirm that alloc_pcie_link_state establishes link->parent and manages link_list (based on FILE_CONTENT) so the freed object is shared across a chain. Reduce FPs by requiring presence of alloc_pcie_link_state and link_list usage in the same compilation unit.

3. Target Elements
- Functions: device removal/exit handlers (e.g., pcie_aspm_exit_link_state).
- Call sites: free_link_state(link), list_del(&link->sibling), pcie_config_aspm_link(link, 0).
- Condition checks: guards comparing pdev to link->downstream or equivalent function-0 checks.
- Lock boundaries: down_read(&pci_bus_sem), mutex_lock(&aspm_lock) around link free and config.
- Structure fields: pcie_link_state.link_state, .downstream, .parent, .root, .sibling.
- Post-free usages: calls using parent_link/root and path traversal (pcie_update_aspm_capable, pcie_config_aspm_path).

4. Dataflow / Taint Considerations
- Track the flow: pdev -> parent = pdev->bus->self -> link = parent->link_state -> free_link_state(link).
- Control-flow guard taint: ensure free_link_state(link) is gated by a check that pdev equals link->downstream; flag absence.
- Relationship flow: link->downstream set via pci_function_0; parent_link = link->parent; root = link->root; detect uses after free indicating chain references persist.

5. Validation & Test Cases
- Positive: Pre-patch pcie_aspm_exit_link_state containing unconditional pcie_config_aspm_link(link, 0); list_del; free_link_state(link) with no “if (pdev != link->downstream) goto out;” guard; expect a detection.
- Negative: Patched version where free_link_state(link) executes only when pdev == link->downstream and otherwise branches to “out:” (based on PATCH_DIFF); expect no detection.
- Test harness notes: Compile the driver file and run the checker over drivers/pci/pcie/aspm.c; ensure the checker reports only the pre-patch hunk and is silent after applying the guard.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Alternative correct guards (e.g., checking PCI_FUNC(child->devfn) == 0 instead of pointer equality): accept either form as valid to avoid FPs.
- Functions that free link state only when no subordinate devices exist: mitigate by requiring link->downstream non-null and presence of parent/root link-chain usage post-free.
- Contexts outside device removal paths: mitigate by requiring lock patterns and presence of parent->link_state usage.

8. Limitations & Assumptions
- The checker assumes link->downstream denotes function 0 (based on FILE_CONTENT comments) and that freeing the upstream link state early is unsafe; dynamic device topology is not derivable statically.
- It cannot determine runtime hot-unplug order (reverse removal via pciehp) and whether subordinate links exist at the moment of free; it relies on structural cues (parent/root usage and link_list membership).
- It assumes this pattern is within the PCIe ASPM subsystem and similar multi-function upstream port semantics apply; applicability to other subsystems with different invariants is not guaranteed.