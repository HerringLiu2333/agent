1. Plan Summary
Detect premature teardown of shared PCIe ASPM link state freed without verifying that the removed device is function 0 (link->downstream), which can leave subordinate links with dangling parent_link references (use-after-free).

2. Detection Steps
1) Step 1: Objective: Identify ASPM link teardown routines handling device removal. Signals: Functions in drivers/pci/pcie/aspm.c that accept a struct pci_dev* parameter and access pdev->bus->self and parent->link_state (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Restrict to functions that also acquire aspm_lock and pci_bus_sem to focus on ASPM link-state management.

2) Step 2: Objective: Locate the link-state teardown sequence. Signals: Presence of the sequence pcie_config_aspm_link(link, 0), list_del(&link->sibling), and free_link_state(link) in order (from FUNCTION_CONTENT). FP mitigation: Require all three calls to occur in the same function to avoid generic frees.

3) Step 3: Objective: Detect unconditional freeing of the parent link state. Signals: free_link_state(link) reachable without a preceding conditional that checks pdev against link->downstream or otherwise ties teardown to function 0 (from PATCH_DIFF showing added “if (pdev != link->downstream) goto out;” and ROOTCAUSE_ANALYSIS noting lack of such guard previously). FP mitigation: Ensure no dominance or gating by a comparison involving link->downstream on all paths to free.

4) Step 4: Objective: Confirm hierarchical linkage implying shared parent link. Signals: Assignment parent_link = link->parent followed by later use (e.g., pcie_config_aspm_path(parent_link)) after the free path exists (FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Require at least one use of parent_link to strengthen that the freed link is a parent in a hierarchy.

5) Step 5: Objective: Identify multi-function device context cues. Signals: Access or mention of link->downstream as the canonical function 0 pointer (PATCH_DIFF comment and ROOTCAUSE_ANALYSIS semantics), even if not compared in pre-patch code. FP mitigation: Prefer cases where the code has access to link->downstream in scope (e.g., link variable of type with downstream field) to align with the CVE class.

6) Step 6: Objective: Verify that teardown applies across all functions (i.e., not scoped to function 0). Signals: Prior call pcie_config_aspm_link(link, 0) that disables ASPM broadly for all functions before free (FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation: Combine this with Step 3 to avoid flagging frees already guarded by function-identity checks.

7) Step 7: Objective: Exclude fixed implementations. Signals: Presence of an early exit or guard such as “if (pdev != link->downstream) … goto out/return” before free_link_state(link) (PATCH_DIFF). FP mitigation: Do not report when such a guard ensures freeing only when pdev == link->downstream.

8) Step 8: Objective: Confirm teardown is not conditioned on subordinate-link absence. Signals: Absence of any checks that subordinate links (children) are gone before freeing the parent link (ROOTCAUSE_ANALYSIS notes premature teardown and dangling parent_link). FP mitigation: Require both the lack of function-0 guard and no checks for subordinate links to reduce FPs where teardown is otherwise safe.

3. Target Elements
- Function definitions that manage ASPM link state during device removal (e.g., pcie_aspm_exit_link_state).
- Calls to free_link_state on a link object and adjacent teardown calls (pcie_config_aspm_link, list_del).
- Field accesses: pdev->bus->self, parent->link_state, link->parent, link->downstream.
- Condition checks comparing pdev and link->downstream, or early exits that gate freeing.
- Lock boundaries: down_read(&pci_bus_sem), mutex_lock(&aspm_lock)/unlock.

4. Dataflow / Taint Considerations
- Track dataflow from function parameter pdev to parent via pdev->bus->self, then to link via parent->link_state.
- Track control-flow to free_link_state(link), and whether it is gated by a predicate tying pdev to link->downstream (function 0).
- Confirm that parent_link = link->parent is established and used later, indicating the freed object is a shared parent referenced by subordinates.

5. Validation & Test Cases
- Positive: Pre-patch pcie_aspm_exit_link_state (FUNCTION_CONTENT) where free_link_state(link) is unconditional and there is no check comparing pdev to link->downstream; expect a report.
- Negative: Post-patch version (PATCH_DIFF) with “if (pdev != link->downstream) goto out;” guarding the free; expect no report.
- Test harness notes: Run on drivers/pci/pcie/aspm.c; ensure CFG analysis captures the guard presence/absence and sequence of teardown calls.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Functions that free non-parent/leaf links where no subordinates exist; mitigate by requiring parent_link assignment and use.
- Routines where teardown is safe because all subordinate links are already removed; mitigate by also checking absence of any subordinate-presence checks.
- Code paths that include implicit guards not expressed as pdev vs link->downstream comparisons; mitigate by conservative reporting only when free is clearly unconditional.

8. Limitations & Assumptions
- Assumes link->downstream denotes function 0 (based on PATCH_DIFF and ROOTCAUSE_ANALYSIS); the checker cannot infer function identity beyond this pattern.
- Cannot determine runtime removal order (pciehp reverse order) or actual existence of subordinate links; analysis relies on structural cues.
- The plan is tailored to the ASPM subsystem; applicability to other subsystems with similar lifetime issues may require adapted heuristics.