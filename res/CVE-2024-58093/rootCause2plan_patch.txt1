1. Plan Summary
Detect premature teardown of a shared ASPM link state when removing a non-0 PCIe function by freeing the parent link without first ensuring the removed device is the designated downstream function (function 0).

2. Detection Steps
1) Step 1: Identify ASPM link teardown sites — find functions that call free_link_state(x) and also perform typical teardown actions like pcie_config_aspm_link(x, ...) and list_del(&x->sibling).
2) Step 2: Establish the link object — within those functions, confirm the freed variable is a link-like structure via accesses to fields named downstream and/or parent (e.g., link->downstream, link->parent).
3) Step 3: Confirm device-removal context — verify the function takes a pci_dev* parameter (e.g., pdev) and that control is under removal/unplug semantics (e.g., function name or nearby calls indicate “exit” or “ASPM exit” behavior).
4) Step 4: Check for proper guard — perform control-flow/condition analysis to see if the free_link_state(link) call is dominated by a condition that ensures pdev equals link->downstream; absence of such a guard indicates potential early free.
5) Step 5: Confirm that premature free is reachable — ensure there exists a path to free_link_state(link) where pdev != link->downstream (e.g., no equality check or an explicit inequality path leads to the free).
6) Step 6: Corroborate hierarchical sharing — within the same function, check for reading link->parent into a local (e.g., parent_link = link->parent) and later usage (e.g., pcie_config_aspm_path(parent_link)), which signals that the freed link is part of a parent/child hierarchy and could be referenced by subordinate links.
7) Step 7: Prioritize strong matches — rank or filter findings higher when all of the following co-occur: link->downstream is read in the function, no equality guard with pdev exists before the free, and the teardown sequence includes pcie_config_aspm_link(link, 0); list_del(&link->sibling); free_link_state(link).

3. Limitations & Assumptions
- Assumes kernel-specific naming (free_link_state, link->downstream, link->parent, pcie_config_aspm_link, pcie_config_aspm_path) is present; the checker may miss variants with different names.
- The checker cannot prove at compile time that subordinate links still exist; it flags the freeing site based on missing guards and structural signals, not runtime state.
- Other valid guards equivalent to “pdev is function 0” (if implemented differently) are not modeled beyond checking pdev == link->downstream.
- Context of hot-unplug removal order and dynamic timing is not statically inferable; the checker focuses on the lifetime condition implied by the guard.