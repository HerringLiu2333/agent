1. Plan Summary
Detect unguarded teardown of shared ASPM parent link state during removal of non-0 PCIe functions, which can leave subordinate links’ parent_link dangling (pre-patch behavior of pcie_aspm_exit_link_state).

2. Detection Steps
1) Step 1: Objective—Locate candidate teardown routines for ASPM link state; Signals—functions in PCIe/ASPM that accept a pci_dev* parameter and invoke free_link_state on a variable commonly named link, with surrounding calls like pcie_config_aspm_link and list_del; FP mitigation—limit to drivers/pci/pcie/aspm.c and to functions mentioning aspm, pci, or link in identifiers/comments based on the [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF].

2) Step 2: Objective—Confirm the freed object is a “parent link” shared by subordinates; Signals—within the same function, presence of a variable assigned from link->parent (e.g., parent_link) and/or dereference of link->parent, indicating hierarchy; FP mitigation—require that both link->parent and at least one operation referencing parent_link appear, aligning with [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

3) Step 3: Objective—Detect whether teardown can occur on removal of non-0 functions; Signals—call to free_link_state(link) reachable on a path that does not require pdev == link->downstream (i.e., no dominating equality guard), as the fix added if (pdev != link->downstream) goto out; FP mitigation—perform control-flow dominance analysis to ensure no equivalent guard exists before free_link_state, per [PATCH_DIFF].

4) Step 4: Objective—Corroborate that link->downstream is the special “function 0” anchor; Signals—field access link->downstream is referenced in the function (in any comparison, assignment, or comment), or the function comments describe function 0 semantics as in [PATCH_DIFF] and [PATCH_DESCRIPTION]; FP mitigation—require presence of link->downstream usage or matching comment text to raise confidence.

5) Step 5: Objective—Assess shared-use risk from subordinate links; Signals—use of link sibling/child relationships (e.g., list_del(&link->sibling)) and subsequent operations using parent_link (e.g., pcie_config_aspm_path(parent_link)), suggesting subordinates may still exist; FP mitigation—require both a sibling list operation and a later use of parent_link in any function to indicate a shared hierarchy, based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS].

6) Step 6: Objective—Ensure the context is device removal where order can be non-0 first; Signals—function name or comments indicate “exit,” “remove,” or “hot-unplug” behavior (e.g., pcie_aspm_exit_link_state), or comments referencing multi-function devices/switch upstream port; FP mitigation—restrict to routines with removal semantics or comments matching those in [PATCH_DESCRIPTION].

7) Step 7: Objective—Flag the early-free pattern; Signals—When Steps 1–6 match and free_link_state(link) is reachable without a guard tying free to pdev == link->downstream, report a warning describing potential UAF due to dangling parent_link; FP mitigation—suppress if a guard exists that ensures free only when pdev equals link->downstream.

8) Step 8: Objective—Prioritize findings with stronger evidence of multi-function switch context; Signals—comments or identifiers mentioning “MFD,” “function 0,” “switch upstream,” or “downstream,” as cited in [PATCH_DESCRIPTION]; FP mitigation—elevate severity only when at least one of these terms is present; otherwise, keep as lower confidence.

9) Step 9: Objective—Check proper unlock path is preserved when free is skipped; Signals—presence of a common out label or uniform unlock tail (mutex_unlock, up_read) reachable when skipping free, as in [PATCH_DIFF]; FP mitigation—non-blocking check to avoid false positives for missing guard if teardown bypass is impossible due to missing unlock path.

10) Step 10: Objective—De-duplicate reports within the file; Signals—if multiple paths reach the same free_link_state without the guard, produce a single consolidated report per function; FP mitigation—summarize per teardown site.

3. Target Elements
- Functions handling ASPM link exit/teardown (e.g., pcie_aspm_exit_link_state).
- Calls to free_link_state and related teardown calls (pcie_config_aspm_link, list_del).
- Field accesses on the link object: parent, downstream, sibling.
- Conditional checks comparing pdev to link->downstream.
- Lock/unlock sequences (aspm_lock, pci_bus_sem) to validate correct exit paths.

4. Dataflow / Taint Considerations
- Track the link variable through the function to its free_site (free_link_state(link)).
- Track control predicates involving pdev and link->downstream to determine if a guard dominates the free.
- Track hierarchical relations via link->parent and uses of parent_link to evidence sharing.
- Track list membership updates (list_del(&link->sibling)) as signals of shared state transition.

5. Validation & Test Cases
- Positive: Pre-patch pcie_aspm_exit_link_state where free_link_state(link) is executed for any pdev, with link->parent used and link->downstream present but not gating the free (matches [ROOTCAUSE_ANALYSIS] and [PATCH_DIFF] before fix); Expect a report.
- Negative: Post-patch pcie_aspm_exit_link_state with an early exit when pdev != link->downstream (if-guard then goto out) and teardown only when pdev == link->downstream; Expect no report.
- Test harness notes: Run on drivers/pci/pcie/aspm.c snapshots before and after the fix; ensure the checker recognizes comments/identifiers and control-flow dominance of the guard.

6. Estimated Effort & Priority
High priority: UAF in kernel (per [ROOTCAUSE_ANALYSIS]) with crash potential during hot-unplug; Medium effort: requires control-flow dominance analysis and simple structural patterning but limited scope.

7. Likely False-Positive Sources & Mitigations
- Other teardown routines freeing non-shared link objects; Mitigation—require evidence of parent_link usage and sibling list operations.
- Code where link->downstream semantics don’t imply function 0; Mitigation—require explicit downstream field usage or comments indicating function 0/anchor.
- Paths where teardown occurs only after all subordinates are guaranteed gone (not visible statically); Mitigation—restrict to functions with removal semantics and missing equality guard.

8. Limitations & Assumptions
- Assumes link->downstream denotes function 0 and is the correct guard condition, based on [PATCH_DESCRIPTION] and [PATCH_DIFF]; not derivable generically outside this subsystem.
- Cannot prove at compile time whether subordinate links still exist; uses structural proxies (parent_link usage and sibling list operations).
- Heavily tied to PCIe ASPM code structure and naming; generalization to other subsystems would need additional domain models not provided here.