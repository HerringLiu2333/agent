1. Plan Summary
Detect missing error propagation in btrfs global root loading that prevents setting BTRFS_FS_STATE_NO_DATA_CSUMS when read_tree_root_path() fails under rescue=ibadroots (IGNOREBADROOTS), leading to later NULL dereference.

2. Detection Steps
1) Step 1: Identify functions that call read_tree_root_path() and immediately test its result with IS_ERR(...) to handle a failed root load. Signals: a local variable (e.g., root) assigned from read_tree_root_path(), followed by an IS_ERR(root) conditional.

2) Step 2: Within the IS_ERR(root) branch, check whether the error code variable (e.g., ret) is assigned an error via PTR_ERR(root) only conditionally based on btrfs_test_opt(fs_info, IGNOREBADROOTS). Signals: a guard “if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))” wrapping “ret = PTR_ERR(root)” in the error path.

3) Step 3: Verify that a “found” flag is set to true before the read_tree_root_path() call and remains true when entering the error branch. Signals: an assignment “found = true;” appearing prior to the call, and no reset of “found” inside the IS_ERR(root) branch.

4) Step 4: Confirm that the function uses a final error-handling gate based on the combined condition “!found || ret”. Signals: a later “if (!found || ret) { ... }” block that performs corrective actions.

5) Step 5: Inside that final block, check that it sets BTRFS_FS_STATE_NO_DATA_CSUMS when handling the checksum tree. Signals: nested condition “if (objectid == BTRFS_CSUM_TREE_OBJECTID)” followed by “set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state)”.

6) Step 6: Establish the problematic control-flow: if IGNOREBADROOTS is true, the IS_ERR(root) branch does not assign ret, leaving ret equal to a non-error (e.g., previously 0), and found is true, thus “!found || ret” evaluates false. Signals: dataflow showing ret is not set inside the IS_ERR(root) branch when IGNOREBADROOTS holds, and prior code sets ret to 0 in the loop.

7) Step 7: Flag the pattern when the final “!found || ret” block is the only place that sets BTRFS_FS_STATE_NO_DATA_CSUMS for the csum tree in this function. Signals: no alternative path outside the “!found || ret” block that sets the NO_DATA_CSUMS flag when read_tree_root_path() fails.

8) Step 8: Report a finding if all are true: (a) IS_ERR(root) path exists, (b) ret assignment is conditioned on !IGNOREBADROOTS, (c) found is true before the call, (d) a later “!found || ret” gate sets NO_DATA_CSUMS, and (e) there is a break/exit after the IS_ERR(root) without forcing ret to an error. Signals: presence of “break;” in the IS_ERR(root) branch and missing unconditional “ret = PTR_ERR(root)” before it.

9) Step 9: Exclude fixed code by recognizing an unconditional error propagation in the IS_ERR(root) branch. Signals to suppress: “ret = PTR_ERR(root)” executed regardless of btrfs_test_opt(fs_info, IGNOREBADROOTS) within the error path.

3. Limitations & Assumptions
- Assumes the semantics of btrfs_test_opt(fs_info, IGNOREBADROOTS) correspond to rescue=ibadroots; only evidence provided supports this specific option and its effect.
- Does not prove a downstream NULL dereference; it detects the control-flow pattern that prevents setting BTRFS_FS_STATE_NO_DATA_CSUMS after read_tree_root_path() failure.
- Limited to functions employing a “found” flag and a final “!found || ret” gate; similar flaws without this structure may be missed.