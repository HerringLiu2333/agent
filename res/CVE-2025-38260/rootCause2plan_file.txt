1. Plan Summary
Detect cases where an error from a pointer-returning root-loading function is intentionally “ignored” under a rescue/ignore option (e.g., IGNOREBADROOTS), leaving a status variable unchanged (e.g., ret == 0), and later error-handling logic keyed off that status is skipped, failing to set critical state flags (e.g., BTRFS_FS_STATE_NO_DATA_CSUMS).

2. Detection Steps
1) Step 1: Identify functions in fs/btrfs/disk-io.c that call a pointer-returning tree/root loader and check IS_ERR() on the result (e.g., read_tree_root_path()). Signals: a local “root” pointer assigned from read_tree_root_path(), followed by IS_ERR(root). FP mitigation: restrict to the specific file and functions shown (load_global_roots_objectid) in [FILE_CONTENT].

2) Step 2: Within the IS_ERR branch, detect conditional assignment of ret = PTR_ERR(root) guarded by a negated “ignore bad roots/rescue” option check (e.g., if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) ret = PTR_ERR(root)). Signals: call to btrfs_test_opt(fs_info, IGNOREBADROOTS) influencing whether ret is set. FP mitigation: require the exact option symbol IGNOREBADROOTS as seen in [FILE_CONTENT]/[ROOTCAUSE_ANALYSIS].

3) Step 3: Verify that ret can remain 0 along the error path due to the ignore option, by checking ret’s initial value and assignments in the loop/body. Signals: ret is not set in the IS_ERR branch when the ignore option is true. FP mitigation: ensure ret is a function-wide status variable used for final outcome decisions.

4) Step 4: Check for a boolean (e.g., found) set to true before the read and not reset on error, creating the condition found == true and ret == 0. Signals: found = true; precedes read_tree_root_path(); found remains true when IS_ERR(root) is taken. FP mitigation: require the exact “found” variable pattern shown in [FILE_CONTENT].

5) Step 5: Locate the end-of-function error handling gated by “if (!found || ret)” that sets critical state flags (e.g., set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state) for BTRFS_CSUM_TREE_OBJECTID). Signals: trailing conditional uses ret and found to set BTRFS_FS_STATE_NO_DATA_CSUMS. FP mitigation: require presence of both the gating condition and the set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, …) call.

6) Step 6: Establish a feasible control-flow path where IS_ERR(root) occurs, the ignore option suppresses ret assignment, and the function reaches the final “if (!found || ret)” check with found true and ret == 0, thereby skipping the flag setup. Signals: control-flow path analysis linking Steps 2–5. FP mitigation: constrain to the same function and loop context shown in [FILE_CONTENT].

7) Step 7: Flag this pattern as a defect: error suppressed by IGNOREBADROOTS prevents setting the status flag and leaves the system in an unsafe state. Rationale: maps exactly to the root cause described in [ROOTCAUSE_ANALYSIS].

8) Step 8: To reduce noise, prioritize cases where objectid == BTRFS_CSUM_TREE_OBJECTID appears near the final gating logic (as in [FILE_CONTENT]), because the impact (missing BTRFS_FS_STATE_NO_DATA_CSUMS) leads to later csum lookups and crashes per [ROOTCAUSE_ANALYSIS]. Signals: comparison against BTRFS_CSUM_TREE_OBJECTID. FP mitigation: require that specific branch exists.

9) Step 9: Optionally generalize to other global root loaders in the same file that use IGNOREBADROOTS and ret gating, but only report when a state bit or error-handling is guarded by (!found || ret), mirroring [FILE_CONTENT] semantics. Signals: similar patterns of IS_ERR() + conditional ret assignment + final ret/found gating + state set. FP mitigation: require both the “ignore” option and a final remediation guarded by ret/found.

10) Step 10: Record contextual evidence in the alert: the IS_ERR site, the conditional ret assignment, and the final skipped set_bit path (to aid triage). Signals: source locations of these three points. FP mitigation: only produce an alert when all three are present.

3. Target Elements
- Functions: load_global_roots_objectid (primary), other root-loading helpers in fs/btrfs/disk-io.c with similar patterns.
- Call sites: read_tree_root_path(...) returning a pointer checked with IS_ERR(...).
- Condition checks: btrfs_test_opt(fs_info, IGNOREBADROOTS) within the IS_ERR branch; final “if (!found || ret)” gating.
- Status variables: ret used as function-level error indicator; found used as “success seen” marker.
- State-setting operations: set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state) under objectid == BTRFS_CSUM_TREE_OBJECTID.

4. Dataflow / Taint Considerations
- Track the dataflow of ret: initialized/assigned across the loop/function; ensure a path where IS_ERR(root) occurs and ret is not set due to IGNOREBADROOTS.
- Track the control-flow of found: set to true before the read; remains true on the IS_ERR branch.
- Path-sensitive gating: ensure the function reaches the end condition “if (!found || ret)” with found == true and ret == 0, skipping state setup.

5. Validation & Test Cases
- Positive: Pre-patch load_global_roots_objectid from [FILE_CONTENT], where IS_ERR(root) only sets ret if !IGNOREBADROOTS, and final “if (!found || ret)” sets NO_DATA_CSUMS but is skipped due to found true, ret == 0. Expected: flagged.
- Negative: Post-patch code in [PATCH_DIFF], where ret = PTR_ERR(root) is unconditional on IS_ERR(root). Expected: not flagged.
- Negative: A function that uses IGNOREBADROOTS but still sets fallback state immediately in the IS_ERR branch (no gating on ret/found). Expected: not flagged.
- Test harness notes: Run the checker on fs/btrfs/disk-io.c for both pre- and post-patch revisions; confirm only the pre-patch is reported.

6. Estimated Effort & Priority
Medium: requires path-sensitive analysis tying IS_ERR suppression under IGNOREBADROOTS to a later gated state-setting block.

7. Likely False-Positive Sources & Mitigations
- Alternative error propagation mechanisms (ret set elsewhere): mitigate by requiring a path where IS_ERR(root) is taken and ret remains 0 specifically due to IGNOREBADROOTS in the same branch.
- Functions where final state-setting does not depend on ret/found: mitigate by requiring the specific “if (!found || ret)” gating and set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS) occurrence.
- Similar ignore patterns that do not affect critical flags: mitigate by focusing on objectid == BTRFS_CSUM_TREE_OBJECTID flows and presence of NO_DATA_CSUMS setting.

8. Limitations & Assumptions
- Assumes availability of fs/btrfs/disk-io.c and symbol names (IGNOREBADROOTS, BTRFS_CSUM_TREE_OBJECTID, BTRFS_FS_STATE_NO_DATA_CSUMS) as in [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS].
- Does not prove the runtime crash path (e.g., btrfs_lookup_csum())—the checker focuses on the structural logic bug described in [ROOTCAUSE_ANALYSIS].
- May not generalize to other subsystems without similar option/error/status gating patterns; the plan prioritizes the specific bug pattern shown in [PATCH_DIFF]/[FILE_CONTENT].