1. Plan Summary
Detect conditional suppression of error propagation under “ignore/rescue” mount options that prevents required fallback state-setting, leaving a NULL global root reachable and causing later NULL dereferences.

2. Detection Steps
1) Step 1: Identify functions that load a global/root structure by calling a pointer-returning loader (for example, read_tree_root_path) and store the result in a variable (e.g., root). Conceptual signals: assignment from a function returning a pointer-like value followed by an IS_ERR(...) check on that variable.
2) Step 2: Within the IS_ERR(...) error branch, detect a conditional that depends on a mount option “ignore/rescue” test (e.g., btrfs_test_opt(fs_info, IGNOREBADROOTS)). Conceptual signals: a nested if that references an “IGNORE*” option, with the error code assignment ret = PTR_ERR(root) only in the “not ignore” path.
3) Step 3: Verify that in the error path when the ignore option evaluates to true, the variable representing the error code (ret) is not written (i.e., remains at its prior value, often 0). Conceptual signals: a control-flow path from IS_ERR(...) to a break/continue/return without any assignment to ret.
4) Step 4: Track a boolean/control flag indicating a successful find (e.g., found = true) that is set before the failing load call. Conceptual signals: a write to a boolean like found = true immediately before the loader call in the same loop/scope.
5) Step 5: Locate a later decision block that uses both the “found” flag and the error code to decide on fallback handling (e.g., if (!found || ret) ...). Conceptual signals: a conditional combining the found variable and ret to gate error-handling actions.
6) Step 6: Inside that fallback handling, check for setting a safety state/flag that disables risky behavior when a root is bad (e.g., set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, ...)). Conceptual signals: function calls or state mutations that disable checksums or otherwise mark the component unavailable based on ret.
7) Step 7: Build a path condition showing: (a) root load fails (IS_ERR true), (b) ignore option is enabled so ret is not set, (c) found is true from earlier, and (d) at the final check, (!found || ret) is false, so the fallback is skipped. Conceptual signals: dataflow from IS_ERR(...) to the final if, with ret possibly 0 and found true.
8) Step 8: Report a diagnostic when the above path condition holds, because the combination allows an error to be suppressed by an ignore option while simultaneously skipping necessary state changes. Highlight the exact locations of (1) the conditional error propagation, and (2) the later conditional that depends on ret/found.
9) Step 9: Exclude fixed patterns where, in the IS_ERR(...) branch, ret is assigned unconditionally (e.g., ret = PTR_ERR(root); without the ignore-option guard). Conceptual signals: presence of a direct ret assignment on all IS_ERR paths.
10) Step 10: Optionally, strengthen confidence by checking that the function processes specific global roots by objectid (e.g., BTRFS_CSUM_TREE_OBJECTID) and that the fallback sets BTRFS_FS_STATE_NO_DATA_CSUMS. Conceptual signals: comparisons against objectid constants and state bit constants for data checksums.
11) Step 11: Optionally, detect similar anti-patterns for other global roots in the same function (extent, free space) by reusing the same analysis: conditional error suppression gated on an “ignore” option and later fallback gated on ret/found. Conceptual signals: repeat of the pattern with different objectid names.
12) Step 12: Prioritize findings where the loop or function terminates after the suppressed error (e.g., break) and no alternative error handling updates ret before the final decision block. Conceptual signals: control-flow break/return without ret assignment before the final if (!found || ret).

3. Limitations & Assumptions
- Assumes presence of recognizable option checks (e.g., btrfs_test_opt(fs_info, IGNOREBADROOTS)); other naming patterns may be missed.
- Does not prove a downstream NULL dereference; it flags the unsafe logical combination that skips fallback state-setting after an error.
- May miss cases where ret is modified through indirect calls or aliases not evident in local control flow.
- May produce false positives if alternative safe guards exist outside the analyzed function or if semantics of “found” differ across contexts.