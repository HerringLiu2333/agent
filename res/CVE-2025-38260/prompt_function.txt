1. CVE Identifier
CVE-2025-38260

2. Vulnerability Type
NULL pointer dereference due to missing error propagation/incorrect error handling

3. Root Cause Summary
The function load_global_roots_objectid() failed to propagate an error when read_tree_root_path() returned an ERR_PTR for the checksum (csum) tree while the rescue=ibadroots (IGNOREBADROOTS) mount option was set. Because ret remained 0 and found was set true, the end-of-function error handling block did not execute, leaving BTRFS_FS_STATE_NO_DATA_CSUMS unset despite a missing/invalid csum root. Subsequent I/O paths attempted to look up checksums via btrfs_lookup_csum without the NO_DATA_CSUMS safeguard, dereferencing a NULL csum root and crashing the kernel.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Btrfs filesystem, global roots loading in fs/btrfs/disk-io.c

2) Pre-Patch Flaw:
In load_global_roots_objectid(), after setting found = true, the error path:
“if (IS_ERR(root)) { if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) ret = PTR_ERR(root); break; }”
left ret as 0 under IGNOREBADROOTS, even though the csum root load failed. This caused the condition “if (!found || ret)” to be false and skipped setting BTRFS_FS_STATE_NO_DATA_CSUMS for a corrupted/missing csum tree.

3) Trigger Condition:
Mounting a filesystem with a corrupted csum tree root using rescue=ibadroots (IGNOREBADROOTS) and then performing a data read (e.g., file read/exec) that triggers checksum lookup. The call trace shows btrfs_lookup_bio_sums → btrfs_lookup_csum invoked after mount.

4) Impact Mechanism:
Because NO_DATA_CSUMS was not set, the read path attempted to access the csum tree and dereferenced a NULL root in btrfs_lookup_csum, leading to a KASAN-detected NULL pointer dereference and kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Unconditionally propagate the error from read_tree_root_path() by setting ret = PTR_ERR(root) regardless of IGNOREBADROOTS. This ensures the final error handling block runs and sets BTRFS_FS_STATE_NO_DATA_CSUMS for the csum tree when the root cannot be loaded.

2) Key Code Changes:
In fs/btrfs/disk-io.c within load_global_roots_objectid():
- Removed the guard:
  “if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))”
- Now always do:
  “ret = PTR_ERR(root);”
This change guarantees that “if (!found || ret)” evaluates true and triggers:
- set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state) for BTRFS_CSUM_TREE_OBJECTID
- Appropriate return handling under IGNOREBADROOTS (ret set to 0) while still setting the flag.

3) Locking/Concurrency Impact:
None. The change is purely in error propagation and state-setting logic, with no modifications to locking or concurrency primitives.

6. Broader Kernel Security Implications
Ensuring consistent error handling and state flags prevents kernel crashes on corrupted filesystems even with rescue options enabled, reducing the potential for denial-of-service via crafted images. Properly setting NO_DATA_CSUMS when the csum root is unavailable avoids unsafe accesses in the I/O path, strengthening robustness of btrfs mount and read paths under failure conditions.