1. Plan Summary
Detect cases where an error detected from a pointer-returning function (e.g., IS_ERR on a root pointer) does not unconditionally propagate to a status variable (e.g., ret) due to an option/flag check, while later logic relies on that status variable to trigger critical error handling.

2. Detection Steps
1) Step 1: Identify error-detecting call sites where a variable is assigned from a function and immediately checked with an error predicate (e.g., IS_ERR on read_tree_root_path’s result) — signals: assignment to a pointer-like variable followed by an IS_ERR check as described in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — FP mitigation: focus on btrfs code paths and functions named in [PATCH_DIFF] (load_global_roots_objectid, read_tree_root_path).
2) Step 2: Within the IS_ERR block, detect conditional propagation of the error into a status variable (e.g., ret) gated by an option check — signals: ret is assigned from an error extractor (e.g., PTR_ERR(var)) only under a condition such as btrfs_test_opt(fs_info, IGNOREBADROOTS) being negated, per [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — FP mitigation: require that the condition references a mount/feature option API (like btrfs_test_opt) and a named option constant (e.g., IGNOREBADROOTS), per [ROOTCAUSE_ANALYSIS].
3) Step 3: Verify early exit from the current loop/scope on the error path without unconditional error return — signals: presence of a break (as in [PATCH_DIFF]) or a non-error return while ret may remain 0 — FP mitigation: ensure the early exit is not directly returning an error code to the caller.
4) Step 4: Track initialization/previous value of the status variable (ret) — signals: ret is 0 or otherwise indicates success before the error block and not definitely assigned on all error paths due to the guard, per [ROOTCAUSE_ANALYSIS] — FP mitigation: exclude cases where ret is already set to an error before the failing call or is always assigned in all error branches.
5) Step 5: Detect a “found/success” flag set true before the failing call that participates in later gating — signals: an assignment like found = true preceding read_tree_root_path, consistent with [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — FP mitigation: require that found (or similarly named boolean) is later used in a joint condition with ret.
6) Step 6: Locate later conditional logic that uses the status variable to decide error handling — signals: conditions such as (!found || ret) or (ret || !found) that guard blocks known to perform extra error handling for csum or global roots, as described in [ROOTCAUSE_ANALYSIS] — FP mitigation: prefer matches where the guarded block interacts with filesystem state/flags (e.g., setting BTRFS_FS_STATE_NO_DATA_CSUMS as per [ROOTCAUSE_ANALYSIS]) or references “csum/checksum” identifiers.
7) Step 7: Confirm the existence of a feasible path where error is detected (IS_ERR true), the guarded assignment to ret is skipped (option condition true), early exit occurs, and the later condition sees found true and ret == 0 — signals: path-sensitive control/data-flow establishing found=true, ret=0, error taken, early exit, then end-of-function gating using ret/found per [ROOTCAUSE_ANALYSIS] — FP mitigation: require that later code is in the same function and dominates function exit or affects subsystem state.
8) Step 8: Prioritize btrfs mount/global-root-loading contexts — signals: function name load_global_roots_objectid and callees read_tree_root_path, btrfs_test_opt(…, IGNOREBADROOTS) as in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS] — FP mitigation: if outside btrfs or without an option like IGNOREBADROOTS, report with lower confidence or suppress unless Steps 2–7 all hold.

3. Target Elements
- Functions: btrfs root/global root loading routines (e.g., load_global_roots_objectid) mentioned in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
- Call sites: assignments from read_tree_root_path and immediate IS_ERR checks.
- Condition checks: option/feature checks (e.g., btrfs_test_opt with IGNOREBADROOTS) that gate error propagation.
- Variables: status variable (ret) and “found” boolean used for gating later error handling.
- Control-flow constructs: break/early-exit statements following the guarded non-propagation.
- Subsequent conditional blocks that use ret and/or found to trigger error handling (e.g., csum-tree handling and state flag updates per [ROOTCAUSE_ANALYSIS]).

4. Dataflow / Taint Considerations
- Track the “error-taint” from an IS_ERR-detected failure to the status variable: ensure ret is not definitely assigned an error on that path due to a guard.
- Track the boolean “found” set to true before the failing call and its participation with ret in later conditions.
- Establish a path where ret stays at its initial success value (e.g., 0) after the error path due to the option-gated assignment, then flows into a later decision point controlling error handling.

5. Validation & Test Cases
- Positive: Pre-patch pattern from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]: IS_ERR(root) then “if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) ret = PTR_ERR(root); break;” with found=true earlier and later condition that uses ret to handle csum error; expect a finding.
- Negative: Post-patch pattern from [PATCH_DIFF]: IS_ERR(root) followed by unconditional “ret = PTR_ERR(root);” and break; expect no finding.
- Negative: Error path that immediately returns an error code to the caller (no later dependence on ret/found); expect no finding.
- Positive: Variant where ret assignment is gated by any option check, found=true, break occurs, and later logic hinges on ret to set a safety flag; expect a finding.
- Test harness notes: Run on fs/btrfs sources, ensure interprocedural resolution for read_tree_root_path and in-function control-flow/path reasoning across loops and early exits.

6. Estimated Effort & Priority
High: Requires path-sensitive control/data-flow, recognition of Linux ERR_PTR idioms, and contextual gating by option checks with later dependence on a status variable.

7. Likely False-Positive Sources & Mitigations
- Cases where ret is intentionally unused later or other mechanisms handle the error: mitigate by requiring a later condition that uses ret to guard error handling as in Step 6.
- Non-btrfs code with similar patterns but benign outcomes: mitigate by prioritizing btrfs contexts/functions and option checks named in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].
- Paths where ret is assigned elsewhere along all executions: mitigate with definite-assignment analysis ensuring a feasible path keeps ret at success on the error path.

8. Limitations & Assumptions
- Assumes the presence of a later condition that uses ret (and possibly found) to trigger error handling, as described in [ROOTCAUSE_ANALYSIS]; exact code for that block is not provided.
- Assumes ERR_PTR/IS_ERR idioms and option checks (btrfs_test_opt with IGNOREBADROOTS) as in [PATCH_DIFF]; generalization to other subsystems may require additional idiom knowledge not provided here.
- Cannot guarantee downstream NULL dereference; the checker focuses on missed error propagation that skips intended safety handling per [ROOTCAUSE_ANALYSIS].