1. Plan Summary
Detect paths where an error from a pointer-returning helper is conditionally not propagated (ret left non-error) under an option, while later logic gates critical safety actions on that ret (and a pre-set “found” flag), potentially skipping necessary state-setting and leading to unsafe dereferences (as in the pre-patch btrfs csum-root load path).

2. Detection Steps
1) Step 1: Objective: identify candidate functions that load tree roots and perform end-of-function safety handling based on ret/found. Signals: functions calling read_tree_root_path(...) and later having a conditional of the form “if (!found || ret) { ... set_bit(...FS_STATE...); ... }” (based on [FUNCTION_CONTENT]). FP mitigation: restrict to functions in fs/btrfs/disk-io.c or with similar structure to load_global_roots_objectid.

2) Step 2: Objective: locate the callsite where a pointer ‘root’ is assigned from read_tree_root_path and immediately checked with IS_ERR. Signals: assignment root = read_tree_root_path(...); followed by if (IS_ERR(root)) { ... } (from [FUNCTION_CONTENT]). FP mitigation: require that the error arm exits the current loop/function via break/return rather than fully handling the error locally.

3) Step 3: Objective: detect conditional error propagation guarded by a mount option that can suppress setting ret. Signals: inside the IS_ERR block, an if with condition btrfs_test_opt(fs_info, IGNOREBADROOTS) or logical negation thereof, such that ret = PTR_ERR(root) executes only under one branch (from [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]). FP mitigation: ensure that there exists a path through the IS_ERR arm that reaches the break/return without any assignment to ret in that arm.

4) Step 4: Objective: verify that a “found” indicator is set true before the read and remains true on the IS_ERR path. Signals: assignment found = true just before root = read_tree_root_path(...), and no reset of found along the error path (from [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]). FP mitigation: require that the found assignment dominates the call and that the IS_ERR path does not reassign found.

5) Step 5: Objective: confirm end-of-function gating relies on both found and ret, enabling the hazard when found is true and ret is 0. Signals: a conditional later “if (!found || ret)” that triggers the safety action (e.g., set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, ...)) (from [FUNCTION_CONTENT]). FP mitigation: ensure the safety action is inside this conditional and not also executed elsewhere on the IS_ERR path.

6) Step 6: Objective: perform path feasibility: there is a CFG path where IS_ERR(root) is true, the option guard is satisfied to skip ret assignment, control flow exits the loop, and reaches the end-of-function conditional where (!found || ret) evaluates false due to found==true and ret possibly 0. Signals: (a) ret is not assigned any nonzero value on this path after the IS_ERR block, and (b) break leads to that end-of-function block (from [FUNCTION_CONTENT]). FP mitigation: require absence of any ret assignment on the path between the break and the end-of-function conditional.

7) Step 7: Step objective: scope to the csum-tree case where the safety flag is specifically NO_DATA_CSUMS. Signals: the presence of an objectid check for BTRFS_CSUM_TREE_OBJECTID guarding set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, ...) in the end-of-function block (from [FUNCTION_CONTENT]). FP mitigation: if this guard is absent, still report only when a comparable safety flag set_bit is present to avoid overgeneralization.

8) Step 8: Objective: discount code that already sets the safety flag or propagates error regardless of option. Signals: within the IS_ERR arm, look for unconditional ret assignment (as in the patched code in [PATCH_DIFF]) or explicit safety flag setting before exit. FP mitigation: if either is present on the IS_ERR path, suppress the alert.

9) Step 9: Objective: account for early-return paths that explicitly set the safety flag for other options (e.g., IGNOREDATACSUMS) but do not apply to this IS_ERR path. Signals: detect early return when objectid == BTRFS_CSUM_TREE_OBJECTID and btrfs_test_opt(..., IGNOREDATACSUMS) then set_bit(NO_DATA_CSUMS) and return 0 (from [FUNCTION_CONTENT]). FP mitigation: do not treat such early paths as mitigating the IS_ERR hazard unless they dominate the failing path.

10) Step 10: Objective: prioritize warnings when the option guard specifically mentions IGNOREBADROOTS (rescue=ibadroots), matching the documented bug. Signals: the exact enum/constant IGNOREBADROOTS within btrfs_test_opt condition inside the IS_ERR block (from [PATCH_DESCRIPTION], [PATCH_DIFF], [ROOTCAUSE_ANALYSIS]). FP mitigation: deprioritize if the option is unrelated or if later code sets equivalent safety state independently.

3. Target Elements
- Functions that call read_tree_root_path and manage global roots (e.g., load_global_roots_objectid).
- Call sites with pointer-returning helpers checked by IS_ERR.
- Condition checks guarding error propagation (btrfs_test_opt(..., IGNOREBADROOTS)).
- Variables representing summarized state: ret (int status), found (boolean/flag).
- End-of-function conditionals that gate safety state-setting on ret/found.
- set_bit calls affecting FS_STATE flags (e.g., BTRFS_FS_STATE_NO_DATA_CSUMS).

4. Dataflow / Taint Considerations
- Track the dataflow of ret from initialization through assignments in the IS_ERR block and after, ensuring there exists a path where ret remains zero/non-error.
- Track the control-flow that sets found = true prior to the call and confirm it reaches the end without being reset.
- Model the branch where btrfs_test_opt(..., IGNOREBADROOTS) evaluates to allow skipping ret assignment on the error path.
- Ensure the path reaches the end-of-function conditional controlling set_bit(NO_DATA_CSUMS), and that the condition can be false given found==true and ret==0.

5. Validation & Test Cases
- Positive: Pre-patch snippet from [FUNCTION_CONTENT] where in the IS_ERR(root) arm, ret is set only under “if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))”, followed by break; end-of-function contains “if (!found || ret) { set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, ...); ... }”.
- Negative: Post-patch snippet from [PATCH_DIFF] where ret = PTR_ERR(root) is unconditional inside the IS_ERR(root) arm; the checker should not flag.
- Negative: Variant where the IS_ERR(root) arm explicitly sets BTRFS_FS_STATE_NO_DATA_CSUMS before break/return; the checker should not flag.
- Test harness notes: Use path exploration to show feasibility of the path from IS_ERR through break to the final conditional with found==true and ret unmodified/zero.

6. Estimated Effort & Priority
Medium: requires interprocedural call modeling of read_tree_root_path return semantics, control/dataflow analysis of ret/found, and option-guard reasoning; high value due to kernel crash prevention (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Cases where ret is assigned elsewhere on all paths after the break via structured cleanup: mitigate by proving no intervening ret assignment on the specific path.
- Error-handling patterns where safety flags are set in a separate function invoked after break: mitigate by detecting calls that set the same flag along the path.
- Option checks that are statically impossible to be true in context: mitigate by prioritizing matches with IGNOREBADROOTS specifically (per [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]).

8. Limitations & Assumptions
- Assumes read_tree_root_path returns ERR_PTR on failure and IS_ERR correctly identifies it (from [FUNCTION_CONTENT]/[ROOTCAUSE_ANALYSIS]); the checker infers this from usage patterns, not from specifications.
- Cannot prove runtime values of mount options; relies on the presence of btrfs_test_opt(..., IGNOREBADROOTS) branches to model the suppressed ret assignment (from [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS]).
- Does not establish the later NULL dereference; it flags the skipped safety-state path that maps to the root cause (from [ROOTCAUSE_ANALYSIS]).