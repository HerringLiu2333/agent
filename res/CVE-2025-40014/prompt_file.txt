1. CVE Identifier
CVE-2025-40014

2. Vulnerability Type
Out-of-bounds array access (off-by-one) leading to undefined behavior

3. Root Cause Summary
amd_set_spi_freq() performed a linear search over amd_spi_freq without handling the “no match” case when speed_hz is below the minimum supported frequency. The pre-patch loop used i < ARRAY_SIZE(amd_spi_freq) and broke only if speed_hz >= amd_spi_freq[i].speed_hz; if no entry matched (speed below AMD_SPI_MIN_HZ), i became ARRAY_SIZE and was then used to index amd_spi_freq[i]. This off-by-one indexing caused an out-of-bounds read from the frequency table and subsequent use of invalid values to program hardware registers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- SPI subsystem, AMD SPI controller driver (drivers/spi/spi-amd.c), function amd_set_spi_freq()

2) Pre-Patch Flaw:
- In amd_set_spi_freq(), the loop searched the table with: for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++) if (speed_hz >= amd_spi_freq[i].speed_hz) break;
- When speed_hz < AMD_SPI_MIN_HZ (the last entry in the descending table), the loop completed without a break, leaving i == ARRAY_SIZE and the code then accessed amd_spi_freq[i], an out-of-bounds index.
- Subsequent code used amd_spi_freq[i] to compute alt_spd and spd7_val and to update amd_spi->speed_hz, all based on invalid memory.

3) Trigger Condition:
- Passing a speed_hz value lower than AMD_SPI_MIN_HZ (800000) into amd_set_spi_freq().
- This can occur via spi_transfer.speed_hz or spi_device.max_speed_hz in amd_spi_fifo_xfer(), or via op->max_freq in amd_spi_exec_mem_op(); the patch description explicitly notes speed_hz < AMD_SPI_MIN_HZ as the trigger.

4) Impact Mechanism:
- Out-of-bounds read of amd_spi_freq (global const table) at index ARRAY_SIZE, causing undefined behavior.
- Results include programming registers with garbage values and control-flow/stack analysis anomalies (UBSAN/objtool warning: “amd_set_spi_freq() falls through to next function”), potentially leading to misconfiguration, crashes, or other erratic behavior.

5. Patch Analysis
1) Fix Approach:
- Saturate the table lookup to the last valid entry (AMD_SPI_MIN_HZ) by capping the loop at ARRAY_SIZE(amd_spi_freq) - 1, ensuring i never exceeds the array bounds.
- This effectively clamps any sub-minimum speed request up to AMD_SPI_MIN_HZ.

2) Key Code Changes:
- Loop bound changed (single-line fix):
  - Pre: for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
  - Post: for (i = 0; i < ARRAY_SIZE(amd_spi_freq)-1; i++)
- No other logic altered; the subsequent dereferences of amd_spi_freq[i] now always operate on a valid index.

3) Locking/Concurrency Impact:
- None. The change is purely a local bounds fix within a single function; no locking or ordering semantics were modified.

6. Broader Kernel Security Implications
- Off-by-one table scan errors are a common source of kernel UB; such patterns should ensure a post-search clamp or use a conditional that guarantees a valid index (e.g., explicit “no match” handling).
- Where drivers expose per-operation frequencies, enforcing controller min/max constraints at call sites and re-validating inside helpers prevents similar bugs.
- Static analysis (objtool) and runtime sanitizers (UBSAN) effectively highlighted the issue; similar checks should be applied to other table-driven configuration paths across drivers.