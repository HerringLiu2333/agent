1. Plan Summary
Detect linear search loops over fixed-size arrays that may exit without a match and then index the array with the loop variable, leading to out-of-bounds access when the loop ran to the full array length.

2. Detection Steps
1) Step 1: Locate loops that iterate an index variable from 0 up to the array’s size (e.g., condition “i < ARRAY_SIZE(arr)”) and reference arr[i] in the body. Signals: for/while loops with a simple monotonic increment of i and a bound tied to ARRAY_SIZE(arr) or equivalent array-length expression; arr[i] used inside the loop.
2) Step 2: Within such loops, identify a conditional early exit based on a comparison involving arr[i] (e.g., “if (param >= arr[i].field) break”). Signals: an if statement whose predicate depends on arr[i] and a break/return only executed under that predicate.
3) Step 3: Determine that the loop has no unconditional exit and can complete all iterations when the predicate never holds (e.g., input lower than minimum table entry). Signals: absence of unconditional break/return/goto that always fires; the only exit is the conditional break tied to arr[i].
4) Step 4: After the loop, find any indexing of the same array using the loop variable (arr[i], arr[i].field) without validating or adjusting i. Signals: immediate post-loop dereferences of arr[i] and no intervening check “i < ARRAY_SIZE(arr)” or assignment that clamps i.
5) Step 5: Confirm that i’s possible value upon loop completion equals the array length (i == ARRAY_SIZE(arr)) due to the loop bound and increment, making arr[i] out-of-bounds. Signals: loop initializer “i = 0”, increment by 1 per iteration, upper bound “i < ARRAY_SIZE(arr)”, and no writes to i after the loop before indexing.
6) Step 6: Check for absence of mitigation via loop bound or clamping (e.g., not using “ARRAY_SIZE(arr) - 1” and no post-loop “i = ARRAY_SIZE(arr) - 1” or equivalent). Signals: loop bound exactly equal to array length and no guard “if (i == ARRAY_SIZE(arr)) { clamp/return }”.
7) Step 7: Raise confidence when multiple post-loop dereferences of arr[i] occur (e.g., reading speed_hz, enable_val, spd7_val) and values derived from arr[i] drive side effects (e.g., register writes). Signals: several arr[i].field reads and subsequent function calls using those values.
8) Step 8: Suppress findings when a safe pattern is present: loop bound already uses “ARRAY_SIZE(arr) - 1” or a clear post-loop clamp/guard ensures i <= ARRAY_SIZE(arr) - 1 before any arr[i] access. Signals: adjusted bound or explicit min/guard logic preceding indexing.
9) Step 9: Report the issue when Steps 1–7 are satisfied and Step 8 is not, highlighting the loop, array symbol, index variable, and first post-loop arr[i] use as the potential out-of-bounds access point. Signals: tie the risky post-loop indexing to the search loop that can run to completion without a match.

3. Limitations & Assumptions
- Assumes the ability to recognize ARRAY_SIZE(arr) or equivalent array-length expressions; cases using dynamic lengths may be harder to reason about statically.
- Does not prove the runtime predicate is never true; treats conditional breaks as potentially untriggered, which may yield false positives if domain constraints guarantee a match.
- Assumes the array is a real fixed-size object; if arr is a pointer to unknown-sized storage, accurately determining bounds may be infeasible.