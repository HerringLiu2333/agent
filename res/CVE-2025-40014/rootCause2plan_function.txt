1. Plan Summary
Detect loops that scan an array up to its full length and then use the loop index after the loop without clamping or bounds checks, which can yield out-of-bounds array access when no match is found (as in CVE-2025-40014).

2. Detection Steps
1) Step 1: Objective — find “search” loops over arrays that iterate from index 0 to index < array_length. Signals — a loop variable initialized to 0, incremented each iteration, with a bound equal to the array’s length (e.g., ARRAY_SIZE(arr)), and a conditional break inside using arr[i] (based on [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]). FP mitigation — require the same array arr[i] is referenced in the break condition to indicate a search, not arbitrary iteration.

2) Step 2: Objective — model the possibility that the loop completes without a break (i.e., no match found). Signals — the only early exit is via a conditional break; no unconditional break/return/goto occurs in all paths; the break condition compares an external value to arr[i] (e.g., speed_hz >= amd_spi_freq[i].speed_hz per [FUNCTION_CONTENT]), which is not provably always true. FP mitigation — if the loop upper bound is already length-1, consider it safe and suppress (matches the fix in [PATCH_DIFF] and the reasoning in [ROOTCAUSE_ANALYSIS]).

3) Step 3: Objective — identify post-loop uses of the index to access the same array. Signals — after the loop concludes, expressions like arr[i] or arr[i].field appear on a path directly reachable from loop exit (e.g., amd_spi_freq[i].speed_hz/use in [FUNCTION_CONTENT]). FP mitigation — require that no re-assignment to i occurs between loop exit and first array access, except clamping to a safe range.

4) Step 4: Objective — confirm that no bounds validation or clamping occurs before the post-loop array access. Signals — absence of checks like “if (i >= length) { clamp or return }” or equivalent clamping of i to length-1 before arr[i] is used; absence of a loop bound of length-1. FP mitigation — recognize safe guards such as “if (i == length) i = length-1;”, “i = min(i, length-1);”, or returning early when i == length.

5) Step 5: Objective — reason about the exit value of i on the no-break path to determine potential OOB. Signals — with loop condition i < length and unit increments, i equals length on normal termination; thus arr[i] is out-of-bounds if used unguarded (as described in [ROOTCAUSE_ANALYSIS]). FP mitigation — if analysis detects that the loop bound is length-1 or that i is decremented/clamped before use, suppress.

6) Step 6: Objective — prioritize matches that mirror the exact AMD SPI pattern to reduce noise. Signals — loop scans a table of structs and uses multiple fields of arr[i] after loop for configuration (e.g., .speed_hz, .enable_val, .spd7_val per [FUNCTION_CONTENT]). FP mitigation — boost confidence if there are at least two distinct field reads from arr[i] after the loop with no intervening bounds check.

7) Step 7: Objective — ensure array identity consistency across loop and post-loop use. Signals — the array referenced in the loop condition/body (arr) is the same symbol referenced after the loop (e.g., amd_spi_freq), and i is the same SSA variable. FP mitigation — if the array expression changes (e.g., different base pointer), or i is redefined in an unknown way, demote or suppress.

8) Step 8: Objective — exclude cases where the loop structurally cannot complete without a break. Signals — presence of an unconditional return inside the loop body or a surrounding control construct that guarantees early exit before arr[i] is used. FP mitigation — require a feasible path where the loop’s condition becomes false without having taken a break before reporting.

3. Target Elements
- For/while loops with index variables and array length-based bounds.
- Break statements guarded by conditions referencing arr[i].
- Post-loop array subscripts arr[i] and struct field accesses arr[i].field.
- Bounds checks and clamps on i (comparisons with array length, min/clamp patterns).
- Constants/macros used as array length (e.g., ARRAY_SIZE(arr)).

4. Dataflow / Taint Considerations
- Track the loop index variable’s value from initialization through the loop to post-loop uses, modeling increments and the loop bound.
- Track the specific array symbol used with the index inside the loop and after the loop to ensure identity.
- Track control-flow paths where the loop exits via condition false (no break) versus via break; ensure a feasible no-break path exists to the subsequent array access.
- Track any post-loop transformations of i (clamping or reassignment) before the array is indexed.

5. Validation & Test Cases
- Positive: A loop “for (i = 0; i < ARRAY_SIZE(tab); i++) if (x >= tab[i].k) break; … y = tab[i].k;” with no clamp/guard; expect a finding (matches [FUNCTION_CONTENT] and [ROOTCAUSE_ANALYSIS]).
- Positive: Same pattern accessing multiple fields of tab[i] after loop; expect a higher-confidence finding (mirrors [FUNCTION_CONTENT]).
- Negative: Loop bounded by “i < ARRAY_SIZE(tab)-1” with post-loop tab[i] access; expect no finding (matches the fix in [PATCH_DIFF]).
- Negative: Post-loop guard “if (i >= ARRAY_SIZE(tab)) i = ARRAY_SIZE(tab)-1;” or “if (i == ARRAY_SIZE(tab)) return;” before any tab[i] access; expect no finding.
- Test harness notes: Include variations using while-loops and different length expressions equivalent to array size; verify control-flow reasoning distinguishes no-break paths.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Loops that are logically guaranteed to break but not provable statically; mitigate by requiring explicit absence of clamps and by the presence of post-loop arr[i] dereferences.
- Arrays whose “length” expression is not recognized as the true bound; mitigate by restricting to common bound forms (e.g., ARRAY_SIZE or explicit constants) and by conservative path feasibility checks.
- Index variables altered in subtle ways post-loop; mitigate by SSA-based tracking and suppress if transformations are not understood to be safe or unsafe.

8. Limitations & Assumptions
- Assumes the analysis can recognize array-length bounds conceptually equivalent to ARRAY_SIZE(arr); other custom macros may be missed.
- Does not prove semantic properties of the break condition (e.g., value ranges); it treats conditional breaks as potentially not taken, as implied by [ROOTCAUSE_ANALYSIS].
- Assumes unit increment and simple loop forms; complex index arithmetic or pointer iteration may not be fully covered.
- Based solely on the provided AMD SPI pattern and the fix reducing the bound to length-1 ([PATCH_DIFF], [FUNCTION_CONTENT], [ROOTCAUSE_ANALYSIS]); broader variations may require additional heuristics.