1. Plan Summary
Detect off-by-one array index bugs where a linear search over a fixed-size lookup table uses the loop index after the loop without handling the “no match” case, leading to out-of-bounds access.

2. Detection Steps
1) Step 1: Identify for-loops that iterate a counter from 0 up to a bound tied to ARRAY_SIZE(some_array) or equivalent; signals include “for (i = 0; i < ARRAY_SIZE(arr); i++)” as seen in amd_set_spi_freq (based on [FILE_CONTENT] and [PATCH_DIFF]). FP mitigation: restrict to loops that contain a break inside the body controlled by a condition.

2) Step 2: Within candidate loops, confirm the break condition compares an external value against arr[i] (e.g., “if (speed_hz >= amd_spi_freq[i].speed_hz) break”) indicating a linear search (based on [FILE_CONTENT] amd_set_spi_freq). FP mitigation: require the external value to originate from a function parameter or a field read from an input object (e.g., xfer->speed_hz, spi->max_speed_hz, op->max_freq per [FILE_CONTENT]).

3) Step 3: Detect post-loop use of arr[i] without a preceding bound check or clamp; signals include direct indexing arr[i] after the loop used to set state or compute values (e.g., “amd_spi->speed_hz = amd_spi_freq[i].speed_hz”) per [FILE_CONTENT]. FP mitigation: do not flag if there is an explicit guard like “if (i == ARRAY_SIZE(arr)) i = ARRAY_SIZE(arr)-1” or any reassignment that ensures i <= last valid index.

4) Step 4: Ensure the loop’s upper bound is exactly ARRAY_SIZE(arr) and not already reduced (ARRAY_SIZE(arr)-1) as the patch does (based on [PATCH_DIFF]). FP mitigation: exclude loops with safe upper bounds (size-1 or equivalent sentinel handling).

5) Step 5: Confirm the loop’s break condition is not guaranteed to trigger for all inputs; signals include non-constant external value compared with table entries and the presence of a minimum entry (AMD_SPI_MIN_HZ) at the end of the table (based on [FILE_CONTENT] table and [ROOTCAUSE_ANALYSIS] trigger condition). FP mitigation: exclude cases where a separate unconditional break or default assignment ensures a match regardless of input.

6) Step 6: Require that the array being searched is a static or const lookup table of structs (e.g., amd_spi_freq) to match the table-driven pattern (based on [FILE_CONTENT]). FP mitigation: exclude arrays that are dynamically sized or mutated within the function.

7) Step 7: Identify subsequent computations that use arr[i] fields to program hardware or state (e.g., alt_spd, spd7_val, register writes) to prioritize impactful cases (based on [FILE_CONTENT] amd_set_spi_freq register programming). FP mitigation: deprioritize or exclude cases where arr[i] is only used in non-effectful calculations.

8) Step 8: Optionally flag if the function’s logic implies clamping should be applied (e.g., presence of a minimum constant like AMD_SPI_MIN_HZ and descending table entries) but no explicit clamp exists, tying to the fix rationale (based on [PATCH_DESCRIPTION] and [ROOTCAUSE_ANALYSIS]). FP mitigation: only apply when steps 1–3 are satisfied to avoid heuristic-only matches.

3. Target Elements
- For-loop constructs with index variables tied to ARRAY_SIZE(array).
- Break statements inside loops with conditions referencing array elements indexed by the loop variable.
- Post-loop array index usages arr[i] where i is the loop variable.
- Static/const global or file-scope arrays used as lookup tables (struct arrays like amd_spi_freq).
- Function parameters and input object fields used in comparisons (e.g., speed_hz, spi->max_speed_hz, op->max_freq).
- Assignments and register programming using arr[i] fields after the loop.

4. Dataflow / Taint Considerations
- Track the external value used in the loop’s break condition back to function parameters or device/operation fields (e.g., xfer->speed_hz, spi->max_speed_hz, op->max_freq) to model that the condition may not be satisfied (based on [FILE_CONTENT]).
- Ensure the loop index i flows from the loop to the post-loop array access without an intervening clamp or reassignment that constrains i to a valid index.

5. Validation & Test Cases
- Positive: Pre-patch amd_set_spi_freq with “for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++) … if (speed_hz >= amd_spi_freq[i].speed_hz) break; … use amd_spi_freq[i]” should be flagged (based on [FILE_CONTENT]).
- Negative: Patched version changing the loop bound to “ARRAY_SIZE(amd_spi_freq)-1” should not be flagged (based on [PATCH_DIFF]).
- Negative: A variant that handles the “no match” case explicitly (e.g., after the loop: if (i == ARRAY_SIZE(arr)) i = ARRAY_SIZE(arr) - 1; then using arr[i]) should not be flagged.
- Test harness notes: Include small C snippets emulating the search pattern over a const struct array with different bounds and post-loop guards; verify that only the off-by-one pattern without guard is reported.

6. Estimated Effort & Priority
Medium effort; High priority due to out-of-bounds access leading to undefined behavior (based on [ROOTCAUSE_ANALYSIS] severity and [PATCH_DESCRIPTION] UBSAN/objtool warning).

7. Likely False-Positive Sources & Mitigations
- Arrays with sentinel last element guaranteeing a break: mitigate by requiring absence of explicit post-loop guard or reassignment.
- Loops where i is revalidated or clamped before use: mitigate by checking for bound checks and corrections.
- Complex loop constructs or macro-expanded bounds not recognized as ARRAY_SIZE: mitigate by focusing on recognizable ARRAY_SIZE and common idioms first.

8. Limitations & Assumptions
- Assumes the checker can recognize ARRAY_SIZE and map the array symbol consistently; macro indirection or custom size macros may reduce coverage.
- Cannot prove table ordering or runtime feasibility of “no match” beyond pattern analysis; relies on the absence of explicit clamps (based on [ROOTCAUSE_ANALYSIS] reasoning).
- Hardware effects and sanitizer warnings are not directly inferable statically; the checker focuses on structural risk patterns (based on [PATCH_DESCRIPTION]).