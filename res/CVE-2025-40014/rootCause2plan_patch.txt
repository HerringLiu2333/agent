1. Plan Summary
Detect loops that scan an array up to its full length with a conditional early break, then use the loop index after the loop without clamping, which can yield i == ARRAY_SIZE(array) and lead to out-of-bounds access.

2. Detection Steps
1) Step 1: Objective — find candidate array-scanning loops; Signals — for-loops initializing an index to 0 and using a bound tied to the array’s length (e.g., i < ARRAY_SIZE(arr)) with a conditional break inside; FP mitigation — restrict to loops where the condition references the indexed array element (arr[i] or a field thereof), indicating a search pattern as in [PATCH_DIFF]/[ROOTCAUSE_ANALYSIS].

2) Step 2: Objective — assess whether the early break is not guaranteed; Signals — break guarded by a predicate involving an external value (e.g., a function parameter like speed_hz) compared against arr[i] members, not a loop counter condition; FP mitigation — treat the external value as unconstrained and flag only if no post-loop check on i is present (to avoid requiring proof of non-break).

3) Step 3: Objective — check if the loop may run to completion; Signals — loop upper bound is ARRAY_SIZE(arr) (exact or equivalent) rather than ARRAY_SIZE(arr)-1 as fixed in [PATCH_DIFF], and the only exit from the loop body is a conditional break; FP mitigation — consider loops that have any unconditional break/return/ goto to be safe.

4) Step 4: Objective — track post-loop uses of the loop index; Signals — any array or pointer arithmetic access using i after the loop, especially arr[i] or related arrays indexed by i; FP mitigation — exclude cases where i is immediately reassigned/clamped before use.

5) Step 5: Objective — detect missing clamping/validation; Signals — absence of checks like if (i == ARRAY_SIZE(arr)) i = ARRAY_SIZE(arr)-1 or equivalent, and no min/max-style bounding before dereference; FP mitigation — treat explicit bounds checks or clamping idioms as safe and suppress.

6) Step 6: Objective — correlate looped-over array with the post-loop access target; Signals — same array symbol as the loop’s subject, or a documented derivative (e.g., using arr[i].field to compute an index to another table) as in [ROOTCAUSE_ANALYSIS] “used i without clamping”; FP mitigation — if the post-loop use is unrelated to the looped array and cannot cause OOB on any array, do not flag.

7) Step 7: Objective — prioritize likely OOB-on-low-input cases (lower-bound clamp missing); Signals — break condition using a “>=”, “>”, or similar comparison between external value and arr[i] (so low values can cause loop completion), consistent with [PATCH_DESCRIPTION]/[ROOTCAUSE_ANALYSIS]; FP mitigation — de-prioritize patterns where the predicate implies high-value-only failures (to reduce noise).

8) Step 8: Objective — recognize safe fixed patterns; Signals — loop bound already uses ARRAY_SIZE(arr)-1 as in the fix in [PATCH_DIFF], or loop contains logic that sets i to a valid last index on completion (clamping up to the minimum acceptable entry per [ROOTCAUSE_ANALYSIS]); FP mitigation — treat these as non-issues.

9) Step 9: Objective — report only when an OOB read/write is plausible; Signals — post-loop i used as an index expression without guards, or used to compute offsets into stack-allocated or fixed-size structures, aligning with “out-of-bounds stack access” in [ROOTCAUSE_ANALYSIS]; FP mitigation — if i is only used in comparisons or as a loop counter for a new, independently-bounded loop, suppress.

3. Target Elements
- For-loops scanning arrays with an index variable (initialization at 0, upper bound tied to ARRAY_SIZE(array)).
- Conditional breaks inside loops that compare an external input to arr[i] or arr[i].field.
- Post-loop uses of the index variable to index arrays or compute memory offsets.
- Bounds-checking statements and clamping idioms after the loop.
- Macro-like constructs of ARRAY_SIZE(...) in conditions.

4. Dataflow / Taint Considerations
- Treat function parameters and non-constant locals involved in the break predicate as unconstrained inputs.
- Track the loop index variable’s value through the loop to the first post-loop use.
- Model the possibility of “no break taken” to propagate a potential value of i == ARRAY_SIZE(arr).
- Correlate the specific array used in the loop condition with arrays indexed by i after the loop.

5. Validation & Test Cases
- Positive: A function that loops for (i = 0; i < ARRAY_SIZE(tbl); i++) with if (x >= tbl[i].val) break; and then uses tbl[i] (or uses i derived from that loop) without any post-loop clamping; expect a finding.
- Positive: Same as above, but the post-loop index is used on a different but same-length table without clamping; expect a finding due to shared index risk.
- Negative: Loop upper bound is ARRAY_SIZE(tbl)-1 as in [PATCH_DIFF], and/or explicit post-loop clamp i = min(i, ARRAY_SIZE(tbl)-1); expect no finding.
- Negative: Loop has an unconditional break/return ensuring i cannot reach ARRAY_SIZE, or i is not used after the loop; expect no finding.
- Test harness notes: Include cases with nested fields (tbl[i].field) and macro-expanded ARRAY_SIZE; verify suppression when explicit clamping or safe bounds exist.

6. Estimated Effort & Priority
High — pattern is common in search loops, and impact includes out-of-bounds access consistent with [ROOTCAUSE_ANALYSIS].

7. Likely False-Positive Sources & Mitigations
- Loops where a domain invariant guarantees the break occurs for all inputs (not provable statically) — mitigate by requiring an unguarded post-loop index use and lack of clamping.
- Arrays with sentinel elements guaranteeing safety — mitigate by checking for ARRAY_SIZE-1 bounds or explicit sentinel handling code.
- Post-loop uses of i that are bounded elsewhere (e.g., separate range checks) — mitigate by recognizing immediate guards before dereference.

8. Limitations & Assumptions
- The checker assumes the break condition may not fire for some inputs; it does not prove table ordering or invariants (per [ROOTCAUSE_ANALYSIS] uncertainty about clamping).
- It cannot infer hardware-specific semantics like “AMD_SPI_MIN_HZ”; it relies on structural evidence (loops, bounds, and uses) as in [PATCH_DIFF]/[PATCH_DESCRIPTION].
- It may not perfectly distinguish stack vs. non-stack arrays; it flags OOB risk based on index bounds and usage rather than storage class.