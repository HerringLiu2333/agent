1. Plan Summary
Detect search loops that iterate up to ARRAY_SIZE(array) and may fall through without a match, then use the loop index to access the array without clamping, leading to out-of-bounds access.

2. Detection Steps
1) Step 1: Identify for-loops whose induction variable starts at 0 and whose loop condition is “index < ARRAY_SIZE(array)” for a concrete array symbol. Signals: a canonical for-loop with a single scalar index and a bound expressed with ARRAY_SIZE(same array).

2) Step 2: Within the loop body, confirm the array is indexed by the induction variable (array[index] or array[index].field) and that there exists a conditional break (break inside an if). Signals: array access using the index and an if (…) { break; } without an unconditional break.

3) Step 3: Establish that the loop has a feasible normal termination path (i reaches ARRAY_SIZE) if no break occurs. Signals: break only under a condition (no else-break/return) and no other unconditional early-exit that guarantees break on every iteration.

4) Step 4: Preferentially filter to search-pattern loops where the break condition depends on a value defined outside the loop (e.g., a function parameter or variable not modified in the loop) compared against array[index] or its field. Signals: comparison like external_var op array[index].field in the if that guards break.

5) Step 5: After the loop, locate uses of the induction variable as an index (array[index], array[index].field) or as pointer arithmetic offset derived from the same array. Signals: post-loop array subscripting or pointer math using the same index and array symbol.

6) Step 6: Check for absence of a clamp or bounds validation on the index between loop exit and the post-loop array access. Signals: no conditional “index >= ARRAY_SIZE(array)” check, no assignment that reduces index to ARRAY_SIZE(array)-1, and no equivalent guard before the access.

7) Step 7: Ensure the loop upper bound is exactly ARRAY_SIZE(array), not ARRAY_SIZE(array)-1 or another construct that prevents index == ARRAY_SIZE on fall-through. Signals: loop condition literal use of ARRAY_SIZE(array) without subtraction or pre-validated sentinel logic.

8) Step 8: Flag the pattern when the index can equal ARRAY_SIZE on the no-break path and is used to read or write the array post-loop without a guard. Signals: control-flow path where the loop exits normally, index equals ARRAY_SIZE(array), and a subsequent array access using that index.

9) Step 9: Optionally raise severity if the array is a local/stack object or the post-loop access affects configuration/control data (indicative of stack OOB and control-flow anomalies). Signals: array storage on stack or access used to set device/config fields.

3. Limitations & Assumptions
- The checker cannot prove the break condition is never satisfied; it assumes the conditional break can fail for some inputs.
- It does not infer monotonic properties of array contents (e.g., sorted thresholds) or concrete values like AMD_SPI_MIN_HZ.
- Macro expansion details may vary; the plan assumes ARRAY_SIZE can be resolved to the referenced array symbol.
- The checker focuses on the same array symbol; parallel arrays of equal size are not reliably correlated.
- Determining stack vs heap placement and precise impact (e.g., objtool fall-through symptoms) may not be available in all codebases.