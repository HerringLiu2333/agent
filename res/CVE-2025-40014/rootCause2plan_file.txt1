1. Plan Summary
Detect off-by-one table-scan loops that can leave the index equal to the array length and then use it to index the same array, causing out-of-bounds access.

2. Detection Steps
1) Step 1: Identify loops that iterate an index (e.g., i) over a fixed-size array with a guard equivalent to i < array_length(arr) and start from 0 with monotonic increment. Signals: for/while constructs with i initialized to 0, incremented by 1, and guard referencing a length expression like ARRAY_SIZE(arr).

2) Step 2: Confirm the loop body contains a conditional early exit (e.g., break/return/goto to a point after the loop) whose predicate reads the current array element. Signals: condition uses arr[i] or a field (arr[i].field) and invokes a control-flow exit from the loop.

3) Step 3: Check that the conditional exit predicate compares a value derived from parameters or locals (e.g., speed_hz) against arr[i] to implement a threshold/match search. Signals: relational comparison between a non-constant expression and arr[i] or its field.

4) Step 4: After the loop, locate any direct use of the index to access the same array. Signals: arr[i] or arr[i].field reads/writes appearing syntactically after the loop.

5) Step 5: Verify there is no bounds validation or clamping of i between loop exit and the array access. Signals: absence of checks like i == len, i = len - 1, min/max clamping, or i-- before arr[i] use.

6) Step 6: Ensure the loop upper bound does not preclude i reaching the array length. Signals: guard is i < array_length(arr), not i < array_length(arr) - 1.

7) Step 7: Model the exit paths to confirm that the loop can terminate via the guard without taking the conditional exit. Signals: presence of paths where the break condition might not hold (conditional break only; no unconditional break; no guaranteed sentinel match).

8) Step 8: Flag the post-loop array access as potentially out-of-bounds if i can equal array_length(arr) on some path. Rationale: with guard i < len, lack of clamping, and a conditional break based on arr[i], i == len yields arr[i] OOB as in amd_set_spi_freq().

9) Step 9: De-duplicate and prioritize findings where multiple downstream uses of arr[i] occur after the loop (e.g., comparisons, assignments, register programming), reporting the first use site. Signals: first post-loop arr[i] dereference.

10) Step 10: Suppress cases where the code explicitly caps the loop to len - 1 or otherwise guarantees a valid index (e.g., changed bound to ARRAY_SIZE(arr) - 1), as such constructs mitigate the off-by-one risk. Signals: loop guard using len - 1 or equivalent expression.

3. Limitations & Assumptions
- The checker cannot prove value ranges (e.g., whether speed_hz is always ≥ the minimal table entry); it assumes conditional breaks may not trigger.
- Recognition of “array_length” relies on compile-time patterns (e.g., ARRAY_SIZE(arr)); dynamic lengths or opaque macros may reduce accuracy.
- It does not infer monotonicity/sortedness of the table; it focuses purely on structural patterns (conditional break + post-loop arr[i] use).
- Non-local index adjustments (e.g., via called functions) between loop and use are not modeled; the plan assumes local straight-line checks.