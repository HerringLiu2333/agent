1. Plan Summary
Detect netlink attribute parsing where a binary attribute is defined with a maximum-length policy but later copied as a fixed-size buffer from nla_data() without an explicit nla_len() equality/length check, risking over-read of uninitialized memory.

2. Detection Steps
1) Step 1: Locate netlink policy arrays. Signals: static or const arrays of struct nla_policy with designated initializers of the form [ATTR_ID] = { .type = NLA_BINARY, .len = <const/sizeof> }.

2) Step 2: Mark “max-length-only” attributes. Signals: entries from Step 1 that explicitly use .type = NLA_BINARY and set .len; exclude entries initialized via the NLA_POLICY_EXACT_LEN(...) macro (i.e., not an explicit struct initializer with .type/.len in source).

3) Step 3: Find parse functions that use nlattr** for those attributes. Signals: functions whose parameters include an nlattr** (commonly named attrs), and which reference attrs[ATTR_ID] where ATTR_ID is from Step 2.

4) Step 4: Identify fixed-size copies from nla_data(attrs[ATTR_ID]). Signals: calls to memcpy/memcpy-like APIs where the source expression is nla_data(attrs[ATTR_ID]) or an alias pointer derived from it; the copy size is a compile-time constant or sizeof(T) (e.g., sizeof(struct in_addr)/sizeof(struct in6_addr)).

5) Step 5: Determine the intended copy size Kcopy. Signals: the third argument of memcpy (constant literal or sizeof expression); record Kcopy for the copy site from Step 4.

6) Step 6: Check for explicit length validation before the copy. Signals: in the same function and dominating the copy site, a conditional that compares nla_len(attrs[ATTR_ID]) to Kcopy (== or >=) guarding the copy; if absent, mark as missing guard.

7) Step 7: Validate that policy does not enforce exact length. Signals: confirm the corresponding policy entry for ATTR_ID is from Step 2 (NLA_BINARY with .len) and not an exact-length helper; if exact-length helper is used, consider the site safe.

8) Step 8: Flag unsafe fixed-size copies. Signals: a site satisfying Steps 4–7 (fixed-size memcpy from nla_data(attrs[ATTR_ID]) with no dominating nla_len check and policy allowing shorter payloads via max-length-only rule).

9) Step 9: Consider aliasing variants. Signals: variants where nla_data(attrs[ATTR_ID]) is assigned to a local pointer p before memcpy, or where memcpy copies directly into a fixed-size struct field; treat these as equivalent to Step 4.

10) Step 10: Exempt safe “length-driven” copies. Signals: copies where the size argument originates from nla_len(attrs[ATTR_ID]) or from a variable earlier set to nla_len(...) (e.g., kmemdup(..., len,...)); do not flag these.

11) Step 11: Exempt code guarded by equality checks. Signals: if there is a guard enforcing equality (nla_len(attrs[ATTR_ID]) == Kcopy) dominating the copy, do not flag.

12) Step 12: Report context for remediation. Signals: include attribute ID, policy definition location (NLA_BINARY with .len), the copy site with Kcopy, and absence of equality/length check or of exact-length policy.

3. Limitations & Assumptions
- Assumes the checker can distinguish explicit struct initializers from macro-based initializers; if NLA_POLICY_EXACT_LEN expands to a struct initializer indistinguishable from NLA_BINARY+.len in the preprocessed code, the exclusion in Step 2 may be imperfect.
- Assumes dominance/dataflow analysis can relate nla_len(attrs[ID]) checks to the copy site; complex control flow may lead to false positives/negatives.
- Only patterns evidenced here are considered: fixed-size memcpy from nla_data(attrs[ID]) governed by a max-length NLA_BINARY policy; other APIs or custom validators are not covered without additional rules.
- Does not determine runtime feasibility; flags are based on static absence of checks and policy semantics inferred from the provided materials.