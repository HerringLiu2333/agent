1. CVE Identifier
CVE-2025-38310

2. Vulnerability Type
Insufficient length validation leading to uninitialized memory read (information disclosure)

3. Root Cause Summary
The netlink attribute policy for SEG6_LOCAL_NH4 and SEG6_LOCAL_NH6 used NLA_BINARY with .len set to sizeof(struct in_addr)/sizeof(struct in6_addr), which only enforces a maximum length. This allowed attributes shorter than the fixed-size address structures to pass validation. Subsequent code expects an exact-sized IPv4/IPv6 address and can read beyond the provided payload or use uninitialized bytes, resulting in the kernel reading uninitialized memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking, IPv6 Segment Routing (SEG6) local processing (netlink attribute parsing via seg6_local_policy)

2) Pre-Patch Flaw:
- seg6_local_policy defined:
  - [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }
  - [SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }
- For NLA_BINARY, .len is a maximum, not an exact size, permitting undersized nexthop attributes.

3) Trigger Condition:
- A user space netlink request sets SEG6_LOCAL_NH4 or SEG6_LOCAL_NH6 with a payload shorter than sizeof(struct in_addr)/sizeof(struct in6_addr) (but not exceeding it). The validator accepts it due to the max-length policy.

4) Impact Mechanism:
- Kernel code that treats these attributes as fixed-size addresses can read beyond the provided data or read uninitialized bytes when accessing the nexthop address, resulting in an uninitialized memory read (as described in the patch description). This can cause information disclosure and potentially incorrect nexthop configuration.

5. Patch Analysis
1) Fix Approach:
- Strengthen netlink attribute validation to enforce exact-length requirements, preventing undersized attributes from being accepted.

2) Key Code Changes:
- Replaced:
  - [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }
  - [SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }
- With:
  - [SEG6_LOCAL_NH4] = NLA_POLICY_EXACT_LEN(sizeof(struct in_addr))
  - [SEG6_LOCAL_NH6] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr))
- This enforces equality rather than “<=” semantics for attribute lengths.

3) Locking/Concurrency Impact:
- None. The change is limited to netlink attribute policy validation; no locking or ordering changes.

6. Broader Kernel Security Implications
- Enforcing exact-length policies for fixed-size netlink attributes prevents a class of uninitialized read and potential info-leak bugs across networking subsystems.
- Tightened validation reduces kernel attack surface from malformed netlink inputs (including from namespaces with CAP_NET_ADMIN), improving robustness and preventing subtle data leaks or misconfigurations tied to length mismatches.