1. Plan Summary
Detect netlink attribute policies that only enforce “length ≤ expected” for fixed-size nexthop/address payloads (e.g., in_addr/in6_addr), while downstream code treats the payload as a full struct, risking uninitialized memory reads.

2. Detection Steps
1) Step 1: Objective: Identify netlink attribute policy declarations. Signals: Find arrays of netlink attribute policies where entries are initialized with a binary type and a .len field set to sizeof of a fixed-size address struct (e.g., sizeof(struct in_addr) or sizeof(struct in6_addr) per PATCH_DIFF and ROOTCAUSE_ANALYSIS). FP mitigation: Limit to policies in SRv6/seg6 or similar networking contexts and to in_addr/in6_addr-sized entries as evidenced.

2) Step 2: Objective: Exclude policies that already enforce exact length. Signals: Detect use of an exact-length policy initializer (conceptually the exact-length macro seen in PATCH_DIFF) instead of a generic binary type with .len. FP mitigation: Do not flag any initializer that expresses exact-length enforcement.

3) Step 3: Objective: Record the attribute identifiers for candidate policies. Signals: Capture the array index/constant (e.g., SEG6_LOCAL_NH4 or SEG6_LOCAL_NH6 from PATCH_DIFF) associated with the flagged policy entries. FP mitigation: Restrict to indices whose names or comments suggest fixed-size address semantics (e.g., NH4/NH6), as supported by ROOTCAUSE_ANALYSIS.

4) Step 4: Objective: Correlate candidate attributes to their consumers. Signals: In netlink parsing/handling functions, find uses of the same attribute indices (from Step 3) where the attribute payload is retrieved and interpreted as a full struct in_addr/in6_addr (e.g., cast to that struct type or copied into such a struct using its full sizeof). FP mitigation: Only flag if such a full-struct interpretation is observed.

5) Step 5: Objective: Verify absence of runtime exact-length checks before the full-struct use. Signals: Search for explicit equality checks comparing the attribute’s runtime length to sizeof(struct in_addr/in6_addr) and returning/aborting on mismatch. FP mitigation: Suppress findings if an explicit “== sizeof(...)” check is present before the use, since that prevents the uninitialized read (per ROOTCAUSE_ANALYSIS).

6) Step 6: Objective: Confirm that the policy’s “≤ len” semantics can admit undersized inputs. Signals: Ensure the candidate policy uses a binary type with .len and no exact-match constraint, consistent with the pre-patch flaw where length <= expected was allowed (ROOTCAUSE_ANALYSIS). FP mitigation: If the policy indicates variable-length semantics or optional payloads without any fixed-size struct use, suppress.

7) Step 7: Objective: Prioritize nexthop address attributes. Signals: Preferentially rank or flag attributes whose identifiers indicate IPv4/IPv6 nexthops (e.g., NH4/NH6) as shown in PATCH_DIFF and PATCH_DESCRIPTION. FP mitigation: Use this as a prioritization heuristic to reduce noise outside address-like payloads.

8) Step 8: Objective: Report a finding when both preconditions hold. Signals: Candidate policy with “≤ len” validation (Steps 1–2, 6) and downstream full-size struct interpretation without exact-length validation (Steps 4–5). FP mitigation: Require both policy-side and use-site evidence to align with the root cause (ROOTCAUSE_ANALYSIS).

3. Target Elements
- Declarations and initializers of netlink attribute policy arrays.
- Designated initializers for specific attribute indices (e.g., SEG6_LOCAL_NH4, SEG6_LOCAL_NH6).
- Netlink parsing/handling functions that retrieve attributes and interpret payloads.
- Casts or copies of attribute payloads to/from struct in_addr or struct in6_addr, including uses implying full-size reads.
- Conditional checks comparing attribute length to sizeof(struct in_addr/in6_addr).

4. Dataflow / Taint Considerations
- Track attribute index from policy definition to its use in parsing/handling functions.
- Track flows from attribute payload retrieval to variables of type struct in_addr/in6_addr or buffers sized by sizeof of these structs.
- Recognize control-flow guards that enforce exact size equality before payload use and treat them as sanitizers.

5. Validation & Test Cases
- Positive: A policy entry uses a binary type with .len = sizeof(struct in_addr), the same attribute is later cast/copied into struct in_addr, and there is no equality check enforcing exact size; expect a finding (matches pre-patch pattern in PATCH_DIFF and ROOTCAUSE_ANALYSIS).
- Negative: The policy uses an exact-length policy initializer (as in PATCH_DIFF) for in_addr/in6_addr; expect no finding.
- Negative: A policy uses binary .len with in_addr/in6_addr size, but before using the payload as a full struct, code checks attr_len == sizeof(struct in_addr/in6_addr) and rejects on mismatch; expect no finding.
- Test harness notes: Include cross-file scenarios where policy and handler are in different units, and ensure the analysis correlates attribute indices across these files.

6. Estimated Effort & Priority
High priority; medium effort. The impact is a memory-safety risk per ROOTCAUSE_ANALYSIS, and patterns are structurally identifiable around policy initializers and fixed-size struct uses.

7. Likely False-Positive Sources & Mitigations
- Variable-length attributes coincidentally sized like in_addr/in6_addr but not used as full structs; mitigate by requiring downstream full-struct interpretation.
- Handlers that read only provided bytes without assuming full struct; mitigate by detecting sizeof-based copies/casts as a necessary condition.
- Code with implicit exact-size enforcement not trivially recognized; mitigate by searching for equality checks or equivalent guards near the use.

8. Limitations & Assumptions
- The plan assumes the ability to identify netlink policy arrays and map attribute indices to handlers; specific API names are not provided in FUNCTION_CONTENT.
- Only in_addr/in6_addr are explicitly evidenced; generalization to other fixed-size payloads is suggested in ROOTCAUSE_ANALYSIS but not enumerated.
- Macro resolution (e.g., recognizing exact-length policy macros) must be available to distinguish exact-length initializers from generic binary+len initializers.