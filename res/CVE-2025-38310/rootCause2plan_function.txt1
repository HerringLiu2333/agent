1. Plan Summary
Detect netlink attribute policies that accept undersized fixed-size nexthop addresses by using NLA_BINARY with a maximum length rather than enforcing exact payload length for struct in_addr/in6_addr.

2. Detection Steps
1) Step 1: Identify declarations of arrays of struct nla_policy (e.g., seg6_local_policy) used for netlink attribute validation. Signals: array initializer with elements keyed by attribute constants in square brackets and fields like .type, .len.
2) Step 2: Within these arrays, find entries whose .type is NLA_BINARY and that specify a .len initializer equal to sizeof(struct in_addr) or sizeof(struct in6_addr). Signals: a field initializer .len with a sizeof expression referencing struct in_addr or struct in6_addr.
3) Step 3: Prioritize entries that are specifically for nexthop addresses by matching attribute indices SEG6_LOCAL_NH4 and SEG6_LOCAL_NH6. Signals: the array index expression [SEG6_LOCAL_NH4] or [SEG6_LOCAL_NH6] on the element being initialized.
4) Step 4: Exclude entries that already use exact-length enforcement macros instead of NLA_BINARY with .len. Signals: element initialized via NLA_POLICY_EXACT_LEN(sizeof(struct in_addr)) or NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)).
5) Step 5: Flag each remaining NLA_BINARY + .len == sizeof(in_addr/in6_addr) entry as a potential improper length validation for fixed-size attributes. Rationale signal: the policy ensures “<= len” rather than “== len” for fixed-size types, matching the pre-patch flaw.
6) Step 6: Optionally annotate severity higher if found in the IPv6 Segment Routing local actions context (seg6_local_policy array). Signals: array symbol name seg6_local_policy and attribute indices aligned with SEG6_LOCAL_* constants.

3. Limitations & Assumptions
- The plan assumes the code uses recognizable struct nla_policy array initializers; if policies are constructed dynamically or via complex macros, detection may miss them.
- The plan cannot verify whether downstream code treats the attribute as a full struct and reads uninitialized memory; it relies on the policy pattern as an indicator.
- Only struct in_addr and struct in6_addr are covered; other fixed-size structs could have similar issues but are not identifiable from the provided materials.
- Macro resolution may vary; the checker assumes it can distinguish entries using NLA_POLICY_EXACT_LEN from those using NLA_BINARY with .len.