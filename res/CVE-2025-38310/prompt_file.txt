1. CVE Identifier
CVE-2025-38310

2. Vulnerability Type
Improper input length validation in netlink attribute parsing leading to out-of-bounds read / uninitialized memory read.

3. Root Cause Summary
The seg6 local netlink policy allowed SEG6_LOCAL_NH4 and SEG6_LOCAL_NH6 attributes to be shorter than the size of struct in_addr/in6_addr (maximum-only length check via NLA_BINARY + .len). Parsing code then unconditionally copied sizeof(struct in_addr)/sizeof(struct in6_addr) bytes:
- parse_nla_nh4: memcpy(&slwt->nh4, nla_data(attrs[SEG6_LOCAL_NH4]), sizeof(struct in_addr));
- parse_nla_nh6: memcpy(&slwt->nh6, nla_data(attrs[SEG6_LOCAL_NH6]), sizeof(struct in6_addr));
If userspace supplied a shorter payload, the kernel read past the provided attribute into uninitialized memory. The patch switches the policy to require exact payload length, eliminating the overread.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking, IPv6 Segment Routing (SRv6) local behaviors (lwtunnel encap seg6_local), file net/seg6_local.c.

2) Pre-Patch Flaw:
- In seg6_local_policy[], SEG6_LOCAL_NH4/NH6 used .type = NLA_BINARY with .len = sizeof(struct in_addr/in6_addr), which only enforces an upper bound.
- parse_nla_nh4()/parse_nla_nh6() blindly memcpy a fixed-size address from nla_data() without verifying nla_len() meets that size, causing reads beyond the attribute payload when a shorter length is accepted by policy.

3) Trigger Condition:
- Userspace creates/updates an SRv6 seg6local lwtunnel (e.g., actions requiring a nexthop: END_X, END_DX6, END_DX4) and supplies SEG6_LOCAL_NH4 or SEG6_LOCAL_NH6 with length smaller than 4 or 16 bytes, respectively. Policy accepts the attribute (max-length check), and parsing performs fixed-size memcpy.

4) Impact Mechanism:
- The memcpy overreads beyond the provided attribute payload, causing the kernel to read uninitialized memory. The resulting slwt->nh4/nh6 can contain bytes derived from unintended memory, which may:
  - Be exposed back to userspace via put_nla_nh4()/put_nla_nh6() in dumps, or
  - Corrupt the configured nexthop address used by seg6 lookup paths, leading to undefined routing behavior.

5. Patch Analysis
1) Fix Approach:
- Tighten netlink attribute validation to enforce exact lengths for nexthop attributes so that parsing codeâ€™s fixed-size memcpy is safe.

2) Key Code Changes:
- seg6_local_policy[]:
  - Replaced:
    [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }
    [SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }
  - With:
    [SEG6_LOCAL_NH4] = NLA_POLICY_EXACT_LEN(sizeof(struct in_addr))
    [SEG6_LOCAL_NH6] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr))
- No changes to parse_nla_nh4()/parse_nla_nh6(); they now rely on policy to guarantee exact size.

3) Locking/Concurrency Impact:
- None. The change is purely input validation in netlink attribute policy; no locking, ordering, or concurrency semantics were altered.

6. Broader Kernel Security Implications
- This highlights a common pitfall when parsing NLA_BINARY attributes: .len specifies a maximum, not an exact size. Fixed-size memcpy from nla_data() must be paired with exact-length policy (NLA_POLICY_EXACT_LEN) or explicit nla_len() checks to avoid overreads.
- Similar patterns elsewhere in the kernel should be audited to ensure attributes that are copied into fixed-size structures enforce exact lengths or perform explicit bounds checks before memcpy, preventing uninitialized memory reads and potential data exposure or logic corruption.