1. Plan Summary
Detect netlink attribute policies that enforce only a maximum length (NLA_BINARY with .len) for fixed-size IPv4/IPv6 nexthop addresses, leading to potential uninitialized memory reads when subsequent code assumes exact-sized data.

2. Detection Steps
1) Step 1: Objective — Find netlink attribute policy entries that use max-length validation for fixed-size addresses; Signals — struct nla_policy array entries with .type set to NLA_BINARY and .len set to sizeof(struct in_addr) or sizeof(struct in6_addr), as in the pre-patch pattern shown; FP mitigation — Restrict to policies within networking/segment routing contexts or attributes named like SEG6_LOCAL_NH4/NH6 (based on the [PATCH_DIFF] identifiers).
2) Step 2: Objective — Identify missing exact-length enforcement; Signals — For the entries found in Step 1, verify they are not using an exact-length policy macro like NLA_POLICY_EXACT_LEN(sizeof(...)), which is the fix applied; FP mitigation — Exclude entries that already use NLA_POLICY_EXACT_LEN or any equivalent exact-length constructs (based on [PATCH_DIFF]).
3) Step 3: Objective — Correlate policy entries to their attribute identifiers for downstream use lookup; Signals — Map the array index (e.g., [SEG6_LOCAL_NH4], [SEG6_LOCAL_NH6]) to a symbolic constant to find code that references the same attribute; FP mitigation — Skip ambiguous or unresolved indices where the attribute cannot be reliably correlated.
4) Step 4: Objective — Confirm that subsequent code treats the attribute as a fixed-size address; Signals — Usages that copy/assign the attribute payload into struct in_addr/struct in6_addr or read exactly sizeof(struct in_addr)/sizeof(struct in6_addr) bytes from the attribute; FP mitigation — Require at least one such fixed-size use to proceed, aligning with “subsequent code expects an exact-sized IPv4/IPv6 address” from [ROOTCAUSE_ANALYSIS].
5) Step 5: Objective — Detect lack of explicit equality-length checks before fixed-size consumption; Signals — In the consumer path, absence of a check that attribute length equals sizeof(struct in_addr/struct in6_addr) prior to copying/using the data; FP mitigation — If an equality check exists locally, suppress the alert even if the policy uses NLA_BINARY with .len (to avoid false positives).
6) Step 6: Objective — Prioritize attributes whose naming indicates nexthops; Signals — Attribute identifiers or policy entry names containing NH4 or NH6, matching the vulnerable SEG6_LOCAL_NH4/NH6 from [PATCH_DIFF]; FP mitigation — Use this as a boosting heuristic, not a hard requirement, to retain generality but reduce noise.
7) Step 7: Objective — Flag the risk when both preconditions hold (max-length policy + fixed-size use); Signals — Conjunction of Steps 1/2 and Steps 4/5 indicates potential “undersized accepted, exact-sized read,” matching the root cause in [ROOTCAUSE_ANALYSIS]; FP mitigation — Report only when the same attribute identifier is consistently used from policy to consumption within the same subsystem/module.
8) Step 8: Objective — Suggest remediation consistent with the patch; Signals — For flagged cases, note that policy should enforce exact length using an exact-length policy macro (as per [PATCH_DIFF]); FP mitigation — None (advice only, derived directly from the fix).

3. Target Elements
- Declarations and initializations of struct nla_policy arrays.
- Policy entry fields: .type initializers and .len initializers.
- Macro invocations that define policy semantics (e.g., NLA_POLICY_EXACT_LEN).
- Attribute identifiers/indexes used in policy arrays (e.g., SEG6_LOCAL_NH4, SEG6_LOCAL_NH6).
- Consumer code that reads attribute payloads into struct in_addr or struct in6_addr, or copies exactly sizeof those types.
- Conditional checks comparing attribute length to expected size (presence/absence).

4. Dataflow / Taint Considerations
- Track conceptual flow from a policy entry’s attribute identifier to consumer code that accesses the attribute payload.
- Identify data movement where attribute data is copied/assigned into a struct in_addr/in6_addr or read with a fixed byte count equal to sizeof those structs, and check whether a preceding equality-length validation is present.

5. Validation & Test Cases
- Positive: A seg6_local_policy with [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) } and consumer code copying attribute data into struct in_addr without an exact-length check; expect a finding (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).
- Negative: The same policy updated to [SEG6_LOCAL_NH4] = NLA_POLICY_EXACT_LEN(sizeof(struct in_addr)) (as in [PATCH_DIFF]); expect no finding.
- Negative: A policy using NLA_BINARY with .len = sizeof(struct in_addr) but consumer code performs an explicit equality check to sizeof(struct in_addr) before reading; expect no finding.
- Test harness notes: Ensure the analyzer can resolve policy array indices to attribute identifiers and find at least one fixed-size consumption site for confirmation.

6. Estimated Effort & Priority
High — The pattern is well-defined, security-relevant, and grounded in a concrete kernel fix path.

7. Likely False-Positive Sources & Mitigations
- Policies using NLA_BINARY with .len as a true maximum for variable-length data that is not later consumed as fixed-size; mitigate by requiring fixed-size consumption evidence.
- Attributes with independent equality checks elsewhere not discovered due to analysis limits; mitigate by scanning nearby control flow for equality-length guards.
- Macros or wrappers that enforce exact-length semantics not recognized; mitigate by whitelisting recognized exact-length macros (e.g., NLA_POLICY_EXACT_LEN per [PATCH_DIFF]) and allowing configuration to extend the list.

8. Limitations & Assumptions
- Assumes the analyzer can correlate policy entries to their consumption sites; the provided materials do not show consumer code locations.
- The plan focuses on IPv4/IPv6 nexthop sizes (struct in_addr/struct in6_addr) specifically, as evidenced in [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]; other fixed-size attributes are out of scope given the provided evidence.
- The exact names and availability of helper APIs for attribute access are not specified; detection relies on conceptual fixed-size copies/assignments matching sizeof the address structs.