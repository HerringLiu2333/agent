1. Plan Summary
Detect fixed-size memcpy from nla_data() of netlink attributes where the policy only enforces a maximum length (NLA_BINARY .len) and no explicit nla_len() check or exact-length policy is present, leading to potential uninitialized memory reads.

2. Detection Steps
1) Step 1: Objective: Identify netlink policy declarations that govern attribute lengths. Signals: Constant arrays of struct nla_policy entries and uses of NLA_BINARY with .len versus NLA_POLICY_EXACT_LEN (based on [PATCH_DIFF] and [FILE_CONTENT]). FP mitigation: Limit to arrays used in the same compilation unit or clearly tied to attribute parsing.

2) Step 2: Objective: Map attribute IDs (e.g., SEG6_LOCAL_NH4/NH6) from policy to their parsing functions. Signals: Functions with signatures like parse_nla_* taking struct nlattr **attrs and accessing attrs[ATTR_ID] (seen in parse_nla_nh4/nla_nh6 in [FILE_CONTENT]). FP mitigation: Require a direct reference to attrs[CONST] within the parse function.

3) Step 3: Objective: Find fixed-size copy operations from nla_data() into a fixed-size destination. Signals: memcpy/memmove or equivalent where source is nla_data(attrs[CONST]) and size argument equals sizeof(struct in_addr)/sizeof(struct in6_addr) or a constant (as in parse_nla_nh4/nh6 in [FILE_CONTENT]). FP mitigation: Restrict to copies where destination is a struct or array field, not dynamically sized buffers.

4) Step 4: Objective: Verify absence of explicit length validation at the copy site. Signals: No preceding condition that checks nla_len(attrs[CONST]) == copy_size or >= copy_size in a dominating block; no helper called that enforces exact size. Why: Root cause is missing exact-length validation before fixed-size memcpy (per [ROOTCAUSE_ANALYSIS]). FP mitigation: Treat as safe if any explicit equality or >= check covers the same attr index before the copy.

5) Step 5: Objective: Cross-check policy to ensure it does not enforce exact length. Signals: Policy entry for the same ATTR_ID uses NLA_BINARY .len rather than NLA_POLICY_EXACT_LEN(size) (the fix in [PATCH_DIFF] replaces the former with exact-length macros). FP mitigation: Skip findings where the policy uses NLA_POLICY_EXACT_LEN or attribute type with inherent fixed length (e.g., NLA_U32).

6) Step 6: Objective: Confirm the copied size matches the policy’s .len or a known struct size, indicating reliance on max-length-only policy. Signals: copy_size equals sizeof(struct in_addr/in6_addr) and policy .len equals that size, but still max-only; this pattern is vulnerable because shorter payloads are permitted (per [ROOTCAUSE_ANALYSIS]). FP mitigation: Exclude cases where policy len is zero or derived from nla_len() at runtime.

7) Step 7: Objective: Flag parse functions for SRv6 local behaviors that meet the above pattern. Signals: parse_nla_nh4 and parse_nla_nh6 using memcpy from nla_data with fixed sizeof and policy using NLA_BINARY .len (as in [FILE_CONTENT]). FP mitigation: Require that the attribute is referenced in seg6_local_policy[] in the same file to avoid mismatches.

8) Step 8: Objective: Optionally strengthen confidence by confirming these attributes are used as required or optional in action tables. Signals: seg6_action_table entries listing SEG6_LOCAL_NH4/NH6 as attrs/optattrs for actions (END_DX4, END_DX6, END_X) per [FILE_CONTENT]. FP mitigation: Use this context to prioritize results likely reachable in practice.

9) Step 9: Objective: Produce a result only if both conditions hold: fixed-size memcpy without length check and non-exact policy. Signals: Conjunction of Steps 3–5 on the same attribute ID and function. FP mitigation: Require same compilation unit or clear symbol resolution to avoid cross-file mis-association.

10) Step 10: Objective: Reduce noise by excluding safe patterns using validated helper APIs. Signals: Calls to seg6_validate_srh or nla_parse_nested where policy entries enforce exact length for the specific attribute; however, for NH4/NH6 this was absent pre-patch ([ROOTCAUSE_ANALYSIS]). FP mitigation: Whitelist cases using NLA_POLICY_EXACT_LEN or explicit nla_len() validation.

3. Target Elements
- Constant arrays of struct nla_policy and their entries for attributes (e.g., SEG6_LOCAL_NH4/NH6).
- Parsing functions that take struct nlattr **attrs and use nla_data()/nla_len() for specific indices.
- memcpy/memmove calls where source is nla_data(attrs[CONST]) and size is a fixed sizeof or constant.
- Conditional checks guarding the memcpy, especially comparisons on nla_len(attrs[CONST]).
- Action tables (seg6_action_table) to provide contextual relevance of attributes.

4. Dataflow / Taint Considerations
- Track dataflow from nla_data(attrs[CONST]) to fixed-size copies into struct fields without intervening length checks.
- Ensure the attribute index CONST is consistently the same across policy and parse sites to correlate policy constraints with copy behavior.
- Consider dominance: the copy should not be guarded by prior validated equality/length checks in the same function.

5. Validation & Test Cases
- Positive: Pre-patch pattern where seg6_local_policy uses NLA_BINARY .len for SEG6_LOCAL_NH4/NH6 and parse_nla_nh4/nla_nh6 memcpy sizeof(struct in_addr/in6_addr) from nla_data without checking nla_len; expect a finding (based on [FILE_CONTENT] and [ROOTCAUSE_ANALYSIS]).
- Negative: Patched pattern where seg6_local_policy uses NLA_POLICY_EXACT_LEN(sizeof(struct in_addr/in6_addr)) for NH4/NH6; even with fixed-size memcpy, expect no finding (based on [PATCH_DIFF]).
- Test harness notes: Run on the provided file net/seg6_local.c; include synthetic variants where an explicit if (nla_len(...) == sizeof(...)) precedes the memcpy to verify suppression.

6. Estimated Effort & Priority
Medium.

7. Likely False-Positive Sources & Mitigations
- Attributes with inherent fixed-length types (e.g., NLA_U32) appearing in similar memcpy patterns; mitigate by checking attribute type.
- Copies where size is validated via helper functions not recognized; mitigate by restricting to local direct nla_len checks or exact-length policy.
- Cross-file mismatches between policy and parse sites; mitigate by requiring same-unit correlation or explicit attribute constants.

8. Limitations & Assumptions
- Assumes the checker can correlate attribute IDs between policy arrays and parse functions; cross-module resolution may be incomplete.
- Does not infer runtime checks in external helpers unless modeled; only explicit nla_len comparisons in the same function are considered.
- Focused on NLA_BINARY attributes; other types may have different guarantees not captured here.