1. Plan Summary
Detect misuse of IS_ERR/PTR_ERR on pointers returned by NULL-on-error allocators (e.g., devm_kzalloc, kmalloc), which can mask allocation failures and lead to NULL dereferences, as exemplified in the pxa1908_apbc_probe bug.

2. Detection Steps
1) Step 1: Objective — identify allocation results from NULL-on-error allocators; Signals — call sites of devm_kzalloc and kmalloc and their assigned result variables; FP mitigation — restrict the allocator set to these names based on the provided analysis.
2) Step 2: Objective — find erroneous error checks; Signals — conditionals or guards using IS_ERR(variable) where variable originates from the above allocators; FP mitigation — require that the variable is the direct or dominated assignment from the allocator call to avoid aliasing confusion.
3) Step 3: Objective — detect misused error propagation; Signals — return or propagation via PTR_ERR(variable) where variable is from devm_kzalloc/kmalloc; FP mitigation — ensure the PTR_ERR argument is the same variable from the allocator and is part of or adjacent to the IS_ERR check, as in the patch hunk.
4) Step 4: Objective — confirm absence of correct NULL handling; Signals — no preceding or dominating explicit NULL check (e.g., if (!variable)) on the same variable before uses; FP mitigation — analyze control-flow dominance to ensure no NULL guard dominates the later use.
5) Step 5: Objective — establish potential impact (dereference/use-as-non-NULL); Signals — variable is dereferenced (field access, pointer deref, or used as a non-optional argument) after the flawed IS_ERR/PTR_ERR pattern; FP mitigation — require that such use is on a path not guarded by a NULL check.
6) Step 6: Objective — prioritize high-confidence findings; Signals — both IS_ERR(variable) and PTR_ERR(variable) appear in the same error path for a devm_kzalloc/kmalloc result (matches the exact flawed idiom in the [PATCH_DIFF]); FP mitigation — elevate severity only for this combined pattern.
7) Step 7: Objective — scope to likely contexts while allowing generality; Signals — occurrences in functions with probe-like naming (e.g., “probe”) or in driver directories, as seen in the example; FP mitigation — treat this as a ranking heuristic, not a filter, to avoid missing general cases.
8) Step 8: Objective — suppress correct patterns; Signals — explicit NULL checks that return -ENOMEM (or equivalent) immediately after the allocation, as in the fixed code; FP mitigation — if such a NULL check exists and dominates all uses, do not report.

3. Target Elements
- Function bodies containing calls to devm_kzalloc or kmalloc.
- Call sites and the local variables receiving their return values.
- Conditionals invoking IS_ERR on those variables.
- Return statements or expressions invoking PTR_ERR on those variables.
- Subsequent uses of the variables (dereferences, member access, or arguments where non-NULL is expected).
- Control-flow/dominance relationships between checks and uses.

4. Dataflow / Taint Considerations
- Track the flow of the allocator’s return value to the checked variable without intervening reassignments that change meaning.
- Model control-flow to determine whether an explicit NULL check dominates subsequent uses.
- Ensure paths from allocation to use are analyzed to confirm a use after a flawed IS_ERR-only guard and absence of a dominating NULL check.

5. Validation & Test Cases
- Positive: devm_kzalloc result assigned to p; if (IS_ERR(p)) return PTR_ERR(p); later p->field = ...; Expect a finding (based on [PATCH_DIFF] and [ROOTCAUSE_ANALYSIS]).
- Positive: kmalloc result assigned to q; if (IS_ERR(q)) return PTR_ERR(q); use q in a function call requiring a valid pointer; Expect a finding (per broader misuse noted in [ROOTCAUSE_ANALYSIS]).
- Negative: devm_kzalloc result r; if (!r) return -ENOMEM; use r; Expect no finding (matches the fix in [PATCH_DIFF]).
- Negative: pointer s from a non-allocator API that returns ERR_PTR-encoded errors is checked with IS_ERR(s) and returned via PTR_ERR(s); Expect no finding because s is not from the allocator set.
- Test harness notes: Compile small kernel-like stubs with these patterns; verify dominance handling by placing checks and uses in different basic blocks.

6. Estimated Effort & Priority
Medium effort; high priority due to potential for system crashes in low-memory conditions and the prevalence of this anti-pattern in drivers (per [ROOTCAUSE_ANALYSIS]).

7. Likely False-Positive Sources & Mitigations
- Aliasing where the checked variable is not directly from the allocator; mitigate by requiring dominance and minimal aliasing between allocation and check.
- Wrapper macros around allocators obscuring the call name; mitigate by starting with exact function names and iteratively expanding only with confirmed aliases.
- Functions that may return either NULL or ERR_PTR not covered by the allocator set; mitigate by restricting to the known NULL-on-error allocators from the provided materials.

8. Limitations & Assumptions
- The allocator catalogue is limited to devm_kzalloc and kmalloc as referenced in the provided analysis; other NULL-on-error allocators (e.g., kzalloc) are not included due to lack of explicit mention.
- The checker assumes IS_ERR/PTR_ERR semantics match the kernel macros; macro resolution must be available.
- The analysis does not model interprocedural NULL checks (e.g., guards in helper functions) and focuses on intra-procedural dominance.