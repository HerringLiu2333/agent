1. Plan Summary
Detect sysfs store callbacks that allocate a new heap buffer and overwrite a persistent struct field without freeing the previously allocated buffer, causing per-write kernel memory leaks (as in memcg_path_store).

2. Detection Steps
1) Step 1: Identify candidate sysfs store callbacks — functions with signature like ssize_t f(struct kobject*, struct kobj_attribute*, const char*, size_t) and/or paired with __ATTR_* macros that imply name_store; this narrows to sysfs attribute setters (based on FILE_CONTENT usage and naming patterns).
2) Step 2: Within such a store function, find a local pointer assigned from a heap allocation call (e.g., kmalloc_array, kmalloc, kzalloc) sized from input count; this signals a newly allocated buffer coming from the sysfs write (seen in memcg_path_store via kmalloc_array in FILE_CONTENT).
3) Step 3: Track dataflow from the allocation to an assignment into a field of a container object derived from the input kobject via container_of (e.g., filter->memcg_path = path); this matches the persistent field overwrite pattern in the root cause (ROOTCAUSE_ANALYSIS and FILE_CONTENT).
4) Step 4: Check for absence of a free on the old field value before the overwrite within the same function (e.g., missing kfree(filter->memcg_path) between function entry and the assignment); this maps directly to the missing free fixed in PATCH_DIFF.
5) Step 5: Require that the target field is a heap-owned pointer freed at object release (e.g., kfree(field) in the type’s release method) to confirm the field’s lifetime spans multiple writes and leaks can accumulate (evidenced by damon_sysfs_scheme_filter_release freeing memcg_path in FILE_CONTENT).
6) Step 6: Exclude cases where the assignment uses in-place reallocation that preserves and manages the old buffer (e.g., krealloc-like patterns) or where the new pointer equals the old pointer; this reduces false positives unrelated to replacement without freeing (not present here).
7) Step 7: Exclude cases where the old field is provably NULL at all call sites of the store function (e.g., first-time initialization guarded by control flow ensuring single assignment); this avoids flagging one-time initialization.
8) Step 8: Consider string-copy indicators (e.g., strscpy from buf into the new buffer sized with count + 1) as corroborating evidence that the buffer is intended to persist and be replaced; this aligns with the memcg_path pattern (FILE_CONTENT).
9) Step 9: If multiple assignment sites exist, ensure no path between function entry and the field overwrite frees the old value (direct kfree(field) or helper that frees it); perform path-sensitive check to avoid missing frees hidden by conditionals.
10) Step 10: Prefer cases where the field is a member of a sysfs-exposed struct used in other callbacks (show handlers printing the field), indicating persistent storage across writes (e.g., memcg_path_show accesses filter->memcg_path in FILE_CONTENT); this strengthens confidence that overwrites without freeing leak.
11) Step 11: Optionally tie the store function to its attribute via naming convention (name_store paired with __ATTR_RW_MODE(name,...)), when resolvable, to confine findings to sysfs attributes (as with damon_sysfs_scheme_filter_memcg_path_attr in FILE_CONTENT).
12) Step 12: Report a result when a newly allocated pointer flows into a persistent field in a sysfs store without an intervening free of the previous value, citing the field name and function; this mirrors the pre-patch flaw described in ROOTCAUSE_ANALYSIS.

3. Target Elements
- Functions: sysfs store callbacks with signature (kobject, kobj_attribute, const char* buf, size_t count).
- Allocation sites: kmalloc_array, kmalloc, kzalloc (and similar kernel heap allocators) producing a buffer from count or fixed size.
- Assignments: writes to fields of structs obtained via container_of on the input kobject (e.g., filter->memcg_path = path).
- Calls: frees (kfree) on the old field value within the function body before reassignment.
- Attribute definitions: __ATTR_* macros pairing name_show/name_store to confirm sysfs context.
- Release methods: ktype .release functions freeing the same field to confirm persistent ownership.

4. Dataflow / Taint Considerations
- Track dataflow from allocation result to the right-hand side of a field assignment on the container object retrieved from kobj.
- Track whether the left-hand side field value is freed within the function prior to the assignment on all feasible paths (path-sensitive).
- Treat the existing field value as the “resource under management” and require an explicit free of that resource before replacement.
- Optionally recognize string copy from buf into the new buffer (e.g., strscpy(path, buf, count + 1)) as supporting evidence.

5. Validation & Test Cases
- Positive: The pre-patch memcg_path_store that allocates with kmalloc_array, copies via strscpy, and assigns filter->memcg_path without kfree; expect a finding referencing memcg_path_store and memcg_path.
- Positive: A hypothetical sysfs store that uses kzalloc to create a new char* and assigns obj->name = p without freeing obj->name; expect a finding.
- Negative: The patched memcg_path_store with kfree(filter->memcg_path) immediately before assignment (PATCH_DIFF); expect no finding.
- Negative: A store function that uses krealloc on obj->buf and reassigns obj->buf with the result; expect no finding.
- Test harness notes: Build minimal kernel-like stubs with kobject/container_of patterns and __ATTR_RW_MODE macros to ensure the signature and attribute linkage are recognized.

6. Estimated Effort & Priority
High effort and priority: requires kernel-specific modeling of sysfs store signatures, heap allocators, and ownership patterns, but addresses a DoS-prone kernel memory leak class.

7. Likely False-Positive Sources & Mitigations
- Fields managed by reference counting or devm/automatic lifetime mechanisms: mitigate by checking for explicit release handlers freeing the field and absence of refcount patterns.
- One-time initialization paths in store functions: mitigate by requiring potential for multiple invocations (sysfs context) and verifying no guaranteed single-assign guard.
- Frees performed in opaque helpers: mitigate by scanning intra-procedural callees for freeing the specific field or flagging with lower confidence when unresolvable.

8. Limitations & Assumptions
- Assumes identification of sysfs store callbacks via signature/name/macros; some store functions may not conform strictly to name conventions.
- Does not prove reachability of repeated writes at runtime; relies on sysfs semantics that store can be invoked multiple times (ROOTCAUSE_ANALYSIS).
- Interprocedural free detection is limited; frees hidden in complex helpers may be missed or cause false positives.
- Allocation API coverage is based on those visible in FILE_CONTENT (kmalloc_array, kmalloc, kzalloc); other allocators may need additional modeling.