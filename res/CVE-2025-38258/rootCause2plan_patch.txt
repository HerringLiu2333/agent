1. Plan Summary
Detect kernel memory leaks where a pointer field is overwritten with a newly allocated buffer without freeing the previously held buffer, as exemplified by memcg_path_store() before the fix in CVE-2025-38258.

2. Detection Steps
1) Step 1: Objective — identify candidate “store-like” handlers likely to be invoked repeatedly (risk amplifier). Signals — functions named *store with signature patterns similar to sysfs store handlers (e.g., taking a kobject-like pointer, a buffer pointer, and a count/size), as seen in memcg_path_store in the patch diff. FP mitigation — treat this as a ranking heuristic; do not require it, but prioritize findings in such functions.

2) Step 2: Objective — find assignments that overwrite a struct field or global pointer with a newly allocated buffer. Signals — detect a local variable receiving a heap allocation followed by an assignment to a pointer field (e.g., filter->memcg_path = path). FP mitigation — require the RHS to be definitely newly allocated in this function (e.g., result of an allocation site tracked to the assignment) to avoid benign pointer reassignments.

3) Step 3: Objective — confirm that the new buffer is populated from external input typical of sysfs writes (strengthens relevance to repeated writes). Signals — a copy from a function parameter buffer into the new allocation via string copy APIs (e.g., strscpy(path, buf, count+1) as shown in the diff). FP mitigation — if no such input copy is evident, still allow detection but lower confidence; prioritize when the copy involves a function parameter named buf and size/count parameter.

4) Step 4: Objective — check for missing deallocation of the old pointer before overwrite. Signals — absence, along the control path immediately preceding the assignment, of an explicit deallocation call on the old field value (e.g., no kfree(filter->memcg_path) before filter->memcg_path = path as added in the patch). FP mitigation — treat a deallocation as satisfying only if it targets the exact old field value (same field and alias) before it is overwritten.

5) Step 5: Objective — ensure the old value could be non-NULL (and thus potentially allocated). Signals — lack of a dominating assignment setting the field to NULL in this function and no proof that the field is always NULL on entry. FP mitigation — boost confidence if the field is used/read earlier or assigned elsewhere in the module; if the field is explicitly set to NULL just before assignment, suppress.

6) Step 6: Objective — verify that the old value is not freed via helper calls indirectly. Signals — scan for calls that pass the old field value to known deallocators; the patch shows explicit kfree as the intended fix. FP mitigation — only treat explicit kfree on the field as a safe free per the patch; if present, suppress the alert.

7) Step 7: Objective — validate that the allocation is fresh and not an alias to the same field (to avoid false “self-assign” reports). Signals — distinct SSA/value identity for the newly allocated pointer before assignment; ensure RHS does not alias the LHS field. FP mitigation — require that the RHS originates from a tracked allocation site in the function.

8) Step 8: Objective — ensure control-flow sensitivity around the assignment. Signals — along all feasible paths reaching the assignment, the field is overwritten and there is no prior free of the old value on those paths. FP mitigation — if some paths free and others don’t, report with reduced confidence or only when a path without free exists that is not dominated by a free.

9) Step 9: Objective — prioritize scenarios that can lead to repeated leaks (DoS risk). Signals — functions likely callable repeatedly by user writes (e.g., store-like handlers copying from buf/count); this matches the root-cause trigger described. FP mitigation — rank these higher; still allow general reports but lower priority when repeated invocation likelihood is unclear.

10) Step 10: Objective — exclude cases where ownership transfer semantics free the old value elsewhere. Signals — absence of patterns where the field is always NULL-initialized and only ever set once in the object’s lifetime within the same function scope. FP mitigation — if object creation/init is evident in the same function and the first assignment occurs under guaranteed NULL state, suppress.

3. Target Elements
- Functions plausibly acting as sysfs store handlers (e.g., name ends with _store, parameters including a buffer and count).
- Allocation sites creating new buffers within a function.
- Assignments to struct fields or global pointers where the RHS is the newly allocated buffer.
- Calls to string copy routines indicating population from input (e.g., strscpy to the new buffer).
- Deallocation call sites (explicit kfree on the old field value).
- Control-flow edges leading to the assignment to assess presence/absence of a prior free.

4. Dataflow / Taint Considerations
- Track dataflow from allocation call result to the assigned RHS pointer.
- Track dataflow from function parameter “buf” (input) into the newly allocated buffer prior to assignment (e.g., via strscpy), to raise confidence of repeated-write relevance.
- Track the old field value (LHS prior value) to identify any deallocation of that exact value along paths reaching the overwrite.
- Ensure alias analysis distinguishes the old field value from the new allocation to avoid misattributing frees.

5. Validation & Test Cases
- Positive: Function memcg_path_store-like example allocating a new buffer, copying from buf/count via strscpy, then assigning field->memcg_path without kfree(field->memcg_path) beforehand; expect a report.
- Negative: Same as above but with kfree(field->memcg_path) immediately before the assignment (as in the patch diff); expect no report.
- Negative: First-time initialization where field is provably NULL (set to NULL then assigned once) and no subsequent writes; expect no report.
- Negative: Overwrite preceded by an explicit kfree on the old field value along all paths; expect no report.
- Test harness notes: Include variants with different control paths (conditional frees), aliasing checks (ensure RHS is a fresh allocation), and functions both named *store and not, to verify prioritization and suppression.

6. Estimated Effort & Priority
Medium effort; High priority due to Denial of Service risk via kernel memory leak on repeated writes, as described in the root cause and patch description.

7. Likely False-Positive Sources & Mitigations
- Indirect deallocation via wrappers not recognized as kfree; mitigation: limit to explicit kfree as per the patch, note as limitation.
- Fields guaranteed to be NULL on overwrite (single-assignment patterns); mitigation: require absence of dominating NULL init before assignment or boost confidence only when repeated-write signals exist.
- One-time setters mistakenly treated as repeated; mitigation: prioritize findings in functions matching store-like signatures and buf/count copy patterns.

8. Limitations & Assumptions
- The detection assumes explicit kfree is the intended deallocator, based on the patch; other deallocation mechanisms (e.g., RCU-based frees or custom wrappers) are not identified.
- The checker cannot conclusively prove invocation frequency; repeated writes are inferred from store-like function patterns (from the patch context) and input copying via strscpy.
- Exact allocation APIs are not enumerated in the provided materials; the plan treats any “newly allocated buffer” abstractly as a heap allocation detected by CodeQL’s kernel allocation models.
- Concurrency and locking behavior are not analyzed; the patch analysis states no locking changes, and the checker focuses solely on memory lifetime at overwrite.