1. Plan Summary
Detect sysfs “store” handlers that allocate a new buffer and overwrite a persistent struct field pointer without first freeing the previous value, causing a kernel memory leak.

2. Detection Steps
1) Step 1: Objective — isolate sysfs store-like handlers. Signals — functions returning ssize_t with parameters (struct kobject*, struct kobj_attribute*, const char* buf, size_t count), and often named *memcg_path_store or *_store (based on FUNCTION_CONTENT). FP mitigation — restrict to this exact signature to model sysfs attribute store paths as in the provided function.

2) Step 2: Objective — confirm the handler manipulates per-attribute state from kobj. Signals — a container_of(kobj, <struct type>, kobj) to obtain a per-attribute struct, and subsequent field accesses via that struct pointer (based on FUNCTION_CONTENT). FP mitigation — require that the field assignment in Step 5 targets a field of this container struct.

3) Step 3: Objective — find newly allocated buffer that could replace the field. Signals — allocation via kmalloc_array with size_add(count, 1) (or equivalent count+1) producing a local pointer used subsequently (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS). FP mitigation — require the allocation variable is a local pointer assigned the allocator’s return value and checked for NULL.

4) Step 4: Objective — confirm the allocation is intended to hold user-supplied data from sysfs. Signals — a copy from buf into the allocated pointer (e.g., strscpy(dst, buf, count+1)) before assignment to the field (based on FUNCTION_CONTENT). FP mitigation — require that the destination of the copy aliases the allocation variable and source aliases the buf parameter.

5) Step 5: Objective — detect the persistent-pointer update. Signals — an assignment of the allocated pointer to a field of the container struct (pattern: container->field = allocated_ptr) on a non-error path (based on FUNCTION_CONTENT). FP mitigation — ensure this assignment post-dominates the copy in Step 4 and is not in a branch that guarantees the field was NULLed immediately prior.

6) Step 6: Objective — check for missing deallocation of the previous field value. Signals — absence of any kfree(container->field) (or an alias thereof) on all control-flow paths that reach the assignment, immediately preceding or dominating the assignment (based on PATCH_DIFF showing kfree(filter->memcg_path) was added). FP mitigation — require dominance analysis: if any feasible path to the assignment does not free container->field beforehand, consider it a leak candidate.

7) Step 7: Objective — avoid cases where the code establishes that the previous value cannot exist. Signals — tests like if (!container->field) or assignments container->field = NULL occurring on all paths leading to the assignment. FP mitigation — if the analysis can prove container->field is always NULL at the assignment, do not report.

8) Step 8: Objective — exclude cases where freeing is delegated to an immediately called helper. Signals — a call to kfree with an argument aliasing container->field, or a thin wrapper that directly calls kfree, in the same basic block or dominating blocks before the assignment. FP mitigation — interprocedural check limited to trivial wrappers around kfree; otherwise, require a direct kfree to minimize FPs (aligned with PATCH_DIFF).

9) Step 9: Objective — prioritize sysfs-store overwrite patterns likely to recur. Signals — function name ends with _store and uses count parameter in allocation and copy (based on FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS describing repeated writes). FP mitigation — score/report only when both allocation size and copy length derive from count to reflect the concrete leak scenario.

3. Target Elements
- Function definitions matching sysfs store signature.
- Calls to container_of involving the kobject parameter.
- Allocation sites using kmalloc_array producing char* locals.
- Calls that copy from buf to the allocated buffer (e.g., strscpy).
- Assignments to struct fields via pointer dereference (container->field = ...).
- Calls to kfree on the same field (or alias) before the assignment.
- Control-flow dominance and path feasibility around the assignment.

4. Dataflow / Taint Considerations
- Track dataflow from kmalloc_array return into a local pointer and then into a struct field assignment.
- Track dataflow from the buf parameter into the allocated pointer via copy functions to confirm sysfs input is being staged for the assignment.
- Track aliasing for the container->field expression to recognize kfree(container->field) and simple aliases thereof before the assignment.
- Use dominance/path analysis to ensure no kfree dominates the assignment on all incoming paths.

5. Validation & Test Cases
- Positive: A function with signature (struct kobject*, struct kobj_attribute*, const char* buf, size_t count) that does kmalloc_array(size_add(count,1)), strscpy(path, buf, count+1), and then container->memcg_path = path with no preceding kfree(container->memcg_path) (matches FUNCTION_CONTENT and ROOTCAUSE_ANALYSIS).
- Negative: Same as above but with kfree(container->memcg_path) immediately before the assignment (matches PATCH_DIFF fix).
- Negative: Store handler that sets container->field = NULL on all paths immediately before first-time assignment, or proves field is NULL via a dominating check before assigning; the checker should not report.
- Test harness notes: Validate control-flow dominance handling by adding branches before the assignment and ensure the checker only flags when at least one path reaches assignment without a prior free of container->field.

6. Estimated Effort & Priority
High — The pattern is well-scoped and high-impact (DoS via kernel memory leak per ROOTCAUSE_ANALYSIS), and the signals are strong (PATCH_DIFF and FUNCTION_CONTENT).

7. Likely False-Positive Sources & Mitigations
- First-time initialization where the field is guaranteed NULL: mitigate via NULL-check/path proof in Step 7.
- Cases where freeing happens in non-trivial helper functions: mitigate by requiring a direct kfree or simple wrapper detection.
- Non-sysfs functions with a similar pattern: mitigate by restricting to the sysfs store signature and buf/count usage.
- Assignments where ownership semantics intentionally discard old value but are freed elsewhere: limit scope to store handlers, which are expected to be repeat-invoked (ROOTCAUSE_ANALYSIS).

8. Limitations & Assumptions
- Assumes sysfs store handlers are identifiable via the exact signature and that they are callable repeatedly (based on ROOTCAUSE_ANALYSIS); the checker cannot prove call frequency.
- Focuses on kmalloc_array + strscpy patterns using count(+1) as in FUNCTION_CONTENT; it may miss alternate allocators/copies not evidenced here.
- Interprocedural freeing beyond simple wrappers is not modeled; complex lifetime protocols outside the function may reduce FPs but are out of scope per provided materials.
- Concurrency/locking semantics are not considered (ROOTCAUSE_ANALYSIS notes no changes there), so races affecting pointer swaps are not analyzed.