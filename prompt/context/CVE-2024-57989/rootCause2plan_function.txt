You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57989

[INFO]
[PATCH_DESCRIPTION]
 wifi: mt76: mt7925: fix NULL deref check in mt7925_change_vif_links
 In mt7925_change_vif_links() devm_kzalloc() may return NULL but this
 returned value is not checked.

 Fixes: 69acd6d910b0 ("wifi: mt76: mt7925: add mt7925_change_vif_links")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/main.c b/drivers/net/wireless/mediatek/mt76/mt7925/main.c
    index 791c8b00e11264..a5110f8485e526 100644
    --- a/drivers/net/wireless/mediatek/mt76/mt7925/main.c
    +++ b/drivers/net/wireless/mediatek/mt76/mt7925/main.c
    @@ -1946,6 +1946,8 @@ mt7925_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
     					     GFP_KERNEL);
     			mlink = devm_kzalloc(dev->mt76.dev, sizeof(*mlink),
     					     GFP_KERNEL);
    +			if (!mconf || !mlink)
    +				return -ENOMEM;
     		}
     
     		mconfs[link_id] = mconf;

[FUNCTION_CONTENT]
static int
mt7925_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
			u16 old_links, u16 new_links,
			struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
{
	struct mt792x_bss_conf *mconfs[IEEE80211_MLD_MAX_NUM_LINKS] = {}, *mconf;
	struct mt792x_link_sta *mlinks[IEEE80211_MLD_MAX_NUM_LINKS] = {}, *mlink;
	struct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;
	unsigned long add = new_links & ~old_links;
	unsigned long rem = old_links & ~new_links;
	struct mt792x_dev *dev = mt792x_hw_dev(hw);
	struct mt792x_phy *phy = mt792x_hw_phy(hw);
	struct ieee80211_bss_conf *link_conf;
	unsigned int link_id;
	int err;

	if (old_links == new_links)
		return 0;

	mt792x_mutex_acquire(dev);

	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
		mconf = mt792x_vif_to_link(mvif, link_id);
		mlink = mt792x_sta_to_link(&mvif->sta, link_id);

		if (!mconf || !mlink)
			continue;

		if (mconf != &mvif->bss_conf) {
			mt792x_mac_link_bss_remove(dev, mconf, mlink);
			devm_kfree(dev->mt76.dev, mconf);
			devm_kfree(dev->mt76.dev, mlink);
		}

		rcu_assign_pointer(mvif->link_conf[link_id], NULL);
		rcu_assign_pointer(mvif->sta.link[link_id], NULL);
	}

	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
		if (!old_links) {
			mvif->deflink_id = link_id;
			mconf = &mvif->bss_conf;
			mlink = &mvif->sta.deflink;
		} else {
			mconf = devm_kzalloc(dev->mt76.dev, sizeof(*mconf),
					     GFP_KERNEL);
			mlink = devm_kzalloc(dev->mt76.dev, sizeof(*mlink),
					     GFP_KERNEL);
		}

		mconfs[link_id] = mconf;
		mlinks[link_id] = mlink;
		mconf->link_id = link_id;
		mconf->vif = mvif;
		mlink->wcid.link_id = link_id;
		mlink->wcid.link_valid = !!vif->valid_links;
		mlink->wcid.def_wcid = &mvif->sta.deflink.wcid;
	}

	if (hweight16(mvif->valid_links) == 0)
		mt792x_mac_link_bss_remove(dev, &mvif->bss_conf,
					   &mvif->sta.deflink);

	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
		mconf = mconfs[link_id];
		mlink = mlinks[link_id];
		link_conf = mt792x_vif_to_bss_conf(vif, link_id);

		rcu_assign_pointer(mvif->link_conf[link_id], mconf);
		rcu_assign_pointer(mvif->sta.link[link_id], mlink);

		err = mt7925_mac_link_bss_add(dev, link_conf, mlink);
		if (err < 0)
			goto free;

		if (mconf != &mvif->bss_conf) {
			err = mt7925_set_mlo_roc(phy, &mvif->bss_conf,
						 vif->active_links);
			if (err < 0)
				goto free;
		}
	}

	mvif->valid_links = new_links;

	mt792x_mutex_release(dev);

	return 0;

free:
	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
		rcu_assign_pointer(mvif->link_conf[link_id], NULL);
		rcu_assign_pointer(mvif->sta.link[link_id], NULL);

		if (mconf != &mvif->bss_conf)
			devm_kfree(dev->mt76.dev, mconfs[link_id]);
		if (mlink != &mvif->sta.deflink)
			devm_kfree(dev->mt76.dev, mlinks[link_id]);
	}

	mt792x_mutex_release(dev);

	return err;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57989

2. Vulnerability Type
NULL pointer dereference due to unchecked memory allocation failure (Denial of Service)

3. Root Cause Summary
mt7925_change_vif_links() allocates per-link structures with devm_kzalloc() when adding new links (non-default case) but does not check for NULL. The function immediately dereferences these pointers (e.g., “mconf->link_id = link_id;” and “mlink->wcid.link_id = link_id;”), causing a NULL pointer dereference if allocation fails. The patch adds explicit NULL checks for both allocations and returns an error code on failure, preventing the dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 mt7925 Wi-Fi driver (drivers/net/wireless/mediatek/mt76/mt7925/main.c), function mt7925_change_vif_links()

2) Pre-Patch Flaw:
In the “add” path for new links (for_each_set_bit over “add”), the code uses devm_kzalloc() to allocate mt792x_bss_conf (mconf) and mt792x_link_sta (mlink) but does not validate the returned pointers before using them. It then writes to these structures and propagates them via RCU pointers and to mt7925_mac_link_bss_add() without ensuring they are non-NULL.

3) Trigger Condition:
- new_links introduces additional links (add = new_links & ~old_links) and old_links != 0 (so allocations are attempted).
- Memory pressure or allocator failure causes devm_kzalloc() to return NULL for mconf or mlink.

4) Impact Mechanism:
The code dereferences mconf and mlink immediately after allocation to set fields and later passes them to other functions, leading to a NULL pointer dereference and kernel crash/oops. This results in denial of service for the system or the Wi-Fi subsystem, potentially triggered by user-space operations that change VIF links under low-memory conditions.

5. Patch Analysis
1) Fix Approach:
Input validation and error handling: after allocating mconf and mlink, the function now checks for NULL and returns -ENOMEM on failure, preventing subsequent dereferences.

2) Key Code Changes:
In mt7925_change_vif_links() “add” loop:
- Added:
  “if (!mconf || !mlink)
      return -ENOMEM;”
This directly addresses the missing NULL checks for devm_kzalloc() results.

3) Locking/Concurrency Impact:
No locking or RCU usage changes are present in the provided diff; the patch solely introduces allocation failure checks. The overall mutex acquisition/release and RCU assignments remain unchanged based on available materials. Any additional locking side-effects are Unknown/Not determinable from the given diff.

6. Broader Kernel Security Implications
Unchecked allocation failures in driver code can convert recoverable low-memory situations into kernel crashes, enabling denial of service. Ensuring all devm_kzalloc() results are validated before use is critical for robustness, especially in code paths influenced by user-space configuration changes. This fix improves the stability of multi-link operations in the Wi-Fi stack and reduces attack surface related to memory pressure-induced failures.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.