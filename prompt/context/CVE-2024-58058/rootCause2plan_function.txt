You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58058

[INFO]
[PATCH_DESCRIPTION]
 wifi: ath11k: fix RCU stall while reaping monitor destination ring
 [ Upstream commit 16c6c35c03ea73054a1f6d3302a4ce4a331b427d ]
 
 While processing the monitor destination ring, MSDUs are reaped from the
 link descriptor based on the corresponding buf_id.
 
 However, sometimes the driver cannot obtain a valid buffer corresponding
 to the buf_id received from the hardware. This causes an infinite loop
 in the destination processing, resulting in a kernel crash.
 
 kernel log:
 ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed
 ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed
 
 Fix this by skipping the problematic buf_id and reaping the next entry,
 replacing the break with the next MSDU processing.

 Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30
 Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1

 Fixes: d5c65159f289 ("ath11k: driver for Qualcomm IEEE 802.11ax devices")

[PATCH_DIFF]
    diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
    index 3f128b9fdfbb23..9613725ed19359 100644
    --- a/fs/ubifs/debug.c
    +++ b/fs/ubifs/debug.c
    @@ -946,16 +946,20 @@ void ubifs_dump_tnc(struct ubifs_info *c)
     
     	pr_err("\n");
     	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
    -	znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
    -	level = znode->level;
    -	pr_err("== Level %d ==\n", level);
    -	while (znode) {
    -		if (level != znode->level) {
    -			level = znode->level;
    -			pr_err("== Level %d ==\n", level);
    -		}
    -		ubifs_dump_znode(c, znode);
    -		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
    +	if (c->zroot.znode) {
    +		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
    +		level = znode->level;
    +		pr_err("== Level %d ==\n", level);
    +		while (znode) {
    +			if (level != znode->level) {
    +				level = znode->level;
    +				pr_err("== Level %d ==\n", level);
    +			}
    +			ubifs_dump_znode(c, znode);
    +			znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
    +		}
    +	} else {
    +		pr_err("empty TNC tree in memory\n");
     	}
     	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
     }

[FUNCTION_CONTENT]
void ubifs_dump_tnc(struct ubifs_info *c)
{
	struct ubifs_znode *znode;
	int level;

	pr_err("\n");
	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
	znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
	level = znode->level;
	pr_err("== Level %d ==\n", level);
	while (znode) {
		if (level != znode->level) {
			level = znode->level;
			pr_err("== Level %d ==\n", level);
		}
		ubifs_dump_znode(c, znode);
		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
	}
	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58058

2. Vulnerability Type
Logic error leading to infinite loop and RCU stall (Denial of Service)

3. Root Cause Summary
The ath11k driver’s RX monitor destination ring processing assumed that every buf_id from hardware maps to a valid buffer. When the driver could not obtain a valid buffer for a buf_id, the loop failed to make forward progress (e.g., breaking out of the inner path and then re-processing the same descriptor), resulting in an infinite loop within the destination processing. This livelock in an RCU context caused an RCU stall and eventual kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ath11k (Qualcomm 802.11ax Wi-Fi driver) data path RX monitor destination ring processing

2) Pre-Patch Flaw:
Invalid/unresolvable buf_id handling lacked a forward-progress path: upon encountering an invalid buf_id, the code did not properly skip/advance to the next MSDU, causing repeated processing of the same entry. Kernel logs show “msdu_pop: invalid buf_id” and “dp_rx_monitor_link_desc_return failed,” indicating the driver repeatedly hits the same invalid buf_id without progressing.

3) Trigger Condition:
Hardware supplies a buf_id that does not correspond to any valid/allocated buffer; the driver cannot retrieve a buffer for that buf_id (as evidenced by logs: “data msdu_pop: invalid buf_id 309”).

4) Impact Mechanism:
The processing loop spins indefinitely on the same descriptor under RCU protection, stalling RCU and leading to a kernel crash/hang (RCU stall). This is a denial-of-service condition.

5. Patch Analysis
1) Fix Approach:
Ensure forward progress by skipping the problematic buf_id and reaping the next entry, replacing the prior break/early-exit behavior with “process next MSDU” logic so the loop advances.

2) Key Code Changes:
Unknown/Not determinable from the provided diff. The [PATCH_DESCRIPTION] states “Fix this by skipping the problematic buf_id and reaping the next entry, replacing the break with the next MSDU processing,” but the [PATCH_DIFF] provided shows unrelated changes in fs/ubifs/debug.c (adding a NULL check for c->zroot.znode in ubifs_dump_tnc), and no ath11k code is included.

3) Locking/Concurrency Impact:
The change removes the livelock within an RCU read-side critical section by guaranteeing loop progress; this prevents RCU stall. No explicit locking/RCU API changes are described, only control-flow changes to ensure the loop advances to the next entry.

6. Broader Kernel Security Implications
Hardware-facing ring-processing loops must guarantee forward progress even on malformed or unexpected inputs; otherwise they can induce livelocks in critical contexts such as RCU, causing system-wide stalls. Robust validation and skip/advance policies for identifiers (buf_id) are essential in drivers to avoid denial-of-service. This case underscores the importance of defensive handling of hardware anomalies and careful control-flow in hot-path loops.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.