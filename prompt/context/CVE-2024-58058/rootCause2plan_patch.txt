You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58058

[INFO]
[PATCH_DESCRIPTION]
 wifi: ath11k: fix RCU stall while reaping monitor destination ring
 [ Upstream commit 16c6c35c03ea73054a1f6d3302a4ce4a331b427d ]
 
 While processing the monitor destination ring, MSDUs are reaped from the
 link descriptor based on the corresponding buf_id.
 
 However, sometimes the driver cannot obtain a valid buffer corresponding
 to the buf_id received from the hardware. This causes an infinite loop
 in the destination processing, resulting in a kernel crash.
 
 kernel log:
 ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed
 ath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309
 ath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failed
 
 Fix this by skipping the problematic buf_id and reaping the next entry,
 replacing the break with the next MSDU processing.

 Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30
 Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1

 Fixes: d5c65159f289 ("ath11k: driver for Qualcomm IEEE 802.11ax devices")

[PATCH_DIFF]
    diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
    index 3f128b9fdfbb23..9613725ed19359 100644
    --- a/fs/ubifs/debug.c
    +++ b/fs/ubifs/debug.c
    @@ -946,16 +946,20 @@ void ubifs_dump_tnc(struct ubifs_info *c)
     
     	pr_err("\n");
     	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
    -	znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
    -	level = znode->level;
    -	pr_err("== Level %d ==\n", level);
    -	while (znode) {
    -		if (level != znode->level) {
    -			level = znode->level;
    -			pr_err("== Level %d ==\n", level);
    -		}
    -		ubifs_dump_znode(c, znode);
    -		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
    +	if (c->zroot.znode) {
    +		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
    +		level = znode->level;
    +		pr_err("== Level %d ==\n", level);
    +		while (znode) {
    +			if (level != znode->level) {
    +				level = znode->level;
    +				pr_err("== Level %d ==\n", level);
    +			}
    +			ubifs_dump_znode(c, znode);
    +			znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
    +		}
    +	} else {
    +		pr_err("empty TNC tree in memory\n");
     	}
     	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58058

2. Vulnerability Type
Denial of service via infinite loop (RCU stall) caused by improper error handling in RX monitor ring processing.

3. Root Cause Summary
The ath11k driver’s monitor destination ring reaping logic failed to correctly handle an invalid buf_id returned by hardware. When no valid buffer could be obtained for a given buf_id, the code did not advance to the next MSDU/ring entry and instead kept reprocessing the same problematic descriptor, resulting in an infinite loop. This tight loop in softirq/NAPI context led to an RCU stall and kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath11k Wi-Fi driver (data path RX monitor destination ring processing).

2) Pre-Patch Flaw:
- Missing robust error handling for invalid buf_id during MSDU pop: on failure, the code did not skip/advance to the next ring entry.
- Control flow used a break/return path that left the problematic descriptor effectively “stuck,” causing the processing loop to revisit the same entry continuously.
- Evidenced by kernel logs: “data msdu_pop: invalid buf_id 309” and “dp_rx_monitor_link_desc_return failed” repeating.

3) Trigger Condition:
Receiving a destination ring entry whose buf_id does not map to a valid buffer (hardware occasionally returns such an invalid buf_id). Once encountered, the loop keeps hitting the same invalid entry.

4) Impact Mechanism:
Continuous reprocessing of the same invalid ring entry creates an infinite loop in the RX monitor processing path, starving RCU and triggering an RCU stall/soft lockup, ultimately leading to a kernel crash.

5. Patch Analysis
1) Fix Approach:
- Skip the problematic buf_id and continue reaping the next MSDU instead of breaking out in a way that leaves the same descriptor to be retried.
- In practice, this changes the error path to advance the ring pointer/state and continue processing, preventing the infinite loop.

2) Key Code Changes:
- Replace the previous break/early-exit on invalid buf_id with logic to:
  - Advance to the next MSDU/ring entry.
  - Continue processing (effectively a “continue” rather than “break”).
- Ensure the link descriptor handling aligns with this advancement so the ring progresses even on error.
(Note: Function names inferred from logs: msdu_pop and dp_rx_monitor_link_desc_return.)

3) Locking/Concurrency Impact:
- No locking primitives or RCU usage semantics were changed.
- The RCU stall is resolved indirectly by eliminating the tight loop that prevented RCU quiescent states; the fix is purely in control flow and error handling during RX ring iteration.

6. Broader Kernel Security Implications
- Demonstrates the importance of defensive handling of hardware-provided indices/identifiers in fast-path drivers; unvalidated or unhandled error cases can escalate to system-wide hangs.
- Highlights that forward progress guarantees (always advancing ring state on error) are critical to prevent livelocks and RCU stalls in networking/driver NAPI contexts.
- Similar monitor/ring-processing paths in other drivers should be reviewed for proper advancement on error conditions to avoid DoS via livelock.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.