You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38301

[INFO]
[PATCH_DESCRIPTION]
    nvmem: zynqmp_nvmem: unbreak driver after cleanup
    Commit 29be47fcd6a0 ("nvmem: zynqmp_nvmem: zynqmp_nvmem_probe cleanup")
    changed the driver to expect the device pointer to be passed as the
    "context", but in nvmem the context parameter comes from nvmem_config.priv
    which is never set - Leading to null pointer exceptions when the device is
    accessed.

[PATCH_DIFF]
    @@ -213,6 +213,7 @@ static int zynqmp_nvmem_probe(struct platform_device *pdev)
     	econfig.word_size = 1;
     	econfig.size = ZYNQMP_NVMEM_SIZE;
     	econfig.dev = dev;
    +	econfig.priv = dev;
     	econfig.add_legacy_fixed_of_cells = true;
     	econfig.reg_read = zynqmp_nvmem_read;
     	econfig.reg_write = zynqmp_nvmem_write;

[FUNCTION_CONTENT]
static int zynqmp_nvmem_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct nvmem_config econfig = {};

	econfig.name = "zynqmp-nvmem";
	econfig.owner = THIS_MODULE;
	econfig.word_size = 1;
	econfig.size = ZYNQMP_NVMEM_SIZE;
	econfig.dev = dev;
	econfig.add_legacy_fixed_of_cells = true;
	econfig.reg_read = zynqmp_nvmem_read;
	econfig.reg_write = zynqmp_nvmem_write;

	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &econfig));
}

/* ----- separator ----- */

MODULE_DEVICE_TABLE(of, zynqmp_nvmem_match);

static int zynqmp_nvmem_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct nvmem_config econfig = {};

	econfig.name = "zynqmp-nvmem";
	econfig.owner = THIS_MODULE;
	econfig.word_size = 1;
	econfig.size = ZYNQMP_NVMEM_SIZE;
	econfig.dev = dev;
	econfig.add_legacy_fixed_of_cells = true;
	econfig.reg_read = zynqmp_nvmem_read;
	econfig.reg_write = zynqmp_nvmem_write;

	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &econfig));
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38301

2. Vulnerability Type
NULL pointer dereference (missing initialization of callback context)

3. Root Cause Summary
A cleanup change made the zynqmp_nvmem driver’s read/write callbacks expect a device context via the nvmem “context” parameter, but zynqmp_nvmem_probe failed to initialize nvmem_config.priv. Since the nvmem framework supplies the callback context from nvmem_config.priv, the callbacks received a NULL pointer and dereferenced it. The patch fixes this by setting econfig.priv = dev before registering the nvmem device.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- NVMEM subsystem, driver: zynqmp_nvmem (Xilinx ZynqMP)

2) Pre-Patch Flaw:
- In zynqmp_nvmem_probe, nvmem_config.priv was never set, while the callbacks (econfig.reg_read = zynqmp_nvmem_read; econfig.reg_write = zynqmp_nvmem_write) were changed to use the context pointer as a device pointer.
- As per the nvmem API, the context passed to reg_read/reg_write is taken from nvmem_config.priv; leaving it unset results in a NULL context.

3) Trigger Condition:
- Any operation that invokes zynqmp_nvmem_read or zynqmp_nvmem_write after device registration (devm_nvmem_register(dev, &econfig))—i.e., when the NVMEM device is accessed.

4) Impact Mechanism:
- The read/write callbacks dereference the context expecting a valid struct device, but receive NULL, causing a NULL pointer dereference and kernel oops/panic (denial of service).

5. Patch Analysis
1) Fix Approach:
- Properly initialize the nvmem context by assigning the device pointer to nvmem_config.priv so callbacks receive a valid context.

2) Key Code Changes:
- In zynqmp_nvmem_probe: added a single line initialization:
  - econfig.priv = dev;
- Context: next to existing initializations (econfig.dev = dev; econfig.reg_read = zynqmp_nvmem_read; econfig.reg_write = zynqmp_nvmem_write).

3) Locking/Concurrency Impact:
- None. The change only sets an immutable context pointer during probe; no locking or ordering adjustments were involved.

6. Broader Kernel Security Implications
- A NULL pointer dereference in a kernel driver enables reliable denial of service whenever the NVMEM device is accessed post-registration. Ensuring nvmem_config.priv is correctly initialized prevents kernel crashes and improves robustness of NVMEM consumers interacting with this driver.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}