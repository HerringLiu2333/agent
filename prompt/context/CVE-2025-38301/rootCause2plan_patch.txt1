You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38301

[INFO]
[PATCH_DESCRIPTION]
    nvmem: zynqmp_nvmem: unbreak driver after cleanup
    Commit 29be47fcd6a0 ("nvmem: zynqmp_nvmem: zynqmp_nvmem_probe cleanup")
    changed the driver to expect the device pointer to be passed as the
    "context", but in nvmem the context parameter comes from nvmem_config.priv
    which is never set - Leading to null pointer exceptions when the device is
    accessed.

[PATCH_DIFF]
    @@ -213,6 +213,7 @@ static int zynqmp_nvmem_probe(struct platform_device *pdev)
     	econfig.word_size = 1;
     	econfig.size = ZYNQMP_NVMEM_SIZE;
     	econfig.dev = dev;
    +	econfig.priv = dev;
     	econfig.add_legacy_fixed_of_cells = true;
     	econfig.reg_read = zynqmp_nvmem_read;
     	econfig.reg_write = zynqmp_nvmem_write;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38301

2. Vulnerability Type
NULL pointer dereference leading to kernel crash/DoS

3. Root Cause Summary
A cleanup change made the zynqmp NVMEM driver’s read/write callbacks expect a device pointer as their “context,” but the NVMEM core supplies that context from nvmem_config.priv. The probe path failed to initialize econfig.priv, so the NVMEM core passed NULL into zynqmp_nvmem_read()/zynqmp_nvmem_write(), and the callbacks dereferenced it. This mismatch between expected context and uninitialized priv resulted in a NULL pointer dereference whenever the NVMEM device was accessed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMEM subsystem, Xilinx ZynqMP NVMEM driver (zynqmp_nvmem)

2) Pre-Patch Flaw:
- API misuse/initialization bug: zynqmp_nvmem_probe did not set econfig.priv to the device pointer after the driver was changed to rely on the context being the device.
- The callbacks were registered (e.g., “econfig.reg_read = zynqmp_nvmem_read; econfig.reg_write = zynqmp_nvmem_write;”) but the corresponding context source (econfig.priv) remained unset (NULL).

3) Trigger Condition:
Any access to the NVMEM device that invokes the registered callbacks, e.g., reading/writing NVMEM cells via the NVMEM framework or device access through sysfs/consumers after the device is probed.

4) Impact Mechanism:
The NVMEM core passes econfig.priv (NULL) as the callback context; zynqmp_nvmem_read()/zynqmp_nvmem_write() dereference this pointer, causing a NULL pointer dereference that leads to a kernel oops/panic (denial of service).

5. Patch Analysis
1) Fix Approach:
Initialize the NVMEM configuration context by setting econfig.priv = dev during probe so the NVMEM core passes a valid device pointer to the callbacks.

2) Key Code Changes:
- In zynqmp_nvmem_probe: added a single line “econfig.priv = dev;” alongside existing initialization (econfig.dev, reg_read, reg_write), ensuring the callback context matches the driver’s expectation.

3) Locking/Concurrency Impact:
None. The change is a one-time initialization of a configuration field; no locking or ordering semantics were added or altered.

6. Broader Kernel Security Implications
- Demonstrates how subtle API contract mismatches (callback context expectations vs. configuration fields) can yield kernel NULL dereferences and system-wide DoS.
- Highlights the need for drivers using the NVMEM framework to correctly initialize nvmem_config.priv when callbacks rely on a non-global context.
- Emphasizes careful review during refactors/cleanups that alter callback expectations, as missing initialization can create crash paths accessible via routine device interactions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}