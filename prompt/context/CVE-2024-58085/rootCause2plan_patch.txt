You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58085

[INFO]
[PATCH_DESCRIPTION]
 tomoyo: don't emit warning in tomoyo_write_control()
 [ Upstream commit 3df7546fc03b8f004eee0b9e3256369f7d096685 ]
 
 syzbot is reporting too large allocation warning at tomoyo_write_control(),
 for one can write a very very long line without new line character. To fix
 this warning, I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZE,
 for practically a valid line should be always shorter than 32KB where the
 "too small to fail" memory-allocation rule applies.

 One might try to write a valid line that is longer than 32KB, but such
 request will likely fail with -ENOMEM. Therefore, I feel that separately
 returning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.
 There is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.

[PATCH_DIFF]
 diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
 index ea3140d510ecbf…e58e265d16578e 100644
 — a/security/tomoyo/common.c
 +++ b/security/tomoyo/common.c
 @@ -2665,7 +2665,7 @@ ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,

 if (head->w.avail >= head->writebuf_size - 1) {
 const int len = head->writebuf_size * 2;
 - char *cp = kzalloc(len, GFP_NOFS);
 + char *cp = kzalloc(len, GFP_NOFS | __GFP_NOWARN);

 if (!cp) {
 error = -ENOMEM;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58085

2. Vulnerability Type
Denial of Service (resource/log flooding due to unbounded buffer growth and large allocations)

3. Root Cause Summary
tomoyo_write_control() dynamically grows its write buffer by doubling head->writebuf_size and allocating a new buffer with kzalloc(len, GFP_NOFS) when head->w.avail >= head->writebuf_size - 1. There was no upper bound on the line length, so writing a very long line without a newline could drive len beyond typical safe sizes and trigger the kernel’s “too large allocation” warnings. The pre-patch logic neither capped the allocation size nor suppressed noisy warn_alloc emissions for such growth attempts. This allows repeated large allocations (and failures) to spam kernel logs and impose memory pressure.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
TOMOYO Linux Security Module (security/tomoyo), control interface handling in security/tomoyo/common.c

2) Pre-Patch Flaw:
Unbounded buffer growth in tomoyo_write_control() using kzalloc(len, GFP_NOFS) with len = head->writebuf_size * 2, lacking a maximum cap or warning suppression. Large allocation attempts due to excessively long input lines cause kernel allocation warnings.

3) Trigger Condition:
Providing a very long line to the TOMOYO control interface without a newline, causing repeated “avail >= writebuf_size - 1” conditions and buffer doubling until allocations exceed typical thresholds (e.g., >32KB, potentially >KMALLOC_MAX_SIZE), which produces “too large allocation” warnings.

4) Impact Mechanism:
Repeated oversized allocations emit kernel warnings and can lead to -ENOMEM, enabling log flooding and potential resource exhaustion that degrades system performance. Privilege requirements for reaching this path are unknown/not determinable from the provided materials.

5. Patch Analysis
1) Fix Approach:
Suppress large-allocation warnings by adding __GFP_NOWARN to the kzalloc flags, relying on natural allocation failure (-ENOMEM) for excessively long lines rather than distinguishing over-32KB versus over-KMALLOC_MAX_SIZE.

2) Key Code Changes:
In tomoyo_write_control(), change kzalloc(len, GFP_NOFS) to kzalloc(len, GFP_NOFS | __GFP_NOWARN), preventing warn_alloc emissions during buffer growth.

3) Locking/Concurrency Impact:
None. The change is limited to allocation flags; no locking or ordering adjustments were made.

6. Broader Kernel Security Implications
Suppressing warn_alloc in this control path prevents attackers or fuzzers from creating warning storms that can clutter logs, impair observability, or consume system resources processing log output. While the change reduces log-based DoS potential, it does not add an explicit upper bound on input length; overly long inputs still fail with -ENOMEM. This emphasizes the importance of controlling user input lengths in privileged interfaces and minimizing noisy failure modes in kernel code paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.