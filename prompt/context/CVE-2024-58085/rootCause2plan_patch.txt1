You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58085

[INFO]
[PATCH_DESCRIPTION]
 tomoyo: don't emit warning in tomoyo_write_control()
 [ Upstream commit 3df7546fc03b8f004eee0b9e3256369f7d096685 ]
 
 syzbot is reporting too large allocation warning at tomoyo_write_control(),
 for one can write a very very long line without new line character. To fix
 this warning, I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZE,
 for practically a valid line should be always shorter than 32KB where the
 "too small to fail" memory-allocation rule applies.

 One might try to write a valid line that is longer than 32KB, but such
 request will likely fail with -ENOMEM. Therefore, I feel that separately
 returning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.
 There is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.

[PATCH_DIFF]
 diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
 index ea3140d510ecbf…e58e265d16578e 100644
 — a/security/tomoyo/common.c
 +++ b/security/tomoyo/common.c
 @@ -2665,7 +2665,7 @@ ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,

 if (head->w.avail >= head->writebuf_size - 1) {
 const int len = head->writebuf_size * 2;
 - char *cp = kzalloc(len, GFP_NOFS);
 + char *cp = kzalloc(len, GFP_NOFS | __GFP_NOWARN);

 if (!cp) {
 error = -ENOMEM;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58085

2. Vulnerability Type
Denial of Service (resource/log flooding due to unbounded buffer growth and large allocations)

3. Root Cause Summary
tomoyo_write_control() dynamically grows its write buffer by doubling head->writebuf_size and allocating a new buffer with kzalloc(len, GFP_NOFS) when head->w.avail >= head->writebuf_size - 1. There was no upper bound on the line length, so writing a very long line without a newline could drive len beyond typical safe sizes and trigger the kernel’s “too large allocation” warnings. The pre-patch logic neither capped the allocation size nor suppressed noisy warn_alloc emissions for such growth attempts. This allows repeated large allocations (and failures) to spam kernel logs and impose memory pressure.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
TOMOYO Linux Security Module (security/tomoyo), control interface handling in security/tomoyo/common.c

2) Pre-Patch Flaw:
Unbounded buffer growth in tomoyo_write_control() using kzalloc(len, GFP_NOFS) with len = head->writebuf_size * 2, lacking a maximum cap or warning suppression. Large allocation attempts due to excessively long input lines cause kernel allocation warnings.

3) Trigger Condition:
Providing a very long line to the TOMOYO control interface without a newline, causing repeated “avail >= writebuf_size - 1” conditions and buffer doubling until allocations exceed typical thresholds (e.g., >32KB, potentially >KMALLOC_MAX_SIZE), which produces “too large allocation” warnings.

4) Impact Mechanism:
Repeated oversized allocations emit kernel warnings and can lead to -ENOMEM, enabling log flooding and potential resource exhaustion that degrades system performance. Privilege requirements for reaching this path are unknown/not determinable from the provided materials.

5. Patch Analysis
1) Fix Approach:
Suppress large-allocation warnings by adding __GFP_NOWARN to the kzalloc flags, relying on natural allocation failure (-ENOMEM) for excessively long lines rather than distinguishing over-32KB versus over-KMALLOC_MAX_SIZE.

2) Key Code Changes:
In tomoyo_write_control(), change kzalloc(len, GFP_NOFS) to kzalloc(len, GFP_NOFS | __GFP_NOWARN), preventing warn_alloc emissions during buffer growth.

3) Locking/Concurrency Impact:
None. The change is limited to allocation flags; no locking or ordering adjustments were made.

6. Broader Kernel Security Implications
Suppressing warn_alloc in this control path prevents attackers or fuzzers from creating warning storms that can clutter logs, impair observability, or consume system resources processing log output. While the change reduces log-based DoS potential, it does not add an explicit upper bound on input length; overly long inputs still fail with -ENOMEM. This emphasizes the importance of controlling user input lengths in privileged interfaces and minimizing noisy failure modes in kernel code paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}