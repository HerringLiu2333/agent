You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58085

[INFO]
[PATCH_DESCRIPTION]
 tomoyo: don't emit warning in tomoyo_write_control()
 [ Upstream commit 3df7546fc03b8f004eee0b9e3256369f7d096685 ]
 
 syzbot is reporting too large allocation warning at tomoyo_write_control(),
 for one can write a very very long line without new line character. To fix
 this warning, I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZE,
 for practically a valid line should be always shorter than 32KB where the
 "too small to fail" memory-allocation rule applies.

 One might try to write a valid line that is longer than 32KB, but such
 request will likely fail with -ENOMEM. Therefore, I feel that separately
 returning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.
 There is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.

[PATCH_DIFF]
 diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
 index ea3140d510ecbf…e58e265d16578e 100644
 — a/security/tomoyo/common.c
 +++ b/security/tomoyo/common.c
 @@ -2665,7 +2665,7 @@ ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,

 if (head->w.avail >= head->writebuf_size - 1) {
 const int len = head->writebuf_size * 2;
 - char *cp = kzalloc(len, GFP_NOFS);
 + char *cp = kzalloc(len, GFP_NOFS | __GFP_NOWARN);

 if (!cp) {
 error = -ENOMEM;

[FUNCTION_CONTENT]
ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,
			     const char __user *buffer, const int buffer_len)
{
	int error = buffer_len;
	size_t avail_len = buffer_len;
	char *cp0;
	int idx;

	if (!head->write)
		return -EINVAL;
	if (mutex_lock_interruptible(&head->io_sem))
		return -EINTR;
	cp0 = head->write_buf;
	head->read_user_buf_avail = 0;
	idx = tomoyo_read_lock();
	/* Read a line and dispatch it to the policy handler. */
	while (avail_len > 0) {
		char c;

		if (head->w.avail >= head->writebuf_size - 1) {
			const int len = head->writebuf_size * 2;
			char *cp = kzalloc(len, GFP_NOFS);

			if (!cp) {
				error = -ENOMEM;
				break;
			}
			memmove(cp, cp0, head->w.avail);
			kfree(cp0);
			head->write_buf = cp;
			cp0 = cp;
			head->writebuf_size = len;
		}
		if (get_user(c, buffer)) {
			error = -EFAULT;
			break;
		}
		buffer++;
		avail_len--;
		cp0[head->w.avail++] = c;
		if (c != '\n')
			continue;
		cp0[head->w.avail - 1] = '\0';
		head->w.avail = 0;
		tomoyo_normalize_line(cp0);
		if (!strcmp(cp0, "reset")) {
			head->w.ns = &tomoyo_kernel_namespace;
			head->w.domain = NULL;
			memset(&head->r, 0, sizeof(head->r));
			continue;
		}
		/* Don't allow updating policies by non manager programs. */
		switch (head->type) {
		case TOMOYO_PROCESS_STATUS:
			/* This does not write anything. */
			break;
		case TOMOYO_DOMAINPOLICY:
			if (tomoyo_select_domain(head, cp0))
				continue;
			fallthrough;
		case TOMOYO_EXCEPTIONPOLICY:
			if (!strcmp(cp0, "select transition_only")) {
				head->r.print_transition_related_only = true;
				continue;
			}
			fallthrough;
		default:
			if (!tomoyo_manager()) {
				error = -EPERM;
				goto out;
			}
		}
		switch (tomoyo_parse_policy(head, cp0)) {
		case -EPERM:
			error = -EPERM;
			goto out;
		case 0:
			switch (head->type) {
			case TOMOYO_DOMAINPOLICY:
			case TOMOYO_EXCEPTIONPOLICY:
			case TOMOYO_STAT:
			case TOMOYO_PROFILE:
			case TOMOYO_MANAGER:
				tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
				break;
			default:
				break;
			}
			break;
		}
	}
out:
	tomoyo_read_unlock(idx);
	mutex_unlock(&head->io_sem);
	return error;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58085

2. Vulnerability Type
Denial of Service via user-triggerable allocator WARN splat (Improper input handling causing large allocation attempts)

3. Root Cause Summary
tomoyo_write_control() grows its write buffer by doubling when reading a line without a newline, and attempts user-controlled large allocations using kzalloc(len, GFP_NOFS) without suppressing allocator warnings. An unprivileged user can feed an extremely long line (no newline), driving len beyond practical limits and causing the allocator to emit “too large allocation” warnings. The missing __GFP_NOWARN flag allows these warnings to be emitted repeatedly, potentially leading to kernel log flooding or system panic when panic_on_warn is enabled. The patch adds __GFP_NOWARN to the allocation to prevent user-controlled warning emission while still returning -ENOMEM on failure.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux Security Module (LSM) TOMOYO, file security/tomoyo/common.c

2) Pre-Patch Flaw:
In tomoyo_write_control(), the buffer expansion path allocates with kzalloc(len, GFP_NOFS) as len doubles for long lines, with no suppression of allocator warnings. This allows a user to trigger “too large allocation” warnings from the page allocator by sending excessively long input without a newline.

3) Trigger Condition:
Write to TOMOYO control interface a very long line lacking a newline, causing repeated buffer growth attempts: when head->w.avail >= head->writebuf_size - 1, len = head->writebuf_size * 2; char *cp = kzalloc(len, GFP_NOFS); This eventually hits large allocations that the allocator warns about.

4) Impact Mechanism:
Allocator emits warnings on failure for large allocations; users can repeatedly trigger these warnings, resulting in kernel log flooding or system panic under panic_on_warn, constituting a denial-of-service.

5. Patch Analysis
1) Fix Approach:
Suppress allocator warnings for the user-controlled large allocation by adding __GFP_NOWARN to kzalloc flags, maintaining failure behavior (return -ENOMEM) without generating WARN splats.

2) Key Code Changes:
In tomoyo_write_control():
- Pre-patch: char *cp = kzalloc(len, GFP_NOFS);
- Post-patch: char *cp = kzalloc(len, GFP_NOFS | __GFP_NOWARN);
No other logic or length checks were added or removed in the provided hunk.

3) Locking/Concurrency Impact:
No changes to locking or concurrency. Existing mutex_lock_interruptible(&head->io_sem) and tomoyo_read_lock()/tomoyo_read_unlock() remain unchanged; the patch only alters allocation flags.

6. Broader Kernel Security Implications
Suppressing allocator warnings prevents unprivileged users from inducing kernel WARN splats via TOMOYO control writes, reducing the risk of log flooding and panic-on-warn triggered reboots. This improves robustness of LSM control pathways against user-triggered DoS vectors while preserving correct error handling (-ENOMEM) for oversized inputs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.