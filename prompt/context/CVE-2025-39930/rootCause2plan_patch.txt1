You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-39930

[INFO]
[PATCH_DESCRIPTION]
    ASoC: simple-card-utils: Don't use __free(device_node) at graph_util_parse_dai()
    commit 419d1918105e ("ASoC: simple-card-utils: use __free(device_node) for
    device node") uses __free(device_node) for dlc->of_node, but we need to
    keep it while driver is in use.
    
    Don't use __free(device_node) in graph_util_parse_dai().

[PATCH_DIFF]
    @@ -1077,6 +1077,7 @@ static int graph_get_dai_id(struct device_node *ep)
     int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     			 struct snd_soc_dai_link_component *dlc, int *is_single_link)
     {
    +	struct device_node *node;
     	struct of_phandle_args args = {};
     	struct snd_soc_dai *dai;
     	int ret;
    @@ -1084,7 +1085,7 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	if (!ep)
     		return 0;
     
    -	struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);
    +	node = of_graph_get_port_parent(ep);
     
     	/*
     	 * Try to find from DAI node
    @@ -1126,8 +1127,10 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	 *    if he unbinded CPU or Codec.
     	 */
     	ret = snd_soc_get_dlc(&args, dlc);
    -	if (ret < 0)
    +	if (ret < 0) {
    +		of_node_put(node);
     		return ret;
    +	}
     
     parse_dai_end:
     	if (is_single_link)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39930

2. Vulnerability Type
Use-after-free due to incorrect lifetime/refcount management (dangling pointer)

3. Root Cause Summary
The function graph_util_parse_dai() used the __free(device_node) attribute on a local device_node pointer, causing an automatic of_node_put() at function exit. This prematurely dropped the reference to the OF device node that was handed off to dlc->of_node for use by the driver, leaving dlc->of_node pointing to a freed or invalid node. The bug is a lifetime/refcount mismanagement: the node must remain valid while the driver is in use, but the auto-free caused it to be released too early.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA System-on-Chip), simple-card-utils, device tree graph DAI parsing

2) Pre-Patch Flaw:
In graph_util_parse_dai(), the line “struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);” ensures node is automatically put at scope exit, even when its reference is stored in dlc->of_node. This results in a dangling pointer in dlc when the function returns successfully, because the driver still expects to use that node reference.

3) Trigger Condition:
Callers that invoke graph_util_parse_dai() with a valid endpoint and subsequently use dlc->of_node after the function returns. The success path is particularly problematic because __free causes of_node_put() unconditionally when the function exits, while dlc retains the pointer.

4) Impact Mechanism:
The premature of_node_put() frees or invalidates the device node, causing dlc->of_node to become a dangling pointer. Subsequent accesses by the driver or ASoC core to dlc->of_node can lead to use-after-free, memory corruption, or crashes.

5. Patch Analysis
1) Fix Approach:
Remove the __free(device_node) attribute from the local node pointer to preserve the reference beyond the function’s scope when dlc consumes it. Add an explicit of_node_put(node) only on error paths to avoid leaks while preventing premature release on success.

2) Key Code Changes:
- Replace “struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);” with “node = of_graph_get_port_parent(ep);” to stop automatic freeing.
- Add explicit “of_node_put(node);” when snd_soc_get_dlc(&args, dlc) returns < 0, ensuring proper cleanup on failure without affecting the success lifetime.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix strictly adjusts reference counting and lifetime management for device_node. RCU/locks are not implicated in the patch hunks.

6. Broader Kernel Security Implications
Automatic cleanup semantics (such as __free) can be dangerous when pointers are handed off to external structures that outlive the local scope. Correct device node reference management is critical across ASoC and DT subsystems to prevent UAF and memory corruption. This change reinforces the importance of explicit lifetime control when sharing references with long-lived driver structures.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}