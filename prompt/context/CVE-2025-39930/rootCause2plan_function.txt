You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-39930

[INFO]
[PATCH_DESCRIPTION]
    ASoC: simple-card-utils: Don't use __free(device_node) at graph_util_parse_dai()
    commit 419d1918105e ("ASoC: simple-card-utils: use __free(device_node) for
    device node") uses __free(device_node) for dlc->of_node, but we need to
    keep it while driver is in use.
    
    Don't use __free(device_node) in graph_util_parse_dai().

[PATCH_DIFF]
    @@ -1077,6 +1077,7 @@ static int graph_get_dai_id(struct device_node *ep)
     int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     			 struct snd_soc_dai_link_component *dlc, int *is_single_link)
     {
    +	struct device_node *node;
     	struct of_phandle_args args = {};
     	struct snd_soc_dai *dai;
     	int ret;
    @@ -1084,7 +1085,7 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	if (!ep)
     		return 0;
     
    -	struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);
    +	node = of_graph_get_port_parent(ep);
     
     	/*
     	 * Try to find from DAI node
    @@ -1126,8 +1127,10 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	 *    if he unbinded CPU or Codec.
     	 */
     	ret = snd_soc_get_dlc(&args, dlc);
    -	if (ret < 0)
    +	if (ret < 0) {
    +		of_node_put(node);
     		return ret;
    +	}
     
     parse_dai_end:
     	if (is_single_link)

[FUNCTION_CONTENT]
int graph_util_parse_dai(struct device *dev, struct device_node *ep,
			 struct snd_soc_dai_link_component *dlc, int *is_single_link)
{
	struct of_phandle_args args = {};
	struct snd_soc_dai *dai;
	int ret;

	if (!ep)
		return 0;

	struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);

	/*
	 * Try to find from DAI node
	 */
	args.np = ep;
	dai = snd_soc_get_dai_via_args(&args);
	if (dai) {
		dlc->of_node  = node;
		dlc->dai_name = snd_soc_dai_name_get(dai);
		dlc->dai_args = snd_soc_copy_dai_args(dev, &args);
		if (!dlc->dai_args)
			return -ENOMEM;

		goto parse_dai_end;
	}

	/* Get dai->name */
	args.np		= node;
	args.args[0]	= graph_get_dai_id(ep);
	args.args_count	= (of_graph_get_endpoint_count(node) > 1);

	/*
	 * FIXME
	 *
	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
	 * If user unbinded CPU or Codec driver, but not for Sound Card,
	 * dlc->dai_name is keeping unbinded CPU or Codec
	 * driver's pointer.
	 *
	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
	 * to rebind Card via snd_soc_try_rebind_card(), but because of
	 * above reason, it might can't bind Sound Card.
	 * Because Sound Card is pointing to released dai_name pointer.
	 *
	 * To avoid this rebind Card issue,
	 * 1) It needs to alloc memory to keep dai_name eventhough
	 *    CPU or Codec driver was unbinded, or
	 * 2) user need to rebind Sound Card everytime
	 *    if he unbinded CPU or Codec.
	 */
	ret = snd_soc_get_dlc(&args, dlc);
	if (ret < 0)
		return ret;

parse_dai_end:
	if (is_single_link)
		*is_single_link = of_graph_get_endpoint_count(node) == 1;

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39930

2. Vulnerability Type
Use-after-free due to premature refcount decrement (lifetime/refcount bug on device_node)

3. Root Cause Summary
graph_util_parse_dai() stored the parent device_node into dlc->of_node for use by the driver, but declared the local variable with "__free(device_node)", causing of_node_put() to be called automatically at function exit. This prematurely drops the reference while dlc->of_node still points to the node, leaving a dangling pointer. Subsequent use of dlc->of_node by the ASoC card/links can dereference a freed device_node, leading to use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA SoC (ASoC) simple-card-utils, device-tree graph DAI parsing

2) Pre-Patch Flaw:
In graph_util_parse_dai(), the line "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);" ensures node is put at scope end, even when assigned to dlc->of_node for longer-term use. No compensating of_node_get() or retention was performed to keep the node alive beyond the function’s scope.

3) Trigger Condition:
- ep is non-NULL and graph_util_parse_dai() returns success.
- dlc->of_node is set to node, and the function exits, triggering the auto of_node_put from __free(device_node).
- Later operations in the driver/card use dlc->of_node (e.g., link handling), while the node may already have been freed.

4) Impact Mechanism:
The auto of_node_put decreases the reference count of the device_node to zero, allowing it to be freed. dlc->of_node then becomes a dangling pointer; dereferencing it can cause use-after-free, leading to crashes or memory corruption in kernel space.

5. Patch Analysis
1) Fix Approach:
Remove the "__free(device_node)" cleanup attribute from the local node variable to prevent automatic of_node_put at function exit, thereby retaining the reference for dlc->of_node on success. Add an explicit of_node_put(node) on the error path to avoid leaks when snd_soc_get_dlc() fails.

2) Key Code Changes:
- Replaced "struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);" with "node = of_graph_get_port_parent(ep);".
- Added explicit "of_node_put(node);" before returning when "ret < 0" after snd_soc_get_dlc(&args, dlc) fails.
- No changes to successful path; dlc->of_node continues to reference node, now without being prematurely put.

3) Locking/Concurrency Impact:
No locking changes. The fix corrects device_node refcount handling, eliminating a race where premature put could free the node while other users (via dlc->of_node) still access it. Ensures proper lifetime management without introducing new synchronization primitives.

6. Broader Kernel Security Implications
This issue highlights the risk of using automatic cleanup attributes with refcounted kernel objects when pointers escape the local scope. Premature refcount drops can lead to subtle use-after-free bugs that are hard to reproduce and diagnose, especially under concurrent device unbind/rebind or graph reconfiguration. Ensuring explicit, context-aware refcount management is critical in subsystems relying on device-tree nodes and shared structures to prevent kernel memory safety violations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.