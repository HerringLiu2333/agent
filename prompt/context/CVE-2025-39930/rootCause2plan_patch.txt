You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-39930

[INFO]
[PATCH_DESCRIPTION]
    ASoC: simple-card-utils: Don't use __free(device_node) at graph_util_parse_dai()
    commit 419d1918105e ("ASoC: simple-card-utils: use __free(device_node) for
    device node") uses __free(device_node) for dlc->of_node, but we need to
    keep it while driver is in use.
    
    Don't use __free(device_node) in graph_util_parse_dai().

[PATCH_DIFF]
    @@ -1077,6 +1077,7 @@ static int graph_get_dai_id(struct device_node *ep)
     int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     			 struct snd_soc_dai_link_component *dlc, int *is_single_link)
     {
    +	struct device_node *node;
     	struct of_phandle_args args = {};
     	struct snd_soc_dai *dai;
     	int ret;
    @@ -1084,7 +1085,7 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	if (!ep)
     		return 0;
     
    -	struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);
    +	node = of_graph_get_port_parent(ep);
     
     	/*
     	 * Try to find from DAI node
    @@ -1126,8 +1127,10 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
     	 *    if he unbinded CPU or Codec.
     	 */
     	ret = snd_soc_get_dlc(&args, dlc);
    -	if (ret < 0)
    +	if (ret < 0) {
    +		of_node_put(node);
     		return ret;
    +	}
     
     parse_dai_end:
     	if (is_single_link)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39930

2. Vulnerability Type
Use-after-free due to incorrect lifetime/refcount management (dangling pointer)

3. Root Cause Summary
The function graph_util_parse_dai() used the __free(device_node) attribute on a local device_node pointer, causing an automatic of_node_put() at function exit. This prematurely dropped the reference to the OF device node that was handed off to dlc->of_node for use by the driver, leaving dlc->of_node pointing to a freed or invalid node. The bug is a lifetime/refcount mismanagement: the node must remain valid while the driver is in use, but the auto-free caused it to be released too early.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA System-on-Chip), simple-card-utils, device tree graph DAI parsing

2) Pre-Patch Flaw:
In graph_util_parse_dai(), the line “struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);” ensures node is automatically put at scope exit, even when its reference is stored in dlc->of_node. This results in a dangling pointer in dlc when the function returns successfully, because the driver still expects to use that node reference.

3) Trigger Condition:
Callers that invoke graph_util_parse_dai() with a valid endpoint and subsequently use dlc->of_node after the function returns. The success path is particularly problematic because __free causes of_node_put() unconditionally when the function exits, while dlc retains the pointer.

4) Impact Mechanism:
The premature of_node_put() frees or invalidates the device node, causing dlc->of_node to become a dangling pointer. Subsequent accesses by the driver or ASoC core to dlc->of_node can lead to use-after-free, memory corruption, or crashes.

5. Patch Analysis
1) Fix Approach:
Remove the __free(device_node) attribute from the local node pointer to preserve the reference beyond the function’s scope when dlc consumes it. Add an explicit of_node_put(node) only on error paths to avoid leaks while preventing premature release on success.

2) Key Code Changes:
- Replace “struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);” with “node = of_graph_get_port_parent(ep);” to stop automatic freeing.
- Add explicit “of_node_put(node);” when snd_soc_get_dlc(&args, dlc) returns < 0, ensuring proper cleanup on failure without affecting the success lifetime.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix strictly adjusts reference counting and lifetime management for device_node. RCU/locks are not implicated in the patch hunks.

6. Broader Kernel Security Implications
Automatic cleanup semantics (such as __free) can be dangerous when pointers are handed off to external structures that outlive the local scope. Correct device node reference management is critical across ASoC and DT subsystems to prevent UAF and memory corruption. This change reinforces the importance of explicit lifetime control when sharing references with long-lived driver structures.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.