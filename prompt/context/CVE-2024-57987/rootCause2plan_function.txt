You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57987

[INFO]
[PATCH_DESCRIPTION]
 Bluetooth: btrtl: check for NULL in btrtl_setup_realtek()
 If insert an USB dongle which chip is not maintained in ic_id_table, it
 will hit the NULL point accessed. Add a null point check to avoid the
 Kernel Oops.

 Fixes: b39910bb54d9 ("Bluetooth: Populate hci_set_hw_info for Intel and Realtek")

[PATCH_DIFF]
 diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
 index 83025f457ca044…d3eba0d4a57d3b 100644
 --- a/drivers/bluetooth/btrtl.c
 +++ b/drivers/bluetooth/btrtl.c
 @@ -1351,12 +1351,14 @@ int btrtl_setup_realtek(struct hci_dev *hdev)

   btrtl_set_quirks(hdev, btrtl_dev);

 - hci_set_hw_info(hdev,
 + if (btrtl_dev->ic_info) {
 + hci_set_hw_info(hdev,
   "RTL lmp_subver=%u hci_rev=%u hci_ver=%u hci_bus=%u",
   btrtl_dev->ic_info->lmp_subver,
   btrtl_dev->ic_info->hci_rev,
   btrtl_dev->ic_info->hci_ver,
   btrtl_dev->ic_info->hci_bus);
 + }

   btrtl_free(btrtl_dev);
   return ret;

[FUNCTION_CONTENT]
int btrtl_setup_realtek(struct hci_dev *hdev)
{
	struct btrtl_device_info *btrtl_dev;
	int ret;

	btrtl_dev = btrtl_initialize(hdev, NULL);
	if (IS_ERR(btrtl_dev))
		return PTR_ERR(btrtl_dev);

	ret = btrtl_download_firmware(hdev, btrtl_dev);

	btrtl_set_quirks(hdev, btrtl_dev);

	hci_set_hw_info(hdev,
			"RTL lmp_subver=%u hci_rev=%u hci_ver=%u hci_bus=%u",
			btrtl_dev->ic_info->lmp_subver,
			btrtl_dev->ic_info->hci_rev,
			btrtl_dev->ic_info->hci_ver,
			btrtl_dev->ic_info->hci_bus);

	btrtl_free(btrtl_dev);
	return ret;
}

/* ----- separator ----- */

EXPORT_SYMBOL_GPL(btrtl_set_quirks);

int btrtl_setup_realtek(struct hci_dev *hdev)
{
	struct btrtl_device_info *btrtl_dev;
	int ret;

	btrtl_dev = btrtl_initialize(hdev, NULL);
	if (IS_ERR(btrtl_dev))
		return PTR_ERR(btrtl_dev);

	ret = btrtl_download_firmware(hdev, btrtl_dev);

	btrtl_set_quirks(hdev, btrtl_dev);

	hci_set_hw_info(hdev,
			"RTL lmp_subver=%u hci_rev=%u hci_ver=%u hci_bus=%u",
			btrtl_dev->ic_info->lmp_subver,
			btrtl_dev->ic_info->hci_rev,
			btrtl_dev->ic_info->hci_ver,
			btrtl_dev->ic_info->hci_bus);

	btrtl_free(btrtl_dev);
	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57987

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (Denial of Service)

3. Root Cause Summary
btrtl_setup_realtek() unconditionally dereferenced btrtl_dev->ic_info fields when populating hardware info via hci_set_hw_info(), without verifying that ic_info was non-NULL. For Realtek chips not present in the ic_id_table, btrtl_dev->ic_info could be NULL, causing a NULL pointer dereference during argument evaluation. The patch adds a NULL check to guard the hci_set_hw_info() call, preventing dereference when ic_info is absent.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Bluetooth subsystem, Realtek USB HCI driver (drivers/bluetooth/btrtl.c)

2) Pre-Patch Flaw:
- In btrtl_setup_realtek(), the code unconditionally executed:
  hci_set_hw_info(hdev, "...", btrtl_dev->ic_info->lmp_subver, ...)
  without validating btrtl_dev->ic_info, assuming it was always initialized.

3) Trigger Condition:
- Inserting a Realtek USB Bluetooth dongle whose chip is not maintained in the ic_id_table, causing btrtl_initialize() to produce a btrtl_device_info with ic_info == NULL, followed by the unguarded call to hci_set_hw_info().

4) Impact Mechanism:
- Evaluating btrtl_dev->ic_info->{lmp_subver,hci_rev,hci_ver,hci_bus} dereferences a NULL pointer, leading to a kernel oops and potential system panic (DoS).

5. Patch Analysis
1) Fix Approach:
- Introduce a defensive NULL check around the hci_set_hw_info() call so that hardware info is only populated when btrtl_dev->ic_info is non-NULL.

2) Key Code Changes:
- Replace the unconditional call:
  hci_set_hw_info(hdev, "...", btrtl_dev->ic_info->lmp_subver, ...)
  with:
  if (btrtl_dev->ic_info) {
      hci_set_hw_info(hdev, "...", btrtl_dev->ic_info->lmp_subver, ...);
  }
- This directly eliminates the possibility of dereferencing a NULL ic_info.

3) Locking/Concurrency Impact:
- None. No locks or ordering were changed; the fix is purely a NULL pointer guard around a read-only operation.

6. Broader Kernel Security Implications
- Validating device-specific metadata before use is critical when handling diverse or unrecognized hardware; failing to do so allows external devices to trigger kernel oops. This change hardens probe/setup paths against malformed or unsupported Realtek chips and reduces the attack surface for physical DoS via USB. Similar NULL checks should be audited in other Bluetooth vendor drivers and initialization paths where optional hardware info structures may be absent.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.