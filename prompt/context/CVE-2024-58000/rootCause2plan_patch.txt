You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58000

[INFO]
[PATCH_DESCRIPTION]
 io_uring: prevent reg-wait speculations
 [ Upstream commit 29b95ac917927ce9f95bf38797e16333ecb489b1 ]
 
 With *ENTER_EXT_ARG_REG instead of passing a user pointer with arguments
 for the waiting loop the user can specify an offset into a pre-mapped
 region of memory, in which case the
 [offset, offset + sizeof(io_uring_reg_wait)) will be intepreted as the
 argument.

 As we address a kernel array using a user given index, it'd be a subject
 to speculation type of exploits. Use array_index_nospec() to prevent
 that. Make sure to pass not the full region size but truncate by the
 maximum offset allowed considering the structure size.

 Fixes: d617b3147d54c ("io_uring: restore back registered wait arguments")
 Fixes: aa00f67adc2c0 ("io_uring: add support for fixed wait regions")

[PATCH_DIFF]
    diff --git a/io_uring/io_uring.c b/io_uring/io_uring.c
    index 4758f1ba902b94..d062c5c69211ba 100644
    --- a/io_uring/io_uring.c
    +++ b/io_uring/io_uring.c
    @@ -3233,6 +3233,7 @@ static struct io_uring_reg_wait *io_get_ext_arg_reg(struct io_ring_ctx *ctx,
     		     end > ctx->cq_wait_size))
     		return ERR_PTR(-EFAULT);
     
    +	offset = array_index_nospec(offset, ctx->cq_wait_size - size);
     	return ctx->cq_wait_arg + offset;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58000

2. Vulnerability Type
Speculative execution (Spectre v1) gadget via user-controlled array index leading to speculative out-of-bounds access and potential information disclosure.

3. Root Cause Summary
The function io_get_ext_arg_reg used a user-controlled offset to index into a kernel array (ctx->cq_wait_arg) after a bounds check, but did not apply array_index_nospec to prevent speculative bypass of that check. Under mispredicted branches, speculative execution could compute ctx->cq_wait_arg + offset beyond the intended bounds. Additionally, the effective masking limit was conceptually wrong if nospec is applied—masking must consider the structure size (sizeof(io_uring_reg_wait)), not the full region size, to keep [offset, offset + size) within bounds. The patch adds array_index_nospec(offset, ctx->cq_wait_size - size) to constrain the index during speculation and ensures the limit accounts for the structure size.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
io_uring core (io_uring/io_uring.c), registered wait arguments handling.

2) Pre-Patch Flaw:
io_get_ext_arg_reg performed range checks on offset/end but then directly returned ctx->cq_wait_arg + offset. The absence of array_index_nospec allowed speculative execution to use an out-of-bounds user-controlled index despite the bounds check, creating a Spectre v1 gadget.

3) Trigger Condition:
A user invokes ENTER_EXT_ARG_REG and supplies an offset into a pre-mapped fixed wait region such that offset or offset + sizeof(io_uring_reg_wait) approaches/exceeds ctx->cq_wait_size, inducing a branch misprediction and speculative OOB indexing into ctx->cq_wait_arg.

4) Impact Mechanism:
Speculative OOB access via ctx->cq_wait_arg + offset can touch unintended kernel memory, enabling side-channel leakage (e.g., cache-based) of kernel data or serving as a gadget in broader Spectre-style attacks.

5. Patch Analysis
1) Fix Approach:
Introduce array_index_nospec to sanitize the user-controlled offset against speculative execution and compute the nospec limit as ctx->cq_wait_size - sizeof(io_uring_reg_wait), ensuring the argument span remains within bounds.

2) Key Code Changes:
- In io_get_ext_arg_reg:
  Added: offset = array_index_nospec(offset, ctx->cq_wait_size - size);
  The function continues to return ctx->cq_wait_arg + offset, but now with a nospec-masked index that accounts for the structure size.

3) Locking/Concurrency Impact:
None. The patch does not change locking, ordering, or concurrency primitives; it solely adds nospec index masking.

6. Broader Kernel Security Implications
Applying array_index_nospec to user-influenced array indices in kernel code reduces Spectre v1 attack surface by preventing speculative OOB accesses. Ensuring limits incorporate structure sizes avoids partial-structure overreach in speculative paths. This hardening in io_uring protects against side-channel leaks and should be mirrored in other paths that use user-controlled indices to access kernel arrays or fixed regions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.