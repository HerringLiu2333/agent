You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38329

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test (wmfw info)
    KASAN reported out of bounds access - cs_dsp_mock_wmfw_add_info(),
    because the source string length was rounded up to the allocation size.

[PATCH_DIFF]
    @@ -133,10 +133,11 @@ void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
     
     	if (info_len % 4) {
     		/* Create a padded string with length a multiple of 4 */
    +		size_t copy_len = info_len;
     		info_len = round_up(info_len, 4);
     		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
     		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
    -		memcpy(tmp, info, info_len);
    +		memcpy(tmp, info, copy_len);
     		info = tmp;
     	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38329

2. Vulnerability Type
Out-of-bounds memory read

3. Root Cause Summary
In cs_dsp_mock_wmfw_add_info, when the info string length was not a multiple of 4, the code rounded info_len up to the padded allocation size and then used this enlarged value as the memcpy length. This caused memcpy to read past the end of the original source buffer (“info”), resulting in an out-of-bounds read. The flaw stems from conflating destination padded length with the actual source data length.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test code, wmfw info handling)

2) Pre-Patch Flaw:
After rounding up info_len to a multiple of 4 and allocating a zeroed buffer of that size, the code performed memcpy(tmp, info, info_len), where info_len had been increased. Evidence: the pre-patch line “memcpy(tmp, info, info_len)” immediately follows “info_len = round_up(info_len, 4);”.

3) Trigger Condition:
When info_len % 4 != 0, the padded path executes and info_len is increased; memcpy then reads the rounded-up number of bytes from the original info pointer, exceeding its actual length.

4) Impact Mechanism:
Out-of-bounds read from the source buffer “info” during memcpy; KASAN reports OOB access. Potential to read adjacent memory beyond the string’s actual bounds (information exposure or fault), though in this KUnit context it manifests as a detected OOB read.

5. Patch Analysis
1) Fix Approach:
Decouple the source copy length from the padded destination size: capture the original info_len as copy_len before rounding, allocate using the rounded length, and copy only copy_len bytes.

2) Key Code Changes:
- Introduced size_t copy_len = info_len prior to rounding.
- Maintained padding behavior: info_len = round_up(info_len, 4) and kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL) for destination.
- Changed memcpy to use memcpy(tmp, info, copy_len) instead of the rounded info_len, leaving the padded tail zero-initialized.

3) Locking/Concurrency Impact:
None. The change addresses a bounds/length misuse in a local memcpy; no locking, RCU, or ordering modifications were involved.

6. Broader Kernel Security Implications
This fix removes an OOB read pattern that could otherwise lead to memory disclosure or stability issues if similar logic existed outside test code. It reinforces correct handling of padded allocations by ensuring copy lengths reflect source data size, a common pitfall in alignment/padding routines. Ensuring separation of source length from destination padding is broadly applicable to prevent OOB reads in firmware and DSP-related data handling paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.