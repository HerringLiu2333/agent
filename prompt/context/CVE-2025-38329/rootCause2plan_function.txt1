You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38329

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test (wmfw info)
    KASAN reported out of bounds access - cs_dsp_mock_wmfw_add_info(),
    because the source string length was rounded up to the allocation size.

[PATCH_DIFF]
    @@ -133,10 +133,11 @@ void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
     
     	if (info_len % 4) {
     		/* Create a padded string with length a multiple of 4 */
    +		size_t copy_len = info_len;
     		info_len = round_up(info_len, 4);
     		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
     		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
    -		memcpy(tmp, info, info_len);
    +		memcpy(tmp, info, copy_len);
     		info = tmp;
     	}

[FUNCTION_CONTENT]
void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
			       const char *info)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_wmfw_add_raw_block(builder, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */


	KUNIT_ASSERT_TRUE(builder->test_priv->test,
			  (builder->write_p + bytes_needed) <
			  (builder->buf + CS_DSP_MOCK_WMFW_BUF_SIZE));

	header->offset = cpu_to_le32(offset | (block_type << 24));
	header->len = cpu_to_le32(payload_len_bytes);
	if (payload_len_bytes > 0)
		memcpy(header->data, payload_data, payload_len_bytes);

	builder->write_p += bytes_needed;
	builder->bytes_used += bytes_needed;
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_wmfw_add_raw_block, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_wmfw_add_info() - Add an info block to the wmfw file.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 * @info:	Pointer to info string to be copied into the file.
 *
 * The string will be padded to a length that is a multiple of 4 bytes.
 */
void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
			       const char *info)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_wmfw_add_raw_block(builder, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */

EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_wmfw_add_raw_block, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_wmfw_add_info() - Add an info block to the wmfw file.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 * @info:	Pointer to info string to be copied into the file.
 *
 * The string will be padded to a length that is a multiple of 4 bytes.
 */
void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
			       const char *info)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_wmfw_add_raw_block(builder, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */

		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_wmfw_add_raw_block(builder, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_wmfw_add_info, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_wmfw_add_data_block() - Add a data block to the wmfw file.
 *
 * @builder:		  Pointer to struct cs_dsp_mock_bin_builder.
 * @mem_region:		  Memory region for the block.
 * @mem_offset_dsp_words: Offset to start of destination in DSP words.
 * @payload_data:	  Pointer to buffer containing the payload data.
 * @payload_len_bytes:	  Length of payload data in bytes.
 */
void cs_dsp_mock_wmfw_add_data_block(struct cs_dsp_mock_wmfw_builder *builder,
				     int mem_region, unsigned int mem_offset_dsp_words,
				     const void *payload_data, size_t payload_len_bytes)
{
	/* Blob payload length must be a multiple of 4 */
	KUNIT_ASSERT_EQ(builder->test_priv->test, payload_len_bytes % 4, 0);

	cs_dsp_mock_wmfw_add_raw_block(builder, mem_region, mem_offset_dsp_words,
				       payload_data, payload_len_bytes);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38329

2. Vulnerability Type
Out-of-bounds read due to incorrect length handling during memory copy

3. Root Cause Summary
In cs_dsp_mock_wmfw_add_info(), the code rounded up the string length to a 4-byte boundary for padding and then used this inflated length as the source size in memcpy(tmp, info, info_len). This reused, padded length exceeded the actual source string length (computed by strlen), causing memcpy to read past the end of the source buffer. The destination buffer was zero-initialized and sized to the padded length, so the overflow occurred on the read side, not the write side. The patch separates the original length from the padded length and uses the original (pre-rounded) length for the memcpy, preventing the OOB read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware utilities for Cirrus Logic DSP (cs_dsp), specifically KUnit test utilities

2) Pre-Patch Flaw:
In cs_dsp_mock_wmfw_add_info(), after padding, the variable info_len was overwritten with the rounded-up size and then used as the memcpy length: “memcpy(tmp, info, info_len)”. This conflated the destination allocation size with the true source string length.

3) Trigger Condition:
Any info string whose length is not a multiple of 4 (info_len % 4 != 0), which causes padding via round_up(info_len, 4). Under this condition, the memcpy length exceeds the actual source length by up to 3 bytes.

4) Impact Mechanism:
memcpy() reads past the end of the source string (info), producing an out-of-bounds read detectable by KASAN. While the destination buffer is large enough, the read beyond the source can lead to access of unrelated kernel memory, potential faulting under sanitizers, or unintended data exposure in testing.

5. Patch Analysis
1) Fix Approach:
Maintain the original string length for the source copy and use the padded length only for allocation, padding, and metadata. Zero-initialization ensures the padded bytes are safe without reading from the source.

2) Key Code Changes:
- Introduced a separate variable to capture the pre-rounded length: “size_t copy_len = info_len;” before modifying info_len.
- Changed memcpy to use the original length: from “memcpy(tmp, info, info_len)” to “memcpy(tmp, info, copy_len)”.
- Kept info_len as the padded size for subsequent block creation (cs_dsp_mock_wmfw_add_raw_block), ensuring correct payload length.

3) Locking/Concurrency Impact:
None. The change is localized to copy length calculation in a KUnit helper and does not alter locking, synchronization, or ordering.

6. Broader Kernel Security Implications
This fix underscores a common class of bugs where a size variable is repurposed after alignment/padding and then incorrectly applied to source operations. Proper separation of source length and padded/aligned size is essential to prevent OOB reads during serialization and block construction. Zero-initialization and using pre-padding lengths for memcpy/str operations should be standard practice. KUnit and KASAN caught this issue, demonstrating the value of runtime sanitizers in test code that mirrors production data handling patterns.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}