You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38298

[INFO]
[PATCH_DESCRIPTION]
    EDAC/skx_common: Fix general protection fault
    After loading i10nm_edac (which automatically loads skx_edac_common), if
    unload only i10nm_edac, then reload it and perform error injection testing,
    a general protection fault may occur:
    
      mce: [Hardware Error]: Machine check events logged
      Oops: general protection fault ...
      ...
      Workqueue: events mce_gen_pool_process
      RIP: 0010:string+0x53/0xe0
      ...
      Call Trace:
      <TASK>
      ? die_addr+0x37/0x90
      ? exc_general_protection+0x1e7/0x3f0
      ? asm_exc_general_protection+0x26/0x30
      ? string+0x53/0xe0
      vsnprintf+0x23e/0x4c0
      snprintf+0x4d/0x70
      skx_adxl_decode+0x16a/0x330 [skx_edac_common]
      skx_mce_check_error.part.0+0xf8/0x220 [skx_edac_common]
      skx_mce_check_error+0x17/0x20 [skx_edac_common]
      ...
    
    The issue arose was because the variable 'adxl_component_count' (inside
    skx_edac_common), which counts the ADXL components, was not reset. During
    the reloading of i10nm_edac, the count was incremented by the actual number
    of ADXL components again, resulting in a count that was double the real
    number of ADXL components. This led to an out-of-bounds reference to the
    ADXL component array, causing the general protection fault above.
    
    Fix this issue by resetting the 'adxl_component_count' in adxl_put(),
    which is called during the unloading of {skx,i10nm}_edac.

[PATCH_DIFF]
     @@ -116,6 +116,7 @@ EXPORT_SYMBOL_GPL(skx_adxl_get);
      
      void skx_adxl_put(void)
      {
     +	adxl_component_count = 0;
      	kfree(adxl_values);
      	kfree(adxl_msg);
      }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38298

2. Vulnerability Type
Out-of-bounds access (OOB read) due to stale global state not reset on module teardown

3. Root Cause Summary
A global counter adxl_component_count in skx_edac_common was not reset during teardown (skx_adxl_put). After unloading only i10nm_edac and reloading it, the initialization path incremented adxl_component_count again, making it larger than the actual number of ADXL components. skx_adxl_decode later used this inflated count to iterate over ADXL component arrays (e.g., adxl_values/adxl_msg), indexing past their valid bounds. This out-of-bounds access led to a general protection fault during string formatting (vsnprintf/string) in the machine check processing path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
EDAC (Skylake/Xeon common EDAC code shared by i10nm_edac and skx_edac_common)

2) Pre-Patch Flaw:
The teardown function skx_adxl_put failed to reset the global ADXL component counter; it only freed adxl_values and adxl_msg. As a result, on subsequent module reload, adxl_component_count accumulated (double-counted) components, desynchronizing the counter from the actual array sizes and contents used by skx_adxl_decode.

3) Trigger Condition:
Unload only the i10nm_edac module (which auto-loads skx_edac_common), then reload i10nm_edac and perform EDAC error injection testing. The workqueue mce_gen_pool_process processes MCE events, invoking skx_mce_check_error → skx_adxl_decode, which uses the stale doubled adxl_component_count.

4) Impact Mechanism:
skx_adxl_decode iterates up to adxl_component_count and accesses ADXL component arrays beyond their valid bounds. The out-of-bounds reference causes vsnprintf/string to operate on invalid memory, resulting in a general protection fault and kernel oops (DoS).

5. Patch Analysis
1) Fix Approach:
Reset the global state during teardown by setting adxl_component_count = 0 in skx_adxl_put so that subsequent reloads start from a clean state and the counter matches the actual number of components.

2) Key Code Changes:
In skx_adxl_put:
- Added a one-line state reset: adxl_component_count = 0;
- This is placed before freeing adxl_values and adxl_msg, ensuring no stale count remains after unload.
Patch hunk:
+ adxl_component_count = 0;
  kfree(adxl_values);
  kfree(adxl_msg);

3) Locking/Concurrency Impact:
No locking changes introduced. The fix operates in the module teardown path, resetting a global variable to eliminate stale state across unload/reload cycles; any additional concurrency considerations are unknown/not determinable from the provided diff.

6. Broader Kernel Security Implications
Failing to reset global/module state during teardown can lead to desynchronized counters and arrays, causing OOB accesses, crashes, or potential info leaks. EDAC paths are exercised by asynchronous workqueues (e.g., MCE handling), magnifying the impact of stale state when modules are reloaded. While exploitation requires privileged control over module load/unload and error injection, the bug leads to kernel DoS and highlights the need for robust teardown/reset of shared common-code state in modular subsystems. Ensuring counters and buffers are consistently reinitialized prevents similar lifetime/state bugs across reloads.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.