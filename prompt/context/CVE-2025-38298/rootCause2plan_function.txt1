You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38298

[INFO]
[PATCH_DESCRIPTION]
    EDAC/skx_common: Fix general protection fault
    After loading i10nm_edac (which automatically loads skx_edac_common), if
    unload only i10nm_edac, then reload it and perform error injection testing,
    a general protection fault may occur:
    
      mce: [Hardware Error]: Machine check events logged
      Oops: general protection fault ...
      ...
      Workqueue: events mce_gen_pool_process
      RIP: 0010:string+0x53/0xe0
      ...
      Call Trace:
      <TASK>
      ? die_addr+0x37/0x90
      ? exc_general_protection+0x1e7/0x3f0
      ? asm_exc_general_protection+0x26/0x30
      ? string+0x53/0xe0
      vsnprintf+0x23e/0x4c0
      snprintf+0x4d/0x70
      skx_adxl_decode+0x16a/0x330 [skx_edac_common]
      skx_mce_check_error.part.0+0xf8/0x220 [skx_edac_common]
      skx_mce_check_error+0x17/0x20 [skx_edac_common]
      ...
    
    The issue arose was because the variable 'adxl_component_count' (inside
    skx_edac_common), which counts the ADXL components, was not reset. During
    the reloading of i10nm_edac, the count was incremented by the actual number
    of ADXL components again, resulting in a count that was double the real
    number of ADXL components. This led to an out-of-bounds reference to the
    ADXL component array, causing the general protection fault above.
    
    Fix this issue by resetting the 'adxl_component_count' in adxl_put(),
    which is called during the unloading of {skx,i10nm}_edac.

[PATCH_DIFF]
     @@ -116,6 +116,7 @@ EXPORT_SYMBOL_GPL(skx_adxl_get);
      
      void skx_adxl_put(void)
      {
     +	adxl_component_count = 0;
      	kfree(adxl_values);
      	kfree(adxl_msg);
      }

[FUNCTION_CONTENT]
void skx_adxl_put(void)
{
	kfree(adxl_values);
	kfree(adxl_msg);
}

/* ----- separator ----- */

EXPORT_SYMBOL_GPL(skx_adxl_get);

void skx_adxl_put(void)
{
	kfree(adxl_values);
	kfree(adxl_msg);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38298

2. Vulnerability Type
Out-of-bounds array access due to stale/lifecycle state (missing counter reset)

3. Root Cause Summary
The skx_edac_common module failed to reset the global ADXL component counter (adxl_component_count) on module teardown. When i10nm_edac was unloaded (leaving skx_edac_common loaded) and then reloaded, the ADXL component discovery incremented the already non-zero counter, doubling it relative to the actual array size. Subsequent decoding paths (e.g., skx_adxl_decode) used this inflated count to index the ADXL component arrays, causing out-of-bounds access and a general protection fault.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
EDAC (Error Detection And Correction) for Intel server platforms (skx_edac_common with i10nm_edac)

2) Pre-Patch Flaw:
In skx_adxl_put(), the code freed ADXL buffers but did not reset adxl_component_count; the function contained only “kfree(adxl_values);” and “kfree(adxl_msg);” with no counter reset. Because skx_edac_common remained loaded across i10nm_edac unload/reload, the stale non-zero counter accumulated on each reload.

3) Trigger Condition:
Unload only i10nm_edac (skx_edac_common stays loaded), then reload i10nm_edac and perform error injection tests. The counter is incremented again during ADXL component enumeration, producing a count larger than the actual number of components.

4) Impact Mechanism:
The inflated adxl_component_count drives loops/indices in skx_adxl_decode, leading to out-of-bounds references to the ADXL component arrays (adxl_values/adxl_msg). This invalid access surfaces during string formatting (string/vsnprintf/snprintf) in the decode path, causing a general protection fault in the mce_gen_pool_process workqueue, as shown in the stack trace.

5. Patch Analysis
1) Fix Approach:
Reset the global ADXL component counter during teardown to ensure a clean state for subsequent reloads.

2) Key Code Changes:
In skx_adxl_put(), the patch adds “adxl_component_count = 0;” before freeing adxl_values and adxl_msg:
- skx_adxl_put(): added a counter reset to zero, preserving correct bounds on re-init.

3) Locking/Concurrency Impact:
No locking or ordering changes were introduced. The change is a simple state reset during module teardown, which aligns with the module unload lifecycle and avoids stale global state; concurrency aspects remain unchanged.

6. Broader Kernel Security Implications
Failing to reset global state across module reloads can yield out-of-bounds accesses, leading to kernel crashes and potential memory corruption. EDAC paths often execute in workqueues and under error-handling contexts, so robustness against lifecycle issues is critical. This fix highlights the need to systematically reset counters and sizes in shared/common EDAC modules and to consider defensive bounds checks in decode paths to mitigate similar state-related bugs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}