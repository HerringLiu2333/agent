You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38254

[INFO]
[PATCH_DESCRIPTION]
    drm/amd/display: Add sanity checks for drm_edid_raw()
    When EDID is retrieved via drm_edid_raw(), it doesn't guarantee to
    return proper EDID bytes the caller wants: it may be either NULL (that
    leads to an Oops) or with too long bytes over the fixed size raw_edid
    array (that may lead to memory corruption).  The latter was reported
    actually when connected with a bad adapter.
    
    Add sanity checks for drm_edid_raw() to address the above corner
    cases, and return EDID_BAD_INPUT accordingly.
    
    Fixes: 48edb2a4256e ("drm/amd/display: switch amdgpu_dm_connector to use struct drm_edid")

[PATCH_DIFF]
    @@ -1029,6 +1029,10 @@ enum dc_edid_status dm_helpers_read_local_edid(
     			return EDID_NO_RESPONSE;
     
     		edid = drm_edid_raw(drm_edid); // FIXME: Get rid of drm_edid_raw()
    +		if (!edid ||
    +		    edid->extensions >= sizeof(sink->dc_edid.raw_edid) / EDID_LENGTH)
    +			return EDID_BAD_INPUT;
    +
     		sink->dc_edid.length = EDID_LENGTH * (edid->extensions + 1);
     		memmove(sink->dc_edid.raw_edid, (uint8_t *)edid, sink->dc_edid.length);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38254

2. Vulnerability Type
- Null pointer dereference
- Out-of-bounds write (buffer overflow) due to missing bounds validation

3. Root Cause Summary
The function dm_helpers_read_local_edid() trusted the output of drm_edid_raw() without validation. It dereferenced a potentially NULL edid pointer and used edid->extensions to compute a copy length into a fixed-size sink->dc_edid.raw_edid array without checking capacity. This allowed a bad or malformed EDID (or a NULL return) to cause either a kernel Oops or memory corruption via memmove with an oversized length. The patch adds explicit checks for NULL and for edid->extensions exceeding the destination buffer’s capacity, returning EDID_BAD_INPUT early.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM AMD display driver (amdgpu_dm), EDID handling logic

2) Pre-Patch Flaw:
- No NULL check on the pointer returned by drm_edid_raw().
- No bounds check on edid->extensions before computing sink->dc_edid.length and performing memmove into sink->dc_edid.raw_edid.

3) Trigger Condition:
- drm_edid_raw() returns NULL.
- drm_edid_raw() returns EDID data where edid->extensions is large enough that EDID_LENGTH * (extensions + 1) exceeds sizeof(sink->dc_edid.raw_edid), e.g., due to a bad/malicious adapter providing malformed EDID.

4) Impact Mechanism:
- NULL dereference when accessing edid->extensions leads to kernel Oops.
- Out-of-bounds memory write when executing:
  - “sink->dc_edid.length = EDID_LENGTH * (edid->extensions + 1);”
  - “memmove(sink->dc_edid.raw_edid, (uint8_t *)edid, sink->dc_edid.length);”
  This can corrupt adjacent kernel memory and cause crashes or undefined behavior.

5. Patch Analysis
1) Fix Approach:
Input validation was added prior to using the edid pointer and computing/copying the EDID length. The function now returns EDID_BAD_INPUT when drm_edid_raw() yields NULL or when the computed number of EDID blocks would overflow the fixed destination buffer.

2) Key Code Changes:
- Inserted:
  - “if (!edid || edid->extensions >= sizeof(sink->dc_edid.raw_edid) / EDID_LENGTH) return EDID_BAD_INPUT;”
This prevents dereferencing NULL and ensures the number of 128-byte EDID blocks does not exceed the capacity of sink->dc_edid.raw_edid, thereby guarding the subsequent length calculation and memmove.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The patch strictly adds input checks and an early return; synchronization behavior is unaffected.

6. Broader Kernel Security Implications
Validating EDID data mitigates externally triggered kernel instability from malformed monitors/adapters, reducing attack surface for denial-of-service via device-driven inputs. Preventing out-of-bounds writes in low-level display paths avoids potential memory corruption that could be exploited for more severe outcomes. This change exemplifies necessary hardening for parsing untrusted hardware-provided data, and similar validation should be consistently applied across EDID and other device descriptor handling paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}