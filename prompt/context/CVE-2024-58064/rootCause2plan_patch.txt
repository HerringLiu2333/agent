You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58064

[INFO]
[PATCH_DESCRIPTION]
 wifi: cfg80211: tests: Fix potential NULL dereference in test_cfg80211_parse_colocated_ap()
 [ Upstream commit 13c4f7714c6a1ecf748a2f22099447c14fe6ed8c ]
 
 kunit_kzalloc() may return NULL, dereferencing it without NULL check may
 lead to NULL dereference.
 Add a NULL check for ies.
 
 Fixes: 45d43937a44c ("wifi: cfg80211: add a kunit test for 6 GHz colocated AP parsing")

[PATCH_DIFF]
 diff --git a/net/wireless/tests/scan.c b/net/wireless/tests/scan.c
 index 9f458be7165951…79a99cf5e8922f 100644
 --- a/net/wireless/tests/scan.c
 +++ b/net/wireless/tests/scan.c
 @@ -810,6 +810,8 @@ static void test_cfg80211_parse_colocated_ap(struct kunit *test)
   skb_put_data(input, "123", 3);

   ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
 + KUNIT_ASSERT_NOT_NULL(test, ies);
 +
   ies->len = input->len;
   memcpy(ies->data, input->data, input->len);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58064

2. Vulnerability Type
NULL pointer dereference due to missing allocation result validation

3. Root Cause Summary
The function test_cfg80211_parse_colocated_ap() in net/wireless/tests/scan.c allocated a buffer with kunit_kzalloc() and immediately dereferenced it without checking for allocation failure. If kunit_kzalloc() returned NULL, subsequent writes to ies->len and ies->data would dereference a NULL pointer, causing a kernel crash in the test environment.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
cfg80211 KUnit tests (net/wireless/tests), specifically test_cfg80211_parse_colocated_ap()

2) Pre-Patch Flaw:
After allocating ies with “ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);” the code immediately accessed ies->len and ies->data without a NULL check. This missing validation of the allocation result created an unsafe dereference path.

3) Trigger Condition:
kunit_kzalloc() returns NULL (e.g., due to memory allocation failure under GFP_KERNEL or test environment constraints). The test then executes “ies->len = input->len; memcpy(ies->data, input->data, input->len);” on a NULL ies pointer.

4) Impact Mechanism:
Dereferencing a NULL pointer leads to a kernel NULL pointer dereference/OOPS during test execution, causing a crash or test failure (Denial of Service within the test context).

5. Patch Analysis
1) Fix Approach:
Introduce a NULL-pointer assertion immediately after allocation to prevent further execution if ies is NULL.

2) Key Code Changes:
Added “KUNIT_ASSERT_NOT_NULL(test, ies);” directly after the kunit_kzalloc() call, ensuring the test aborts safely instead of dereferencing a NULL pointer.

3) Locking/Concurrency Impact:
None. The change is a defensive check in test code and does not alter locking, RCU, or concurrency behavior.

6. Broader Kernel Security Implications
Validating allocation results prevents NULL dereference crashes, improving robustness and reliability, even in test code paths. This change promotes safer coding practices that are applicable across kernel subsystems, reducing the risk of similar issues in production paths. Ensuring KUnit tests handle allocation failures gracefully supports stable automated testing and avoids spurious test-induced kernel crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.