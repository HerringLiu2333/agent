You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58064

[INFO]
[PATCH_DESCRIPTION]
 wifi: cfg80211: tests: Fix potential NULL dereference in test_cfg80211_parse_colocated_ap()
 [ Upstream commit 13c4f7714c6a1ecf748a2f22099447c14fe6ed8c ]
 
 kunit_kzalloc() may return NULL, dereferencing it without NULL check may
 lead to NULL dereference.
 Add a NULL check for ies.
 
 Fixes: 45d43937a44c ("wifi: cfg80211: add a kunit test for 6 GHz colocated AP parsing")

[PATCH_DIFF]
 diff --git a/net/wireless/tests/scan.c b/net/wireless/tests/scan.c
 index 9f458be7165951…79a99cf5e8922f 100644
 --- a/net/wireless/tests/scan.c
 +++ b/net/wireless/tests/scan.c
 @@ -810,6 +810,8 @@ static void test_cfg80211_parse_colocated_ap(struct kunit *test)
   skb_put_data(input, "123", 3);

   ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
 + KUNIT_ASSERT_NOT_NULL(test, ies);
 +
   ies->len = input->len;
   memcpy(ies->data, input->data, input->len);

[FUNCTION_CONTENT]
static void test_cfg80211_parse_colocated_ap(struct kunit *test)
{
	const struct cfg80211_parse_colocated_ap_case *params = test->param_value;
	struct sk_buff *input = kunit_zalloc_skb(test, 1024, GFP_KERNEL);
	struct cfg80211_bss_ies *ies;
	struct ieee80211_neighbor_ap_info info;
	LIST_HEAD(coloc_ap_list);
	int count;

	KUNIT_ASSERT_NOT_NULL(test, input);

	info = params->info;

	/* Reasonable values for a colocated AP */
	if (!info.tbtt_info_len)
		info.tbtt_info_len = sizeof(params->tbtt_long);
	if (!info.op_class)
		info.op_class = 131;
	if (!info.channel)
		info.channel = 33;
	/* Zero is the correct default for .btt_info_hdr (one entry, TBTT type) */

	skb_put_u8(input, WLAN_EID_SSID);
	skb_put_u8(input, 4);
	skb_put_data(input, "TEST", 4);

	skb_put_u8(input, WLAN_EID_REDUCED_NEIGHBOR_REPORT);
	skb_put_u8(input, sizeof(info) + info.tbtt_info_len + (params->add_junk ? 3 : 0));
	skb_put_data(input, &info, sizeof(info));
	skb_put_data(input, &params->tbtt_long, info.tbtt_info_len);

	if (params->add_junk)
		skb_put_data(input, "123", 3);

	ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
	ies->len = input->len;
	memcpy(ies->data, input->data, input->len);

	count = cfg80211_parse_colocated_ap(ies, &coloc_ap_list);

	KUNIT_EXPECT_EQ(test, count, params->valid);
	KUNIT_EXPECT_EQ(test, list_count_nodes(&coloc_ap_list), params->valid);

	if (params->valid && !list_empty(&coloc_ap_list)) {
		struct cfg80211_colocated_ap *ap;

		ap = list_first_entry(&coloc_ap_list, typeof(*ap), list);
		if (info.tbtt_info_len <= sizeof(params->tbtt_short))
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_short.bssid, ETH_ALEN);
		else
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_long.bssid, ETH_ALEN);

		if (params->same_ssid) {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 4);
			KUNIT_EXPECT_MEMEQ(test, ap->ssid, "TEST", 4);
		} else {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 0);
		}
	}

	cfg80211_free_coloc_ap_list(&coloc_ap_list);
}

/* ----- separator ----- */

KUNIT_ARRAY_PARAM_DESC(cfg80211_parse_colocated_ap, cfg80211_parse_colocated_ap_cases, desc)

static void test_cfg80211_parse_colocated_ap(struct kunit *test)
{
	const struct cfg80211_parse_colocated_ap_case *params = test->param_value;
	struct sk_buff *input = kunit_zalloc_skb(test, 1024, GFP_KERNEL);
	struct cfg80211_bss_ies *ies;
	struct ieee80211_neighbor_ap_info info;
	LIST_HEAD(coloc_ap_list);
	int count;

	KUNIT_ASSERT_NOT_NULL(test, input);

	info = params->info;

	/* Reasonable values for a colocated AP */
	if (!info.tbtt_info_len)
		info.tbtt_info_len = sizeof(params->tbtt_long);
	if (!info.op_class)
		info.op_class = 131;
	if (!info.channel)
		info.channel = 33;
	/* Zero is the correct default for .btt_info_hdr (one entry, TBTT type) */

	skb_put_u8(input, WLAN_EID_SSID);
	skb_put_u8(input, 4);
	skb_put_data(input, "TEST", 4);

	skb_put_u8(input, WLAN_EID_REDUCED_NEIGHBOR_REPORT);
	skb_put_u8(input, sizeof(info) + info.tbtt_info_len + (params->add_junk ? 3 : 0));
	skb_put_data(input, &info, sizeof(info));
	skb_put_data(input, &params->tbtt_long, info.tbtt_info_len);

	if (params->add_junk)
		skb_put_data(input, "123", 3);

	ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
	ies->len = input->len;
	memcpy(ies->data, input->data, input->len);

	count = cfg80211_parse_colocated_ap(ies, &coloc_ap_list);

	KUNIT_EXPECT_EQ(test, count, params->valid);
	KUNIT_EXPECT_EQ(test, list_count_nodes(&coloc_ap_list), params->valid);

	if (params->valid && !list_empty(&coloc_ap_list)) {
		struct cfg80211_colocated_ap *ap;

		ap = list_first_entry(&coloc_ap_list, typeof(*ap), list);
		if (info.tbtt_info_len <= sizeof(params->tbtt_short))
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_short.bssid, ETH_ALEN);
		else
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_long.bssid, ETH_ALEN);

		if (params->same_ssid) {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 4);
			KUNIT_EXPECT_MEMEQ(test, ap->ssid, "TEST", 4);
		} else {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 0);
		}
	}

	cfg80211_free_coloc_ap_list(&coloc_ap_list);
}

/* ----- separator ----- */

	LIST_HEAD(coloc_ap_list);
	int count;

	KUNIT_ASSERT_NOT_NULL(test, input);

	info = params->info;

	/* Reasonable values for a colocated AP */
	if (!info.tbtt_info_len)
		info.tbtt_info_len = sizeof(params->tbtt_long);
	if (!info.op_class)
		info.op_class = 131;
	if (!info.channel)
		info.channel = 33;
	/* Zero is the correct default for .btt_info_hdr (one entry, TBTT type) */

	skb_put_u8(input, WLAN_EID_SSID);
	skb_put_u8(input, 4);
	skb_put_data(input, "TEST", 4);

	skb_put_u8(input, WLAN_EID_REDUCED_NEIGHBOR_REPORT);
	skb_put_u8(input, sizeof(info) + info.tbtt_info_len + (params->add_junk ? 3 : 0));
	skb_put_data(input, &info, sizeof(info));
	skb_put_data(input, &params->tbtt_long, info.tbtt_info_len);

	if (params->add_junk)
		skb_put_data(input, "123", 3);

	ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
	ies->len = input->len;
	memcpy(ies->data, input->data, input->len);

	count = cfg80211_parse_colocated_ap(ies, &coloc_ap_list);

	KUNIT_EXPECT_EQ(test, count, params->valid);
	KUNIT_EXPECT_EQ(test, list_count_nodes(&coloc_ap_list), params->valid);

	if (params->valid && !list_empty(&coloc_ap_list)) {
		struct cfg80211_colocated_ap *ap;

		ap = list_first_entry(&coloc_ap_list, typeof(*ap), list);
		if (info.tbtt_info_len <= sizeof(params->tbtt_short))
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_short.bssid, ETH_ALEN);
		else
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_long.bssid, ETH_ALEN);

		if (params->same_ssid) {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 4);
			KUNIT_EXPECT_MEMEQ(test, ap->ssid, "TEST", 4);
		} else {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 0);
		}
	}

/* ----- separator ----- */


	KUNIT_ASSERT_NOT_NULL(test, input);

	info = params->info;

	/* Reasonable values for a colocated AP */
	if (!info.tbtt_info_len)
		info.tbtt_info_len = sizeof(params->tbtt_long);
	if (!info.op_class)
		info.op_class = 131;
	if (!info.channel)
		info.channel = 33;
	/* Zero is the correct default for .btt_info_hdr (one entry, TBTT type) */

	skb_put_u8(input, WLAN_EID_SSID);
	skb_put_u8(input, 4);
	skb_put_data(input, "TEST", 4);

	skb_put_u8(input, WLAN_EID_REDUCED_NEIGHBOR_REPORT);
	skb_put_u8(input, sizeof(info) + info.tbtt_info_len + (params->add_junk ? 3 : 0));
	skb_put_data(input, &info, sizeof(info));
	skb_put_data(input, &params->tbtt_long, info.tbtt_info_len);

	if (params->add_junk)
		skb_put_data(input, "123", 3);

	ies = kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL);
	ies->len = input->len;
	memcpy(ies->data, input->data, input->len);

	count = cfg80211_parse_colocated_ap(ies, &coloc_ap_list);

	KUNIT_EXPECT_EQ(test, count, params->valid);
	KUNIT_EXPECT_EQ(test, list_count_nodes(&coloc_ap_list), params->valid);

	if (params->valid && !list_empty(&coloc_ap_list)) {
		struct cfg80211_colocated_ap *ap;

		ap = list_first_entry(&coloc_ap_list, typeof(*ap), list);
		if (info.tbtt_info_len <= sizeof(params->tbtt_short))
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_short.bssid, ETH_ALEN);
		else
			KUNIT_EXPECT_MEMEQ(test, ap->bssid, params->tbtt_long.bssid, ETH_ALEN);

		if (params->same_ssid) {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 4);
			KUNIT_EXPECT_MEMEQ(test, ap->ssid, "TEST", 4);
		} else {
			KUNIT_EXPECT_EQ(test, ap->ssid_len, 0);
		}
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58064

2. Vulnerability Type
NULL pointer dereference (missing NULL check after allocation)

3. Root Cause Summary
In net/wireless/tests/scan.c:test_cfg80211_parse_colocated_ap(), the pointer ies allocated via kunit_kzalloc(test, struct_size(ies, data, input->len), GFP_KERNEL) was dereferenced unconditionally (ies->len and memcpy to ies->data) without verifying the allocation succeeded. If kunit_kzalloc() returned NULL (e.g., under memory pressure or fault injection), this led to a NULL pointer dereference. The patch adds the missing KUnit assertion to validate ies before use.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
cfg80211 KUnit tests (net/wireless/tests), specifically test_cfg80211_parse_colocated_ap()

2) Pre-Patch Flaw:
Missing NULL check on the result of kunit_kzalloc() for ies; code immediately accessed ies->len and ies->data after allocation.

3) Trigger Condition:
kunit_kzalloc() returns NULL due to allocation failure (e.g., low memory or KUnit fault injection), and the function proceeds to write to ies fields.

4) Impact Mechanism:
Dereferencing a NULL pointer in kernel context causes a kernel oops/panic during test execution, resulting in denial of service of the test environment and potentially destabilizing the kernel running the tests.

5. Patch Analysis
1) Fix Approach:
Defensive programming: add an explicit KUnit assertion to check ies is non-NULL immediately after allocation, aborting the test on failure.

2) Key Code Changes:
- Inserted KUNIT_ASSERT_NOT_NULL(test, ies); right after ies = kunit_kzalloc(...), before any dereferences. This directly addresses the missing validation.

3) Locking/Concurrency Impact:
None. The change is a simple NULL check/assertion and does not alter locking or execution ordering.

6. Broader Kernel Security Implications
This highlights the necessity of checking all kernel memory allocations—even in test code—to prevent kernel crashes from unexpected allocation failures. Similar patterns in KUnit tests and auxiliary kernel code should be audited to ensure all kunit_kzalloc/kzalloc calls are followed by appropriate NULL checks, reducing the risk of stability issues during testing and automated fuzzing.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.