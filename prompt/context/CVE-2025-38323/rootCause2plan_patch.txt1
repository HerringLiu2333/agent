You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38323

[INFO]
[PATCH_DESCRIPTION]
    net: atm: add lec_mutex
    syzbot found its way in net/atm/lec.c, and found an error path
    in lecd_attach() could leave a dangling pointer in dev_lec[].
    
    Add a mutex to protect dev_lecp[] uses from lecd_attach(),
    lec_vcc_attach() and lec_mcast_attach().
    
    Following patch will use this mutex for /proc/net/atm/lec.
    
    BUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline]
    BUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008
    Read of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142
    
    CPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full)
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025
    Call Trace:
     <TASK>
      __dump_stack lib/dump_stack.c:94 [inline]
      dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120
      print_address_description mm/kasan/report.c:408 [inline]
      print_report+0xcd/0x680 mm/kasan/report.c:521
      kasan_report+0xe0/0x110 mm/kasan/report.c:634
      lecd_attach net/atm/lec.c:751 [inline]
      lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893
      do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
      do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
     </TASK>
    
    Allocated by task 6132:
      kasan_save_stack+0x33/0x60 mm/kasan/common.c:47
      kasan_save_track+0x14/0x30 mm/kasan/common.c:68
      poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
      __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394
      kasan_kmalloc include/linux/kasan.h:260 [inline]
      __do_kmalloc_node mm/slub.c:4328 [inline]
      __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015
      alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711
      lecd_attach net/atm/lec.c:737 [inline]
      lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893
      do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
      do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
    
    Freed by task 6132:
      kasan_save_stack+0x33/0x60 mm/kasan/common.c:47
      kasan_save_track+0x14/0x30 mm/kasan/common.c:68
      kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576
      poison_slab_object mm/kasan/common.c:247 [inline]
      __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264
      kasan_slab_free include/linux/kasan.h:233 [inline]
      slab_free_hook mm/slub.c:2381 [inline]
      slab_free mm/slub.c:4643 [inline]
      kfree+0x2b4/0x4d0 mm/slub.c:4842
      free_netdev+0x6c5/0x910 net/core/dev.c:11892
      lecd_attach net/atm/lec.c:744 [inline]
      lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893

[PATCH_DIFF]
    diff --git a/net/atm/lec.c b/net/atm/lec.c
    index acef984f336709..1e1f3eb0e2ba3c 100644
    --- a/net/atm/lec.c
    +++ b/net/atm/lec.c
    @@ -124,6 +124,7 @@ static unsigned char bus_mac[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
     
     /* Device structures */
     static struct net_device *dev_lec[MAX_LEC_ITF];
    +static DEFINE_MUTEX(lec_mutex);
     
     #if IS_ENABLED(CONFIG_BRIDGE)
     static void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)
    @@ -742,6 +746,7 @@ static int lecd_attach(struct atm_vcc *vcc, int arg)
     		snprintf(dev_lec[i]->name, IFNAMSIZ, "lec%d", i);
     		if (register_netdev(dev_lec[i])) {
     			free_netdev(dev_lec[i]);
    +			dev_lec[i] = NULL;
     			return -EINVAL;
     		}
     
    @@ -1003,6 +1008,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
     		return -ENOIOCTLCMD;
     	}
     
    +	mutex_lock(&lec_mutex);
     	switch (cmd) {
     	case ATMLEC_CTRL:
     		err = lecd_attach(vcc, (int)arg);
    @@ -1017,6 +1023,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
     		break;
     	}
     
    +	mutex_unlock(&lec_mutex);
     	return err;
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38323

2. Vulnerability Type
Use-after-free due to dangling pointer and missing synchronization (race condition)

3. Root Cause Summary
- lecd_attach() freed the allocated net_device on register_netdev() failure but did not clear the corresponding entry in the global dev_lec[] array, leaving a dangling pointer.
- Accesses to dev_lec[] from lane_ioctl() (and functions it invokes such as lecd_attach(), lec_vcc_attach(), lec_mcast_attach()) were performed without any mutual exclusion, allowing races where one thread frees or replaces dev_lec[i] while another dereferences it.
- Combined, the stale pointer and lack of locking enabled a use-after-free when dev_lec[] was read after free_netdev().

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ATM LAN Emulation (net/atm/lec.c)

2) Pre-Patch Flaw:
- The global device pointer array dev_lec[MAX_LEC_ITF] was modified and read without serialization in lane_ioctl() and related helpers.
- On the error path in lecd_attach(), when register_netdev() failed, code executed free_netdev(dev_lec[i]); and immediately returned without nullifying dev_lec[i], leaving a dangling pointer in the global array.
- No mutex or other lock protected concurrent accesses to dev_lec[], despite multiple IOCTL operations potentially manipulating it concurrently.

3) Trigger Condition:
- An IOCTL invoking lane_ioctl() triggers lecd_attach(), which allocates a net_device and then hits the failure path (register_netdev() fails), freeing the device but leaving dev_lec[i] pointing to freed memory.
- Concurrent or subsequent IOCTLs (or the same path) read dev_lec[] while it still contains the stale pointer, leading to a dereference of freed memory.
- This matches the KASAN report showing allocation and free within lecd_attach() and a use-after-free read at lecd_attach:751 inside lane_ioctl.

4) Impact Mechanism:
- Dereferencing dev_lec[i] after free_netdev() results in a slab use-after-free (read of size 8) at a freed address, causing memory safety violation and potential kernel crash or further corruption.

5. Patch Analysis
1) Fix Approach:
- Eliminate the dangling pointer by setting dev_lec[i] = NULL on the lecd_attach() error path after free_netdev().
- Introduce a global mutex (lec_mutex) and serialize IOCTL-driven operations that touch dev_lec[] by taking this mutex in lane_ioctl() around the switch that calls lecd_attach() and related functions.

2) Key Code Changes:
- Added static DEFINE_MUTEX(lec_mutex);
- In lecd_attach(): on register_netdev() failure, added dev_lec[i] = NULL right after free_netdev(dev_lec[i]);
- In lane_ioctl(): added mutex_lock(&lec_mutex); before the switch and mutex_unlock(&lec_mutex); after the switch to serialize ATMLEC_CTRL and related commands.

3) Locking/Concurrency Impact:
- Introduces a global mutual exclusion around lane_ioctl() operations that manipulate dev_lec[], preventing concurrent modification/inspection races among lecd_attach(), lec_vcc_attach(), and lec_mcast_attach() as invoked via IOCTL.
- Ensures that dev_lec[] updates (including error-path cleanup) are atomic with respect to readers in the same IOCTL path, removing the race window that led to UAF.
- Patch description notes a follow-up will extend this mutex to /proc/net/atm/lec access, further broadening protection coverage.

6. Broader Kernel Security Implications
- Highlights the necessity of clearing global/shared pointers immediately upon freeing their targets to avoid stale references.
- Demonstrates the importance of adding explicit locking when multiple control paths can concurrently manipulate shared device state via IOCTLs, especially in legacy subsystems.
- The introduced mutex reduces the surface for UAF and race-related memory corruption in the ATM LANE stack and serves as a model for protecting other procfs and control-plane accessors touching shared arrays.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}