You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38323

[INFO]
[PATCH_DESCRIPTION]
    net: atm: add lec_mutex
    syzbot found its way in net/atm/lec.c, and found an error path
    in lecd_attach() could leave a dangling pointer in dev_lec[].
    
    Add a mutex to protect dev_lecp[] uses from lecd_attach(),
    lec_vcc_attach() and lec_mcast_attach().
    
    Following patch will use this mutex for /proc/net/atm/lec.
    
    BUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline]
    BUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008
    Read of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142
    
    CPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full)
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025
    Call Trace:
     <TASK>
      __dump_stack lib/dump_stack.c:94 [inline]
      dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120
      print_address_description mm/kasan/report.c:408 [inline]
      print_report+0xcd/0x680 mm/kasan/report.c:521
      kasan_report+0xe0/0x110 mm/kasan/report.c:634
      lecd_attach net/atm/lec.c:751 [inline]
      lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893
      do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
      do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
     </TASK>
    
    Allocated by task 6132:
      kasan_save_stack+0x33/0x60 mm/kasan/common.c:47
      kasan_save_track+0x14/0x30 mm/kasan/common.c:68
      poison_kmalloc_redzone mm/kasan/common.c:377 [inline]
      __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394
      kasan_kmalloc include/linux/kasan.h:260 [inline]
      __do_kmalloc_node mm/slub.c:4328 [inline]
      __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015
      alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711
      lecd_attach net/atm/lec.c:737 [inline]
      lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893
      do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
      do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
    
    Freed by task 6132:
      kasan_save_stack+0x33/0x60 mm/kasan/common.c:47
      kasan_save_track+0x14/0x30 mm/kasan/common.c:68
      kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576
      poison_slab_object mm/kasan/common.c:247 [inline]
      __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264
      kasan_slab_free include/linux/kasan.h:233 [inline]
      slab_free_hook mm/slub.c:2381 [inline]
      slab_free mm/slub.c:4643 [inline]
      kfree+0x2b4/0x4d0 mm/slub.c:4842
      free_netdev+0x6c5/0x910 net/core/dev.c:11892
      lecd_attach net/atm/lec.c:744 [inline]
      lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008
      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
      sock_do_ioctl+0x118/0x280 net/socket.c:1190
      sock_ioctl+0x227/0x6b0 net/socket.c:1311
      vfs_ioctl fs/ioctl.c:51 [inline]
      __do_sys_ioctl fs/ioctl.c:907 [inline]
      __se_sys_ioctl fs/ioctl.c:893 [inline]
      __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893

[PATCH_DIFF]
    diff --git a/net/atm/lec.c b/net/atm/lec.c
    index acef984f336709..1e1f3eb0e2ba3c 100644
    --- a/net/atm/lec.c
    +++ b/net/atm/lec.c
    @@ -124,6 +124,7 @@ static unsigned char bus_mac[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
     
     /* Device structures */
     static struct net_device *dev_lec[MAX_LEC_ITF];
    +static DEFINE_MUTEX(lec_mutex);
     
     #if IS_ENABLED(CONFIG_BRIDGE)
     static void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)
    @@ -742,6 +746,7 @@ static int lecd_attach(struct atm_vcc *vcc, int arg)
     		snprintf(dev_lec[i]->name, IFNAMSIZ, "lec%d", i);
     		if (register_netdev(dev_lec[i])) {
     			free_netdev(dev_lec[i]);
    +			dev_lec[i] = NULL;
     			return -EINVAL;
     		}
     
    @@ -1003,6 +1008,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
     		return -ENOIOCTLCMD;
     	}
     
    +	mutex_lock(&lec_mutex);
     	switch (cmd) {
     	case ATMLEC_CTRL:
     		err = lecd_attach(vcc, (int)arg);
    @@ -1017,6 +1023,7 @@ static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
     		break;
     	}
     
    +	mutex_unlock(&lec_mutex);
     	return err;
     }

[FUNCTION_CONTENT]
static void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)
{
	char *buff;
	struct lec_priv *priv;

	/*
	 * Check if this is a BPDU. If so, ask zeppelin to send
	 * LE_TOPOLOGY_REQUEST with the same value of Topology Change bit
	 * as the Config BPDU has
	 */
	buff = skb->data + skb->dev->hard_header_len;
	if (*buff++ == 0x42 && *buff++ == 0x42 && *buff++ == 0x03) {
		struct sock *sk;
		struct sk_buff *skb2;
		struct atmlec_msg *mesg;

		skb2 = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);
		if (skb2 == NULL)
			return;
		skb2->len = sizeof(struct atmlec_msg);
		mesg = (struct atmlec_msg *)skb2->data;
		mesg->type = l_topology_change;
		buff += 4;
		mesg->content.normal.flag = *buff & 0x01;
					/* 0x01 is topology change */

		priv = netdev_priv(dev);
		atm_force_charge(priv->lecd, skb2->truesize);
		sk = sk_atm(priv->lecd);
		skb_queue_tail(&sk->sk_receive_queue, skb2);
		sk->sk_data_ready(sk);
	}
}

/* ----- separator ----- */

static int lecd_attach(struct atm_vcc *vcc, int arg)
{
	int i;
	struct lec_priv *priv;

	if (arg < 0)
		arg = 0;
	if (arg >= MAX_LEC_ITF)
		return -EINVAL;
	i = array_index_nospec(arg, MAX_LEC_ITF);
	if (!dev_lec[i]) {
		int size;

		size = sizeof(struct lec_priv);
		dev_lec[i] = alloc_etherdev(size);
		if (!dev_lec[i])
			return -ENOMEM;
		dev_lec[i]->netdev_ops = &lec_netdev_ops;
		dev_lec[i]->max_mtu = 18190;
		snprintf(dev_lec[i]->name, IFNAMSIZ, "lec%d", i);
		if (register_netdev(dev_lec[i])) {
			free_netdev(dev_lec[i]);
			return -EINVAL;
		}

		priv = netdev_priv(dev_lec[i]);
	} else {
		priv = netdev_priv(dev_lec[i]);
		if (priv->lecd)
			return -EADDRINUSE;
	}
	lec_arp_init(priv);
	priv->itfnum = i;	/* LANE2 addition */
	priv->lecd = vcc;
	vcc->dev = &lecatm_dev;
	vcc_insert_socket(sk_atm(vcc));

	vcc->proto_data = dev_lec[i];
	set_bit(ATM_VF_META, &vcc->flags);
	set_bit(ATM_VF_READY, &vcc->flags);

	/* Set default values to these variables */
	priv->maximum_unknown_frame_count = 1;
	priv->max_unknown_frame_time = (1 * HZ);
	priv->vcc_timeout_period = (1200 * HZ);
	priv->max_retry_count = 1;
	priv->aging_time = (300 * HZ);
	priv->forward_delay_time = (15 * HZ);
	priv->topology_change = 0;
	priv->arp_response_time = (1 * HZ);
	priv->flush_timeout = (4 * HZ);
	priv->path_switching_delay = (6 * HZ);

	if (dev_lec[i]->flags & IFF_UP)
		netif_start_queue(dev_lec[i]);
	__module_get(THIS_MODULE);
	return i;
}

/* ----- separator ----- */

static int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	struct atm_vcc *vcc = ATM_SD(sock);
	int err = 0;

	switch (cmd) {
	case ATMLEC_CTRL:
	case ATMLEC_MCAST:
	case ATMLEC_DATA:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		break;
	default:
		return -ENOIOCTLCMD;
	}

	switch (cmd) {
	case ATMLEC_CTRL:
		err = lecd_attach(vcc, (int)arg);
		if (err >= 0)
			sock->state = SS_CONNECTED;
		break;
	case ATMLEC_MCAST:
		err = lec_mcast_attach(vcc, (int)arg);
		break;
	case ATMLEC_DATA:
		err = lec_vcc_attach(vcc, (void __user *)arg);
		break;
	}

	return err;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38323

2. Vulnerability Type
Use-after-free due to dangling pointer and missing synchronization (race condition)

3. Root Cause Summary
The error path in lecd_attach() freed a newly allocated net_device with free_netdev(dev_lec[i]) when register_netdev() failed, but left the global pointer dev_lec[i] non-NULL, creating a dangling pointer. Concurrent ioctl handlers (ATMLEC_CTRL/MCAST/DATA) accessed and modified the shared dev_lec[] array without any mutual exclusion, allowing races where another thread could dereference the freed net_device. This combination led to slab-use-after-free in lecd_attach() and lane_ioctl(), as reported by KASAN.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
net/atm LANE (lec) driver (net/atm/lec.c)

2) Pre-Patch Flaw:
- In lecd_attach(): on register_netdev() failure, the code executed "free_netdev(dev_lec[i]);" but did not clear dev_lec[i], leaving a stale pointer.
- lane_ioctl() invoked lecd_attach(), lec_mcast_attach(), and lec_vcc_attach() without any locking, despite all touching the shared dev_lec[] array.

3) Trigger Condition:
- Issuing ATMLEC_CTRL ioctl to create/attach an LEC interface where register_netdev() fails (error path).
- Or running concurrent ATMLEC_* ioctls across sockets that access the same dev_lec[i], racing with the error path or other attach paths.

4) Impact Mechanism:
- Subsequent code paths observed dev_lec[i] as non-NULL and dereferenced it (e.g., netdev_priv(dev_lec[i]) or state checks), resulting in reads from freed memory. KASAN reported slab-use-after-free in lecd_attach() and lane_ioctl(), confirming UAF due to the dangling dev_lec[i] and lack of synchronization.

5. Patch Analysis
1) Fix Approach:
- Eliminate the dangling pointer by explicitly nulling dev_lec[i] after free_netdev() on the error path.
- Introduce a global mutex (lec_mutex) to serialize all ioctl-driven access to dev_lec[] from lecd_attach(), lec_vcc_attach(), and lec_mcast_attach(), removing the race window.

2) Key Code Changes:
- Added "static DEFINE_MUTEX(lec_mutex);" to lec.c.
- In lecd_attach(): after free_netdev(dev_lec[i]) on register_netdev() failure, added "dev_lec[i] = NULL;" to prevent stale references.
- In lane_ioctl(): added mutex_lock(&lec_mutex) before the switch handling ATMLEC_CTRL/MCAST/DATA and mutex_unlock(&lec_mutex) after, ensuring exclusive access during modifications and checks of dev_lec[].

3) Locking/Concurrency Impact:
- Pre-patch: no locking around global dev_lec[] led to races between ioctl handlers and error paths, enabling use of freed objects.
- Post-patch: lec_mutex enforces mutual exclusion for all ioctl operations that touch dev_lec[], preventing concurrent attach/mcast/data operations from observing or acting on partially initialized or freed entries.
- Pointer nullification guarantees that even if observed without races, subsequent logic will not treat a freed entry as valid.

6. Broader Kernel Security Implications
This fix removes a UAF primitive in a legacy networking subsystem by addressing both error-path hygiene (nulling after free) and missing serialization over shared global state. It highlights the need for consistent locking around shared arrays/registries and defensive clearing of pointers on failure paths. The introduced mutex also sets the groundwork for safely exposing lec state via procfs (as mentioned in the patch description), reducing future information leak or UAF risks stemming from concurrent readers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}