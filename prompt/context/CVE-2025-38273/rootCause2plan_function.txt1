You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38273

[INFO]
[PATCH_DESCRIPTION]
    net: tipc: fix refcount warning in tipc_aead_encrypt
    syzbot reported a refcount warning [1] caused by calling get_net() on
    a network namespace that is being destroyed (refcount=0). This happens
    when a TIPC discovery timer fires during network namespace cleanup.
    
    The recently added get_net() call in commit e279024617134 ("net/tipc:
    fix slab-use-after-free Read in tipc_aead_encrypt_done") attempts to
    hold a reference to the network namespace. However, if the namespace
    is already being destroyed, its refcount might be zero, leading to the
'   use-after-free warning.
    
    Replace get_net() with maybe_get_net(), which safely checks if the
    refcount is non-zero before incrementing it. If the namespace is being
    destroyed, return -ENODEV early, after releasing the bearer reference.

[PATCH_DIFF]
     @@ -818,7 +818,11 @@ static int tipc_aead_encrypt(struct tipc_aead *aead, struct sk_buff *skb,
      	}
      
      	/* Get net to avoid freed tipc_crypto when delete namespace */
     -	get_net(aead->crypto->net);
     +	if (!maybe_get_net(aead->crypto->net)) {
     +		tipc_bearer_put(b);
     +		rc = -ENODEV;
     +		goto exit;
     +	}
      
      	/* Now, do encrypt */
      	rc = crypto_aead_encrypt(req);

[FUNCTION_CONTENT]
static int tipc_aead_encrypt(struct tipc_aead *aead, struct sk_buff *skb,
			     struct tipc_bearer *b,
			     struct tipc_media_addr *dst,
			     struct tipc_node *__dnode)
{
	struct crypto_aead *tfm = tipc_aead_tfm_next(aead);
	struct tipc_crypto_tx_ctx *tx_ctx;
	struct aead_request *req;
	struct sk_buff *trailer;
	struct scatterlist *sg;
	struct tipc_ehdr *ehdr;
	int ehsz, len, tailen, nsg, rc;
	void *ctx;
	u32 salt;
	u8 *iv;

	/* Make sure message len at least 4-byte aligned */
	len = ALIGN(skb->len, 4);
	tailen = len - skb->len + aead->authsize;

	/* Expand skb tail for authentication tag:
	 * As for simplicity, we'd have made sure skb having enough tailroom
	 * for authentication tag @skb allocation. Even when skb is nonlinear
	 * but there is no frag_list, it should be still fine!
	 * Otherwise, we must cow it to be a writable buffer with the tailroom.
	 */
	SKB_LINEAR_ASSERT(skb);
	if (tailen > skb_tailroom(skb)) {
		pr_debug("TX(): skb tailroom is not enough: %d, requires: %d\n",
			 skb_tailroom(skb), tailen);
	}

	nsg = skb_cow_data(skb, tailen, &trailer);
	if (unlikely(nsg < 0)) {
		pr_err("TX: skb_cow_data() returned %d\n", nsg);
		return nsg;
	}

	pskb_put(skb, trailer, tailen);

	/* Allocate memory for the AEAD operation */
	ctx = tipc_aead_mem_alloc(tfm, sizeof(*tx_ctx), &iv, &req, &sg, nsg);
	if (unlikely(!ctx))
		return -ENOMEM;
	TIPC_SKB_CB(skb)->crypto_ctx = ctx;

	/* Map skb to the sg lists */
	sg_init_table(sg, nsg);
	rc = skb_to_sgvec(skb, sg, 0, skb->len);
	if (unlikely(rc < 0)) {
		pr_err("TX: skb_to_sgvec() returned %d, nsg %d!\n", rc, nsg);
		goto exit;
	}

	/* Prepare IV: [SALT (4 octets)][SEQNO (8 octets)]
	 * In case we're in cluster-key mode, SALT is varied by xor-ing with
	 * the source address (or w0 of id), otherwise with the dest address
	 * if dest is known.
	 */
	ehdr = (struct tipc_ehdr *)skb->data;
	salt = aead->salt;
	if (aead->mode == CLUSTER_KEY)
		salt ^= __be32_to_cpu(ehdr->addr);
	else if (__dnode)
		salt ^= tipc_node_get_addr(__dnode);
	memcpy(iv, &salt, 4);
	memcpy(iv + 4, (u8 *)&ehdr->seqno, 8);

	/* Prepare request */
	ehsz = tipc_ehdr_size(ehdr);
	aead_request_set_tfm(req, tfm);
	aead_request_set_ad(req, ehsz);
	aead_request_set_crypt(req, sg, sg, len - ehsz, iv);

	/* Set callback function & data */
	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
				  tipc_aead_encrypt_done, skb);
	tx_ctx = (struct tipc_crypto_tx_ctx *)ctx;
	tx_ctx->aead = aead;
	tx_ctx->bearer = b;
	memcpy(&tx_ctx->dst, dst, sizeof(*dst));

	/* Hold bearer */
	if (unlikely(!tipc_bearer_hold(b))) {
		rc = -ENODEV;
		goto exit;
	}

	/* Get net to avoid freed tipc_crypto when delete namespace */
	get_net(aead->crypto->net);

	/* Now, do encrypt */
	rc = crypto_aead_encrypt(req);
	if (rc == -EINPROGRESS || rc == -EBUSY)
		return rc;

	tipc_bearer_put(b);
	put_net(aead->crypto->net);

exit:
	kfree(ctx);
	TIPC_SKB_CB(skb)->crypto_ctx = NULL;
	return rc;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38273

2. Vulnerability Type
Reference counting/lifetime bug leading to use-after-free warning during network namespace teardown

3. Root Cause Summary
tipc_aead_encrypt unconditionally called get_net(aead->crypto->net) to hold a network namespace reference, even when the namespace was already in teardown with refcount=0. This improper refcount increment on a zeroed refcount (using refcount_t) triggers a refcount warning and risks accessing freed objects associated with the namespace during the AEAD encryption workflow and its completion callback. The flaw is a missing validation of the netns refcount/state before acquiring the reference in an asynchronous context that races with namespace destruction.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
net/tipc (Transparent Inter-Process Communication), AEAD encryption path in tipc_aead_encrypt

2) Pre-Patch Flaw:
Unconditional get_net on aead->crypto->net after successfully holding the bearer, without checking whether the network namespace is already being destroyed (refcount==0). Specifically, the code did: "get_net(aead->crypto->net);" in tipc_aead_encrypt, relying on it to prevent tipc_crypto from being freed, but failing when the namespace is in teardown.

3) Trigger Condition:
A TIPC discovery timer fires while the associated network namespace is being cleaned up, making aead->crypto->net’s refcount zero. tipc_aead_encrypt is invoked and calls get_net on this dying namespace, racing with its destruction.

4) Impact Mechanism:
Incrementing a refcount_t from zero triggers a refcount warning and indicates use-after-free risk. Continuing with the AEAD request and later calling put_net may operate on an invalid netns and associated tipc_crypto state, potentially leading to UAF in the completion path or other memory safety violations.

5. Patch Analysis
1) Fix Approach:
Replace get_net with maybe_get_net to atomically check the namespace’s refcount before incrementing. If the refcount is zero (namespace being destroyed), abort the operation early, release the bearer reference, and return -ENODEV to avoid using freed resources.

2) Key Code Changes:
- Changed: get_net(aead->crypto->net);
- To: if (!maybe_get_net(aead->crypto->net)) { tipc_bearer_put(b); rc = -ENODEV; goto exit; }
This introduces a safe conditional reference acquisition and ensures proper rollback of previously acquired bearer references on failure.

3) Locking/Concurrency Impact:
No new locks added; the race with netns teardown is mitigated by using maybe_get_net’s atomic refcount check to prevent acquiring a reference on a dying namespace. Early exit prevents scheduling the crypto operation and avoids subsequent put_net on an invalid netns, reducing lifetime/race hazards.

6. Broader Kernel Security Implications
Correct refcount handling around network namespace lifetimes is crucial in asynchronous paths (timers, workqueues, crypto callbacks). Failing to guard reference acquisition in teardown races can lead to use-after-free, kernel warnings, and stability issues. The fix strengthens lifetime management in TIPC crypto paths, reducing UAF exposure during namespace cleanup and exemplifying the need for safe try-get patterns in netns-sensitive code.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}