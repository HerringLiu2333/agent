You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38495

[INFO]
[PATCH_DESCRIPTION]
    HID: core: ensure the allocated report buffer can contain the reserved report ID
    When the report ID is not used, the low level transport drivers expect
    the first byte to be 0. However, currently the allocated buffer not
    account for that extra byte, meaning that instead of having 8 guaranteed
    bytes for implement to be working, we only have 7.

[PATCH_DIFF]
    @@ -1883,9 +1883,12 @@ u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
     	/*
     	 * 7 extra bytes are necessary to achieve proper functionality
     	 * of implement() working on 8 byte chunks
+	 * 1 extra byte for the report ID if it is null (not used) so
+	 * we can reserve that extra byte in the first position of the buffer
+	 * when sending it to .raw_request()
     	 */
     
-	u32 len = hid_report_len(report) + 7;
+	u32 len = hid_report_len(report) + 7 + (report->id == 0);
     
     	return kzalloc(len, flags);
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38495

2. Vulnerability Type
Heap buffer under-allocation leading to out-of-bounds write (off-by-one) due to length miscalculation.

3. Root Cause Summary
hid_alloc_report_buf() miscomputed the buffer size when the HID report has no report ID (report->id == 0). The pre-patch logic allocated hid_report_len(report) + 7 bytes, but low-level transport drivers reserve the first byte for a zero report ID and implement() operates on 8-byte chunks. This left only 7 “extra” bytes instead of the required 8, causing a 1-byte overrun when drivers wrote the reserved ID byte plus an 8-byte chunk.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID core (hid_alloc_report_buf in HID report handling)

2) Pre-Patch Flaw:
Incorrect buffer length calculation: u32 len = hid_report_len(report) + 7; did not include an extra byte for the reserved report ID when report->id == 0, despite drivers expecting the first byte to be 0 in this case.

3) Trigger Condition:
Any path that allocates a report buffer via hid_alloc_report_buf() for a report with report->id == 0 and then sends it to .raw_request() or processes it with implement() working on 8-byte chunks.

4) Impact Mechanism:
The under-sized kzalloc leads to a write past the end of the buffer (by 1 byte) when the driver writes the reserved first byte for the null report ID and then performs 8-byte chunk operations, causing kernel heap memory corruption and potential denial of service.

5. Patch Analysis
1) Fix Approach:
Adjust buffer allocation size to account for the reserved report ID byte when report->id == 0, ensuring the buffer contains hid_report_len(report) + 7 + 1 bytes in that case.

2) Key Code Changes:
- In hid_alloc_report_buf():
  - Change: u32 len = hid_report_len(report) + 7;
  - To: u32 len = hid_report_len(report) + 7 + (report->id == 0);
- Added explanatory comments clarifying the need for an extra byte for a null report ID and the 8-byte chunk expectations of implement().

3) Locking/Concurrency Impact:
None. The change is limited to buffer size calculation and allocation; no locking or synchronization semantics were modified.

6. Broader Kernel Security Implications
This issue highlights the risk of off-by-one allocation errors tied to protocol-specific headers or reserved fields in kernel subsystems. Ensuring buffer sizing correctly accounts for transport expectations (e.g., reserved report ID bytes) is critical to prevent heap corruption. Similar allocation paths in HID and other subsystems should be audited for conditional header/reserved-byte handling to avoid subtle under-allocation bugs that can be triggered by device inputs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}