You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38495

[INFO]
[PATCH_DESCRIPTION]
    HID: core: ensure the allocated report buffer can contain the reserved report ID
    When the report ID is not used, the low level transport drivers expect
    the first byte to be 0. However, currently the allocated buffer not
    account for that extra byte, meaning that instead of having 8 guaranteed
    bytes for implement to be working, we only have 7.

[PATCH_DIFF]
    @@ -1883,9 +1883,12 @@ u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
     	/*
     	 * 7 extra bytes are necessary to achieve proper functionality
     	 * of implement() working on 8 byte chunks
+	 * 1 extra byte for the report ID if it is null (not used) so
+	 * we can reserve that extra byte in the first position of the buffer
+	 * when sending it to .raw_request()
     	 */
     
-	u32 len = hid_report_len(report) + 7;
+	u32 len = hid_report_len(report) + 7 + (report->id == 0);
     
     	return kzalloc(len, flags);
     }

[FUNCTION_CONTENT]
u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
{
	/*
	 * 7 extra bytes are necessary to achieve proper functionality
	 * of implement() working on 8 byte chunks
	 */

	u32 len = hid_report_len(report) + 7;

	return kzalloc(len, flags);
}

/* ----- separator ----- */

EXPORT_SYMBOL_GPL(hid_output_report);

/*
 * Allocator for buffer that is going to be passed to hid_output_report()
 */
u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
{
	/*
	 * 7 extra bytes are necessary to achieve proper functionality
	 * of implement() working on 8 byte chunks
	 */

	u32 len = hid_report_len(report) + 7;

	return kzalloc(len, flags);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38495

2. Vulnerability Type
Heap buffer under-allocation leading to out-of-bounds write/read (memory corruption)

3. Root Cause Summary
The HID core allocator hid_alloc_report_buf() miscomputed the buffer length by only adding 7 bytes for 8-byte chunk processing and failed to reserve an extra byte when the report ID is unused (report->id == 0). Low-level transport drivers expect the first byte of such buffers to be 0 (reserved report ID), but the pre-patch buffer length (hid_report_len(report) + 7) did not include this extra byte. This off-by-one under-allocation could cause writes or reads past the end of the allocated buffer when the reserved ID byte is used or when working on 8-byte chunks.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- HID core (buffer allocation for output/raw requests)

2) Pre-Patch Flaw:
- In hid_alloc_report_buf(), the length was computed as "u32 len = hid_report_len(report) + 7;" without accounting for an extra leading byte required when report->id == 0. This omitted reservation for the null report ID that transport drivers place at the first position.

3) Trigger Condition:
- Any path that allocates a report buffer via hid_alloc_report_buf() for a report with report->id == 0 and then uses it with hid_output_report() or .raw_request(), where the first byte is expected to be a reserved 0 and 8-byte chunk operations are performed.

4) Impact Mechanism:
- The buffer is one byte too small; writing the reserved ID at buf[0] and performing 8-byte chunk operations can cause a one-byte out-of-bounds write/read at the buffer end, leading to slab corruption, potential kernel crashes, or information disclosure.

5. Patch Analysis
1) Fix Approach:
- Correct the buffer size calculation by adding one extra byte when report->id == 0, ensuring space for the reserved report ID. This preserves the existing 7-byte padding for 8-byte chunk operations and prevents OOB access.

2) Key Code Changes:
- In hid_alloc_report_buf():
  - Changed "u32 len = hid_report_len(report) + 7;" to "u32 len = hid_report_len(report) + 7 + (report->id == 0);"
  - Added explanatory comments: "1 extra byte for the report ID if it is null (not used) ... when sending it to .raw_request()".

3) Locking/Concurrency Impact:
- None. The change is limited to size computation and allocation; no locks or ordering semantics were modified.

6. Broader Kernel Security Implications
- Ensuring accurate buffer sizing in core subsystems like HID is critical to prevent subtle heap overflows that can be triggered by common I/O paths. This fix reduces the risk of memory corruption and potential exploitation stemming from device- or userspace-controlled HID traffic. It highlights the importance of accounting for protocol-specific fields (e.g., report ID) in buffer allocations to maintain kernel robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.