You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38485

[INFO]
[PATCH_DESCRIPTION]
    iio: accel: fxls8962af: Fix use after free in fxls8962af_fifo_flush
    fxls8962af_fifo_flush() uses indio_dev->active_scan_mask (with
    iio_for_each_active_channel()) without making sure the indio_dev
    stays in buffer mode.
    There is a race if indio_dev exits buffer mode in the middle of the
    interrupt that flushes the fifo. Fix this by calling
    synchronize_irq() to ensure that no interrupt is currently running when
    disabling buffer mode.
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read
    [...]
    _find_first_bit_le from fxls8962af_fifo_flush+0x17c/0x290
    fxls8962af_fifo_flush from fxls8962af_interrupt+0x80/0x178
    fxls8962af_interrupt from irq_thread_fn+0x1c/0x7c
    irq_thread_fn from irq_thread+0x110/0x1f4
    irq_thread from kthread+0xe0/0xfc
    kthread from ret_from_fork+0x14/0x2c

[PATCH_DIFF]
    @@ -877,6 +877,8 @@ static int fxls8962af_buffer_predisable(struct iio_dev *indio_dev)
     	if (ret)
     		return ret;
     
    +	synchronize_irq(data->irq);
    +
     	ret = __fxls8962af_fifo_set_mode(data, false);
     
     	if (data->enable_event)

[FUNCTION_CONTENT]
static int fxls8962af_buffer_predisable(struct iio_dev *indio_dev)
{
	struct fxls8962af_data *data = iio_priv(indio_dev);
	int ret;

	fxls8962af_standby(data);

	/* Disable buffer interrupt */
	ret = regmap_clear_bits(data->regmap, FXLS8962AF_INT_EN,
				FXLS8962AF_INT_EN_BUF_EN);
	if (ret)
		return ret;

	ret = __fxls8962af_fifo_set_mode(data, false);

	if (data->enable_event)
		fxls8962af_active(data);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38485

2. Vulnerability Type
Race condition leading to use-after-free/NULL dereference in interrupt handler

3. Root Cause Summary
The driver exited buffer mode without synchronizing with the device IRQ thread, allowing fxls8962af_interrupt() to run fxls8962af_fifo_flush() concurrently while indio_dev->active_scan_mask was being torn down. fxls8962af_fifo_flush() iterates channels via iio_for_each_active_channel(), which dereferences indio_dev->active_scan_mask and calls _find_first_bit_le. Without synchronization, active_scan_mask could become NULL or invalid (freed) during buffer teardown, causing a NULL pointer dereference/use-after-free. The missing step was to wait for any in-flight IRQ handlers to complete before disabling FIFO mode and changing buffer state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) accelerometer driver: fxls8962af (NXP FXLS8962AF)

2) Pre-Patch Flaw:
fxls8962af_buffer_predisable() disabled buffer interrupts and FIFO mode without ensuring no IRQ handler was currently executing (no synchronize_irq). The interrupt path fxls8962af_interrupt() could call fxls8962af_fifo_flush() which uses indio_dev->active_scan_mask, racing with buffer teardown that invalidates this mask.

3) Trigger Condition:
Disabling buffer mode while an IRQ is pending or the irq thread is running, so fxls8962af_fifo_flush() executes after indio_dev->active_scan_mask has been cleared/freed by the buffer disable path.

4) Impact Mechanism:
iio_for_each_active_channel() dereferences indio_dev->active_scan_mask inside fxls8962af_fifo_flush(); with the race, this pointer becomes NULL/invalid, leading to a NULL pointer dereference in _find_first_bit_le and potentially use-after-free, crashing the kernel (as reflected in the stack trace).

5. Patch Analysis
1) Fix Approach:
Serialize buffer teardown with the IRQ handler by calling synchronize_irq(data->irq) during predisable, ensuring no interrupt is currently running before disabling FIFO mode and finalizing buffer exit.

2) Key Code Changes:
Inserted synchronize_irq(data->irq) in fxls8962af_buffer_predisable() after clearing the device’s buffer interrupt enable bit and before calling __fxls8962af_fifo_set_mode(data, false):
- Before: cleared FXLS8962AF_INT_EN_BUF_EN and immediately set FIFO mode false.
- After: cleared FXLS8962AF_INT_EN_BUF_EN, then synchronize_irq(data->irq), then set FIFO mode false.

3) Locking/Concurrency Impact:
Adding synchronize_irq enforces ordering and mutual exclusion between the IRQ thread (fxls8962af_interrupt → fxls8962af_fifo_flush) and the buffer disable path. It closes the race window where the interrupt could access active_scan_mask while buffer mode is being torn down, preventing UAF/NULL deref.

6. Broader Kernel Security Implications
Driver transitions that affect buffer state and shared structures must synchronize with interrupt handlers to prevent lifetime violations, UAF, and kernel crashes. This fix exemplifies the need to pair interrupt disablement with synchronize_irq (or equivalent) during mode changes. Similar patterns across IIO and other subsystems should be audited to ensure object lifetimes remain valid under concurrent IRQ/thread execution.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.