You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38485

[INFO]
[PATCH_DESCRIPTION]
    iio: accel: fxls8962af: Fix use after free in fxls8962af_fifo_flush
    fxls8962af_fifo_flush() uses indio_dev->active_scan_mask (with
    iio_for_each_active_channel()) without making sure the indio_dev
    stays in buffer mode.
    There is a race if indio_dev exits buffer mode in the middle of the
    interrupt that flushes the fifo. Fix this by calling
    synchronize_irq() to ensure that no interrupt is currently running when
    disabling buffer mode.
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read
    [...]
    _find_first_bit_le from fxls8962af_fifo_flush+0x17c/0x290
    fxls8962af_fifo_flush from fxls8962af_interrupt+0x80/0x178
    fxls8962af_interrupt from irq_thread_fn+0x1c/0x7c
    irq_thread_fn from irq_thread+0x110/0x1f4
    irq_thread from kthread+0xe0/0xfc
    kthread from ret_from_fork+0x14/0x2c

[PATCH_DIFF]
    @@ -877,6 +877,8 @@ static int fxls8962af_buffer_predisable(struct iio_dev *indio_dev)
     	if (ret)
     		return ret;
     
    +	synchronize_irq(data->irq);
    +
     	ret = __fxls8962af_fifo_set_mode(data, false);
     
     	if (data->enable_event)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38485

2. Vulnerability Type
Use-after-free due to interrupt/teardown race, leading to NULL pointer dereference

3. Root Cause Summary
fxls8962af_fifo_flush() iterates channels via iio_for_each_active_channel(indio_dev, …), reading indio_dev->active_scan_mask, while buffer teardown can concurrently clear/free that mask. The pre-patch buffer disable path (fxls8962af_buffer_predisable) did not synchronize with the device IRQ, allowing fxls8962af_interrupt -> fxls8962af_fifo_flush to run while buffer mode was being disabled, causing a race on active_scan_mask. This missing synchronization created a window where fxls8962af_fifo_flush dereferenced a stale/NULL mask, triggering a use-after-free/NULL dereference in find_first_bit().

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) accelerometer driver: drivers/iio/accel/fxls8962af

2) Pre-Patch Flaw:
- fxls8962af_fifo_flush() uses indio_dev->active_scan_mask via iio_for_each_active_channel() without ensuring indio_dev remains in buffer mode.
- fxls8962af_buffer_predisable() disabled buffer/FIFO state without first quiescing the IRQ, leaving the interrupt handler free to run concurrently.

3) Trigger Condition:
- Concurrent execution of fxls8962af_interrupt (which calls fxls8962af_fifo_flush) while fxls8962af_buffer_predisable is disabling buffer mode.
- During this overlap, the IIO core can clear/free active_scan_mask, and the interrupt-driven flush still tries to read it.

4) Impact Mechanism:
- Dereference of indio_dev->active_scan_mask during iio_for_each_active_channel() calls into _find_first_bit_le on a freed/NULL pointer, causing “Unable to handle kernel NULL pointer dereference” with stack: _find_first_bit_le → fxls8962af_fifo_flush → fxls8962af_interrupt → irq_thread_fn → irq_thread.
- Results in kernel crash (DoS) and a classic UAF race in the IRQ path.

5. Patch Analysis
1) Fix Approach:
Introduce IRQ synchronization before disabling buffer mode to eliminate the race window between the IRQ handler and buffer teardown.

2) Key Code Changes:
- In fxls8962af_buffer_predisable():
  - Added synchronize_irq(data->irq);
  - This is placed immediately before __fxls8962af_fifo_set_mode(data, false), ensuring no interrupt is executing when buffer/FIFO is turned off.

3) Locking/Concurrency Impact:
- synchronize_irq(data->irq) acts as a barrier that waits for any in-flight interrupt handler (including threaded IRQ path) to complete before state changes occur.
- This orders operations so that fxls8962af_interrupt/fxls8962af_fifo_flush cannot access active_scan_mask while buffer mode is being disabled, removing the UAF/NULL deref race without introducing additional locks.

6. Broader Kernel Security Implications
This fix underscores the need to quiesce device interrupts before tearing down shared state used by IRQ handlers, especially in IIO drivers where buffer and scan masks can be invalidated on disable. Failure to synchronize IRQs during teardown is a common kernel anti-pattern that leads to race-induced UAF/NULL dereferences and system instability. Similar drivers should ensure IRQs are disabled or synchronized before modifying or freeing buffer-related structures to prevent exploitable concurrency bugs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.