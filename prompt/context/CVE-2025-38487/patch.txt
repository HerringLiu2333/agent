     @@ -58,6 +58,7 @@ struct aspeed_lpc_snoop_model_data {
      };
      
      struct aspeed_lpc_snoop_channel {
     +	bool enabled;
      	struct kfifo		fifo;
      	wait_queue_head_t	wq;
      	struct miscdevice	miscdev;
     @@ -190,6 +191,9 @@ static int aspeed_lpc_enable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
      	const struct aspeed_lpc_snoop_model_data *model_data =
      		of_device_get_match_data(dev);
      
     +	if (WARN_ON(lpc_snoop->chan[channel].enabled))
     +		return -EBUSY;
     +
      	init_waitqueue_head(&lpc_snoop->chan[channel].wq);
      	/* Create FIFO datastructure */
      	rc = kfifo_alloc(&lpc_snoop->chan[channel].fifo,
     @@ -236,6 +240,8 @@ static int aspeed_lpc_enable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
      		regmap_update_bits(lpc_snoop->regmap, HICRB,
      				hicrb_en, hicrb_en);
      
     +	lpc_snoop->chan[channel].enabled = true;
     +
      	return 0;
      
      err_misc_deregister:
     @@ -248,6 +254,9 @@ err_free_fifo:
      static void aspeed_lpc_disable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
      				     int channel)
      {
     +	if (!lpc_snoop->chan[channel].enabled)
     +		return;
     +
      	switch (channel) {
      	case 0:
      		regmap_update_bits(lpc_snoop->regmap, HICR5,
     @@ -263,6 +272,8 @@ static void aspeed_lpc_disable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
      		return;
      	}
      
     +	lpc_snoop->chan[channel].enabled = false;
     +	/* Consider improving safety wrt concurrent reader(s) */
      	misc_deregister(&lpc_snoop->chan[channel].miscdev);
      	kfifo_free(&lpc_snoop->chan[channel].fifo);
      }