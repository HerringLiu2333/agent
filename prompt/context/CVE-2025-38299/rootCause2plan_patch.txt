You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38299

[INFO]
[PATCH_DESCRIPTION]
    ASoC: mediatek: mt8195: Set ETDM1/2 IN/OUT to COMP_DUMMY()
    ETDM2_IN_BE and ETDM1_OUT_BE are defined as COMP_EMPTY(),
    in the case the codec dai_name will be null.
    
    Avoid a crash if the device tree is not assigning a codec
    to these links.
    
    [    1.179936] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000
    [    1.181065] Mem abort info:
    [    1.181420]   ESR = 0x0000000096000004
    [    1.181892]   EC = 0x25: DABT (current EL), IL = 32 bits
    [    1.182576]   SET = 0, FnV = 0
    [    1.182964]   EA = 0, S1PTW = 0
    [    1.183367]   FSC = 0x04: level 0 translation fault
    [    1.183983] Data abort info:
    [    1.184406]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
    [    1.185097]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0
    [    1.185766]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
    [    1.186439] [0000000000000000] user address but active_mm is swapper
    [    1.187239] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
    [    1.188029] Modules linked in:
    [    1.188420] CPU: 7 UID: 0 PID: 70 Comm: kworker/u32:1 Not tainted 6.14.0-rc4-next-20250226+ #85
    [    1.189515] Hardware name: Radxa NIO 12L (DT)
    [    1.190065] Workqueue: events_unbound deferred_probe_work_func
    [    1.190808] pstate: 40400009 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
    [    1.191683] pc : __pi_strcmp+0x24/0x140
    [    1.192170] lr : mt8195_mt6359_soc_card_probe+0x224/0x7b0
    [    1.192854] sp : ffff800083473970
    [    1.193271] x29: ffff800083473a10 x28: 0000000000001008 x27: 0000000000000002
    [    1.194168] x26: ffff800082408960 x25: ffff800082417db0 x24: ffff800082417d88
    [    1.195065] x23: 000000000000001e x22: ffff800082dbf480 x21: ffff800082dc07b8
    [    1.195961] x20: 0000000000000000 x19: 0000000000000013 x18: 00000000ffffffff
    [    1.196858] x17: 000000040044ffff x16: 005000f2b5503510 x15: 0000000000000006
    [    1.197755] x14: ffff800082407af0 x13: 6e6f69737265766e x12: 692d6b636f6c6374
    [    1.198651] x11: 0000000000000002 x10: ffff80008240b920 x9 : 0000000000000018
    [    1.199547] x8 : 0101010101010101 x7 : 0000000000000000 x6 : 0000000000000000
    [    1.200443] x5 : 0000000000000000 x4 : 8080808080000000 x3 : 303933383978616d
    [    1.201339] x2 : 0000000000000000 x1 : ffff80008240b920 x0 : 0000000000000000
    [    1.202236] Call trace:
    [    1.202545]  __pi_strcmp+0x24/0x140 (P)
    [    1.203029]  mtk_soundcard_common_probe+0x3bc/0x5b8
    [    1.203644]  platform_probe+0x70/0xe8
    [    1.204106]  really_probe+0xc8/0x3a0
    [    1.204556]  __driver_probe_device+0x84/0x160
    [    1.205104]  driver_probe_device+0x44/0x130
    [    1.205630]  __device_attach_driver+0xc4/0x170
    [    1.206189]  bus_for_each_drv+0x8c/0xf8
    [    1.206672]  __device_attach+0xa8/0x1c8
    [    1.207155]  device_initial_probe+0x1c/0x30
    [    1.207681]  bus_probe_device+0xb0/0xc0
    [    1.208165]  deferred_probe_work_func+0xa4/0x100
    [    1.208747]  process_one_work+0x158/0x3e0
    [    1.209254]  worker_thread+0x2c4/0x3e8
    [    1.209727]  kthread+0x134/0x1f0
    [    1.210136]  ret_from_fork+0x10/0x20
    [    1.210589] Code: 54000401 b50002c6 d503201f f86a6803 (f8408402)
    [    1.211355] ---[ end trace 0000000000000000 ]---

[PATCH_DIFF]
    @@ -831,12 +831,12 @@ SND_SOC_DAILINK_DEFS(ETDM1_IN_BE,
     
     SND_SOC_DAILINK_DEFS(ETDM2_IN_BE,
    		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM2_IN")),
    -		     DAILINK_COMP_ARRAY(COMP_EMPTY()),
    +		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
    		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
     
     SND_SOC_DAILINK_DEFS(ETDM1_OUT_BE,
    		     DAILINK_COMP_ARRAY(COMP_CPU("ETDM1_OUT")),
    -		     DAILINK_COMP_ARRAY(COMP_EMPTY()),
    +		     DAILINK_COMP_ARRAY(COMP_DUMMY()),
    		     DAILINK_COMP_ARRAY(COMP_EMPTY()));
     
     SND_SOC_DAILINK_DEFS(ETDM2_OUT_BE,



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38299

2. Vulnerability Type
NULL pointer dereference (missing handling of optional codec component)

3. Root Cause Summary
The MT8195 ASoC card defined the codec component for ETDM2_IN_BE and ETDM1_OUT_BE as COMP_EMPTY(), which leaves the codec dai_name NULL when the device tree does not provide a codec for these links. Subsequent probe logic (mtk_soundcard_common_probe) unconditionally compares this name, leading to a NULL pointer passed into strcmp (__pi_strcmp), and a kernel crash. The patch replaces COMP_EMPTY() with COMP_DUMMY(), ensuring a valid dummy component so that dai_name is not NULL and probe code does not dereference a NULL pointer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA SoC (ASoC) – MediaTek MT8195 machine driver/link definitions

2) Pre-Patch Flaw:
- ETDM2_IN_BE and ETDM1_OUT_BE were defined with DAILINK_COMP_ARRAY(COMP_EMPTY()), leaving the codec dai_name unset (NULL) if DT did not bind a codec.
- Probe path (mtk_soundcard_common_probe) performs string comparisons on the codec DAI name without guarding against NULL, resulting in calling __pi_strcmp with a NULL pointer.

3) Trigger Condition:
- Device tree omits assigning a codec to ETDM2_IN_BE or ETDM1_OUT_BE.
- During deferred probe (deferred_probe_work_func), mtk_soundcard_common_probe iterates links and attempts strcmp on a NULL dai_name, triggering the fault.

4) Impact Mechanism:
- A NULL pointer dereference in __pi_strcmp (pc: __pi_strcmp+0x24/0x140) causes an oops during probe, leading to a boot-time crash/denial of service on affected platforms.

5. Patch Analysis
1) Fix Approach:
- Convert the codec component for the affected DAI links from COMP_EMPTY() to COMP_DUMMY(), providing a valid dummy codec endpoint when no real codec is specified by DT.
- This ensures the ASoC core/machine driver has a non-NULL codec dai_name or otherwise valid placeholder, preventing NULL dereferences in comparison logic.

2) Key Code Changes:
- In SND_SOC_DAILINK_DEFS(ETDM2_IN_BE): DAILINK_COMP_ARRAY(COMP_EMPTY()) -> DAILINK_COMP_ARRAY(COMP_DUMMY()).
- In SND_SOC_DAILINK_DEFS(ETDM1_OUT_BE): DAILINK_COMP_ARRAY(COMP_EMPTY()) -> DAILINK_COMP_ARRAY(COMP_DUMMY()).

3) Locking/Concurrency Impact:
- None. The change is declarative in DAI link component definitions and does not alter locking or execution order.

6. Broader Kernel Security Implications
- Strengthens robustness of ASoC machine drivers against incomplete or optional DT configurations by using dummy components for unconnected links.
- Prevents boot-time denial-of-service conditions caused by NULL dereferences in probe paths.
- Encourages correct use of COMP_DUMMY() for optional endpoints, reducing similar NULL handling bugs in other ASoC drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.