You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58014

[INFO]
[PATCH_DESCRIPTION]
 wifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()
 [ Upstream commit 3f4a0948c3524ae50f166dbc6572a3296b014e62 ]
 
 In 'wlc_phy_iqcal_gainparams_nphy()', add gain range check to WARN()
 instead of possible out-of-bounds 'tbl_iqcal_gainparams_nphy' access.
 Compile tested only.

 Found by Linux Verification Center (linuxtesting.org) with SVACE.

[PATCH_DIFF]
 diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c
 index 8580a275478918…42e7bc67e9143e 100644
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c
 @@ -23427,6 +23427,9 @@ wlc_phy_iqcal_gainparams_nphy(struct brcms_phy *pi, u16 core_no,
   break;
 }

 + if (WARN_ON(k == NPHY_IQCAL_NUMGAINS))
 + return;
 +
   params->txgm = tbl_iqcal_gainparams_nphy[band_idx][k][1];
   params->pga = tbl_iqcal_gainparams_nphy[band_idx][k][2];
   params->pad = tbl_iqcal_gainparams_nphy[band_idx][k][3];

[FUNCTION_CONTENT]
static void
wlc_phy_iqcal_gainparams_nphy(struct brcms_phy *pi, u16 core_no,
			      struct nphy_txgains target_gain,
			      struct nphy_iqcal_params *params)
{
	u8 k;
	u16 gain_index;
	u8 band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);

	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
		if (NREV_GE(pi->pubpi.phy_rev, 7))
			params->txlpf = target_gain.txlpf[core_no];

		params->txgm = target_gain.txgm[core_no];
		params->pga = target_gain.pga[core_no];
		params->pad = target_gain.pad[core_no];
		params->ipa = target_gain.ipa[core_no];
		if (NREV_GE(pi->pubpi.phy_rev, 7))
			params->cal_gain =
				((params->txlpf << 15) | (params->txgm << 12) |
				 (params->pga << 8) |
				 (params->pad << 3) | (params->ipa));
		else
			params->cal_gain =
				((params->txgm << 12) | (params->pga << 8) |
				 (params->pad << 4) | (params->ipa));

		params->ncorr[0] = 0x79;
		params->ncorr[1] = 0x79;
		params->ncorr[2] = 0x79;
		params->ncorr[3] = 0x79;
		params->ncorr[4] = 0x79;
	} else {

		gain_index = ((target_gain.pad[core_no] << 0) |
			      (target_gain.pga[core_no] << 4) |
			      (target_gain.txgm[core_no] << 8));

		for (k = 0; k < NPHY_IQCAL_NUMGAINS; k++) {
			if (tbl_iqcal_gainparams_nphy[band_idx][k][0] ==
			    gain_index)
				break;
		}

		params->txgm = tbl_iqcal_gainparams_nphy[band_idx][k][1];
		params->pga = tbl_iqcal_gainparams_nphy[band_idx][k][2];
		params->pad = tbl_iqcal_gainparams_nphy[band_idx][k][3];
		params->cal_gain = ((params->txgm << 7) | (params->pga << 4) |
				    (params->pad << 2));
		params->ncorr[0] = tbl_iqcal_gainparams_nphy[band_idx][k][4];
		params->ncorr[1] = tbl_iqcal_gainparams_nphy[band_idx][k][5];
		params->ncorr[2] = tbl_iqcal_gainparams_nphy[band_idx][k][6];
		params->ncorr[3] = tbl_iqcal_gainparams_nphy[band_idx][k][7];
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58014

2. Vulnerability Type
Out-of-bounds array access (read)

3. Root Cause Summary
In wlc_phy_iqcal_gainparams_nphy(), the code searches a calibration table for a matching gain_index and then unconditionally indexes tbl_iqcal_gainparams_nphy using k. If no match is found, k remains equal to NPHY_IQCAL_NUMGAINS, causing an out-of-bounds read when accessing tbl_iqcal_gainparams_nphy[band_idx][k][...]. This missing bounds validation enables reading past the end of the table and propagating invalid data into calibration parameters.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Broadcom brcmsmac wireless driver, N-PHY calibration (drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_n.c)

2) Pre-Patch Flaw:
After the loop over k (0..NPHY_IQCAL_NUMGAINS-1), the code does not check whether a match was found before using k to index tbl_iqcal_gainparams_nphy. The subsequent assignments to params->txgm/pga/pad/ncorr and cal_gain use potentially invalid k, leading to OOB access.

3) Trigger Condition:
On PHY revisions < 3 (the else branch), when the constructed gain_index from target_gain.{pad,pga,txgm} does not match any entry in tbl_iqcal_gainparams_nphy[band_idx][k][0], the for-loop exits with k == NPHY_IQCAL_NUMGAINS and the code still indexes the table with k.

4) Impact Mechanism:
Out-of-bounds reads from tbl_iqcal_gainparams_nphy can fetch unintended memory, leading to invalid parameter values written into params, potential kernel faults (e.g., page fault/KASAN report), and instability during PHY calibration. While the write targets only the params struct, the read from beyond the table boundary can corrupt execution with undefined data or trigger a crash.

5. Patch Analysis
1) Fix Approach:
Add a bounds check that detects the “not found” case and aborts early, preventing any table access with an invalid index.

2) Key Code Changes:
Inserted immediately after the search loop:
- if (WARN_ON(k == NPHY_IQCAL_NUMGAINS))
-     return;
This validates k before any tbl_iqcal_gainparams_nphy[band_idx][k][...] accesses, converting the previous implicit assumption into explicit guard with a WARN and safe early return.

3) Locking/Concurrency Impact:
None. The change is purely a bounds check and early return; no locking or ordering semantics were added or modified.

6. Broader Kernel Security Implications
Bounds validation after failed lookups into static tables is essential in kernel drivers to prevent OOB memory access. Even with hardware-derived inputs, unexpected or inconsistent states can occur; defensive checks avoid crashes and latent bugs. This patch reinforces safe calibration logic and reduces the risk of denial-of-service conditions due to malformed or unrecognized gain settings on older PHY revisions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.