You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38313

[INFO]
[PATCH_DESCRIPTION]
    bus: fsl-mc: fix double-free on mc_dev
    The blamed commit tried to simplify how the deallocations are done but,
    in the process, introduced a double-free on the mc_dev variable.
    
    In case the MC device is a DPRC, a new mc_bus is allocated and the
    mc_dev variable is just a reference to one of its fields. In this
    circumstance, on the error path only the mc_bus should be freed.
    
    This commit introduces back the following checkpatch warning which is a
    false-positive.
    
    WARNING: kfree(NULL) is safe and this check is probably not required
    +       if (mc_bus)
    +               kfree(mc_bus);

[PATCH_DIFF]
    @@ -906,8 +906,10 @@ int fsl_mc_device_add(struct fsl_mc_obj_desc *obj_desc,
     
     error_cleanup_dev:
     	kfree(mc_dev->regions);
    -	kfree(mc_bus);
    -	kfree(mc_dev);
    +	if (mc_bus)
    +		kfree(mc_bus);
    +	else
    +		kfree(mc_dev);
     
     	return error;
     }

[FUNCTION_CONTENT]
int fsl_mc_device_add(struct fsl_mc_obj_desc *obj_desc,
		      struct fsl_mc_io *mc_io,
		      struct device *parent_dev,
		      struct fsl_mc_device **new_mc_dev)
{
	int error;
	struct fsl_mc_device *mc_dev = NULL;
	struct fsl_mc_bus *mc_bus = NULL;
	struct fsl_mc_device *parent_mc_dev;

	if (dev_is_fsl_mc(parent_dev))
		parent_mc_dev = to_fsl_mc_device(parent_dev);
	else
		parent_mc_dev = NULL;

	if (strcmp(obj_desc->type, "dprc") == 0) {
		/*
		 * Allocate an MC bus device object:
		 */
		mc_bus = kzalloc(sizeof(*mc_bus), GFP_KERNEL);
		if (!mc_bus)
			return -ENOMEM;

		mutex_init(&mc_bus->scan_mutex);
		mc_dev = &mc_bus->mc_dev;
	} else {
		/*
		 * Allocate a regular fsl_mc_device object:
		 */
		mc_dev = kzalloc(sizeof(*mc_dev), GFP_KERNEL);
		if (!mc_dev)
			return -ENOMEM;
	}

	mc_dev->obj_desc = *obj_desc;
	mc_dev->mc_io = mc_io;
	device_initialize(&mc_dev->dev);
	mc_dev->dev.parent = parent_dev;
	mc_dev->dev.bus = &fsl_mc_bus_type;
	mc_dev->dev.release = fsl_mc_device_release;
	mc_dev->dev.type = fsl_mc_get_device_type(obj_desc->type);
	if (!mc_dev->dev.type) {
		error = -ENODEV;
		dev_err(parent_dev, "unknown device type %s\n", obj_desc->type);
		goto error_cleanup_dev;
	}
	dev_set_name(&mc_dev->dev, "%s.%d", obj_desc->type, obj_desc->id);

	if (strcmp(obj_desc->type, "dprc") == 0) {
		struct fsl_mc_io *mc_io2;

		mc_dev->flags |= FSL_MC_IS_DPRC;

		/*
		 * To get the DPRC's ICID, we need to open the DPRC
		 * in get_dprc_icid(). For child DPRCs, we do so using the
		 * parent DPRC's MC portal instead of the child DPRC's MC
		 * portal, in case the child DPRC is already opened with
		 * its own portal (e.g., the DPRC used by AIOP).
		 *
		 * NOTE: There cannot be more than one active open for a
		 * given MC object, using the same MC portal.
		 */
		if (parent_mc_dev) {
			/*
			 * device being added is a child DPRC device
			 */
			mc_io2 = parent_mc_dev->mc_io;
		} else {
			/*
			 * device being added is the root DPRC device
			 */
			if (!mc_io) {
				error = -EINVAL;
				goto error_cleanup_dev;
			}

			mc_io2 = mc_io;
		}

		error = get_dprc_icid(mc_io2, obj_desc->id, &mc_dev->icid);
		if (error < 0)
			goto error_cleanup_dev;
	} else {
		/*
		 * A non-DPRC object has to be a child of a DPRC, use the
		 * parent's ICID and interrupt domain.
		 */
		mc_dev->icid = parent_mc_dev->icid;
		mc_dev->dma_mask = FSL_MC_DEFAULT_DMA_MASK;
		mc_dev->dev.dma_mask = &mc_dev->dma_mask;
		mc_dev->dev.coherent_dma_mask = mc_dev->dma_mask;
		dev_set_msi_domain(&mc_dev->dev,
				   dev_get_msi_domain(&parent_mc_dev->dev));
	}

	/*
	 * Get MMIO regions for the device from the MC:
	 *
	 * NOTE: the root DPRC is a special case as its MMIO region is
	 * obtained from the device tree
	 */
	if (parent_mc_dev && obj_desc->region_count != 0) {
		error = fsl_mc_device_get_mmio_regions(mc_dev,
						       parent_mc_dev);
		if (error < 0)
			goto error_cleanup_dev;
	}

	/*
	 * The device-specific probe callback will get invoked by device_add()
	 */
	error = device_add(&mc_dev->dev);
	if (error < 0) {
		dev_err(parent_dev,
			"device_add() failed for device %s: %d\n",
			dev_name(&mc_dev->dev), error);
		goto error_cleanup_dev;
	}

	dev_dbg(parent_dev, "added %s\n", dev_name(&mc_dev->dev));

	*new_mc_dev = mc_dev;
	return 0;

error_cleanup_dev:
	kfree(mc_dev->regions);
	kfree(mc_bus);
	kfree(mc_dev);

	return error;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38313

2. Vulnerability Type
Double free / invalid free (free of non-kmalloc pointer alias leading to memory corruption)

3. Root Cause Summary
The error cleanup path unconditionally freed both mc_bus and mc_dev without respecting their allocation/ownership relationship. In the DPRC path, mc_dev is not separately allocated; it aliases the mc_bus->mc_dev field (“mc_dev = &mc_bus->mc_dev”). Pre-patch code did “kfree(mc_bus); kfree(mc_dev);” which frees the kmalloc’d mc_bus and then attempts to free an interior pointer (&mc_bus->mc_dev), effectively a double-free/invalid free of the same allocation. The patch corrects this by freeing only mc_bus when it was allocated, and freeing mc_dev only when it was separately allocated (non-DPRC path).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
bus: fsl-mc (Freescale Management Complex bus/device handling)

2) Pre-Patch Flaw:
Unconditional deallocation in error_cleanup_dev: “kfree(mc_bus); kfree(mc_dev);” despite mc_dev being an embedded field within mc_bus for DPRC devices (“mc_dev = &mc_bus->mc_dev”), causing a free of a non-kmalloc interior pointer after freeing its owning allocation.

3) Trigger Condition:
Any error path taken after allocating mc_bus in the DPRC case (obj_desc->type == "dprc"), such as unknown device type, get_dprc_icid() failure, MMIO region retrieval failure, or device_add() failure, leading execution to error_cleanup_dev.

4) Impact Mechanism:
The second kfree() on mc_dev (an alias to &mc_bus->mc_dev) after kfree(mc_bus) results in double-free/invalid free, corrupting slab metadata and potentially causing kernel crashes, memory corruption, or exploitable conditions.

5. Patch Analysis
1) Fix Approach:
Introduce conditional deallocation based on whether mc_bus was allocated. If mc_bus exists, free only mc_bus; otherwise free mc_dev. This aligns deallocation with the allocation path and ownership model.

2) Key Code Changes:
In error_cleanup_dev:
- Replace:
  kfree(mc_bus);
  kfree(mc_dev);
- With:
  if (mc_bus)
      kfree(mc_bus);
  else
      kfree(mc_dev);
Unchanged: kfree(mc_dev->regions) remains safe (kfree(NULL) allowed).

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely in memory management on the error path. Mutex initialization (mc_bus->scan_mutex) remains unaffected; no race/ordering adjustments were made.

6. Broader Kernel Security Implications
Error paths must strictly mirror allocation ownership, especially when using embedded struct patterns (pointer aliasing to fields within kmalloc’d objects). Unconditional frees can lead to double-free or invalid free vulnerabilities, which are high-impact in kernel space. This emphasizes careful design of cleanup code to distinguish between separately allocated objects versus embedded members and the importance of defensive checks even if checkpatch warns about kfree(NULL).

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.