You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58020

[INFO]
[PATCH_DESCRIPTION]
 HID: multitouch: Add NULL check in mt_input_configured
 [ Upstream commit 9b8e2220d3a052a690b1d1b23019673e612494c5 ]
 
 devm_kasprintf() can return a NULL pointer on failure,but this
 returned value in mt_input_configured() is not checked.
 Add NULL check in mt_input_configured(), to handle kernel NULL
 pointer dereference error.

 Fixes: 479439463529 ("HID: multitouch: Correct devm device reference for hidinput input_dev name")

[PATCH_DIFF]
 diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
 index 369414c92fccbe…93b5c648ef82c9 100644
 --- a/drivers/hid/hid-multitouch.c
 +++ b/drivers/hid/hid-multitouch.c
 @@ -1673,9 +1673,12 @@ static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
   break;
   }

 - if (suffix)
 + if (suffix) {
   hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
   "%s %s", hdev->name, suffix);
 + if (!hi->input->name)
 + return -ENOMEM;
 + }

   return 0;
 }

[FUNCTION_CONTENT]
static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
{
	struct mt_device *td = hid_get_drvdata(hdev);
	const char *suffix = NULL;
	struct mt_report_data *rdata;
	struct mt_application *mt_application = NULL;
	struct hid_report *report;
	int ret;

	list_for_each_entry(report, &hi->reports, hidinput_list) {
		rdata = mt_find_report_data(td, report);
		if (!rdata) {
			hid_err(hdev, "failed to allocate data for report\n");
			return -ENOMEM;
		}

		mt_application = rdata->application;

		if (rdata->is_mt_collection) {
			ret = mt_touch_input_configured(hdev, hi,
							mt_application);
			if (ret)
				return ret;
		}
	}

	switch (hi->application) {
	case HID_GD_KEYBOARD:
	case HID_GD_KEYPAD:
	case HID_GD_MOUSE:
	case HID_DG_TOUCHPAD:
	case HID_GD_SYSTEM_CONTROL:
	case HID_CP_CONSUMER_CONTROL:
	case HID_GD_WIRELESS_RADIO_CTLS:
	case HID_GD_SYSTEM_MULTIAXIS:
		/* already handled by hid core */
		break;
	case HID_DG_TOUCHSCREEN:
		/* we do not set suffix = "Touchscreen" */
		hi->input->name = hdev->name;
		break;
	case HID_VD_ASUS_CUSTOM_MEDIA_KEYS:
		suffix = "Custom Media Keys";
		break;
	case HID_DG_STYLUS:
		/* force BTN_STYLUS to allow tablet matching in udev */
		__set_bit(BTN_STYLUS, hi->input->keybit);
		break;
	default:
		suffix = "UNKNOWN";
		break;
	}

	if (suffix)
		hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
						 "%s %s", hdev->name, suffix);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58020

2. Vulnerability Type
NULL pointer dereference due to unchecked memory allocation failure (improper error handling)

3. Root Cause Summary
mt_input_configured() assigns hi->input->name using devm_kasprintf() when a suffix is set but fails to check for a NULL return on allocation failure. This allows hi->input->name to become NULL, which is later dereferenced by the input/HID core paths, triggering a kernel NULL pointer dereference. The patch adds the missing NULL check and returns -ENOMEM on failure, preventing propagation of a NULL name.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID subsystem, multitouch driver (drivers/hid/hid-multitouch.c)

2) Pre-Patch Flaw:
In mt_input_configured(), the call hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix); is not followed by a check for a NULL return value. As a result, on allocation failure, hi->input->name is set to NULL without error handling.

3) Trigger Condition:
- Execution path where suffix is set (e.g., HID_VD_ASUS_CUSTOM_MEDIA_KEYS or default “UNKNOWN”).
- devm_kasprintf() fails (e.g., memory pressure), returning NULL.

4) Impact Mechanism:
The input device name pointer (hi->input->name) becomes NULL and is later dereferenced by the input/HID core or user-space exposure paths, leading to a kernel NULL pointer dereference and system crash/DoS.

5. Patch Analysis
1) Fix Approach:
Add a NULL check after devm_kasprintf() and return -ENOMEM if allocation fails, ensuring hi->input->name is never left NULL in the configured path.

2) Key Code Changes:
- Pre-patch: 
  if (suffix)
      hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix);
- Post-patch: 
  if (suffix) {
      hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix);
      if (!hi->input->name)
          return -ENOMEM;
  }
This change is confined to mt_input_configured() in drivers/hid/hid-multitouch.c as shown in the diff hunk.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely an error-path check for allocation failure.

6. Broader Kernel Security Implications
Properly handling allocation failures in device initialization paths prevents kernel crashes triggered by low-memory conditions and untrusted device inputs. This bolsters robustness against denial-of-service scenarios where a malicious or malformed HID device (or memory pressure) could cause system instability via unchecked NULL pointers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.