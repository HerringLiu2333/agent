You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58020

[INFO]
[PATCH_DESCRIPTION]
 HID: multitouch: Add NULL check in mt_input_configured
 [ Upstream commit 9b8e2220d3a052a690b1d1b23019673e612494c5 ]
 
 devm_kasprintf() can return a NULL pointer on failure,but this
 returned value in mt_input_configured() is not checked.
 Add NULL check in mt_input_configured(), to handle kernel NULL
 pointer dereference error.

 Fixes: 479439463529 ("HID: multitouch: Correct devm device reference for hidinput input_dev name")

[PATCH_DIFF]
 diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
 index 369414c92fccbe…93b5c648ef82c9 100644
 --- a/drivers/hid/hid-multitouch.c
 +++ b/drivers/hid/hid-multitouch.c
 @@ -1673,9 +1673,12 @@ static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
   break;
   }

 - if (suffix)
 + if (suffix) {
   hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
   "%s %s", hdev->name, suffix);
 + if (!hi->input->name)
 + return -ENOMEM;
 + }

   return 0;
 }

[FUNCTION_CONTENT]
static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
{
	struct mt_device *td = hid_get_drvdata(hdev);
	const char *suffix = NULL;
	struct mt_report_data *rdata;
	struct mt_application *mt_application = NULL;
	struct hid_report *report;
	int ret;

	list_for_each_entry(report, &hi->reports, hidinput_list) {
		rdata = mt_find_report_data(td, report);
		if (!rdata) {
			hid_err(hdev, "failed to allocate data for report\n");
			return -ENOMEM;
		}

		mt_application = rdata->application;

		if (rdata->is_mt_collection) {
			ret = mt_touch_input_configured(hdev, hi,
							mt_application);
			if (ret)
				return ret;
		}
	}

	switch (hi->application) {
	case HID_GD_KEYBOARD:
	case HID_GD_KEYPAD:
	case HID_GD_MOUSE:
	case HID_DG_TOUCHPAD:
	case HID_GD_SYSTEM_CONTROL:
	case HID_CP_CONSUMER_CONTROL:
	case HID_GD_WIRELESS_RADIO_CTLS:
	case HID_GD_SYSTEM_MULTIAXIS:
		/* already handled by hid core */
		break;
	case HID_DG_TOUCHSCREEN:
		/* we do not set suffix = "Touchscreen" */
		hi->input->name = hdev->name;
		break;
	case HID_VD_ASUS_CUSTOM_MEDIA_KEYS:
		suffix = "Custom Media Keys";
		break;
	case HID_DG_STYLUS:
		/* force BTN_STYLUS to allow tablet matching in udev */
		__set_bit(BTN_STYLUS, hi->input->keybit);
		break;
	default:
		suffix = "UNKNOWN";
		break;
	}

	if (suffix)
		hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
						 "%s %s", hdev->name, suffix);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58020

2. Vulnerability Type
NULL pointer dereference due to unchecked memory allocation failure (improper error handling)

3. Root Cause Summary
mt_input_configured() assigns hi->input->name using devm_kasprintf() when a suffix is set but fails to check for a NULL return on allocation failure. This allows hi->input->name to become NULL, which is later dereferenced by the input/HID core paths, triggering a kernel NULL pointer dereference. The patch adds the missing NULL check and returns -ENOMEM on failure, preventing propagation of a NULL name.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID subsystem, multitouch driver (drivers/hid/hid-multitouch.c)

2) Pre-Patch Flaw:
In mt_input_configured(), the call hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix); is not followed by a check for a NULL return value. As a result, on allocation failure, hi->input->name is set to NULL without error handling.

3) Trigger Condition:
- Execution path where suffix is set (e.g., HID_VD_ASUS_CUSTOM_MEDIA_KEYS or default “UNKNOWN”).
- devm_kasprintf() fails (e.g., memory pressure), returning NULL.

4) Impact Mechanism:
The input device name pointer (hi->input->name) becomes NULL and is later dereferenced by the input/HID core or user-space exposure paths, leading to a kernel NULL pointer dereference and system crash/DoS.

5. Patch Analysis
1) Fix Approach:
Add a NULL check after devm_kasprintf() and return -ENOMEM if allocation fails, ensuring hi->input->name is never left NULL in the configured path.

2) Key Code Changes:
- Pre-patch: 
  if (suffix)
      hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix);
- Post-patch: 
  if (suffix) {
      hi->input->name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s %s", hdev->name, suffix);
      if (!hi->input->name)
          return -ENOMEM;
  }
This change is confined to mt_input_configured() in drivers/hid/hid-multitouch.c as shown in the diff hunk.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely an error-path check for allocation failure.

6. Broader Kernel Security Implications
Properly handling allocation failures in device initialization paths prevents kernel crashes triggered by low-memory conditions and untrusted device inputs. This bolsters robustness against denial-of-service scenarios where a malicious or malformed HID device (or memory pressure) could cause system instability via unchecked NULL pointers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}