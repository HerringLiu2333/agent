You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58065

[INFO]
[PATCH_DESCRIPTION]
 clk: mmp: pxa1908-apbc: Fix NULL vs IS_ERR() check
 The devm_kzalloc() function returns NULL on error, not error pointers.
 Fix the check.
 
 Fixes: 51ce55919273 ("clk: mmp: Add Marvell PXA1908 APBC driver")

[PATCH_DIFF]
    diff --git a/drivers/clk/mmp/clk-pxa1908-apbc.c b/drivers/clk/mmp/clk-pxa1908-apbc.c
    index b93d0846619856..3fd7b5e644f3b6 100644
    --- a/drivers/clk/mmp/clk-pxa1908-apbc.c
    +++ b/drivers/clk/mmp/clk-pxa1908-apbc.c
    @@ -96,8 +96,8 @@ static int pxa1908_apbc_probe(struct platform_device *pdev)
     	struct pxa1908_clk_unit *pxa_unit;
     
     	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
    -	if (IS_ERR(pxa_unit))
    -		return PTR_ERR(pxa_unit);
    +	if (!pxa_unit)
    +		return -ENOMEM;

[FILE_CONTENT]
// SPDX-License-Identifier: GPL-2.0-only
#include <linux/clk-provider.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/spinlock.h>

#include <dt-bindings/clock/marvell,pxa1908.h>

#include "clk.h"

#define APBC_UART0		0x0
#define APBC_UART1		0x4
#define APBC_GPIO		0x8
#define APBC_PWM0		0xc
#define APBC_PWM1		0x10
#define APBC_PWM2		0x14
#define APBC_PWM3		0x18
#define APBC_SSP0		0x1c
#define APBC_SSP1		0x20
#define APBC_IPC_RST		0x24
#define APBC_RTC		0x28
#define APBC_TWSI0		0x2c
#define APBC_KPC		0x30
#define APBC_SWJTAG		0x40
#define APBC_SSP2		0x4c
#define APBC_TWSI1		0x60
#define APBC_THERMAL		0x6c
#define APBC_TWSI3		0x70

#define APBC_NR_CLKS		19

struct pxa1908_clk_unit {
	struct mmp_clk_unit unit;
	void __iomem *base;
};

static DEFINE_SPINLOCK(pwm0_lock);
static DEFINE_SPINLOCK(pwm2_lock);

static DEFINE_SPINLOCK(uart0_lock);
static DEFINE_SPINLOCK(uart1_lock);

static const char * const uart_parent_names[] = {"pll1_117", "uart_pll"};
static const char * const ssp_parent_names[] = {"pll1_d16", "pll1_d48", "pll1_d24", "pll1_d12"};

static struct mmp_param_gate_clk apbc_gate_clks[] = {
	{PXA1908_CLK_TWSI0, "twsi0_clk", "pll1_32", CLK_SET_RATE_PARENT, APBC_TWSI0, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_TWSI1, "twsi1_clk", "pll1_32", CLK_SET_RATE_PARENT, APBC_TWSI1, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_TWSI3, "twsi3_clk", "pll1_32", CLK_SET_RATE_PARENT, APBC_TWSI3, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_GPIO, "gpio_clk", "vctcxo", CLK_SET_RATE_PARENT, APBC_GPIO, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_KPC, "kpc_clk", "clk32", CLK_SET_RATE_PARENT, APBC_KPC, 0x7, 3, 0, MMP_CLK_GATE_NEED_DELAY, NULL},
	{PXA1908_CLK_RTC, "rtc_clk", "clk32", CLK_SET_RATE_PARENT, APBC_RTC, 0x87, 0x83, 0, MMP_CLK_GATE_NEED_DELAY, NULL},
	{PXA1908_CLK_PWM0, "pwm0_clk", "pwm01_apb_share", CLK_SET_RATE_PARENT, APBC_PWM0, 0x2, 2, 0, 0, &pwm0_lock},
	{PXA1908_CLK_PWM1, "pwm1_clk", "pwm01_apb_share", CLK_SET_RATE_PARENT, APBC_PWM1, 0x6, 2, 0, 0, NULL},
	{PXA1908_CLK_PWM2, "pwm2_clk", "pwm23_apb_share", CLK_SET_RATE_PARENT, APBC_PWM2, 0x2, 2, 0, 0, NULL},
	{PXA1908_CLK_PWM3, "pwm3_clk", "pwm23_apb_share", CLK_SET_RATE_PARENT, APBC_PWM3, 0x6, 2, 0, 0, NULL},
	{PXA1908_CLK_UART0, "uart0_clk", "uart0_mux", CLK_SET_RATE_PARENT, APBC_UART0, 0x7, 3, 0, 0, &uart0_lock},
	{PXA1908_CLK_UART1, "uart1_clk", "uart1_mux", CLK_SET_RATE_PARENT, APBC_UART1, 0x7, 3, 0, 0, &uart1_lock},
	{PXA1908_CLK_THERMAL, "thermal_clk", NULL, 0, APBC_THERMAL, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_IPC_RST, "ipc_clk", NULL, 0, APBC_IPC_RST, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_SSP0, "ssp0_clk", "ssp0_mux", 0, APBC_SSP0, 0x7, 3, 0, 0, NULL},
	{PXA1908_CLK_SSP2, "ssp2_clk", "ssp2_mux", 0, APBC_SSP2, 0x7, 3, 0, 0, NULL},
};

static struct mmp_param_mux_clk apbc_mux_clks[] = {
	{0, "uart0_mux", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART0, 4, 3, 0, &uart0_lock},
	{0, "uart1_mux", uart_parent_names, ARRAY_SIZE(uart_parent_names), CLK_SET_RATE_PARENT, APBC_UART1, 4, 3, 0, &uart1_lock},
	{0, "ssp0_mux", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), 0, APBC_SSP0, 4, 3, 0, NULL},
	{0, "ssp2_mux", ssp_parent_names, ARRAY_SIZE(ssp_parent_names), 0, APBC_SSP2, 4, 3, 0, NULL},
};

static void pxa1908_apb_periph_clk_init(struct pxa1908_clk_unit *pxa_unit)
{
	struct mmp_clk_unit *unit = &pxa_unit->unit;
	struct clk *clk;

	mmp_clk_register_gate(NULL, "pwm01_apb_share", "pll1_d48",
			CLK_SET_RATE_PARENT,
			pxa_unit->base + APBC_PWM0,
			0x5, 1, 0, 0, &pwm0_lock);
	mmp_clk_register_gate(NULL, "pwm23_apb_share", "pll1_d48",
			CLK_SET_RATE_PARENT,
			pxa_unit->base + APBC_PWM2,
			0x5, 1, 0, 0, &pwm2_lock);
	clk = mmp_clk_register_apbc("swjtag", NULL,
			pxa_unit->base + APBC_SWJTAG, 10, 0, NULL);
	mmp_clk_add(unit, PXA1908_CLK_SWJTAG, clk);
	mmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->base,
			ARRAY_SIZE(apbc_mux_clks));
	mmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->base,
			ARRAY_SIZE(apbc_gate_clks));
}

static int pxa1908_apbc_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, APBC_NR_CLKS);

	pxa1908_apb_periph_clk_init(pxa_unit);

	return 0;
}

static const struct of_device_id pxa1908_apbc_match_table[] = {
	{ .compatible = "marvell,pxa1908-apbc" },
	{ }
};
MODULE_DEVICE_TABLE(of, pxa1908_apbc_match_table);

static struct platform_driver pxa1908_apbc_driver = {
	.probe = pxa1908_apbc_probe,
	.driver = {
		.name = "pxa1908-apbc",
		.of_match_table = pxa1908_apbc_match_table
	}
};
module_platform_driver(pxa1908_apbc_driver);

MODULE_AUTHOR("Duje Mihanović <duje.mihanovic@skole.hr>");
MODULE_DESCRIPTION("Marvell PXA1908 APBC Clock Driver");
MODULE_LICENSE("GPL");




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58065

2. Vulnerability Type
NULL pointer dereference due to improper error handling (incorrect NULL vs ERR_PTR check)

3. Root Cause Summary
In pxa1908_apbc_probe(), the code checked devm_kzalloc()’s return value using IS_ERR()/PTR_ERR, but devm_kzalloc() returns NULL on failure, not ERR_PTR. This mischeck failed to detect allocation failure, allowing execution to proceed and dereference a NULL pxa_unit, causing a kernel NULL pointer dereference during driver probe.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Clock subsystem, Marvell PXA1908 APBC driver (drivers/clk/mmp/clk-pxa1908-apbc.c)

2) Pre-Patch Flaw:
In pxa1908_apbc_probe(), after "pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);", the code erroneously did "if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);". IS_ERR(NULL) is false, so a NULL allocation result was treated as success.

3) Trigger Condition:
devm_kzalloc() fails and returns NULL (e.g., under memory pressure or allocation failure) during platform driver probe.

4) Impact Mechanism:
The subsequent line "pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);" dereferences pxa_unit, which is NULL, leading to a kernel NULL pointer dereference (oops/panic) and device probe failure, potentially impacting system boot stability.

5. Patch Analysis
1) Fix Approach:
Correct the error handling by checking for NULL and returning a proper -ENOMEM code when devm_kzalloc() fails.

2) Key Code Changes:
Within pxa1908_apbc_probe():
- Replaced:
  "if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);"
- With:
  "if (!pxa_unit) return -ENOMEM;"
This aligns the check with devm_kzalloc() semantics. The existing IS_ERR() check for devm_platform_ioremap_resource() remains appropriate, as that API returns ERR_PTR on failure.

3) Locking/Concurrency Impact:
None. The change is limited to allocation failure handling in probe; no locks, ordering, or concurrency behavior was modified.

6. Broader Kernel Security Implications
Correctly distinguishing NULL-returning allocators from ERR_PTR-returning APIs is essential to avoid probe-time crashes and denial-of-service conditions. This fix improves robustness of the clock driver during initialization and reduces the risk that memory allocation failures can be escalated into system instability. It highlights the need for consistent error handling patterns across drivers using devm_* helpers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.