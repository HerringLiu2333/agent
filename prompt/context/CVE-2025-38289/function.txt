void
lpfc_dev_loss_tmo_callbk(struct fc_rport *rport)
{
	struct lpfc_nodelist *ndlp;
	struct lpfc_vport *vport;
	struct lpfc_hba   *phba;
	struct lpfc_work_evt *evtp;
	unsigned long iflags;
	bool nvme_reg = false;

	ndlp = ((struct lpfc_rport_data *)rport->dd_data)->pnode;
	if (!ndlp)
		return;

	vport = ndlp->vport;
	phba  = vport->phba;

	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,
		"rport devlosscb: sid:x%x did:x%x flg:x%lx",
		ndlp->nlp_sid, ndlp->nlp_DID, ndlp->nlp_flag);

	lpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,
			 "3181 dev_loss_callbk x%06x, rport x%px flg x%lx "
			 "load_flag x%lx refcnt %u state %d xpt x%x\n",
			 ndlp->nlp_DID, ndlp->rport, ndlp->nlp_flag,
			 vport->load_flag, kref_read(&ndlp->kref),
			 ndlp->nlp_state, ndlp->fc4_xpt_flags);

	/* Don't schedule a worker thread event if the vport is going down. */
	if (test_bit(FC_UNLOADING, &vport->load_flag) ||
	    !test_bit(HBA_SETUP, &phba->hba_flag)) {

		spin_lock_irqsave(&ndlp->lock, iflags);
		ndlp->rport = NULL;

		if (ndlp->fc4_xpt_flags & NVME_XPT_REGD)
			nvme_reg = true;

		/* The scsi_transport is done with the rport so lpfc cannot
		 * call to unregister.
		 */
		if (ndlp->fc4_xpt_flags & SCSI_XPT_REGD) {
			ndlp->fc4_xpt_flags &= ~SCSI_XPT_REGD;

			/* If NLP_XPT_REGD was cleared in lpfc_nlp_unreg_node,
			 * unregister calls were made to the scsi and nvme
			 * transports and refcnt was already decremented. Clear
			 * the NLP_XPT_REGD flag only if the NVME Rport is
			 * confirmed unregistered.
			 */
			if (!nvme_reg && ndlp->fc4_xpt_flags & NLP_XPT_REGD) {
				ndlp->fc4_xpt_flags &= ~NLP_XPT_REGD;
				spin_unlock_irqrestore(&ndlp->lock, iflags);
				lpfc_nlp_put(ndlp); /* may free ndlp */
			} else {
				spin_unlock_irqrestore(&ndlp->lock, iflags);
			}
		} else {
			spin_unlock_irqrestore(&ndlp->lock, iflags);
		}

		/* Only 1 thread can drop the initial node reference.  If
		 * another thread has set NLP_DROPPED, this thread is done.
		 */
		if (nvme_reg || test_bit(NLP_DROPPED, &ndlp->nlp_flag))
			return;

		set_bit(NLP_DROPPED, &ndlp->nlp_flag);
		lpfc_nlp_put(ndlp);
		return;
	}

	if (ndlp->nlp_state == NLP_STE_MAPPED_NODE)
		return;

	/* Ignore callback for a mismatched (stale) rport */
	if (ndlp->rport != rport) {
		lpfc_vlog_msg(vport, KERN_WARNING, LOG_NODE,
			      "6788 fc rport mismatch: d_id x%06x ndlp x%px "
			      "fc rport x%px node rport x%px state x%x "
			      "refcnt %u\n",
			      ndlp->nlp_DID, ndlp, rport, ndlp->rport,
			      ndlp->nlp_state, kref_read(&ndlp->kref));
		return;
	}

	if (rport->port_name != wwn_to_u64(ndlp->nlp_portname.u.wwn))
		lpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,
				 "6789 rport name %llx != node port name %llx",
				 rport->port_name,
				 wwn_to_u64(ndlp->nlp_portname.u.wwn));

	evtp = &ndlp->dev_loss_evt;

	if (!list_empty(&evtp->evt_listp)) {
		lpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,
				 "6790 rport name %llx dev_loss_evt pending\n",
				 rport->port_name);
		return;
	}

	set_bit(NLP_IN_DEV_LOSS, &ndlp->nlp_flag);

	spin_lock_irqsave(&ndlp->lock, iflags);
	/* If there is a PLOGI in progress, and we are in a
	 * NLP_NPR_2B_DISC state, don't turn off the flag.
	 */
	if (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE)
		clear_bit(NLP_NPR_2B_DISC, &ndlp->nlp_flag);

	/*
	 * The backend does not expect any more calls associated with this
	 * rport. Remove the association between rport and ndlp.
	 */
	ndlp->fc4_xpt_flags &= ~SCSI_XPT_REGD;
	((struct lpfc_rport_data *)rport->dd_data)->pnode = NULL;
	ndlp->rport = NULL;
	spin_unlock_irqrestore(&ndlp->lock, iflags);

	if (phba->worker_thread) {
		/* We need to hold the node by incrementing the reference
		 * count until this queued work is done
		 */
		evtp->evt_arg1 = lpfc_nlp_get(ndlp);

		spin_lock_irqsave(&phba->hbalock, iflags);
		if (evtp->evt_arg1) {
			evtp->evt = LPFC_EVT_DEV_LOSS;
			list_add_tail(&evtp->evt_listp, &phba->work_list);
			spin_unlock_irqrestore(&phba->hbalock, iflags);
			lpfc_worker_wake_up(phba);
			return;
		}
		spin_unlock_irqrestore(&phba->hbalock, iflags);
	} else {
		lpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,
				 "3188 worker thread is stopped %s x%06x, "
				 " rport x%px flg x%lx load_flag x%lx refcnt "
				 "%d\n", __func__, ndlp->nlp_DID,
				 ndlp->rport, ndlp->nlp_flag,
				 vport->load_flag, kref_read(&ndlp->kref));
		if (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD)) {
			/* Node is in dev loss.  No further transaction. */
			clear_bit(NLP_IN_DEV_LOSS, &ndlp->nlp_flag);
			lpfc_disc_state_machine(vport, ndlp, NULL,
						NLP_EVT_DEVICE_RM);
		}
	}
}