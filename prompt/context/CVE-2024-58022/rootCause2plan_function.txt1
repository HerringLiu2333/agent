You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58022

[INFO]
[PATCH_DESCRIPTION]
 bpf: consider that tail calls invalidate packet pointers
 commit 1a4607ffba35bf2a630aab299e34dd3f6e658d70 upstream.
 
 Tail-called programs could execute any of the helpers that invalidate
 packet pointers. Hence, conservatively assume that each tail call
 invalidates packet pointers.
 
 Making the change in bpf_helper_changes_pkt_data() automatically makes
 use of check_cfg() logic that computes 'changes_pkt_data' effect for
 global sub-programs, such that the following program could be
 rejected:
 
     int tail_call(struct __sk_buff *sk)
     {
     	bpf_tail_call_static(sk, &jmp_table, 0);
     	return 0;
     }
 
     SEC("tc")
     int not_safe(struct __sk_buff *sk)
     {
     	int *p = (void *)(long)sk->data;
     	... make p valid ...
     	tail_call(sk);
     	*p = 42; /* this is unsafe /
     	...
     }
 The tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function that
 can invalidate packet pointers. Otherwise, it can't be freplaced with
 tailcall_freplace.c:entry_freplace() that does a tail call.

[PATCH_DIFF]
    diff --git a/drivers/mailbox/mailbox-th1520.c b/drivers/mailbox/mailbox-th1520.c
    index 4e84640ac3b876..e16e7c85ee3cd5 100644
    --- a/drivers/mailbox/mailbox-th1520.c
    +++ b/drivers/mailbox/mailbox-th1520.c
    @@ -387,8 +387,10 @@ static void __iomem *th1520_map_mmio(struct platform_device *pdev,
     
     	mapped = devm_ioremap(&pdev->dev, res->start + offset,
     			      resource_size(res) - offset);
    -	if (IS_ERR(mapped))
    +	if (!mapped) {
     		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);
    +		return ERR_PTR(-ENOMEM);
    +	}
     
     	return mapped;
     }

[FUNCTION_CONTENT]
static void __iomem *th1520_map_mmio(struct platform_device *pdev,
				     char *res_name, size_t offset)
{
	void __iomem *mapped;
	struct resource *res;

	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);

	if (!res) {
		dev_err(&pdev->dev, "Failed to get resource: %s\n", res_name);
		return ERR_PTR(-EINVAL);
	}

	mapped = devm_ioremap(&pdev->dev, res->start + offset,
			      resource_size(res) - offset);
	if (IS_ERR(mapped))
		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);

	return mapped;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58022

2. Vulnerability Type
Improper error handling (ERR_PTR vs NULL) leading to potential NULL pointer dereference

3. Root Cause Summary
th1520_map_mmio() used IS_ERR(mapped) to detect devm_ioremap() failures, but devm_ioremap() returns NULL on failure, not ERR_PTR. As a result, a failed ioremap returned NULL, was not recognized as an error, and was propagated to callers despite the function otherwise using ERR_PTR for errors (e.g., returns ERR_PTR(-EINVAL) when the resource is missing). Callers expecting ERR_PTR-based error signaling could treat the NULL as a valid mapping or miss the error, leading to NULL dereference or unintended MMIO access.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Mailbox subsystem, drivers/mailbox/mailbox-th1520.c (TH1520 mailbox driver)

2) Pre-Patch Flaw:
Incorrect failure check and error propagation in th1520_map_mmio(): “if (IS_ERR(mapped))” was used after devm_ioremap(), which returns NULL on failure, and the function returned NULL instead of an ERR_PTR, breaking its error-handling contract.

3) Trigger Condition:
Any devm_ioremap() failure for the requested resource/offset range (e.g., invalid resource, offset causing mapping failure, or memory/resource exhaustion) resulting in a NULL return from devm_ioremap().

4) Impact Mechanism:
NULL returned to callers in a code path that otherwise uses ERR_PTR signaling; callers may not detect the error via IS_ERR() and could dereference the NULL pointer or perform I/O on an unmapped address, causing a kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Treat a NULL mapping as a failure and convert it to an ERR_PTR(-ENOMEM), aligning with the function’s error-pointer return convention so callers can reliably detect errors via IS_ERR().

2) Key Code Changes:
- Replaced “if (IS_ERR(mapped))” with “if (!mapped)”.
- Added error return: “return ERR_PTR(-ENOMEM);” after logging with dev_err().
- Ensured th1520_map_mmio() uniformly returns ERR_PTR on errors (both resource retrieval and mapping failures).

3) Locking/Concurrency Impact:
None; the change is strictly in error-path handling and does not modify locking or concurrency behavior.

6. Broader Kernel Security Implications
Consistent error handling (distinguishing NULL vs ERR_PTR) is critical in kernel APIs; mismatches can lead to NULL dereferences and system instability. This fix eliminates a crash vector triggered by MMIO mapping failures and reinforces robust error-propagation semantics. It highlights the need to audit similar helpers to ensure uniform error signaling across subsystems, reducing the risk of exploitable kernel faults.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}