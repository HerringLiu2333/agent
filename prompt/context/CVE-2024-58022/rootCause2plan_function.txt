You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58022

[INFO]
[PATCH_DESCRIPTION]
 bpf: consider that tail calls invalidate packet pointers
 commit 1a4607ffba35bf2a630aab299e34dd3f6e658d70 upstream.
 
 Tail-called programs could execute any of the helpers that invalidate
 packet pointers. Hence, conservatively assume that each tail call
 invalidates packet pointers.
 
 Making the change in bpf_helper_changes_pkt_data() automatically makes
 use of check_cfg() logic that computes 'changes_pkt_data' effect for
 global sub-programs, such that the following program could be
 rejected:
 
     int tail_call(struct __sk_buff *sk)
     {
     	bpf_tail_call_static(sk, &jmp_table, 0);
     	return 0;
     }
 
     SEC("tc")
     int not_safe(struct __sk_buff *sk)
     {
     	int *p = (void *)(long)sk->data;
     	... make p valid ...
     	tail_call(sk);
     	*p = 42; /* this is unsafe /
     	...
     }
 The tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function that
 can invalidate packet pointers. Otherwise, it can't be freplaced with
 tailcall_freplace.c:entry_freplace() that does a tail call.

[PATCH_DIFF]
    diff --git a/drivers/mailbox/mailbox-th1520.c b/drivers/mailbox/mailbox-th1520.c
    index 4e84640ac3b876..e16e7c85ee3cd5 100644
    --- a/drivers/mailbox/mailbox-th1520.c
    +++ b/drivers/mailbox/mailbox-th1520.c
    @@ -387,8 +387,10 @@ static void __iomem *th1520_map_mmio(struct platform_device *pdev,
     
     	mapped = devm_ioremap(&pdev->dev, res->start + offset,
     			      resource_size(res) - offset);
    -	if (IS_ERR(mapped))
    +	if (!mapped) {
     		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);
    +		return ERR_PTR(-ENOMEM);
    +	}
     
     	return mapped;
     }

[FUNCTION_CONTENT]
static void __iomem *th1520_map_mmio(struct platform_device *pdev,
				     char *res_name, size_t offset)
{
	void __iomem *mapped;
	struct resource *res;

	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);

	if (!res) {
		dev_err(&pdev->dev, "Failed to get resource: %s\n", res_name);
		return ERR_PTR(-EINVAL);
	}

	mapped = devm_ioremap(&pdev->dev, res->start + offset,
			      resource_size(res) - offset);
	if (IS_ERR(mapped))
		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);

	return mapped;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58022

2. Vulnerability Type
Improper error handling (ERR_PTR vs NULL) leading to potential NULL pointer dereference

3. Root Cause Summary
th1520_map_mmio() used IS_ERR(mapped) to detect devm_ioremap() failures, but devm_ioremap() returns NULL on failure, not ERR_PTR. As a result, a failed ioremap returned NULL, was not recognized as an error, and was propagated to callers despite the function otherwise using ERR_PTR for errors (e.g., returns ERR_PTR(-EINVAL) when the resource is missing). Callers expecting ERR_PTR-based error signaling could treat the NULL as a valid mapping or miss the error, leading to NULL dereference or unintended MMIO access.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Mailbox subsystem, drivers/mailbox/mailbox-th1520.c (TH1520 mailbox driver)

2) Pre-Patch Flaw:
Incorrect failure check and error propagation in th1520_map_mmio(): “if (IS_ERR(mapped))” was used after devm_ioremap(), which returns NULL on failure, and the function returned NULL instead of an ERR_PTR, breaking its error-handling contract.

3) Trigger Condition:
Any devm_ioremap() failure for the requested resource/offset range (e.g., invalid resource, offset causing mapping failure, or memory/resource exhaustion) resulting in a NULL return from devm_ioremap().

4) Impact Mechanism:
NULL returned to callers in a code path that otherwise uses ERR_PTR signaling; callers may not detect the error via IS_ERR() and could dereference the NULL pointer or perform I/O on an unmapped address, causing a kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Treat a NULL mapping as a failure and convert it to an ERR_PTR(-ENOMEM), aligning with the function’s error-pointer return convention so callers can reliably detect errors via IS_ERR().

2) Key Code Changes:
- Replaced “if (IS_ERR(mapped))” with “if (!mapped)”.
- Added error return: “return ERR_PTR(-ENOMEM);” after logging with dev_err().
- Ensured th1520_map_mmio() uniformly returns ERR_PTR on errors (both resource retrieval and mapping failures).

3) Locking/Concurrency Impact:
None; the change is strictly in error-path handling and does not modify locking or concurrency behavior.

6. Broader Kernel Security Implications
Consistent error handling (distinguishing NULL vs ERR_PTR) is critical in kernel APIs; mismatches can lead to NULL dereferences and system instability. This fix eliminates a crash vector triggered by MMIO mapping failures and reinforces robust error-propagation semantics. It highlights the need to audit similar helpers to ensure uniform error signaling across subsystems, reducing the risk of exploitable kernel faults.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.