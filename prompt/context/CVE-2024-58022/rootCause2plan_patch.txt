You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58022

[INFO]
[PATCH_DESCRIPTION]
 bpf: consider that tail calls invalidate packet pointers
 commit 1a4607ffba35bf2a630aab299e34dd3f6e658d70 upstream.
 
 Tail-called programs could execute any of the helpers that invalidate
 packet pointers. Hence, conservatively assume that each tail call
 invalidates packet pointers.
 
 Making the change in bpf_helper_changes_pkt_data() automatically makes
 use of check_cfg() logic that computes 'changes_pkt_data' effect for
 global sub-programs, such that the following program could be
 rejected:
 
     int tail_call(struct __sk_buff *sk)
     {
     	bpf_tail_call_static(sk, &jmp_table, 0);
     	return 0;
     }
 
     SEC("tc")
     int not_safe(struct __sk_buff *sk)
     {
     	int *p = (void *)(long)sk->data;
     	... make p valid ...
     	tail_call(sk);
     	*p = 42; /* this is unsafe /
     	...
     }
 The tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function that
 can invalidate packet pointers. Otherwise, it can't be freplaced with
 tailcall_freplace.c:entry_freplace() that does a tail call.

[PATCH_DIFF]
    diff --git a/drivers/mailbox/mailbox-th1520.c b/drivers/mailbox/mailbox-th1520.c
    index 4e84640ac3b876..e16e7c85ee3cd5 100644
    --- a/drivers/mailbox/mailbox-th1520.c
    +++ b/drivers/mailbox/mailbox-th1520.c
    @@ -387,8 +387,10 @@ static void __iomem *th1520_map_mmio(struct platform_device *pdev,
     
     	mapped = devm_ioremap(&pdev->dev, res->start + offset,
     			      resource_size(res) - offset);
    -	if (IS_ERR(mapped))
    +	if (!mapped) {
     		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);
    +		return ERR_PTR(-ENOMEM);
    +	}
     
     	return mapped;
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58022

2. Vulnerability Type
Improper state tracking in the eBPF verifier leading to unsafe use of packet pointers after tail calls (logic/verifier unsoundness; effectively a TOCTOU on pointer validity across tail-call boundaries)

3. Root Cause Summary
The eBPF verifier did not model that a tail-called program can execute helpers which invalidate packet pointers, so it failed to conservatively invalidate packet pointer state at tail-call sites. As a result, the verifier allowed programs to take a packet data pointer, perform a tail call, and then continue using the stale pointer, despite the callee being able to invalidate it. This unsoundness enabled unsafe memory access to packet data after tail calls.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- eBPF verifier and tc eBPF program infrastructure

2) Pre-Patch Flaw:
- The verifier’s changes_pkt_data tracking did not treat tail calls as potentially invalidating packet pointers. Specifically, bpf_helper_changes_pkt_data() did not consider tail call helpers, and check_cfg() did not propagate invalidation across global sub-program tail-call edges.

3) Trigger Condition:
- A tc eBPF program obtains a pointer to sk->data, makes it valid, performs a tail call to another program (which may run helpers that change/invalidate packet data/pointers), and then attempts to use the original pointer after the tail call (e.g., “*p = 42”).

4) Impact Mechanism:
- Continued use of a stale/invalid packet pointer after a tail call leads to unsafe memory access to packet data, with potential out-of-bounds or invalid writes/reads, resulting in memory corruption or kernel instability.

5. Patch Analysis
1) Fix Approach:
- The patch conservatively assumes each tail call invalidates packet pointers by updating bpf_helper_changes_pkt_data(). It leverages check_cfg() so that the invalidation effect is computed for global sub-programs, causing unsafe patterns to be rejected. Additionally, tc_bpf2bpf.c:subprog_tc() is explicitly marked as a function that can invalidate packet pointers to align with tail-call behavior.

2) Key Code Changes:
- In bpf_helper_changes_pkt_data(): tail-call helpers are treated as changing packet data, thereby invalidating packet pointers at tail-call sites.
- The verifier’s check_cfg() logic automatically applies changes_pkt_data across global sub-programs, resulting in rejection of programs that use packet pointers after tail calls.
- tc_bpf2bpf.c:subprog_tc() updated to be recognized as a function that can invalidate packet pointers, enabling safe freplace with entry_freplace() that performs a tail call.

3) Locking/Concurrency Impact:
- No locking or concurrency changes; the patch strictly adjusts verifier state modeling and function annotations related to packet pointer invalidation.

6. Broader Kernel Security Implications
- Strengthening the verifier’s state tracking across tail-call boundaries prevents unsafe packet pointer reuse, reducing avenues for memory corruption in tc eBPF programs. The conservative invalidation model improves the soundness of eBPF program verification, decreasing the attack surface for verifier-bypass techniques and enhancing overall kernel robustness when running untrusted eBPF code.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.