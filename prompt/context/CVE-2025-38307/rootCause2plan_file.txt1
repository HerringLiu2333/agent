You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38307

[INFO]
[PATCH_DESCRIPTION]
    ASoC: Intel: avs: Verify content returned by parse_int_array()
    The first element of the returned array stores its length. If it is 0,
    any manipulation beyond the element at index 0 ends with null-ptr-deref.

[PATCH_DIFF]
    @@ -373,7 +373,10 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     		return ret;
     
     	num_elems = *array;
    -	resource_mask = array[1];
    +	if (!num_elems) {
    +		ret = -EINVAL;
    +		goto free_array;
    +	}
     
     	/*
     	 * Disable if just resource mask is provided - no log priority flags.
    @@ -381,6 +384,7 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     	 * Enable input format:   mask, prio1, .., prioN
     	 * Where 'N' equals number of bits set in the 'mask'.
     	 */
    +	resource_mask = array[1];
     	if (num_elems == 1) {
     		ret = disable_logs(adev, resource_mask);
     	} else {

[FILE_CONTENT]
// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright(c) 2021-2022 Intel Corporation
//
// Authors: Cezary Rojewski <cezary.rojewski@intel.com>
//          Amadeusz Slawinski <amadeuszx.slawinski@linux.intel.com>
//

#include <linux/debugfs.h>
#include <linux/kfifo.h>
#include <linux/wait.h>
#include <linux/sched/signal.h>
#include <linux/string_helpers.h>
#include <sound/soc.h>
#include "avs.h"
#include "messages.h"

static unsigned int __kfifo_fromio(struct kfifo *fifo, const void __iomem *src, unsigned int len)
{
	struct __kfifo *__fifo = &fifo->kfifo;
	unsigned int l, off;

	len = min(len, kfifo_avail(fifo));
	off = __fifo->in & __fifo->mask;
	l = min(len, kfifo_size(fifo) - off);

	memcpy_fromio(__fifo->data + off, src, l);
	memcpy_fromio(__fifo->data, src + l, len - l);
	/* Make sure data copied from SRAM is visible to all CPUs. */
	smp_mb();
	__fifo->in += len;

	return len;
}

bool avs_logging_fw(struct avs_dev *adev)
{
	return kfifo_initialized(&adev->trace_fifo);
}

void avs_dump_fw_log(struct avs_dev *adev, const void __iomem *src, unsigned int len)
{
	__kfifo_fromio(&adev->trace_fifo, src, len);
}

void avs_dump_fw_log_wakeup(struct avs_dev *adev, const void __iomem *src, unsigned int len)
{
	avs_dump_fw_log(adev, src, len);
	wake_up(&adev->trace_waitq);
}

static ssize_t fw_regs_read(struct file *file, char __user *to, size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	char *buf;
	int ret;

	buf = kzalloc(AVS_FW_REGS_SIZE, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	memcpy_fromio(buf, avs_sram_addr(adev, AVS_FW_REGS_WINDOW), AVS_FW_REGS_SIZE);

	ret = simple_read_from_buffer(to, count, ppos, buf, AVS_FW_REGS_SIZE);
	kfree(buf);
	return ret;
}

static const struct file_operations fw_regs_fops = {
	.open = simple_open,
	.read = fw_regs_read,
};

static ssize_t debug_window_read(struct file *file, char __user *to, size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	size_t size;
	char *buf;
	int ret;

	size = adev->hw_cfg.dsp_cores * AVS_WINDOW_CHUNK_SIZE;
	buf = kzalloc(size, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	memcpy_fromio(buf, avs_sram_addr(adev, AVS_DEBUG_WINDOW), size);

	ret = simple_read_from_buffer(to, count, ppos, buf, size);
	kfree(buf);
	return ret;
}

static const struct file_operations debug_window_fops = {
	.open = simple_open,
	.read = debug_window_read,
};

static ssize_t probe_points_read(struct file *file, char __user *to, size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	struct avs_probe_point_desc *desc;
	size_t num_desc, len = 0;
	char *buf;
	int i, ret;

	/* Prevent chaining, send and dump IPC value just once. */
	if (*ppos)
		return 0;

	buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	ret = avs_ipc_probe_get_points(adev, &desc, &num_desc);
	if (ret) {
		ret = AVS_IPC_RET(ret);
		goto exit;
	}

	for (i = 0; i < num_desc; i++) {
		ret = snprintf(buf + len, PAGE_SIZE - len,
			       "Id: %#010x  Purpose: %d  Node id: %#x\n",
			       desc[i].id.value, desc[i].purpose, desc[i].node_id.val);
		if (ret < 0)
			goto free_desc;
		len += ret;
	}

	ret = simple_read_from_buffer(to, count, ppos, buf, len);
free_desc:
	kfree(desc);
exit:
	kfree(buf);
	return ret;
}

static ssize_t probe_points_write(struct file *file, const char __user *from, size_t count,
				  loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	struct avs_probe_point_desc *desc;
	u32 *array, num_elems;
	size_t bytes;
	int ret;

	ret = parse_int_array_user(from, count, (int **)&array);
	if (ret < 0)
		return ret;

	num_elems = *array;
	bytes = sizeof(*array) * num_elems;
	if (bytes % sizeof(*desc)) {
		ret = -EINVAL;
		goto exit;
	}

	desc = (struct avs_probe_point_desc *)&array[1];
	ret = avs_ipc_probe_connect_points(adev, desc, bytes / sizeof(*desc));
	if (ret)
		ret = AVS_IPC_RET(ret);
	else
		ret = count;
exit:
	kfree(array);
	return ret;
}

static const struct file_operations probe_points_fops = {
	.open = simple_open,
	.read = probe_points_read,
	.write = probe_points_write,
};

static ssize_t probe_points_disconnect_write(struct file *file, const char __user *from,
					     size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	union avs_probe_point_id *id;
	u32 *array, num_elems;
	size_t bytes;
	int ret;

	ret = parse_int_array_user(from, count, (int **)&array);
	if (ret < 0)
		return ret;

	num_elems = *array;
	bytes = sizeof(*array) * num_elems;
	if (bytes % sizeof(*id)) {
		ret = -EINVAL;
		goto exit;
	}

	id = (union avs_probe_point_id *)&array[1];
	ret = avs_ipc_probe_disconnect_points(adev, id, bytes / sizeof(*id));
	if (ret)
		ret = AVS_IPC_RET(ret);
	else
		ret = count;
exit:
	kfree(array);
	return ret;
}

static const struct file_operations probe_points_disconnect_fops = {
	.open = simple_open,
	.write = probe_points_disconnect_write,
	.llseek = default_llseek,
};

static ssize_t strace_read(struct file *file, char __user *to, size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	struct kfifo *fifo = &adev->trace_fifo;
	unsigned int copied;

	if (kfifo_is_empty(fifo)) {
		DEFINE_WAIT(wait);

		prepare_to_wait(&adev->trace_waitq, &wait, TASK_INTERRUPTIBLE);
		if (!signal_pending(current))
			schedule();
		finish_wait(&adev->trace_waitq, &wait);
	}

	if (kfifo_to_user(fifo, to, count, &copied))
		return -EFAULT;
	*ppos += copied;
	return copied;
}

static int strace_open(struct inode *inode, struct file *file)
{
	struct avs_dev *adev = inode->i_private;
	int ret;

	if (!try_module_get(adev->dev->driver->owner))
		return -ENODEV;

	if (kfifo_initialized(&adev->trace_fifo))
		return -EBUSY;

	ret = kfifo_alloc(&adev->trace_fifo, PAGE_SIZE, GFP_KERNEL);
	if (ret < 0)
		return ret;

	file->private_data = adev;
	return 0;
}

static int strace_release(struct inode *inode, struct file *file)
{
	union avs_notify_msg msg = AVS_NOTIFICATION(LOG_BUFFER_STATUS);
	struct avs_dev *adev = file->private_data;
	unsigned long resource_mask;
	unsigned long flags, i;
	u32 num_cores;

	resource_mask = adev->logged_resources;
	num_cores = adev->hw_cfg.dsp_cores;

	spin_lock_irqsave(&adev->trace_lock, flags);

	/* Gather any remaining logs. */
	for_each_set_bit(i, &resource_mask, num_cores) {
		msg.log.core = i;
		avs_dsp_op(adev, log_buffer_status, &msg);
	}

	kfifo_free(&adev->trace_fifo);

	spin_unlock_irqrestore(&adev->trace_lock, flags);

	module_put(adev->dev->driver->owner);
	return 0;
}

static const struct file_operations strace_fops = {
	.llseek = default_llseek,
	.read = strace_read,
	.open = strace_open,
	.release = strace_release,
};

#define DISABLE_TIMERS	UINT_MAX

static int enable_logs(struct avs_dev *adev, u32 resource_mask, u32 *priorities)
{
	int ret;

	/* Logging demands D0i0 state from DSP. */
	if (!adev->logged_resources) {
		pm_runtime_get_sync(adev->dev);

		ret = avs_dsp_disable_d0ix(adev);
		if (ret)
			goto err_d0ix;
	}

	ret = avs_ipc_set_system_time(adev);
	if (ret && ret != AVS_IPC_NOT_SUPPORTED) {
		ret = AVS_IPC_RET(ret);
		goto err_ipc;
	}

	ret = avs_dsp_op(adev, enable_logs, AVS_LOG_ENABLE, adev->aging_timer_period,
			 adev->fifo_full_timer_period, resource_mask, priorities);
	if (ret)
		goto err_ipc;

	adev->logged_resources |= resource_mask;
	return 0;

err_ipc:
	if (!adev->logged_resources) {
		avs_dsp_enable_d0ix(adev);
err_d0ix:
		pm_runtime_mark_last_busy(adev->dev);
		pm_runtime_put_autosuspend(adev->dev);
	}

	return ret;
}

static int disable_logs(struct avs_dev *adev, u32 resource_mask)
{
	int ret;

	/* Check if there's anything to do. */
	if (!adev->logged_resources)
		return 0;

	ret = avs_dsp_op(adev, enable_logs, AVS_LOG_DISABLE, DISABLE_TIMERS, DISABLE_TIMERS,
			 resource_mask, NULL);

	/*
	 * If IPC fails causing recovery, logged_resources is already zero
	 * so unsetting bits is still safe.
	 */
	adev->logged_resources &= ~resource_mask;

	/* If that's the last resource, allow for D3. */
	if (!adev->logged_resources) {
		avs_dsp_enable_d0ix(adev);
		pm_runtime_mark_last_busy(adev->dev);
		pm_runtime_put_autosuspend(adev->dev);
	}

	return ret;
}

static ssize_t trace_control_read(struct file *file, char __user *to, size_t count, loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	char buf[64];
	int len;

	len = snprintf(buf, sizeof(buf), "0x%08x\n", adev->logged_resources);

	return simple_read_from_buffer(to, count, ppos, buf, len);
}

static ssize_t trace_control_write(struct file *file, const char __user *from, size_t count,
				   loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	u32 *array, num_elems;
	u32 resource_mask;
	int ret;

	ret = parse_int_array_user(from, count, (int **)&array);
	if (ret < 0)
		return ret;

	num_elems = *array;
	resource_mask = array[1];

	/*
	 * Disable if just resource mask is provided - no log priority flags.
	 *
	 * Enable input format:   mask, prio1, .., prioN
	 * Where 'N' equals number of bits set in the 'mask'.
	 */
	if (num_elems == 1) {
		ret = disable_logs(adev, resource_mask);
	} else {
		if (num_elems != (hweight_long(resource_mask) + 1)) {
			ret = -EINVAL;
			goto free_array;
		}

		ret = enable_logs(adev, resource_mask, &array[2]);
	}

	if (!ret)
		ret = count;
free_array:
	kfree(array);
	return ret;
}

static const struct file_operations trace_control_fops = {
	.llseek = default_llseek,
	.read = trace_control_read,
	.write = trace_control_write,
	.open = simple_open,
};

void avs_debugfs_init(struct avs_dev *adev)
{
	init_waitqueue_head(&adev->trace_waitq);
	spin_lock_init(&adev->trace_lock);

	adev->debugfs_root = debugfs_create_dir("avs", snd_soc_debugfs_root);

	/* Initialize timer periods with recommended defaults. */
	adev->aging_timer_period = 10;
	adev->fifo_full_timer_period = 10;

	debugfs_create_file("strace", 0444, adev->debugfs_root, adev, &strace_fops);
	debugfs_create_file("trace_control", 0644, adev->debugfs_root, adev, &trace_control_fops);
	debugfs_create_file("fw_regs", 0444, adev->debugfs_root, adev, &fw_regs_fops);
	debugfs_create_file("debug_window", 0444, adev->debugfs_root, adev, &debug_window_fops);

	debugfs_create_u32("trace_aging_period", 0644, adev->debugfs_root,
			   &adev->aging_timer_period);
	debugfs_create_u32("trace_fifo_full_period", 0644, adev->debugfs_root,
			   &adev->fifo_full_timer_period);

	debugfs_create_file("probe_points", 0644, adev->debugfs_root, adev, &probe_points_fops);
	debugfs_create_file("probe_points_disconnect", 0200, adev->debugfs_root, adev,
			    &probe_points_disconnect_fops);
}

void avs_debugfs_exit(struct avs_dev *adev)
{
	debugfs_remove_recursive(adev->debugfs_root);
}




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38307

2. Vulnerability Type
Null pointer dereference due to missing length validation (unsafe array indexing from parsed user input)

3. Root Cause Summary
trace_control_write() accessed array[1] immediately after parsing user-provided integers without verifying that the parsed length (array[0]) was non-zero. When parse_int_array_user() returned an array whose first element (the count) was 0, dereferencing array[1] performed an out-of-bounds access that could lead to a null-pointer dereference and kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA SoC) Intel AVS driver debugfs control path (trace_control)

2) Pre-Patch Flaw:
In trace_control_write(), after parsing input, the code did: “num_elems = *array; resource_mask = array[1];” without checking that num_elems > 0. This assumes at least one additional element exists, which is not guaranteed per parse_int_array_user() semantics where array[0] carries the length and can be 0.

3) Trigger Condition:
A write to the debugfs file “trace_control” with content that parse_int_array_user() interprets as an integer array whose first element (length) is 0. This causes the function to index beyond the sole valid element at array[0].

4) Impact Mechanism:
Accessing array[1] when num_elems == 0 results in an out-of-bounds read leading to a null-pointer dereference in kernel space, causing an oops and denial of service. Subsequent logic (e.g., computing hweight_long(resource_mask) and potentially referencing &array[2]) further relies on the invalid resource_mask derived from the out-of-bounds read, exacerbating the fault.

5. Patch Analysis
1) Fix Approach:
Introduce explicit validation that the parsed length is non-zero before any access beyond array[0], and return -EINVAL if the array is empty.

2) Key Code Changes:
- Added:
  “if (!num_elems) { ret = -EINVAL; goto free_array; }”
- Deferred “resource_mask = array[1];” until after the non-zero length check.
These changes are confined to trace_control_write().

3) Locking/Concurrency Impact:
None. The patch only adds input validation and reorders a single assignment; no locking primitives or concurrency assumptions were modified.

6. Broader Kernel Security Implications
User-controllable debugfs input must be robustly validated, especially when using parsers like parse_int_array_user() that encode array length at index 0. Access beyond the length element must be guarded against zero-length arrays to prevent kernel crashes. Similar array-based interfaces should audit for and enforce non-zero lengths before indexing past array[0], reducing the risk of kernel oops from malformed inputs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}