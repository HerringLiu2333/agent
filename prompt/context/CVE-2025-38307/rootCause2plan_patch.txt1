You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38307

[INFO]
[PATCH_DESCRIPTION]
    ASoC: Intel: avs: Verify content returned by parse_int_array()
    The first element of the returned array stores its length. If it is 0,
    any manipulation beyond the element at index 0 ends with null-ptr-deref.

[PATCH_DIFF]
    @@ -373,7 +373,10 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     		return ret;
     
     	num_elems = *array;
    -	resource_mask = array[1];
    +	if (!num_elems) {
    +		ret = -EINVAL;
    +		goto free_array;
    +	}
     
     	/*
     	 * Disable if just resource mask is provided - no log priority flags.
    @@ -381,6 +384,7 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     	 * Enable input format:   mask, prio1, .., prioN
     	 * Where 'N' equals number of bits set in the 'mask'.
     	 */
    +	resource_mask = array[1];
     	if (num_elems == 1) {
     		ret = disable_logs(adev, resource_mask);
     	} else {



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38307

2. Vulnerability Type
NULL pointer dereference (triggered by out-of-bounds array access due to missing length validation)

3. Root Cause Summary
trace_control_write() unconditionally accessed array[1] (resource_mask) before validating the number of elements returned by parse_int_array(). When the first element (length) was 0, accessing array[1] was out-of-bounds, leading to a subsequent NULL pointer dereference. The patch adds a zero-length check and defers the access to array[1] until after validation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA SoC), Intel AVS driver, trace control write handler (trace_control_write)

2) Pre-Patch Flaw:
Missing validation of the parsed integer array length; resource_mask = array[1] was performed even when *array (num_elems) could be 0.

3) Trigger Condition:
Userspace writes data that parse_int_array() interprets as an integer array whose first element (length) is 0, causing the code to access array[1] despite no elements beyond index 0.

4) Impact Mechanism:
Out-of-bounds read at array[1] with zero length corrupts subsequent logic and culminates in a NULL pointer dereference in kernel context, causing a kernel oops/denial-of-service.

5. Patch Analysis
1) Fix Approach:
Defensive input validation: check for zero-length arrays and bail out with -EINVAL before any access beyond index 0; reorder the resource_mask assignment to occur only after the check.

2) Key Code Changes:
- Added:
  if (!num_elems) {
      ret = -EINVAL;
      goto free_array;
  }
- Moved resource_mask = array[1]; to after the zero-length check to prevent out-of-bounds access when num_elems == 0.

3) Locking/Concurrency Impact:
None. The change is purely input validation and ordering within the same execution context; no locks or concurrency primitives were added or modified.

6. Broader Kernel Security Implications
This highlights the need for strict length/bounds validation for helper APIs like parse_int_array() across debugfs/sysfs-like handlers. Similar patterns (length in element 0 followed by immediate indexing) should be audited to prevent OOB and NULL dereference bugs that can lead to local denial-of-service.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}