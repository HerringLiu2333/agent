You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38307

[INFO]
[PATCH_DESCRIPTION]
    ASoC: Intel: avs: Verify content returned by parse_int_array()
    The first element of the returned array stores its length. If it is 0,
    any manipulation beyond the element at index 0 ends with null-ptr-deref.

[PATCH_DIFF]
    @@ -373,7 +373,10 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     		return ret;
     
     	num_elems = *array;
    -	resource_mask = array[1];
    +	if (!num_elems) {
    +		ret = -EINVAL;
    +		goto free_array;
    +	}
     
     	/*
     	 * Disable if just resource mask is provided - no log priority flags.
    @@ -381,6 +384,7 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     	 * Enable input format:   mask, prio1, .., prioN
     	 * Where 'N' equals number of bits set in the 'mask'.
     	 */
    +	resource_mask = array[1];
     	if (num_elems == 1) {
     		ret = disable_logs(adev, resource_mask);
     	} else {

[FUNCTION_CONTENT]
static ssize_t trace_control_write(struct file *file, const char __user *from, size_t count,
				   loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	u32 *array, num_elems;
	u32 resource_mask;
	int ret;

	ret = parse_int_array_user(from, count, (int **)&array);
	if (ret < 0)
		return ret;

	num_elems = *array;
	resource_mask = array[1];

	/*
	 * Disable if just resource mask is provided - no log priority flags.
	 *
	 * Enable input format:   mask, prio1, .., prioN
	 * Where 'N' equals number of bits set in the 'mask'.
	 */
	if (num_elems == 1) {
		ret = disable_logs(adev, resource_mask);
	} else {
		if (num_elems != (hweight_long(resource_mask) + 1)) {
			ret = -EINVAL;
			goto free_array;
		}

		ret = enable_logs(adev, resource_mask, &array[2]);
	}

	if (!ret)
		ret = count;
free_array:
	kfree(array);
	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38307

2. Vulnerability Type
NULL pointer dereference due to missing bounds validation (out-of-bounds access on zero-length parsed array)

3. Root Cause Summary
trace_control_write() reads array[1] (resource_mask) without validating that the parsed array has at least 2 elements. When parse_int_array_user() returns an array whose first element (array[0]) indicates zero elements, any access beyond index 0 is invalid. The missing check for num_elems == 0 leads to out-of-bounds access and subsequent NULL pointer dereference during further manipulation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA System on Chip): Intel AVS trace control

2) Pre-Patch Flaw:
In trace_control_write(), the code assigns resource_mask = array[1] immediately after num_elems = *array, with no verification that num_elems > 0. This violates the contract described in the patch description that the first element stores the length and that zero length means no valid elements beyond index 0.

3) Trigger Condition:
A user write to the trace_control file with input that parse_int_array_user() parses into an array whose first element equals 0 (zero-length array). This causes the function to read array[1] and potentially manipulate &array[2], despite there being no valid elements.

4) Impact Mechanism:
Accessing array[1] when num_elems == 0 is an out-of-bounds read; subsequent logic may dereference invalid pointers, leading to a NULL pointer dereference and kernel crash/oops (Denial of Service).

5. Patch Analysis
1) Fix Approach:
Input validation was added to guard against zero-length arrays returned by parse_int_array_user(). The assignment of resource_mask was deferred until after validating num_elems is non-zero.

2) Key Code Changes:
- Inserted:
  if (!num_elems) {
      ret = -EINVAL;
      goto free_array;
  }
- Moved resource_mask = array[1]; to occur after the above check.
These changes ensure no access beyond array[0] when num_elems == 0 and return a safe error (-EINVAL) instead.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch strictly adds bounds validation and reorders a read. The function’s synchronization behavior remains unchanged.

6. Broader Kernel Security Implications
This highlights the need to validate length fields from parser helpers before indexing into arrays, especially in file write handlers exposed to user space. Failing to validate such inputs can allow unprivileged users to trigger kernel crashes via crafted writes, leading to denial of service. Consistent defensive checks on parsed input structures help prevent similar NULL dereferences and memory safety issues across subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}