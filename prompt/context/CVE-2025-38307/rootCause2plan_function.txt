You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38307

[INFO]
[PATCH_DESCRIPTION]
    ASoC: Intel: avs: Verify content returned by parse_int_array()
    The first element of the returned array stores its length. If it is 0,
    any manipulation beyond the element at index 0 ends with null-ptr-deref.

[PATCH_DIFF]
    @@ -373,7 +373,10 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     		return ret;
     
     	num_elems = *array;
    -	resource_mask = array[1];
    +	if (!num_elems) {
    +		ret = -EINVAL;
    +		goto free_array;
    +	}
     
     	/*
     	 * Disable if just resource mask is provided - no log priority flags.
    @@ -381,6 +384,7 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
     	 * Enable input format:   mask, prio1, .., prioN
     	 * Where 'N' equals number of bits set in the 'mask'.
     	 */
    +	resource_mask = array[1];
     	if (num_elems == 1) {
     		ret = disable_logs(adev, resource_mask);
     	} else {

[FUNCTION_CONTENT]
static ssize_t trace_control_write(struct file *file, const char __user *from, size_t count,
				   loff_t *ppos)
{
	struct avs_dev *adev = file->private_data;
	u32 *array, num_elems;
	u32 resource_mask;
	int ret;

	ret = parse_int_array_user(from, count, (int **)&array);
	if (ret < 0)
		return ret;

	num_elems = *array;
	resource_mask = array[1];

	/*
	 * Disable if just resource mask is provided - no log priority flags.
	 *
	 * Enable input format:   mask, prio1, .., prioN
	 * Where 'N' equals number of bits set in the 'mask'.
	 */
	if (num_elems == 1) {
		ret = disable_logs(adev, resource_mask);
	} else {
		if (num_elems != (hweight_long(resource_mask) + 1)) {
			ret = -EINVAL;
			goto free_array;
		}

		ret = enable_logs(adev, resource_mask, &array[2]);
	}

	if (!ret)
		ret = count;
free_array:
	kfree(array);
	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38307

2. Vulnerability Type
NULL pointer dereference due to missing bounds validation (out-of-bounds access on zero-length parsed array)

3. Root Cause Summary
trace_control_write() reads array[1] (resource_mask) without validating that the parsed array has at least 2 elements. When parse_int_array_user() returns an array whose first element (array[0]) indicates zero elements, any access beyond index 0 is invalid. The missing check for num_elems == 0 leads to out-of-bounds access and subsequent NULL pointer dereference during further manipulation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC (ALSA System on Chip): Intel AVS trace control

2) Pre-Patch Flaw:
In trace_control_write(), the code assigns resource_mask = array[1] immediately after num_elems = *array, with no verification that num_elems > 0. This violates the contract described in the patch description that the first element stores the length and that zero length means no valid elements beyond index 0.

3) Trigger Condition:
A user write to the trace_control file with input that parse_int_array_user() parses into an array whose first element equals 0 (zero-length array). This causes the function to read array[1] and potentially manipulate &array[2], despite there being no valid elements.

4) Impact Mechanism:
Accessing array[1] when num_elems == 0 is an out-of-bounds read; subsequent logic may dereference invalid pointers, leading to a NULL pointer dereference and kernel crash/oops (Denial of Service).

5. Patch Analysis
1) Fix Approach:
Input validation was added to guard against zero-length arrays returned by parse_int_array_user(). The assignment of resource_mask was deferred until after validating num_elems is non-zero.

2) Key Code Changes:
- Inserted:
  if (!num_elems) {
      ret = -EINVAL;
      goto free_array;
  }
- Moved resource_mask = array[1]; to occur after the above check.
These changes ensure no access beyond array[0] when num_elems == 0 and return a safe error (-EINVAL) instead.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch strictly adds bounds validation and reorders a read. The function’s synchronization behavior remains unchanged.

6. Broader Kernel Security Implications
This highlights the need to validate length fields from parser helpers before indexing into arrays, especially in file write handlers exposed to user space. Failing to validate such inputs can allow unprivileged users to trigger kernel crashes via crafted writes, leading to denial of service. Consistent defensive checks on parsed input structures help prevent similar NULL dereferences and memory safety issues across subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.