You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58095

[INFO]
[PATCH_DESCRIPTION]
 jfs: add check read-only before txBeginAnon() call
 [ Upstream commit 0176e69743ecc02961f2ae1ea42439cd2bf9ed58 ]
 
 Added a read-only check before calling `txBeginAnon` in `extAlloc`
 and `extRecord`. This prevents modification attempts on a read-only
 mounted filesystem, avoiding potential errors or crashes.
 
 Call trace:
  txBeginAnon+0xac/0x154
  extAlloc+0xe8/0xdec fs/jfs/jfs_extent.c:78
  jfs_get_block+0x340/0xb98 fs/jfs/inode.c:248
  __block_write_begin_int+0x580/0x166c fs/buffer.c:2128
  __block_write_begin fs/buffer.c:2177 [inline]
  block_write_begin+0x98/0x11c fs/buffer.c:2236
  jfs_write_begin+0x44/0x88 fs/jfs/inode.c:299
 
 Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")

[PATCH_DIFF]
 diff --git a/fs/jfs/jfs_extent.c b/fs/jfs/jfs_extent.c
 index 63d21822d309be…46529bcc8297ea 100644
 --- a/fs/jfs/jfs_extent.c
 +++ b/fs/jfs/jfs_extent.c
 @@ -74,6 +74,11 @@ extAlloc(struct inode ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)
   int rc;
   int xflag;

 + if (isReadOnly(ip)) {
 + jfs_error(ip->i_sb, “read-only filesystem\n”);
 + return -EIO;
 + }
 +
   / This blocks if we are low on resources /
   txBeginAnon(ip->i_sb);

 @@ -253,6 +258,11 @@ int extRecord(struct inode *ip, xad_t * xp)
   {
   int rc;

 + if (isReadOnly(ip)) {
 + jfs_error(ip->i_sb, “read-only filesystem\n”);
 + return -EIO;
 + }
 +
   txBeginAnon(ip->i_sb);

   mutex_lock(&JFS_IP(ip)->commit_mutex);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58095

2. Vulnerability Type
Missing state validation (improper enforcement of read-only mount) leading to illegal journaling/metadata modification attempts and potential kernel error/crash

3. Root Cause Summary
extAlloc() and extRecord() in fs/jfs/jfs_extent.c unconditionally invoked txBeginAnon(ip->i_sb) without verifying that the inode/superblock was not mounted read-only. This missing read-only state check allowed transaction initiation on a read-only filesystem, violating mount semantics and leading to errors or crashes in the journaling/extent allocation paths.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS (fs/jfs), specifically extent allocation/recording and journaling transaction initiation in fs/jfs/jfs_extent.c (extAlloc(), extRecord(), txBeginAnon()).

2) Pre-Patch Flaw:
Both extAlloc() (around line ~74) and extRecord() (around line ~258) called txBeginAnon(ip->i_sb) regardless of mount state; no isReadOnly() check was performed prior to starting a transaction. The unconditional transaction start on a read-only superblock is a logic/state validation error.

3) Trigger Condition:
Attempting operations that reach extAlloc()/extRecord() while the filesystem is mounted read-only. The provided call trace shows this can occur via the write path: extAlloc -> jfs_get_block -> __block_write_begin_int -> block_write_begin -> jfs_write_begin, on a read-only mount, leading to txBeginAnon being called.

4) Impact Mechanism:
Initiating a journaling transaction on a read-only filesystem can result in internal errors or kernel crashes in JFS journaling/extent code paths (as per the patch description). It also represents an attempted metadata modification in violation of read-only semantics, potentially causing inconsistent state or triggering error handling that crashes.

5. Patch Analysis
1) Fix Approach:
Introduce a precondition check to enforce read-only mount semantics before any transaction begins. If isReadOnly(ip) is true, log an error and return -EIO, preventing txBeginAnon() from being invoked.

2) Key Code Changes:
- In extAlloc(): added:
  if (isReadOnly(ip)) { jfs_error(ip->i_sb, "read-only filesystem\n"); return -EIO; }
  directly before the existing txBeginAnon(ip->i_sb) call.
- In extRecord(): added the same read-only check and early return before txBeginAnon(ip->i_sb).
These changes gate transaction initiation on mount state and stop extent allocation/recording on read-only filesystems.

3) Locking/Concurrency Impact:
No locking primitives were added or altered. The change introduces an early return in extRecord() before mutex_lock(&JFS_IP(ip)->commit_mutex), which prevents acquiring commit_mutex on read-only mounts; this reduces the chance of entering inconsistent transactional states but does not modify locking behavior elsewhere.

6. Broader Kernel Security Implications
Enforcing read-only state checks before initiating filesystem transactions hardens JFS against illegal write paths and prevents potential denial-of-service via crashes triggered by journaling on read-only mounts. It underscores the need for consistent mount-state validation across all write/transactional entry points in filesystems. Similar checks should be audited in other JFS and VFS interaction points to ensure read-only semantics are uniformly upheld.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}