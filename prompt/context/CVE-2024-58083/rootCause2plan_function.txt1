You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58083

[INFO]
[PATCH_DESCRIPTION]
 KVM: Explicitly verify target vCPU is online in kvm_get_vcpu()
 commit 1e7381f3617d14b3c11da80ff5f8a93ab14cfc46 upstream.
 
 Explicitly verify the target vCPU is fully online _prior_ to clamping the
 index in kvm_get_vcpu().  If the index is "bad", the nospec clamping will
 generate '0', i.e. KVM will return vCPU0 instead of NULL.

 In practice, the bug is unlikely to cause problems, as it will only come
 into play if userspace or the guest is buggy or misbehaving, e.g. KVM may
 send interrupts to vCPU0 instead of dropping them on the floor.
 
 However, returning vCPU0 when it shouldn't exist per online_vcpus is
 problematic now that KVM uses an xarray for the vCPUs array, as KVM needs
 to insert into the xarray before publishing the vCPU to userspace (see
 commit c5b077549136 ("KVM: Convert the kvm->vcpus array to a xarray")),
 i.e. before vCPU creation is guaranteed to succeed.

 As a result, incorrectly providing access to vCPU0 will trigger a
 use-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()
 bails out of vCPU creation due to an error and frees vCPU0.  Commit
 afb2acb2e3a3 ("KVM: Fix vcpu_array[0] races") papered over that issue, but
 in doing so introduced an unsolvable teardown conundrum.  Preventing
 accesses to vCPU0 before it's fully online will allow reverting commit
 afb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.
 
 Fixes: 1d487e9bf8ba ("KVM: fix spectrev1 gadgets")

[PATCH_DIFF]
 diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
 index 85fe9d0ebb9152…2c66ca21801c17 100644
 — a/include/linux/kvm_host.h
 +++ b/include/linux/kvm_host.h
 @@ -969,6 +969,15 @@ static inline struct kvm_io_bus *kvm_get_bus(struct kvm *kvm, enum kvm_bus idx)
 static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm kvm, int i)
 {
 int num_vcpus = atomic_read(&kvm->online_vcpus);
 +
 + /*
 +  * Explicitly verify the target vCPU is online, as the anti-speculation
 +  * logic only limits the CPU’s ability to speculate, e.g. given a “bad”
 +  * index, clamping the index to 0 would return vCPU0, not NULL.
 +  /
 + if (i >= num_vcpus)
 + return NULL;
 +
 i = array_index_nospec(i, num_vcpus);

 /* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu. /

[FUNCTION_CONTENT]
static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm *kvm, int i)
{
	int num_vcpus = atomic_read(&kvm->online_vcpus);
	i = array_index_nospec(i, num_vcpus);

	/* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu.  */
	smp_rmb();
	return xa_load(&kvm->vcpu_array, i);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58083

2. Vulnerability Type
Use-after-free due to missing bounds validation and unsafe object access; logical misuse of Spectre v1 index clamping

3. Root Cause Summary
kvm_get_vcpu() used array_index_nospec(i, num_vcpus) without first validating that i < online_vcpus. For “bad” indices, array_index_nospec clamps to 0, causing kvm_get_vcpu() to return vCPU0 instead of NULL. With KVM’s vCPU storage converted to an xarray, vCPU objects are inserted before they are fully “online” and before creation is guaranteed to succeed. If vCPU0 is accessed via this flawed path and kvm_vm_ioctl_create_vcpu() fails and frees vCPU0, subsequent dereferences of the returned pointer can trigger a use-after-free. The issue stems from conflating anti-speculation clamping (which limits speculation) with semantic bounds checking (which must return NULL on invalid indices).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
KVM core, vCPU management (kvm_get_vcpu, vcpu_array xarray)

2) Pre-Patch Flaw:
kvm_get_vcpu() only did i = array_index_nospec(i, num_vcpus) and then xa_load(&kvm->vcpu_array, i) with a read barrier, but did not verify i < num_vcpus (online_vcpus) before clamping. As a result, an out-of-range index could be coerced to 0 and yield vCPU0 instead of a NULL pointer.

3) Trigger Condition:
A caller passes i >= atomic_read(&kvm->online_vcpus) (e.g., due to buggy/malicious userspace or guest), while vCPU0 exists in the xarray but is not fully online, and vCPU creation subsequently fails and frees vCPU0.

4) Impact Mechanism:
kvm_get_vcpu() returns a pointer to vCPU0 when it should return NULL; if vCPU0 is freed during creation failure, any dereference of the previously returned pointer becomes a use-after-free. Secondary impact includes misrouting events (e.g., interrupts) to vCPU0 that should have been dropped.

5. Patch Analysis
1) Fix Approach:
Introduce explicit semantic bounds checking prior to anti-speculation clamping: return NULL if i >= num_vcpus. This ensures invalid indices fail fast and do not map to vCPU0, preventing access to non-online or soon-to-be-freed vCPU objects.

2) Key Code Changes:
Added:
- if (i >= num_vcpus) return NULL;
Placed before:
- i = array_index_nospec(i, num_vcpus);
Comment clarifies anti-speculation logic does not replace real bounds checking.

3) Locking/Concurrency Impact:
No locking changes; existing smp_rmb() remains to pair with smp_wmb() in kvm_vm_ioctl_create_vcpu. By preventing access to vCPU0 until it is fully online, the patch eliminates a race window where callers could observe or dereference a vCPU object that might concurrently be freed during failed creation, thus removing the UAF hazard created by pre-publication xarray insertion.

6. Broader Kernel Security Implications
Strengthens KVM’s safety around vCPU lookup by distinguishing anti-speculation from correctness checks, reducing the chance of UAF and misdirected events triggered by invalid indices. Aligns with xarray publishing/teardown semantics, enabling removal of prior workarounds while avoiding reintroduction of races. Mitigates potential host memory corruption and crashes from malicious guest/userspace inputs that exploit invalid vCPU indices. Improves robustness of index validation patterns in kernel subsystems using array_index_nospec.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}