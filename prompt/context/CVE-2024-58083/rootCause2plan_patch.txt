You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58083

[INFO]
[PATCH_DESCRIPTION]
 KVM: Explicitly verify target vCPU is online in kvm_get_vcpu()
 commit 1e7381f3617d14b3c11da80ff5f8a93ab14cfc46 upstream.
 
 Explicitly verify the target vCPU is fully online _prior_ to clamping the
 index in kvm_get_vcpu().  If the index is "bad", the nospec clamping will
 generate '0', i.e. KVM will return vCPU0 instead of NULL.

 In practice, the bug is unlikely to cause problems, as it will only come
 into play if userspace or the guest is buggy or misbehaving, e.g. KVM may
 send interrupts to vCPU0 instead of dropping them on the floor.
 
 However, returning vCPU0 when it shouldn't exist per online_vcpus is
 problematic now that KVM uses an xarray for the vCPUs array, as KVM needs
 to insert into the xarray before publishing the vCPU to userspace (see
 commit c5b077549136 ("KVM: Convert the kvm->vcpus array to a xarray")),
 i.e. before vCPU creation is guaranteed to succeed.

 As a result, incorrectly providing access to vCPU0 will trigger a
 use-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()
 bails out of vCPU creation due to an error and frees vCPU0.  Commit
 afb2acb2e3a3 ("KVM: Fix vcpu_array[0] races") papered over that issue, but
 in doing so introduced an unsolvable teardown conundrum.  Preventing
 accesses to vCPU0 before it's fully online will allow reverting commit
 afb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.
 
 Fixes: 1d487e9bf8ba ("KVM: fix spectrev1 gadgets")

[PATCH_DIFF]
 diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
 index 85fe9d0ebb9152…2c66ca21801c17 100644
 — a/include/linux/kvm_host.h
 +++ b/include/linux/kvm_host.h
 @@ -969,6 +969,15 @@ static inline struct kvm_io_bus *kvm_get_bus(struct kvm *kvm, enum kvm_bus idx)
 static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm kvm, int i)
 {
 int num_vcpus = atomic_read(&kvm->online_vcpus);
 +
 + /*
 +  * Explicitly verify the target vCPU is online, as the anti-speculation
 +  * logic only limits the CPU’s ability to speculate, e.g. given a “bad”
 +  * index, clamping the index to 0 would return vCPU0, not NULL.
 +  /
 + if (i >= num_vcpus)
 + return NULL;
 +
 i = array_index_nospec(i, num_vcpus);

 /* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu. /



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58083

2. Vulnerability Type
Use-after-free via incorrect index validation (functional bounds check missing; anti-speculation clamping misused)

3. Root Cause Summary
kvm_get_vcpu() failed to perform a real bounds/online check before applying array_index_nospec(), causing out-of-range indices (i >= online_vcpus) to be clamped to 0 and return vCPU0 instead of NULL. Because KVM now inserts a vCPU into the xarray before the vCPU is fully online, pre-patch callers could obtain a reference to vCPU0 while online_vcpus == 0. If vCPU creation later failed and freed vCPU0, any such reference could be dereferenced, triggering a use-after-free. The intended memory ordering (online_vcpus increment after publish) was undermined by returning vCPU0 when online_vcpus said it shouldn’t exist.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- KVM core, vCPU lookup path: include/linux/kvm_host.h, kvm_get_vcpu()

2) Pre-Patch Flaw:
- kvm_get_vcpu() read online_vcpus, then immediately did i = array_index_nospec(i, num_vcpus) without first verifying i < num_vcpus.
- array_index_nospec() is an anti-speculation gadget; with a “bad” index it clamps to 0, effectively returning vCPU0 instead of signaling invalid access (NULL).

3) Trigger Condition:
- Any caller provides an index i >= atomic_read(&kvm->online_vcpus), especially when online_vcpus == 0.
- With the xarray conversion, vCPU0 may be present in the xarray before being fully online; if kvm_vm_ioctl_create_vcpu() subsequently bails and frees vCPU0, a stale reference obtained via kvm_get_vcpu() can be dereferenced.

4) Impact Mechanism:
- Wrong-object access: vCPU0 is returned for out-of-range indices, enabling operations on a vCPU that should be considered non-existent per online_vcpus.
- Lifetime violation: dereferencing vCPU0 after create failure and free results in a use-after-free; alternatively, misroutes actions (e.g., interrupts) intended for non-existent vCPUs to vCPU0.

5. Patch Analysis
1) Fix Approach:
- Add a functional bounds/online check before the nospec clamping: if (i >= num_vcpus) return NULL; ensuring kvm_get_vcpu() never returns a vCPU pointer for an offline/non-existent index.

2) Key Code Changes:
- In kvm_get_vcpu():
  - New early check:
    - if (i >= num_vcpus) return NULL;
  - Retains array_index_nospec(i, num_vcpus) afterward to prevent Spectre v1 gadgets.
- Comment clarifies rationale: anti-speculation logic only limits speculation and cannot replace correctness checks.

3) Locking/Concurrency Impact:
- Relies on atomic_read(&kvm->online_vcpus) and preserves the ordering with the existing “Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu” sequence.
- By gating access on online_vcpus, the patch restores intended publication order: vCPUs are only accessible after being fully online, eliminating the UAF window introduced by pre-online xarray insertion. No new locks were added.

6. Broader Kernel Security Implications
- Anti-speculation primitives like array_index_nospec() must not be used as functional bounds checks; failing to do explicit validation can create logic errors with memory safety consequences.
- The change underscores the importance of strict lifecycle gating when objects are inserted into shared structures (xarray) before they are fully initialized/online.
- Prevents malicious or buggy userspace/guest from coercing KVM into operating on vCPU0 via invalid indices, reducing the risk of use-after-free and misdirected event delivery.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.