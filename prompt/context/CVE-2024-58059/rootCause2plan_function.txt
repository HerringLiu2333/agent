You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58059

[INFO]
[PATCH_DESCRIPTION]
 media: uvcvideo: Fix deadlock during uvc_probe
 [ Upstream commit a67f75c2b5ecf534eab416ce16c11fe780c4f8f6 ]
 
 If uvc_probe() fails, it can end up calling uvc_status_unregister() before
 uvc_status_init() is called.
 
 Fix this by checking if dev->status is NULL or not in
 uvc_status_unregister().
 
 Reported-by: syzbot+9446d5e0d25571e6a212@syzkaller.appspotmail.com
 Closes: https://lore.kernel.org/linux-media/20241020160249.GD7770@pendragon.ideasonboard.com/T/#m506744621d72a2ace5dd2ab64055be9898112dbd
 Fixes: c5fe3ed618f9 ("media: uvcvideo: Avoid race condition during unregister")

[PATCH_DIFF]
 diff --git a/drivers/media/usb/uvc/uvc_status.c b/drivers/media/usb/uvc/uvc_status.c
 index 06c867510c8fe6…f37417634ee944 100644
 -- a/drivers/media/usb/uvc/uvc_status.c
 +++ b/drivers/media/usb/uvc/uvc_status.c
 @@ -294,6 +294,9 @@ int uvc_status_init(struct uvc_device *dev)

   void uvc_status_unregister(struct uvc_device *dev)
   {
 + if (!dev->status)
 + return;
 +
   uvc_status_suspend(dev);
   uvc_input_unregister(dev);
   }

[FUNCTION_CONTENT]
void uvc_status_unregister(struct uvc_device *dev)
{
	uvc_status_suspend(dev);
	uvc_input_unregister(dev);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58059

2. Vulnerability Type
Deadlock / Denial-of-Service due to missing initialization-state check (probe failure path race)

3. Root Cause Summary
uvc_status_unregister() unconditionally invoked uvc_status_suspend() and uvc_input_unregister() assuming dev->status had been initialized. When uvc_probe() failed before uvc_status_init() ran, dev->status remained NULL, yet uvc_status_unregister() still executed. Entering suspend/unregister paths without an initialized status context led to a deadlock in the cleanup path during probe failure.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Media subsystem, USB Video Class (uvcvideo), file drivers/media/usb/uvc/uvc_status.c.

2) Pre-Patch Flaw:
uvc_status_unregister(struct uvc_device *dev) lacked a precondition check for dev->status and called:
- uvc_status_suspend(dev);
- uvc_input_unregister(dev);
even when status had never been initialized.

3) Trigger Condition:
Failure in uvc_probe() that causes its error path to call uvc_status_unregister() before uvc_status_init() has been executed, leaving dev->status as NULL.

4) Impact Mechanism:
Executing suspend/unregister routines without an initialized status object causes a deadlock during device probe cleanup (as reported by syzbot), resulting in a kernel-level hang in the driver path and a denial-of-service for device enumeration.

5. Patch Analysis
1) Fix Approach:
Defensive initialization-state check in uvc_status_unregister() to short-circuit when dev->status is NULL, preventing entry into suspend/unregister logic that assumes an initialized status context.

2) Key Code Changes:
In uvc_status_unregister():
- Added:
  if (!dev->status)
      return;
This precedes existing calls to uvc_status_suspend(dev) and uvc_input_unregister(dev).

3) Locking/Concurrency Impact:
No new locks or ordering changes were introduced. The early-return guard prevents invoking code that may acquire locks or wait on resources in an invalid state, thereby eliminating the deadlock observed when unregister was called prior to initialization.

6. Broader Kernel Security Implications
Improper state handling in probe error paths can allow local attackers (or malformed/malicious USB devices) to trigger deadlocks, leading to denial-of-service by stalling device enumeration or blocking related kernel threads. While not a memory-safety flaw, ensuring robust init/uninit sequencing and state checks is critical to maintain kernel availability and resilience against fuzzing or hostile peripherals.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.