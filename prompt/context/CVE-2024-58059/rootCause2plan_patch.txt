You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58059

[INFO]
[PATCH_DESCRIPTION]
 media: uvcvideo: Fix deadlock during uvc_probe
 [ Upstream commit a67f75c2b5ecf534eab416ce16c11fe780c4f8f6 ]
 
 If uvc_probe() fails, it can end up calling uvc_status_unregister() before
 uvc_status_init() is called.
 
 Fix this by checking if dev->status is NULL or not in
 uvc_status_unregister().
 
 Reported-by: syzbot+9446d5e0d25571e6a212@syzkaller.appspotmail.com
 Closes: https://lore.kernel.org/linux-media/20241020160249.GD7770@pendragon.ideasonboard.com/T/#m506744621d72a2ace5dd2ab64055be9898112dbd
 Fixes: c5fe3ed618f9 ("media: uvcvideo: Avoid race condition during unregister")

[PATCH_DIFF]
 diff --git a/drivers/media/usb/uvc/uvc_status.c b/drivers/media/usb/uvc/uvc_status.c
 index 06c867510c8fe6…f37417634ee944 100644
 -- a/drivers/media/usb/uvc/uvc_status.c
 +++ b/drivers/media/usb/uvc/uvc_status.c
 @@ -294,6 +294,9 @@ int uvc_status_init(struct uvc_device *dev)

   void uvc_status_unregister(struct uvc_device *dev)
   {
 + if (!dev->status)
 + return;
 +
   uvc_status_suspend(dev);
   uvc_input_unregister(dev);
   }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58059

2. Vulnerability Type
Deadlock due to missing pre-initialization state validation (improper cleanup on error path)

3. Root Cause Summary
uvc_status_unregister() unconditionally invoked uvc_status_suspend() and uvc_input_unregister() even when dev->status had not been initialized. When uvc_probe() failed before uvc_status_init() ran, calling uvc_status_unregister() with dev->status == NULL led to a deadlock in the probe failure cleanup path. The flaw is the lack of a guard for the uninitialized status context in uvc_status_unregister().

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Media subsystem, USB Video Class (UVC) driver; drivers/media/usb/uvc/uvc_status.c

2) Pre-Patch Flaw:
uvc_status_unregister(struct uvc_device *dev) lacked a NULL check for dev->status and unconditionally executed:
- uvc_status_suspend(dev);
- uvc_input_unregister(dev);
This assumed that uvc_status_init() had already set up dev->status.

3) Trigger Condition:
uvc_probe() fails and, in its error handling path, calls uvc_status_unregister() before uvc_status_init() has been called, leaving dev->status == NULL.

4) Impact Mechanism:
The unconditional suspend/unregister operations on an uninitialized status context caused a deadlock during device probing cleanup, stalling the probe path and potentially hanging the system (DoS). The patch description explicitly reports a deadlock during uvc_probe tied to this sequence.

5. Patch Analysis
1) Fix Approach:
Add a defensive early return in uvc_status_unregister() to skip suspend/unregister operations when dev->status is NULL, ensuring teardown only occurs after successful initialization.

2) Key Code Changes:
In drivers/media/usb/uvc/uvc_status.c, at the start of uvc_status_unregister():
- Inserted:
  if (!dev->status)
      return;
No other logic changes.

3) Locking/Concurrency Impact:
By avoiding calls to uvc_status_suspend() and uvc_input_unregister() when dev->status is NULL, the patch prevents entering suspend/unregister paths that may acquire locks or wait on resources that were never initialized, thereby removing the deadlock window in the probe failure path. It enforces correct ordering (init before unregister) and avoids race-prone cleanup when initialization hasn’t occurred.

6. Broader Kernel Security Implications
Ensuring error-path cleanup routines validate initialization state prevents deadlocks and system hangs, improving robustness against malformed or failing devices and fuzzing inputs (as reported by syzbot). This pattern reduces denial-of-service risks by guarding teardown code with initialization checks, a common requirement in complex driver probe/unregister sequences.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.