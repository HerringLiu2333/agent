You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57996

[INFO]
[PATCH_DESCRIPTION]
 net_sched: sch_sfq: don't allow 1 packet limit
 [ Upstream commit 10685681bafce6febb39770f3387621bf5d67d0b ]
 
 The current implementation does not work correctly with a limit of
 1. iproute2 actually checks for this and this patch adds the check in
 kernel as well.
 
 This fixes the following syzkaller reported crash:
 
 UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6
 index 65535 is out of range for type 'struct sfq_head[128]'
 CPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1
 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
 Call Trace:
   __dump_stack lib/dump_stack.c:79 [inline]
   dump_stack+0x125/0x19f lib/dump_stack.c:120
   ubsan_epilogue lib/ubsan.c:148 [inline]
   __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347
   sfq_link net/sched/sch_sfq.c:210 [inline]
   sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238
   sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500
   sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296
   netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline]
   dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362
   __dev_close_many+0x214/0x350 net/core/dev.c:1468
   dev_close_many+0x207/0x510 net/core/dev.c:1506
   unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738
   unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695
   unregister_netdevice include/linux/netdevice.h:2893 [inline]
   __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689
   tun_detach drivers/net/tun.c:705 [inline]
   tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640
   __fput+0x203/0x840 fs/file_table.c:280
   task_work_run+0x129/0x1b0 kernel/task_work.c:185
   exit_task_work include/linux/task_work.h:33 [inline]
   do_exit+0x5ce/0x2200 kernel/exit.c:931
   do_group_exit+0x144/0x310 kernel/exit.c:1046
   __do_sys_exit_group kernel/exit.c:1057 [inline]
   __se_sys_exit_group kernel/exit.c:1055 [inline]
   __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055
  do_syscall_64+0x6c/0xd0
  entry_SYSCALL_64_after_hwframe+0x61/0xcb
 RIP: 0033:0x7fe5e7b52479
 Code: Unable to access opcode bytes at RIP 0x7fe5e7b5244f.
 RSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479
 RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000
 RBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014
 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0
 R13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270
 
 The crash can be also be reproduced with the following (with a tc
 recompiled to allow for sfq limits of 1):
 
 tc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1s
 ../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1
 ifconfig dummy0 up
 ping -I dummy0 -f -c2 -W0.1 8.8.8.8
 sleep 1
 
 Scenario that triggers the crash:
 
 * the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1
 
 * TBF dequeues: it peeks from SFQ which moves the packet to the
   gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens so
   it schedules itself for later.
 
 * the second packet is sent and TBF tries to queues it to SFQ. qdisc
   qlen is now 2 and because the SFQ limit is 1 the packet is dropped
   by SFQ. At this point qlen is 1, and all of the SFQ slots are empty,
   however q->tail is not NULL.
 
 At this point, assuming no more packets are queued, when sch_dequeue
 runs again it will decrement the qlen for the current empty slot
 causing an underflow and the subsequent out of bounds access.

 Reported-by: syzbot <syzkaller@googlegroups.com>
 Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")

[PATCH_DIFF]
 diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c
 index 7d4feae2fae369…60754f366ab7bc 100644
 --- a/net/sched/sch_sfq.c
 +++ b/net/sched/sch_sfq.c
 @@ -652,6 +652,10 @@ static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
   if (!p)
   return -ENOMEM;
   }
 + if (ctl->limit == 1) {
 + NL_SET_ERR_MSG_MOD(extack, "invalid limit");
 + return -EINVAL;
 + }
   sch_tree_lock(sch);
   if (ctl->quantum)
   q->quantum = ctl->quantum;

[FUNCTION_CONTENT]
static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
		      struct netlink_ext_ack *extack)
{
	struct sfq_sched_data *q = qdisc_priv(sch);
	struct tc_sfq_qopt *ctl = nla_data(opt);
	struct tc_sfq_qopt_v1 *ctl_v1 = NULL;
	unsigned int qlen, dropped = 0;
	struct red_parms *p = NULL;
	struct sk_buff *to_free = NULL;
	struct sk_buff *tail = NULL;

	if (opt->nla_len < nla_attr_size(sizeof(*ctl)))
		return -EINVAL;
	if (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1)))
		ctl_v1 = nla_data(opt);
	if (ctl->divisor &&
	    (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536))
		return -EINVAL;

	if ((int)ctl->quantum < 0) {
		NL_SET_ERR_MSG_MOD(extack, "invalid quantum");
		return -EINVAL;
	}
	if (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,
					ctl_v1->Wlog, ctl_v1->Scell_log, NULL))
		return -EINVAL;
	if (ctl_v1 && ctl_v1->qth_min) {
		p = kmalloc(sizeof(*p), GFP_KERNEL);
		if (!p)
			return -ENOMEM;
	}
	sch_tree_lock(sch);
	if (ctl->quantum)
		q->quantum = ctl->quantum;
	WRITE_ONCE(q->perturb_period, ctl->perturb_period * HZ);
	if (ctl->flows)
		q->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);
	if (ctl->divisor) {
		q->divisor = ctl->divisor;
		q->maxflows = min_t(u32, q->maxflows, q->divisor);
	}
	if (ctl_v1) {
		if (ctl_v1->depth)
			q->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);
		if (p) {
			swap(q->red_parms, p);
			red_set_parms(q->red_parms,
				      ctl_v1->qth_min, ctl_v1->qth_max,
				      ctl_v1->Wlog,
				      ctl_v1->Plog, ctl_v1->Scell_log,
				      NULL,
				      ctl_v1->max_P);
		}
		q->flags = ctl_v1->flags;
		q->headdrop = ctl_v1->headdrop;
	}
	if (ctl->limit) {
		q->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);
		q->maxflows = min_t(u32, q->maxflows, q->limit);
	}

	qlen = sch->q.qlen;
	while (sch->q.qlen > q->limit) {
		dropped += sfq_drop(sch, &to_free);
		if (!tail)
			tail = to_free;
	}

	rtnl_kfree_skbs(to_free, tail);
	qdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);

	del_timer(&q->perturb_timer);
	if (q->perturb_period) {
		mod_timer(&q->perturb_timer, jiffies + q->perturb_period);
		get_random_bytes(&q->perturbation, sizeof(q->perturbation));
	}
	sch_tree_unlock(sch);
	kfree(p);
	return 0;
}

/* ----- separator ----- */

		NL_SET_ERR_MSG_MOD(extack, "invalid quantum");
		return -EINVAL;
	}
	if (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,
					ctl_v1->Wlog, ctl_v1->Scell_log, NULL))
		return -EINVAL;
	if (ctl_v1 && ctl_v1->qth_min) {
		p = kmalloc(sizeof(*p), GFP_KERNEL);
		if (!p)
			return -ENOMEM;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57996

2. Vulnerability Type
Improper input validation leading to array-index underflow/out-of-bounds (kernel memory-safety/DoS)

3. Root Cause Summary
sfq_change() accepted a queue limit of 1 (ctl->limit == 1), a configuration that violates SFQ’s internal invariants. With limit=1, the dequeue path can reach a state where all SFQ slots are empty while q->tail remains non-NULL; a subsequent decrement on the “current” empty slot underflows a size/index variable, producing an index of 65535. This underflow is then used to index sfq_head[128], causing array out-of-bounds access (as reported by UBSAN in sfq_link/sfq_dec/sfq_dequeue). The kernel lacked a guard against limit=1 (userspace iproute2 enforced it, but the kernel did not). The patch adds an explicit rejection of limit==1 in sfq_change(), preventing entry into the invalid state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
net_sched (Stochastic Fairness Queueing, sch_sfq)

2) Pre-Patch Flaw:
- sfq_change() permitted ctl->limit == 1, allowing a configuration SFQ logic cannot handle.
- This leads to an inconsistent internal state where q->tail is not NULL while all per-flow slots are empty, and a decrement is performed on an empty slot’s length, causing an underflow.

3) Trigger Condition:
- Configure SFQ with limit=1 (under a parent TBF), then enqueue two packets as described:
  - First packet is moved to gso_skb on TBF peek; qdisc qlen remains 1.
  - Second packet is dropped due to SFQ limit=1; all slots become empty but q->tail remains non-NULL.
  - Next dequeue decrements the “current empty slot,” underflowing the slot length/index.
- Reproducer from PATCH_DESCRIPTION matches this sequence; crash trace shows sfq_link -> sfq_dec -> sfq_dequeue.

4) Impact Mechanism:
- Underflowed index value 65535 is used to index sfq_head[128], causing array-index-out-of-bounds (UBSAN report: index 65535 in sfq_head[128] at net/sched/sch_sfq.c:210).
- Results in kernel memory access beyond bounds, leading to crash/DoS and potential memory corruption.

5. Patch Analysis
1) Fix Approach:
- Defensive input validation: explicitly reject ctl->limit == 1 in sfq_change(), returning -EINVAL and setting an extack error message.

2) Key Code Changes:
- Added in net/sched/sch_sfq.c, in sfq_change(), before taking sch_tree_lock():
  - if (ctl->limit == 1) { NL_SET_ERR_MSG_MOD(extack, "invalid limit"); return -EINVAL; }

3) Locking/Concurrency Impact:
- No locking changes; the new validation occurs before sch_tree_lock(sch), preventing installation of an invalid configuration and the ensuing inconsistent state in concurrent paths.

6. Broader Kernel Security Implications
- Kernel must validate qdisc parameters independently of userspace tools; relying on iproute2 checks is insufficient, especially under fuzzing (syzkaller) or malicious inputs.
- Edge-case configuration values that violate internal invariants can cascade into memory-safety issues; similar guards may be needed across other qdiscs.
- The bug’s longevity (Fixes tag: Linux-2.6.12-rc2) highlights the importance of re-evaluating legacy assumptions and adding explicit kernel-side constraints to maintain invariants.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.