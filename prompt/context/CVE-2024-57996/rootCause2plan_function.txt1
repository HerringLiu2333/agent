You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57996

[INFO]
[PATCH_DESCRIPTION]
 net_sched: sch_sfq: don't allow 1 packet limit
 [ Upstream commit 10685681bafce6febb39770f3387621bf5d67d0b ]
 
 The current implementation does not work correctly with a limit of
 1. iproute2 actually checks for this and this patch adds the check in
 kernel as well.
 
 This fixes the following syzkaller reported crash:
 
 UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6
 index 65535 is out of range for type 'struct sfq_head[128]'
 CPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1
 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
 Call Trace:
   __dump_stack lib/dump_stack.c:79 [inline]
   dump_stack+0x125/0x19f lib/dump_stack.c:120
   ubsan_epilogue lib/ubsan.c:148 [inline]
   __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347
   sfq_link net/sched/sch_sfq.c:210 [inline]
   sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238
   sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500
   sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296
   netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline]
   dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362
   __dev_close_many+0x214/0x350 net/core/dev.c:1468
   dev_close_many+0x207/0x510 net/core/dev.c:1506
   unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738
   unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695
   unregister_netdevice include/linux/netdevice.h:2893 [inline]
   __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689
   tun_detach drivers/net/tun.c:705 [inline]
   tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640
   __fput+0x203/0x840 fs/file_table.c:280
   task_work_run+0x129/0x1b0 kernel/task_work.c:185
   exit_task_work include/linux/task_work.h:33 [inline]
   do_exit+0x5ce/0x2200 kernel/exit.c:931
   do_group_exit+0x144/0x310 kernel/exit.c:1046
   __do_sys_exit_group kernel/exit.c:1057 [inline]
   __se_sys_exit_group kernel/exit.c:1055 [inline]
   __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055
  do_syscall_64+0x6c/0xd0
  entry_SYSCALL_64_after_hwframe+0x61/0xcb
 RIP: 0033:0x7fe5e7b52479
 Code: Unable to access opcode bytes at RIP 0x7fe5e7b5244f.
 RSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479
 RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000
 RBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014
 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0
 R13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270
 
 The crash can be also be reproduced with the following (with a tc
 recompiled to allow for sfq limits of 1):
 
 tc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1s
 ../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1
 ifconfig dummy0 up
 ping -I dummy0 -f -c2 -W0.1 8.8.8.8
 sleep 1
 
 Scenario that triggers the crash:
 
 * the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1
 
 * TBF dequeues: it peeks from SFQ which moves the packet to the
   gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens so
   it schedules itself for later.
 
 * the second packet is sent and TBF tries to queues it to SFQ. qdisc
   qlen is now 2 and because the SFQ limit is 1 the packet is dropped
   by SFQ. At this point qlen is 1, and all of the SFQ slots are empty,
   however q->tail is not NULL.
 
 At this point, assuming no more packets are queued, when sch_dequeue
 runs again it will decrement the qlen for the current empty slot
 causing an underflow and the subsequent out of bounds access.

 Reported-by: syzbot <syzkaller@googlegroups.com>
 Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")

[PATCH_DIFF]
 diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c
 index 7d4feae2fae369…60754f366ab7bc 100644
 --- a/net/sched/sch_sfq.c
 +++ b/net/sched/sch_sfq.c
 @@ -652,6 +652,10 @@ static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
   if (!p)
   return -ENOMEM;
   }
 + if (ctl->limit == 1) {
 + NL_SET_ERR_MSG_MOD(extack, "invalid limit");
 + return -EINVAL;
 + }
   sch_tree_lock(sch);
   if (ctl->quantum)
   q->quantum = ctl->quantum;

[FUNCTION_CONTENT]
static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
		      struct netlink_ext_ack *extack)
{
	struct sfq_sched_data *q = qdisc_priv(sch);
	struct tc_sfq_qopt *ctl = nla_data(opt);
	struct tc_sfq_qopt_v1 *ctl_v1 = NULL;
	unsigned int qlen, dropped = 0;
	struct red_parms *p = NULL;
	struct sk_buff *to_free = NULL;
	struct sk_buff *tail = NULL;

	if (opt->nla_len < nla_attr_size(sizeof(*ctl)))
		return -EINVAL;
	if (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1)))
		ctl_v1 = nla_data(opt);
	if (ctl->divisor &&
	    (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536))
		return -EINVAL;

	if ((int)ctl->quantum < 0) {
		NL_SET_ERR_MSG_MOD(extack, "invalid quantum");
		return -EINVAL;
	}
	if (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,
					ctl_v1->Wlog, ctl_v1->Scell_log, NULL))
		return -EINVAL;
	if (ctl_v1 && ctl_v1->qth_min) {
		p = kmalloc(sizeof(*p), GFP_KERNEL);
		if (!p)
			return -ENOMEM;
	}
	sch_tree_lock(sch);
	if (ctl->quantum)
		q->quantum = ctl->quantum;
	WRITE_ONCE(q->perturb_period, ctl->perturb_period * HZ);
	if (ctl->flows)
		q->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);
	if (ctl->divisor) {
		q->divisor = ctl->divisor;
		q->maxflows = min_t(u32, q->maxflows, q->divisor);
	}
	if (ctl_v1) {
		if (ctl_v1->depth)
			q->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);
		if (p) {
			swap(q->red_parms, p);
			red_set_parms(q->red_parms,
				      ctl_v1->qth_min, ctl_v1->qth_max,
				      ctl_v1->Wlog,
				      ctl_v1->Plog, ctl_v1->Scell_log,
				      NULL,
				      ctl_v1->max_P);
		}
		q->flags = ctl_v1->flags;
		q->headdrop = ctl_v1->headdrop;
	}
	if (ctl->limit) {
		q->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);
		q->maxflows = min_t(u32, q->maxflows, q->limit);
	}

	qlen = sch->q.qlen;
	while (sch->q.qlen > q->limit) {
		dropped += sfq_drop(sch, &to_free);
		if (!tail)
			tail = to_free;
	}

	rtnl_kfree_skbs(to_free, tail);
	qdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);

	del_timer(&q->perturb_timer);
	if (q->perturb_period) {
		mod_timer(&q->perturb_timer, jiffies + q->perturb_period);
		get_random_bytes(&q->perturbation, sizeof(q->perturbation));
	}
	sch_tree_unlock(sch);
	kfree(p);
	return 0;
}

/* ----- separator ----- */

		NL_SET_ERR_MSG_MOD(extack, "invalid quantum");
		return -EINVAL;
	}
	if (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,
					ctl_v1->Wlog, ctl_v1->Scell_log, NULL))
		return -EINVAL;
	if (ctl_v1 && ctl_v1->qth_min) {
		p = kmalloc(sizeof(*p), GFP_KERNEL);
		if (!p)
			return -ENOMEM;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57996

2. Vulnerability Type
Improper input validation leading to array-index underflow/out-of-bounds (kernel memory-safety/DoS)

3. Root Cause Summary
sfq_change() accepted a queue limit of 1 (ctl->limit == 1), a configuration that violates SFQ’s internal invariants. With limit=1, the dequeue path can reach a state where all SFQ slots are empty while q->tail remains non-NULL; a subsequent decrement on the “current” empty slot underflows a size/index variable, producing an index of 65535. This underflow is then used to index sfq_head[128], causing array out-of-bounds access (as reported by UBSAN in sfq_link/sfq_dec/sfq_dequeue). The kernel lacked a guard against limit=1 (userspace iproute2 enforced it, but the kernel did not). The patch adds an explicit rejection of limit==1 in sfq_change(), preventing entry into the invalid state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
net_sched (Stochastic Fairness Queueing, sch_sfq)

2) Pre-Patch Flaw:
- sfq_change() permitted ctl->limit == 1, allowing a configuration SFQ logic cannot handle.
- This leads to an inconsistent internal state where q->tail is not NULL while all per-flow slots are empty, and a decrement is performed on an empty slot’s length, causing an underflow.

3) Trigger Condition:
- Configure SFQ with limit=1 (under a parent TBF), then enqueue two packets as described:
  - First packet is moved to gso_skb on TBF peek; qdisc qlen remains 1.
  - Second packet is dropped due to SFQ limit=1; all slots become empty but q->tail remains non-NULL.
  - Next dequeue decrements the “current empty slot,” underflowing the slot length/index.
- Reproducer from PATCH_DESCRIPTION matches this sequence; crash trace shows sfq_link -> sfq_dec -> sfq_dequeue.

4) Impact Mechanism:
- Underflowed index value 65535 is used to index sfq_head[128], causing array-index-out-of-bounds (UBSAN report: index 65535 in sfq_head[128] at net/sched/sch_sfq.c:210).
- Results in kernel memory access beyond bounds, leading to crash/DoS and potential memory corruption.

5. Patch Analysis
1) Fix Approach:
- Defensive input validation: explicitly reject ctl->limit == 1 in sfq_change(), returning -EINVAL and setting an extack error message.

2) Key Code Changes:
- Added in net/sched/sch_sfq.c, in sfq_change(), before taking sch_tree_lock():
  - if (ctl->limit == 1) { NL_SET_ERR_MSG_MOD(extack, "invalid limit"); return -EINVAL; }

3) Locking/Concurrency Impact:
- No locking changes; the new validation occurs before sch_tree_lock(sch), preventing installation of an invalid configuration and the ensuing inconsistent state in concurrent paths.

6. Broader Kernel Security Implications
- Kernel must validate qdisc parameters independently of userspace tools; relying on iproute2 checks is insufficient, especially under fuzzing (syzkaller) or malicious inputs.
- Edge-case configuration values that violate internal invariants can cascade into memory-safety issues; similar guards may be needed across other qdiscs.
- The bug’s longevity (Fixes tag: Linux-2.6.12-rc2) highlights the importance of re-evaluating legacy assumptions and adding explicit kernel-side constraints to maintain invariants.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}