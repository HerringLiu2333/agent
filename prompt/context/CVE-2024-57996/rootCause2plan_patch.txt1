You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57996

[INFO]
[PATCH_DESCRIPTION]
 net_sched: sch_sfq: don't allow 1 packet limit
 [ Upstream commit 10685681bafce6febb39770f3387621bf5d67d0b ]
 
 The current implementation does not work correctly with a limit of
 1. iproute2 actually checks for this and this patch adds the check in
 kernel as well.
 
 This fixes the following syzkaller reported crash:
 
 UBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6
 index 65535 is out of range for type 'struct sfq_head[128]'
 CPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1
 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
 Call Trace:
   __dump_stack lib/dump_stack.c:79 [inline]
   dump_stack+0x125/0x19f lib/dump_stack.c:120
   ubsan_epilogue lib/ubsan.c:148 [inline]
   __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347
   sfq_link net/sched/sch_sfq.c:210 [inline]
   sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238
   sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500
   sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319
   qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026
   dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296
   netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline]
   dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362
   __dev_close_many+0x214/0x350 net/core/dev.c:1468
   dev_close_many+0x207/0x510 net/core/dev.c:1506
   unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738
   unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695
   unregister_netdevice include/linux/netdevice.h:2893 [inline]
   __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689
   tun_detach drivers/net/tun.c:705 [inline]
   tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640
   __fput+0x203/0x840 fs/file_table.c:280
   task_work_run+0x129/0x1b0 kernel/task_work.c:185
   exit_task_work include/linux/task_work.h:33 [inline]
   do_exit+0x5ce/0x2200 kernel/exit.c:931
   do_group_exit+0x144/0x310 kernel/exit.c:1046
   __do_sys_exit_group kernel/exit.c:1057 [inline]
   __se_sys_exit_group kernel/exit.c:1055 [inline]
   __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055
  do_syscall_64+0x6c/0xd0
  entry_SYSCALL_64_after_hwframe+0x61/0xcb
 RIP: 0033:0x7fe5e7b52479
 Code: Unable to access opcode bytes at RIP 0x7fe5e7b5244f.
 RSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
 RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479
 RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000
 RBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014
 R10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0
 R13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270
 
 The crash can be also be reproduced with the following (with a tc
 recompiled to allow for sfq limits of 1):
 
 tc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1s
 ../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1
 ifconfig dummy0 up
 ping -I dummy0 -f -c2 -W0.1 8.8.8.8
 sleep 1
 
 Scenario that triggers the crash:
 
 * the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1
 
 * TBF dequeues: it peeks from SFQ which moves the packet to the
   gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens so
   it schedules itself for later.
 
 * the second packet is sent and TBF tries to queues it to SFQ. qdisc
   qlen is now 2 and because the SFQ limit is 1 the packet is dropped
   by SFQ. At this point qlen is 1, and all of the SFQ slots are empty,
   however q->tail is not NULL.
 
 At this point, assuming no more packets are queued, when sch_dequeue
 runs again it will decrement the qlen for the current empty slot
 causing an underflow and the subsequent out of bounds access.

 Reported-by: syzbot <syzkaller@googlegroups.com>
 Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")

[PATCH_DIFF]
 diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c
 index 7d4feae2fae369…60754f366ab7bc 100644
 --- a/net/sched/sch_sfq.c
 +++ b/net/sched/sch_sfq.c
 @@ -652,6 +652,10 @@ static int sfq_change(struct Qdisc *sch, struct nlattr *opt,
   if (!p)
   return -ENOMEM;
   }
 + if (ctl->limit == 1) {
 + NL_SET_ERR_MSG_MOD(extack, "invalid limit");
 + return -EINVAL;
 + }
   sch_tree_lock(sch);
   if (ctl->quantum)
   q->quantum = ctl->quantum;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57996

2. Vulnerability Type
Improper input validation leading to array index out-of-bounds via integer underflow in queue accounting

3. Root Cause Summary
The sch_sfq qdisc allowed configuration with ctl->limit == 1, a corner case its internal accounting does not support. Under this configuration, SFQ’s per-slot state can become inconsistent (all slots empty while qdisc qlen remains 1 and q->tail is non-NULL), causing a subsequent dequeue path to decrement an empty slot counter and underflow. This underflow produces an invalid slot/index (observed as 65535) that is then used to access sfq_head[128], triggering an out-of-bounds array access. The pre-patch logic lacked validation in sfq_change to reject an invalid limit of 1, allowing the system to enter an unsupported state and crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Network scheduler (net_sched), Stochastic Fairness Queueing (sch_sfq)

2) Pre-Patch Flaw:
sfq_change did not validate ctl->limit and permitted limit == 1, despite the algorithm not being correct in that case. This allowed creation of a qdisc whose internal slot/accounting logic could reach a state where qlen and slot emptiness diverge while q->tail remains non-NULL.

3) Trigger Condition:
- Use of a TBF parent qdisc with an SFQ child configured with limit 1 (via recompiled tc or crafted netlink).
- TBF peeks from SFQ, moving the packet to the gso_skb list while keeping qdisc qlen at 1, leaving SFQ’s slots empty.
- A second packet is dropped due to the limit, leaving qlen 1, all slots empty, and q->tail non-NULL.
- A subsequent sch_dequeue causes a decrement on an empty slot, underflowing the slot/index.

4) Impact Mechanism:
The underflow yields an index of 65535 used against sfq_head[128], resulting in an array-index-out-of-bounds in sfq_link (reported at net/sched/sch_sfq.c:210) during the sfq_dec/sfq_dequeue path, leading to a kernel crash and potential memory corruption.

5. Patch Analysis
1) Fix Approach:
Input validation: explicitly reject an SFQ configuration with ctl->limit == 1, aligning kernel checks with iproute2 and preventing the unsupported corner case from being instantiated.

2) Key Code Changes:
- In sfq_change:
  - Added:
    if (ctl->limit == 1) {
      NL_SET_ERR_MSG_MOD(extack, "invalid limit");
      return -EINVAL;
    }
  This early return prevents entering the flawed state before any reconfiguration under sch_tree_lock.

3) Locking/Concurrency Impact:
No changes to locking or concurrency; the new validation occurs before sch_tree_lock(sch) and simply aborts invalid configurations. The fix does not alter code paths related to RCU, atomicity, or lock ordering.

6. Broader Kernel Security Implications
Rejecting invalid qdisc parameters at the kernel boundary hardens the scheduler against crafted netlink messages or modified userspace tools that bypass userland validation, reducing the attack surface for DoS via kernel crashes. Aligning kernel-side validation with iproute2 prevents unsupported algorithmic corner cases that can lead to memory-safety violations. This emphasizes the importance of defensive parameter checking for subsystems with complex internal invariants, especially in networking where qdisc stacking and interactions (e.g., TBF + SFQ) can expose subtle bugs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}