You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38308

[INFO]
[PATCH_DESCRIPTION]
    ASoC: Intel: avs: Fix possible null-ptr-deref when initing hw
    Search result of avs_dai_find_path_template() shall be verified before
    being used. As 'template' is already known when
    avs_hw_constraints_init() is fired, drop the search entirely.

[PATCH_DIFF]
     @@ -83,10 +83,8 @@ void avs_period_elapsed(struct snd_pcm_substream *substream)
      static int hw_rule_param_size(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule);
      static int avs_hw_constraints_init(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
      {
     -	struct snd_soc_pcm_runtime *rtd = snd_soc_substream_to_rtd(substream);
      	struct snd_pcm_runtime *runtime = substream->runtime;
      	struct snd_pcm_hw_constraint_list *r, *c, *s;
     -	struct avs_tplg_path_template *template;
      	struct avs_dma_data *data;
      	int ret;
      
     @@ -99,8 +97,7 @@ static int avs_hw_constraints_init(struct snd_pcm_substream *substream, struct s
      	c = &(data->channels_list);
      	s = &(data->sample_bits_list);
      
     -	template = avs_dai_find_path_template(dai, !rtd->dai_link->no_pcm, substream->stream);
     -	ret = avs_path_set_constraint(data->adev, template, r, c, s);
     +	ret = avs_path_set_constraint(data->adev, data->template, r, c, s);
      	if (ret <= 0)
      		return ret;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38308

2. Vulnerability Type
NULL pointer dereference leading to kernel denial-of-service

3. Root Cause Summary
avs_hw_constraints_init() unconditionally used the result of avs_dai_find_path_template() without verifying it was non-NULL, passing a potentially NULL template into avs_path_set_constraint(), which could dereference it. The patch description explicitly states the search result “shall be verified before being used,” indicating the missing NULL check. The fix avoids the unsafe lookup entirely by using a pre-established, valid data->template.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA SoC (ASoC) – Intel AVS (audio DSP) driver

2) Pre-Patch Flaw:
In avs_hw_constraints_init(), the code did:
- template = avs_dai_find_path_template(dai, !rtd->dai_link->no_pcm, substream->stream);
- ret = avs_path_set_constraint(data->adev, template, r, c, s);
It failed to check whether template was NULL before passing it to avs_path_set_constraint().

3) Trigger Condition:
When avs_dai_find_path_template() returns NULL (e.g., no matching path template exists for the given DAI/no_pcm/stream combination), which can occur during PCM hardware constraints initialization for a substream.

4) Impact Mechanism:
avs_path_set_constraint() receives a NULL template and dereferences it, causing a NULL pointer dereference in kernel context, leading to an oops/panic and denial of service.

5. Patch Analysis
1) Fix Approach:
Eliminate the unsafe runtime lookup and instead use a known-good template already stored in data->template at the time avs_hw_constraints_init() runs, thereby guaranteeing a valid pointer and removing the NULL deref risk.

2) Key Code Changes:
- Removed rtd and template locals and the call to avs_dai_find_path_template(...).
- Changed:
  - pre-patch: ret = avs_path_set_constraint(data->adev, template, r, c, s);
  - post-patch: ret = avs_path_set_constraint(data->adev, data->template, r, c, s);
This enforces use of a prevalidated template and sidesteps the need to validate a search result.

3) Locking/Concurrency Impact:
No locking or concurrency changes were made or required; the fix is purely a control-flow/data-flow correction to ensure a valid pointer is used.

6. Broader Kernel Security Implications
- Reinforces the importance of validating helper function returns before use, especially when they may legitimately return NULL.
- Preferring state established earlier in the device/stream setup (e.g., a validated data->template) reduces error-prone re-discovery and eliminates classes of NULL deref bugs.
- Since ALSA device usage can be initiated by unprivileged users, such NULL dereferences in open/setup paths can provide an easy denial-of-service vector; hardening these paths improves overall kernel robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.