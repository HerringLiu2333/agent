You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38316

[INFO]
[PATCH_DESCRIPTION]
    wifi: mt76: mt7996: avoid NULL pointer dereference in mt7996_set_monitor()
    The function mt7996_set_monitor() dereferences phy before
    the NULL sanity check.
    
    Fix this to avoid NULL pointer dereference by moving the
    dereference after the check.

[PATCH_DIFF]
     @@ -414,11 +414,13 @@ static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
      
      static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
      {
     -	struct mt7996_dev *dev = phy->dev;
     +	struct mt7996_dev *dev;
      
      	if (!phy)
      		return;
      
     +	dev = phy->dev;
     +
      	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
      		return;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38316

2. Vulnerability Type
NULL pointer dereference leading to kernel crash/DoS

3. Root Cause Summary
mt7996_set_monitor() dereferenced the phy argument before validating it against NULL. Specifically, the pre-patch code initialized "struct mt7996_dev *dev = phy->dev;" prior to "if (!phy) return;", causing an immediate NULL pointer dereference when phy was NULL. The flaw is an incorrect ordering of the NULL check relative to the dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux Wi-Fi subsystem, mt76 driver for MediaTek mt7996

2) Pre-Patch Flaw:
Incorrect initialization order: "struct mt7996_dev *dev = phy->dev;" occurs before the NULL sanity check "if (!phy) return;". This dereferences phy unconditionally.

3) Trigger Condition:
Calling mt7996_set_monitor() with phy == NULL.

4) Impact Mechanism:
The premature dereference of phy->dev when phy == NULL results in a NULL pointer dereference, causing a kernel oops and potential system crash (denial of service).

5. Patch Analysis
1) Fix Approach:
Reorder operations so that the NULL check happens before any dereference of phy. Initialize dev only after confirming phy is non-NULL.

2) Key Code Changes:
- Changed "struct mt7996_dev *dev = phy->dev;" to "struct mt7996_dev *dev;" at declaration.
- Moved "dev = phy->dev;" after the "if (!phy) return;" check.
- No functional changes beyond preventing the early dereference.

3) Locking/Concurrency Impact:
None. The patch only reorders a NULL check and variable initialization; no locks or concurrency mechanisms are introduced or modified.

6. Broader Kernel Security Implications
This fix enforces a fundamental defensive coding practice: validate pointers before dereferencing to prevent kernel crashes. Ensuring correct check-before-use ordering reduces the risk of trivial denial-of-service conditions in driver control paths. Similar patterns should be audited across driver code to eliminate comparable NULL dereference hazards.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.