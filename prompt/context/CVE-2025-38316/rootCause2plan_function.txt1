You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38316

[INFO]
[PATCH_DESCRIPTION]
    wifi: mt76: mt7996: avoid NULL pointer dereference in mt7996_set_monitor()
    The function mt7996_set_monitor() dereferences phy before
    the NULL sanity check.
    
    Fix this to avoid NULL pointer dereference by moving the
    dereference after the check.

[PATCH_DIFF]
     @@ -414,11 +414,13 @@ static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
      
      static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
      {
     -	struct mt7996_dev *dev = phy->dev;
     +	struct mt7996_dev *dev;
      
      	if (!phy)
      		return;
      
     +	dev = phy->dev;
     +
      	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
      		return;

[FUNCTION_CONTENT]
static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
{
	struct mt7996_dev *dev = phy->dev;

	if (!phy)
		return;

	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
		return;

	if (!enabled)
		phy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;
	else
		phy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;

	mt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),
		       MT_DMA_DCR0_RXD_G5_EN, enabled);
	mt7996_phy_set_rxfilter(phy);
	mt7996_mcu_set_sniffer_mode(phy, enabled);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38316

2. Vulnerability Type
NULL pointer dereference (missing NULL validation before dereference), leading to kernel denial-of-service

3. Root Cause Summary
mt7996_set_monitor() dereferenced the input pointer phy to initialize dev (dev = phy->dev) before verifying that phy was non-NULL. If phy was NULL, this early dereference caused an immediate NULL pointer dereference in the driver.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 Wi-Fi driver (mt7996 chipset), function mt7996_set_monitor()

2) Pre-Patch Flaw:
The function performed dev = phy->dev prior to checking if (!phy). This order-of-operations bug used phy without validation.

3) Trigger Condition:
Calling mt7996_set_monitor() with phy == NULL. The precise call path that can pass NULL is not provided (Unknown/Not determinable), but any such call would trigger the fault immediately upon function entry.

4) Impact Mechanism:
A NULL dereference of phy when evaluating phy->dev results in a kernel Oops/BUG and denial-of-service (system crash or driver crash), depending on system configuration.

5. Patch Analysis
1) Fix Approach:
Reorder operations to validate phy before any dereference. Specifically, delay reading phy->dev until after confirming phy is non-NULL.

2) Key Code Changes:
- Changed the declaration and initialization of dev:
  - Pre-patch: struct mt7996_dev *dev = phy->dev; (dereferences phy immediately)
  - Post-patch: struct mt7996_dev *dev; if (!phy) return; dev = phy->dev; (dereference only after NULL check)

3) Locking/Concurrency Impact:
No locking or concurrency semantics were changed. The fix is limited to pointer validation ordering.

6. Broader Kernel Security Implications
NULL pointer dereferences in driver entry points can be used to cause local denial-of-service via reachable configuration paths (e.g., enabling monitor/sniffer mode). This issue highlights the importance of validating inputs before any dereference across similar helper paths in the mt76/mt7996 codebase; a systematic audit for pointer use-before-check patterns is advisable to prevent similar crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}