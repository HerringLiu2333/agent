You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38275

[INFO]
[PATCH_DESCRIPTION]
    phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug
    The qmp_usb_iomap() helper function currently returns the raw result of
    devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return
    a NULL pointer and the caller only checks error pointers with IS_ERR(),
    NULL could bypass the check and lead to an invalid dereference.
    
    Fix the issue by checking if devm_ioremap() returns NULL. When it does,
    qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM),
    ensuring safe and consistent error handling.

[PATCH_DIFF]
     @@ -2106,12 +2106,16 @@ static void __iomem *qmp_usb_iomap(struct device *dev, struct device_node *np,
     					int index, bool exclusive)
     {
     	struct resource res;
    +	void __iomem *mem;
     
     	if (!exclusive) {
     		if (of_address_to_resource(np, index, &res))
     			return IOMEM_ERR_PTR(-EINVAL);
     
    -		return devm_ioremap(dev, res.start, resource_size(&res));
    +		mem = devm_ioremap(dev, res.start, resource_size(&res));
    +		if (!mem)
    +			return IOMEM_ERR_PTR(-ENOMEM);
    +		return mem;
     	}
     
     	return devm_of_iomap(dev, np, index, NULL);

[FUNCTION_CONTENT]
static void __iomem *qmp_usb_iomap(struct device *dev, struct device_node *np,
					int index, bool exclusive)
{
	struct resource res;

	if (!exclusive) {
		if (of_address_to_resource(np, index, &res))
			return IOMEM_ERR_PTR(-EINVAL);

		return devm_ioremap(dev, res.start, resource_size(&res));
	}

	return devm_of_iomap(dev, np, index, NULL);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38275

2. Vulnerability Type
NULL pointer dereference due to inconsistent error handling (NULL vs ERR_PTR)

3. Root Cause Summary
In qmp_usb_iomap(), the non-exclusive path returned the raw result of devm_ioremap(), which can be NULL on failure. Callers only tested for error pointers using IS_ERR(), so a NULL return bypassed error handling and was subsequently dereferenced. The patch enforces consistent error semantics by converting NULL to an error pointer via IOMEM_ERR_PTR(-ENOMEM).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm QMP USB PHY driver (phy: qcom-qmp-usb)

2) Pre-Patch Flaw:
The function returned devm_ioremap() directly in the non-exclusive case (“return devm_ioremap(dev, res.start, resource_size(&res));”), mixing NULL and ERR_PTR error conventions and violating caller expectations that only check IS_ERR().

3) Trigger Condition:
- of_address_to_resource() succeeds (resource acquired).
- devm_ioremap() fails and returns NULL (e.g., due to allocation/mapping failure).
- Caller performs only IS_ERR() checks, treating NULL as success.

4) Impact Mechanism:
The caller uses the returned mapping assuming it is valid (not an ERR_PTR), leading to dereference of a NULL pointer and a kernel crash/DoS.

5. Patch Analysis
1) Fix Approach:
Normalize error handling by detecting a NULL return from devm_ioremap() and returning an ERR_PTR via IOMEM_ERR_PTR(-ENOMEM), ensuring callers using IS_ERR() catch the failure.

2) Key Code Changes:
- Introduced a local variable “void __iomem *mem;”.
- Assigned mem = devm_ioremap(...).
- Added “if (!mem) return IOMEM_ERR_PTR(-ENOMEM);” before returning mem.
- Exclusive path (devm_of_iomap) unchanged.

3) Locking/Concurrency Impact:
None; the change is limited to error propagation and does not alter locking, ordering, or concurrency.

6. Broader Kernel Security Implications
Consistent error propagation prevents NULL dereferences that can crash the kernel, improving robustness under low-memory or mapping-failure conditions. This hardening reduces denial-of-service risk and aligns driver error semantics with callers’ IS_ERR() checks, lowering the chance of similar latent bugs in I/O memory mapping paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.