You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38275

[INFO]
[PATCH_DESCRIPTION]
    phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug
    The qmp_usb_iomap() helper function currently returns the raw result of
    devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return
    a NULL pointer and the caller only checks error pointers with IS_ERR(),
    NULL could bypass the check and lead to an invalid dereference.
    
    Fix the issue by checking if devm_ioremap() returns NULL. When it does,
    qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM),
    ensuring safe and consistent error handling.

[PATCH_DIFF]
     @@ -2106,12 +2106,16 @@ static void __iomem *qmp_usb_iomap(struct device *dev, struct device_node *np,
     					int index, bool exclusive)
     {
     	struct resource res;
    +	void __iomem *mem;
     
     	if (!exclusive) {
     		if (of_address_to_resource(np, index, &res))
     			return IOMEM_ERR_PTR(-EINVAL);
     
    -		return devm_ioremap(dev, res.start, resource_size(&res));
    +		mem = devm_ioremap(dev, res.start, resource_size(&res));
    +		if (!mem)
    +			return IOMEM_ERR_PTR(-ENOMEM);
    +		return mem;
     	}
     
     	return devm_of_iomap(dev, np, index, NULL);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38275

2. Vulnerability Type
NULL pointer dereference due to inconsistent error handling (NULL vs ERR_PTR)

3. Root Cause Summary
qmp_usb_iomap() returned the raw result of devm_ioremap() in the non-exclusive path, which can be NULL on failure. Callers of qmp_usb_iomap() only checked IS_ERR(), not for NULL, so a NULL return bypassed error handling and was later dereferenced. The exclusive path used devm_of_iomap(), which returns ERR_PTR on failure, creating an inconsistency between branches and leading to unchecked NULL in the non-exclusive case.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm QMP USB PHY driver (phy: qcom-qmp-usb)

2) Pre-Patch Flaw:
- In qmp_usb_iomap(struct device *dev, struct device_node *np, int index, bool exclusive), the non-exclusive branch did: return devm_ioremap(dev, res.start, resource_size(&res));.
- devm_ioremap() may return NULL on failure, but callers expected ERR_PTR-style error reporting and only used IS_ERR() checks.
- This mismatch allowed NULL to propagate as a “success” value.

3) Trigger Condition:
- exclusive == false, of_address_to_resource(np, index, &res) succeeds, and devm_ioremap(dev, ...) fails and returns NULL.
- Callers rely solely on IS_ERR() against the returned pointer and do not check for NULL, proceeding to use the mapping.

4) Impact Mechanism:
- Subsequent dereference of the returned mapping pointer causes a NULL pointer dereference in the PHY driver code path (e.g., during register access), leading to a kernel oops/crash (denial of service).

5. Patch Analysis
1) Fix Approach:
- Normalize error reporting by converting a NULL devm_ioremap() result into an ERR_PTR using IOMEM_ERR_PTR(-ENOMEM).
- Ensures consistent error semantics across both exclusive and non-exclusive mapping paths so caller IS_ERR() checks are effective.

2) Key Code Changes:
- Introduced a local variable mem to hold the devm_ioremap() result.
- Added explicit NULL check:
  - mem = devm_ioremap(...);
  - if (!mem) return IOMEM_ERR_PTR(-ENOMEM);
  - return mem;
- Left existing IOMEM_ERR_PTR(-EINVAL) on of_address_to_resource() failure unchanged and retained devm_of_iomap() use for exclusive case.

3) Locking/Concurrency Impact:
- None. The change is confined to error handling of return pointers; no locking or ordering semantics were modified.

6. Broader Kernel Security Implications
- Highlights the risk of mixing APIs that return NULL on failure with ERR_PTR-based error handling. Similar helper functions should be audited to ensure consistent error propagation (NULL-to-ERR_PTR conversion or explicit NULL checks).
- Strengthens robustness of device initialization paths where early failures must be reliably detected to avoid kernel crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}