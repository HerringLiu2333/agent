You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38275

[INFO]
[PATCH_DESCRIPTION]
    phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug
    The qmp_usb_iomap() helper function currently returns the raw result of
    devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return
    a NULL pointer and the caller only checks error pointers with IS_ERR(),
    NULL could bypass the check and lead to an invalid dereference.
    
    Fix the issue by checking if devm_ioremap() returns NULL. When it does,
    qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM),
    ensuring safe and consistent error handling.

[PATCH_DIFF]
     @@ -2106,12 +2106,16 @@ static void __iomem *qmp_usb_iomap(struct device *dev, struct device_node *np,
     					int index, bool exclusive)
     {
     	struct resource res;
    +	void __iomem *mem;
     
     	if (!exclusive) {
     		if (of_address_to_resource(np, index, &res))
     			return IOMEM_ERR_PTR(-EINVAL);
     
    -		return devm_ioremap(dev, res.start, resource_size(&res));
    +		mem = devm_ioremap(dev, res.start, resource_size(&res));
    +		if (!mem)
    +			return IOMEM_ERR_PTR(-ENOMEM);
    +		return mem;
     	}
     
     	return devm_of_iomap(dev, np, index, NULL);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38275

2. Vulnerability Type
NULL pointer dereference due to inconsistent error handling (NULL vs ERR_PTR)

3. Root Cause Summary
qmp_usb_iomap() returned the raw result of devm_ioremap() in the non-exclusive path, which can be NULL on failure. Callers of qmp_usb_iomap() only checked IS_ERR(), not for NULL, so a NULL return bypassed error handling and was later dereferenced. The exclusive path used devm_of_iomap(), which returns ERR_PTR on failure, creating an inconsistency between branches and leading to unchecked NULL in the non-exclusive case.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm QMP USB PHY driver (phy: qcom-qmp-usb)

2) Pre-Patch Flaw:
- In qmp_usb_iomap(struct device *dev, struct device_node *np, int index, bool exclusive), the non-exclusive branch did: return devm_ioremap(dev, res.start, resource_size(&res));.
- devm_ioremap() may return NULL on failure, but callers expected ERR_PTR-style error reporting and only used IS_ERR() checks.
- This mismatch allowed NULL to propagate as a “success” value.

3) Trigger Condition:
- exclusive == false, of_address_to_resource(np, index, &res) succeeds, and devm_ioremap(dev, ...) fails and returns NULL.
- Callers rely solely on IS_ERR() against the returned pointer and do not check for NULL, proceeding to use the mapping.

4) Impact Mechanism:
- Subsequent dereference of the returned mapping pointer causes a NULL pointer dereference in the PHY driver code path (e.g., during register access), leading to a kernel oops/crash (denial of service).

5. Patch Analysis
1) Fix Approach:
- Normalize error reporting by converting a NULL devm_ioremap() result into an ERR_PTR using IOMEM_ERR_PTR(-ENOMEM).
- Ensures consistent error semantics across both exclusive and non-exclusive mapping paths so caller IS_ERR() checks are effective.

2) Key Code Changes:
- Introduced a local variable mem to hold the devm_ioremap() result.
- Added explicit NULL check:
  - mem = devm_ioremap(...);
  - if (!mem) return IOMEM_ERR_PTR(-ENOMEM);
  - return mem;
- Left existing IOMEM_ERR_PTR(-EINVAL) on of_address_to_resource() failure unchanged and retained devm_of_iomap() use for exclusive case.

3) Locking/Concurrency Impact:
- None. The change is confined to error handling of return pointers; no locking or ordering semantics were modified.

6. Broader Kernel Security Implications
- Highlights the risk of mixing APIs that return NULL on failure with ERR_PTR-based error handling. Similar helper functions should be audited to ensure consistent error propagation (NULL-to-ERR_PTR conversion or explicit NULL checks).
- Strengthens robustness of device initialization paths where early failures must be reliably detected to avoid kernel crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.