You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38245

[INFO]
[PATCH_DESCRIPTION]
    atm: Release atm_dev_mutex after removing procfs in atm_dev_deregister().
    syzbot reported a warning below during atm_dev_register(). [0]
    
    Before creating a new device and procfs/sysfs for it, atm_dev_register()
    looks up a duplicated device by __atm_dev_lookup().  These operations are
    done under atm_dev_mutex.
    
    However, when removing a device in atm_dev_deregister(), it releases the
    mutex just after removing the device from the list that __atm_dev_lookup()
    iterates over.
    
    So, there will be a small race window where the device does not exist on
    the device list but procfs/sysfs are still not removed, triggering the
    splat.
    
    Let's hold the mutex until procfs/sysfs are removed in
    atm_dev_deregister().
    
    [0]:
    proc_dir_entry 'atm/atmtcp:0' already registered
    WARNING: CPU: 0 PID: 5919 at fs/proc/generic.c:377 proc_register+0x455/0x5f0 fs/proc/generic.c:377
    Modules linked in:
    CPU: 0 UID: 0 PID: 5919 Comm: syz-executor284 Not tainted 6.16.0-rc2-syzkaller-00047-g52da431bf03b #0 PREEMPT(full)
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025
    RIP: 0010:proc_register+0x455/0x5f0 fs/proc/generic.c:377
    Code: 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 a2 01 00 00 48 8b 44 24 10 48 c7 c7 20 c0 c2 8b 48 8b b0 d8 00 00 00 e8 0c 02 1c ff 90 <0f> 0b 90 90 48 c7 c7 80 f2 82 8e e8 0b de 23 09 48 8b 4c 24 28 48
    RSP: 0018:ffffc9000466fa30 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817ae248
    RDX: ffff888026280000 RSI: ffffffff817ae255 RDI: 0000000000000001
    RBP: ffff8880232bed48 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000001 R12: ffff888076ed2140
    R13: dffffc0000000000 R14: ffff888078a61340 R15: ffffed100edda444
    FS:  00007f38b3b0c6c0(0000) GS:ffff888124753000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f38b3bdf953 CR3: 0000000076d58000 CR4: 00000000003526f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <TASK>
     proc_create_data+0xbe/0x110 fs/proc/generic.c:585
     atm_proc_dev_register+0x112/0x1e0 net/atm/proc.c:361
     atm_dev_register+0x46d/0x890 net/atm/resources.c:113
     atmtcp_create+0x77/0x210 drivers/atm/atmtcp.c:369
     atmtcp_attach drivers/atm/atmtcp.c:403 [inline]
     atmtcp_ioctl+0x2f9/0xd60 drivers/atm/atmtcp.c:464
     do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
     sock_do_ioctl+0x115/0x280 net/socket.c:1190
     sock_ioctl+0x227/0x6b0 net/socket.c:1311
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:907 [inline]
     __se_sys_ioctl fs/ioctl.c:893 [inline]
     __x64_sys_ioctl+0x18b/0x210 fs/ioctl.c:893
     do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
     do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
    RIP: 0033:0x7f38b3b74459
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007f38b3b0c198 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 00007f38b3bfe318 RCX: 00007f38b3b74459
    RDX: 0000000000000000 RSI: 0000000000006180 RDI: 0000000000000005
    RBP: 00007f38b3bfe310 R08: 65732f636f72702f R09: 65732f636f72702f
    R10: 65732f636f72702f R11: 0000000000000246 R12: 00007f38b3bcb0ac
    R13: 00007f38b3b0c1a0 R14: 0000200000000200 R15: 00007f38b3bcb03b
     </TASK>
    
    Fixes: 64bf69ddff76 ("[ATM]: deregistration removes device from atm_devs list immediately")

[PATCH_DIFF]
    @@ -146,11 +146,10 @@ void atm_dev_deregister(struct atm_dev *dev)
         mutex_lock(&atm_dev_mutex);
         list_del(&dev->dev_list);
    -	  mutex_unlock(&atm_dev_mutex);
    -
         atm_dev_release_vccs(dev);
         atm_unregister_sysfs(dev);
         atm_proc_dev_deregister(dev);
    +    mutex_lock(&atm_dev_mutex);
     
         atm_dev_put(dev);

[FUNCTION_CONTENT]
void atm_dev_deregister(struct atm_dev *dev)
{
	BUG_ON(test_bit(ATM_DF_REMOVED, &dev->flags));
	set_bit(ATM_DF_REMOVED, &dev->flags);

	/*
	 * if we remove current device from atm_devs list, new device
	 * with same number can appear, such we need deregister proc,
	 * release async all vccs and remove them from vccs list too
	 */
	mutex_lock(&atm_dev_mutex);
	list_del(&dev->dev_list);
	mutex_unlock(&atm_dev_mutex);

	atm_dev_release_vccs(dev);
	atm_unregister_sysfs(dev);
	atm_proc_dev_deregister(dev);

	atm_dev_put(dev);
}

/* ----- separator ----- */

EXPORT_SYMBOL(atm_dev_register);

void atm_dev_deregister(struct atm_dev *dev)
{
	BUG_ON(test_bit(ATM_DF_REMOVED, &dev->flags));
	set_bit(ATM_DF_REMOVED, &dev->flags);

	/*
	 * if we remove current device from atm_devs list, new device
	 * with same number can appear, such we need deregister proc,
	 * release async all vccs and remove them from vccs list too
	 */
	mutex_lock(&atm_dev_mutex);
	list_del(&dev->dev_list);
	mutex_unlock(&atm_dev_mutex);

	atm_dev_release_vccs(dev);
	atm_unregister_sysfs(dev);
	atm_proc_dev_deregister(dev);

	atm_dev_put(dev);
}

/* ----- separator ----- */

	BUG_ON(test_bit(ATM_DF_REMOVED, &dev->flags));
	set_bit(ATM_DF_REMOVED, &dev->flags);

	/*
	 * if we remove current device from atm_devs list, new device
	 * with same number can appear, such we need deregister proc,
	 * release async all vccs and remove them from vccs list too
	 */
	mutex_lock(&atm_dev_mutex);
	list_del(&dev->dev_list);
	mutex_unlock(&atm_dev_mutex);

	atm_dev_release_vccs(dev);
	atm_unregister_sysfs(dev);
	atm_proc_dev_deregister(dev);

	atm_dev_put(dev);
}
EXPORT_SYMBOL(atm_dev_deregister);

static void copy_aal_stats(struct k_atm_aal_stats *from,
    struct atm_aal_stats *to)
{
#define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)
	__AAL_STAT_ITEMS
#undef __HANDLE_ITEM
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38245

2. Vulnerability Type
Race condition (improper lock coverage / TOCTOU) leading to inconsistent device state and duplicate procfs/sysfs registration.

3. Root Cause Summary
atm_dev_deregister() released atm_dev_mutex immediately after list_del(&dev->dev_list), while subsequent cleanup (atm_dev_release_vccs(), atm_unregister_sysfs(), atm_proc_dev_deregister()) ran without the lock. atm_dev_register() performs duplicate-device lookup (__atm_dev_lookup()) under atm_dev_mutex; during the race window, the device is absent from the list but its procfs/sysfs entries still exist. A concurrent registration then proceeds and attempts to create already-existing procfs entries, triggering the kernel warning. The patch closes this race by holding atm_dev_mutex until after procfs/sysfs have been removed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ATM core device management and procfs/sysfs integration (net/atm/resources.c, net/atm/proc.c).

2) Pre-Patch Flaw:
In atm_dev_deregister(), the mutex is unlocked immediately after list_del, leaving procfs/sysfs/vccs teardown outside the critical section. This creates a mismatch with atm_dev_register() which uses the same mutex to guard __atm_dev_lookup().

3) Trigger Condition:
Concurrent execution of atm_dev_deregister() and atm_dev_register() for the same device number: deregistration removes the device from the list, while registration (under the mutex) no longer sees it and proceeds to create procfs/sysfs entries that still exist because cleanup hasn’t run yet.

4) Impact Mechanism:
Duplicate procfs entry creation causes proc_register() to warn (“proc_dir_entry ... already registered”). The system enters an inconsistent state where device discovery via the list contradicts the presence of procfs/sysfs entries.

5. Patch Analysis
1) Fix Approach:
Extend the atm_dev_mutex critical section in atm_dev_deregister() to cover teardown of vccs, sysfs, and procfs entries, ensuring consistency between device list state and filesystem representations.

2) Key Code Changes:
- Removed the early mutex_unlock(&atm_dev_mutex) immediately after list_del(&dev->dev_list).
- Ensured atm_dev_release_vccs(), atm_unregister_sysfs(), and atm_proc_dev_deregister() execute while the mutex remains held.
- The mutex is released only after procfs/sysfs removal (per the patch description).

3) Locking/Concurrency Impact:
By deferring the mutex release until after procfs/sysfs deregistration, the race window is eliminated. __atm_dev_lookup() in atm_dev_register() now observes a state consistent with filesystem teardown, preventing duplicate registrations and the associated warning.

6. Broader Kernel Security Implications
Strengthening lock coverage in device lifecycle paths reduces TOCTOU races across subsystems that share global lists and create filesystem entries. This prevents invariant violations and state corruption under concurrent operations and fuzzing, improving robustness and lowering the risk of secondary bugs stemming from inconsistent procfs/sysfs states.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.