You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38245

[INFO]
[PATCH_DESCRIPTION]
    atm: Release atm_dev_mutex after removing procfs in atm_dev_deregister().
    syzbot reported a warning below during atm_dev_register(). [0]
    
    Before creating a new device and procfs/sysfs for it, atm_dev_register()
    looks up a duplicated device by __atm_dev_lookup().  These operations are
    done under atm_dev_mutex.
    
    However, when removing a device in atm_dev_deregister(), it releases the
    mutex just after removing the device from the list that __atm_dev_lookup()
    iterates over.
    
    So, there will be a small race window where the device does not exist on
    the device list but procfs/sysfs are still not removed, triggering the
    splat.
    
    Let's hold the mutex until procfs/sysfs are removed in
    atm_dev_deregister().
    
    [0]:
    proc_dir_entry 'atm/atmtcp:0' already registered
    WARNING: CPU: 0 PID: 5919 at fs/proc/generic.c:377 proc_register+0x455/0x5f0 fs/proc/generic.c:377
    Modules linked in:
    CPU: 0 UID: 0 PID: 5919 Comm: syz-executor284 Not tainted 6.16.0-rc2-syzkaller-00047-g52da431bf03b #0 PREEMPT(full)
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025
    RIP: 0010:proc_register+0x455/0x5f0 fs/proc/generic.c:377
    Code: 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 a2 01 00 00 48 8b 44 24 10 48 c7 c7 20 c0 c2 8b 48 8b b0 d8 00 00 00 e8 0c 02 1c ff 90 <0f> 0b 90 90 48 c7 c7 80 f2 82 8e e8 0b de 23 09 48 8b 4c 24 28 48
    RSP: 0018:ffffc9000466fa30 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817ae248
    RDX: ffff888026280000 RSI: ffffffff817ae255 RDI: 0000000000000001
    RBP: ffff8880232bed48 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000001 R12: ffff888076ed2140
    R13: dffffc0000000000 R14: ffff888078a61340 R15: ffffed100edda444
    FS:  00007f38b3b0c6c0(0000) GS:ffff888124753000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f38b3bdf953 CR3: 0000000076d58000 CR4: 00000000003526f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <TASK>
     proc_create_data+0xbe/0x110 fs/proc/generic.c:585
     atm_proc_dev_register+0x112/0x1e0 net/atm/proc.c:361
     atm_dev_register+0x46d/0x890 net/atm/resources.c:113
     atmtcp_create+0x77/0x210 drivers/atm/atmtcp.c:369
     atmtcp_attach drivers/atm/atmtcp.c:403 [inline]
     atmtcp_ioctl+0x2f9/0xd60 drivers/atm/atmtcp.c:464
     do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
     sock_do_ioctl+0x115/0x280 net/socket.c:1190
     sock_ioctl+0x227/0x6b0 net/socket.c:1311
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:907 [inline]
     __se_sys_ioctl fs/ioctl.c:893 [inline]
     __x64_sys_ioctl+0x18b/0x210 fs/ioctl.c:893
     do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
     do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
     entry_SYSCALL_64_after_hwframe+0x77/0x7f
    RIP: 0033:0x7f38b3b74459
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007f38b3b0c198 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 00007f38b3bfe318 RCX: 00007f38b3b74459
    RDX: 0000000000000000 RSI: 0000000000006180 RDI: 0000000000000005
    RBP: 00007f38b3bfe310 R08: 65732f636f72702f R09: 65732f636f72702f
    R10: 65732f636f72702f R11: 0000000000000246 R12: 00007f38b3bcb0ac
    R13: 00007f38b3b0c1a0 R14: 0000200000000200 R15: 00007f38b3bcb03b
     </TASK>
    
    Fixes: 64bf69ddff76 ("[ATM]: deregistration removes device from atm_devs list immediately")

[PATCH_DIFF]
    @@ -146,11 +146,10 @@ void atm_dev_deregister(struct atm_dev *dev)
         mutex_lock(&atm_dev_mutex);
         list_del(&dev->dev_list);
    -	  mutex_unlock(&atm_dev_mutex);
    -
         atm_dev_release_vccs(dev);
         atm_unregister_sysfs(dev);
         atm_proc_dev_deregister(dev);
    +    mutex_lock(&atm_dev_mutex);
     
         atm_dev_put(dev);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38245

2. Vulnerability Type
Race condition causing inconsistent device/procfs state and duplicate procfs entry registration

3. Root Cause Summary
atm_dev_deregister() released atm_dev_mutex immediately after list_del(&dev->dev_list) while procfs/sysfs for the device were still present, creating a race with atm_dev_register() which performs __atm_dev_lookup() under the same mutex and then creates procfs. This premature unlock allowed registration to see the device absent from the list and proceed to create a new procfs entry while the old entry had not yet been removed, triggering “proc_dir_entry already registered” WARN. The flaw is incorrect lock holding duration leading to non-atomic updates of related shared state (device list vs procfs/sysfs lifetime).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ATM networking subsystem (net/atm), device registration/deregistration paths involving procfs/sysfs (resources.c, proc.c)

2) Pre-Patch Flaw:
In atm_dev_deregister(), the code sequence was:
- mutex_lock(&atm_dev_mutex);
- list_del(&dev->dev_list);
- mutex_unlock(&atm_dev_mutex);
followed by atm_dev_release_vccs(dev), atm_unregister_sysfs(dev), and atm_proc_dev_deregister(dev). This unlocked the global device mutex before procfs/sysfs teardown, leaving a window where the device was absent from the list but its procfs/sysfs entries still existed.

3) Trigger Condition:
Concurrent atm_dev_register() for the same device name while atm_dev_deregister() is in progress. Registration does __atm_dev_lookup() under atm_dev_mutex and, finding no duplicate in the list due to early list_del, proceeds to create procfs entries while deregistration has not yet removed the existing procfs entries.

4) Impact Mechanism:
Duplicate procfs registration attempt triggers a WARN in proc_register (“proc_dir_entry 'atm/...' already registered”) and indicates inconsistent global state. This can lead to kernel warnings (“splat”), potential instability, and in configurations with panic_on_warn, a denial-of-service.

5. Patch Analysis
1) Fix Approach:
Hold atm_dev_mutex across the teardown of sysfs/procfs in atm_dev_deregister(), releasing the mutex only after atm_unregister_sysfs() and atm_proc_dev_deregister() complete. This makes removal of the device list entry and its procfs/sysfs entries effectively atomic with respect to concurrent registration.

2) Key Code Changes:
- Removed the immediate mutex_unlock(&atm_dev_mutex) after list_del(&dev->dev_list).
- Deferred mutex release until after:
  - atm_dev_release_vccs(dev);
  - atm_unregister_sysfs(dev);
  - atm_proc_dev_deregister(dev);
Evidence (hunk): the pre-patch unlock was removed after list_del; the description states “Release atm_dev_mutex after removing procfs/sysfs.”

3) Locking/Concurrency Impact:
By extending the critical section protected by atm_dev_mutex to include procfs/sysfs removal, the patch eliminates the race window where __atm_dev_lookup() sees the device absent while its procfs/sysfs still exist. This serializes device list updates with procfs/sysfs lifetime changes, ensuring consistent state observation by concurrent registration and preventing duplicate procfs entry creation.

6. Broader Kernel Security Implications
This fix highlights the necessity of holding global device-level locks across all related state transitions (list membership and associated filesystem artifacts) to avoid TOCTOU races. Similar patterns in other subsystems that update in-kernel registries alongside procfs/sysfs exposure must ensure atomicity under appropriate locks to prevent inconsistent states, warnings, or potential denial-of-service via panic-on-warn configurations. Consistent lifetime management reduces risk of resource duplication, stale entries, and broader integrity issues in kernel-exposed namespaces.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.