You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38274

[INFO]
[PATCH_DESCRIPTION]
    fpga: fix potential null pointer deref in fpga_mgr_test_img_load_sgt()
    fpga_mgr_test_img_load_sgt() allocates memory for sgt using
    kunit_kzalloc() however it does not check if the allocation failed.
    It then passes sgt to sg_alloc_table(), which passes it to
    __sg_alloc_table(). This function calls memset() on sgt in an attempt to
    zero it out. If the allocation fails then sgt will be NULL and the
    memset will trigger a NULL pointer dereference.
    
    Fix this by checking the allocation with KUNIT_ASSERT_NOT_ERR_OR_NULL().

[PATCH_DIFF]
    @@ -263,6 +263,7 @@ static void fpga_mgr_test_img_load_sgt(struct kunit *test)
     	img_buf = init_test_buffer(test, IMAGE_SIZE);
     
     	sgt = kunit_kzalloc(test, sizeof(*sgt), GFP_KERNEL);
    +	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt);
     	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
     	KUNIT_ASSERT_EQ(test, ret, 0);
     	sg_init_one(sgt->sgl, img_buf, IMAGE_SIZE);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38274

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation failure

3. Root Cause Summary
The function fpga_mgr_test_img_load_sgt() allocated a struct sg_table with kunit_kzalloc() but did not check for allocation failure. It then passed the possibly-NULL sgt to sg_alloc_table(), which (via __sg_alloc_table()) performs a memset() on the provided table pointer, dereferencing NULL and crashing the kernel when sgt is NULL.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
FPGA manager KUnit tests (fpga test code using scatter-gather tables)

2) Pre-Patch Flaw:
Missing validation of the kunit_kzalloc() return value for sgt; the code immediately invoked sg_alloc_table(sgt, ...) without ensuring sgt was non-NULL.

3) Trigger Condition:
Memory allocation failure in kunit_kzalloc(test, sizeof(*sgt), GFP_KERNEL), e.g., due to low memory or fault injection during test execution.

4) Impact Mechanism:
Passing NULL to sg_alloc_table() leads to __sg_alloc_table() calling memset() on a NULL pointer, causing a kernel NULL pointer dereference and test-induced kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Introduce an explicit allocation check using KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt) to abort the test when sgt allocation fails, preventing the subsequent call to sg_alloc_table() with a NULL pointer.

2) Key Code Changes:
Added one assertion immediately after allocation:
- sgt = kunit_kzalloc(test, sizeof(*sgt), GFP_KERNEL);
- KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt);
This enforces non-NULL sgt before sg_alloc_table(sgt, 1, GFP_KERNEL).

3) Locking/Concurrency Impact:
None. The change is purely an allocation check in a KUnit test; no locks or concurrency control were added or modified.

6. Broader Kernel Security Implications
Unchecked allocations in kernel code (including tests) can escalate to kernel crashes when core helpers assume valid pointers. Ensuring allocation results are validated before passing to APIs like sg_alloc_table() reduces denial-of-service risk under memory pressure or fault injection. This patch reinforces defensive programming practices in tests that run in kernel context, preventing test-induced kernel faults and improving robustness of the FPGA subsystem’s test coverage.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.