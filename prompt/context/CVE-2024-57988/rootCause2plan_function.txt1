You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57988

[INFO]
[PATCH_DESCRIPTION]
 Bluetooth: btbcm: Fix NULL deref in btbcm_get_board_name()
 [ Upstream commit b88655bc6593c6a7fdc1248b212d17e581c4334e ]
 
 devm_kstrdup() can return a NULL pointer on failure,but this
 returned value in btbcm_get_board_name() is not checked.
 Add NULL check in btbcm_get_board_name(), to handle kernel NULL
 pointer dereference error.

 Fixes: f9183eaad915 ("Bluetooth: btbcm: Use devm_kstrdup()")

[PATCH_DIFF]
 diff --git a/drivers/bluetooth/btbcm.c b/drivers/bluetooth/btbcm.c
 index a1153ada74d206…0a60660fc8ce80 100644
 --- a/drivers/bluetooth/btbcm.c
 +++ b/drivers/bluetooth/btbcm.c
 @@ -553,6 +553,9 @@ static const char *btbcm_get_board_name(struct device dev)

   /* get rid of any '/' in the compatible string /
   board_type = devm_kstrdup(dev, tmp, GFP_KERNEL);
 + if (!board_type)
 + return NULL;
 +
   strreplace(board_type, '/', '-');

   return board_type;

[FUNCTION_CONTENT]
static const char *btbcm_get_board_name(struct device *dev)
{
#ifdef CONFIG_OF
	struct device_node *root __free(device_node) = of_find_node_by_path("/");
	char *board_type;
	const char *tmp;

	if (!root)
		return NULL;

	if (of_property_read_string_index(root, "compatible", 0, &tmp))
		return NULL;

	/* get rid of any '/' in the compatible string */
	board_type = devm_kstrdup(dev, tmp, GFP_KERNEL);
	strreplace(board_type, '/', '-');

	return board_type;
#else
	return NULL;
#endif
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57988

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation failure

3. Root Cause Summary
btbcm_get_board_name() unconditionally called strreplace(board_type, '/', '-') after board_type = devm_kstrdup(dev, tmp, GFP_KERNEL) without verifying that devm_kstrdup() succeeded. On allocation failure (devm_kstrdup() returns NULL), strreplace() dereferenced a NULL pointer, causing a kernel Oops.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth subsystem, Broadcom driver (drivers/bluetooth/btbcm.c)

2) Pre-Patch Flaw:
Missing NULL check on the result of devm_kstrdup() in btbcm_get_board_name(), leading to unconditional use of the returned pointer.

3) Trigger Condition:
- CONFIG_OF enabled and a valid device tree root with a "compatible" property.
- devm_kstrdup(dev, tmp, GFP_KERNEL) fails (e.g., due to memory pressure), returning NULL.

4) Impact Mechanism:
strreplace() is invoked with a NULL pointer, immediately dereferencing NULL and causing a kernel NULL pointer dereference (Oops), resulting in a potential system crash/denial-of-service.

5. Patch Analysis
1) Fix Approach:
Add a defensive NULL check after devm_kstrdup() and return NULL early if allocation fails.

2) Key Code Changes:
- In btbcm_get_board_name():
  - After board_type = devm_kstrdup(dev, tmp, GFP_KERNEL);
  - Added:
    if (!board_type)
        return NULL;
  - This prevents calling strreplace() on a NULL pointer.

3) Locking/Concurrency Impact:
None. The change is purely a NULL-check addition; no locking or ordering semantics were modified.

6. Broader Kernel Security Implications
This fix reinforces a common kernel safety requirement: always validate results of memory allocation helpers (including devm_* variants). Without such checks, attackers or stress conditions could exploit allocation failures to trigger kernel crashes, leading to denial-of-service. Ensuring consistent NULL checks in similar code paths across drivers reduces the risk of trivial system-wide instability under memory pressure.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}