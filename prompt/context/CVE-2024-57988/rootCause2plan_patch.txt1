You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57988

[INFO]
[PATCH_DESCRIPTION]
 Bluetooth: btbcm: Fix NULL deref in btbcm_get_board_name()
 [ Upstream commit b88655bc6593c6a7fdc1248b212d17e581c4334e ]
 
 devm_kstrdup() can return a NULL pointer on failure,but this
 returned value in btbcm_get_board_name() is not checked.
 Add NULL check in btbcm_get_board_name(), to handle kernel NULL
 pointer dereference error.

 Fixes: f9183eaad915 ("Bluetooth: btbcm: Use devm_kstrdup()")

[PATCH_DIFF]
 diff --git a/drivers/bluetooth/btbcm.c b/drivers/bluetooth/btbcm.c
 index a1153ada74d206…0a60660fc8ce80 100644
 --- a/drivers/bluetooth/btbcm.c
 +++ b/drivers/bluetooth/btbcm.c
 @@ -553,6 +553,9 @@ static const char *btbcm_get_board_name(struct device dev)

   /* get rid of any '/' in the compatible string /
   board_type = devm_kstrdup(dev, tmp, GFP_KERNEL);
 + if (!board_type)
 + return NULL;
 +
   strreplace(board_type, '/', '-');

   return board_type;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57988

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation failure

3. Root Cause Summary
btbcm_get_board_name() called devm_kstrdup() and then unconditionally passed its return value to strreplace() without checking for NULL. When devm_kstrdup() failed and returned NULL, strreplace() dereferenced a NULL pointer, causing a kernel crash. This flaw was introduced when switching to devm_kstrdup() (Fixes: f9183eaad915).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Bluetooth subsystem, Broadcom driver (drivers/bluetooth/btbcm.c)

2) Pre-Patch Flaw:
- Missing NULL check after allocation:
  - Code path: btbcm_get_board_name()
  - Pre-patch sequence: "board_type = devm_kstrdup(dev, tmp, GFP_KERNEL);" followed immediately by "strreplace(board_type, '/', '-');" with no NULL validation.

3) Trigger Condition:
- devm_kstrdup(dev, tmp, GFP_KERNEL) returns NULL (e.g., under memory pressure or allocation failure), and btbcm_get_board_name() proceeds to call strreplace() on the NULL pointer.

4) Impact Mechanism:
- strreplace() dereferences the NULL board_type pointer, leading to a kernel NULL pointer dereference (OOPS/panic), resulting in denial of service.

5. Patch Analysis
1) Fix Approach:
- Introduced early NULL return check after devm_kstrdup() to prevent passing a NULL pointer to strreplace().

2) Key Code Changes:
- In btbcm_get_board_name():
  - Added:
    - "if (!board_type) return NULL;"
  - This directly guards the subsequent strreplace(board_type, '/', '-') call.

3) Locking/Concurrency Impact:
- None. The change is limited to error handling for allocation failure and does not modify locking or concurrency behavior.

6. Broader Kernel Security Implications
- Emphasizes the necessity of checking the return value of allocation helpers (including devm_* variants) across drivers to prevent kernel crashes. Similar unchecked devm_kstrdup() patterns elsewhere could lead to system-wide DoS. Strengthening allocation failure handling improves kernel robustness, especially under memory pressure scenarios.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}