You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38292

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: fix invalid access to memory
    In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean
    is_continuation is part of rxcb.
    Currently, after freeing the skb, the rxcb->is_continuation accessed
    again which is wrong since the memory is already freed.
    This might lead use-after-free error.
    
    Hence, fix by locally defining bool is_continuation from rxcb,
    so that after freeing skb, is_continuation can be used.
    
    Compile tested only.

[PATCH_DIFF]
    @@ -1841,6 +1841,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	struct hal_rx_desc *ldesc;
     	int space_extra, rem_len, buf_len;
     	u32 hal_rx_desc_sz = ar->ab->hal.hal_desc_sz;
    +	bool is_continuation;
     
     	/* As the msdu is spread across multiple rx buffers,
     	 * find the offset to the start of msdu for computing
    @@ -1889,7 +1890,8 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	rem_len = msdu_len - buf_first_len;
     	while ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {
     		rxcb = ATH12K_SKB_RXCB(skb);
    -		if (rxcb->is_continuation)
    +		is_continuation = rxcb->is_continuation;
    +		if (is_continuation)
     			buf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;
     		else
     			buf_len = rem_len;
    @@ -1907,7 +1909,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     		dev_kfree_skb_any(skb);
     
     		rem_len -= buf_len;
    -		if (!rxcb->is_continuation)
    +		if (!is_continuation)
     			break;
     	}

[FUNCTION_CONTENT]
static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
				      struct sk_buff_head *msdu_list,
				      struct sk_buff *first, struct sk_buff *last,
				      u8 l3pad_bytes, int msdu_len)
{
	struct ath12k_base *ab = ar->ab;
	struct sk_buff *skb;
	struct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(first);
	int buf_first_hdr_len, buf_first_len;
	struct hal_rx_desc *ldesc;
	int space_extra, rem_len, buf_len;
	u32 hal_rx_desc_sz = ar->ab->hal.hal_desc_sz;

	/* As the msdu is spread across multiple rx buffers,
	 * find the offset to the start of msdu for computing
	 * the length of the msdu in the first buffer.
	 */
	buf_first_hdr_len = hal_rx_desc_sz + l3pad_bytes;
	buf_first_len = DP_RX_BUFFER_SIZE - buf_first_hdr_len;

	if (WARN_ON_ONCE(msdu_len <= buf_first_len)) {
		skb_put(first, buf_first_hdr_len + msdu_len);
		skb_pull(first, buf_first_hdr_len);
		return 0;
	}

	ldesc = (struct hal_rx_desc *)last->data;
	rxcb->is_first_msdu = ath12k_dp_rx_h_first_msdu(ab, ldesc);
	rxcb->is_last_msdu = ath12k_dp_rx_h_last_msdu(ab, ldesc);

	/* MSDU spans over multiple buffers because the length of the MSDU
	 * exceeds DP_RX_BUFFER_SIZE - HAL_RX_DESC_SIZE. So assume the data
	 * in the first buf is of length DP_RX_BUFFER_SIZE - HAL_RX_DESC_SIZE.
	 */
	skb_put(first, DP_RX_BUFFER_SIZE);
	skb_pull(first, buf_first_hdr_len);

	/* When an MSDU spread over multiple buffers MSDU_END
	 * tlvs are valid only in the last buffer. Copy those tlvs.
	 */
	ath12k_dp_rx_desc_end_tlv_copy(ab, rxcb->rx_desc, ldesc);

	space_extra = msdu_len - (buf_first_len + skb_tailroom(first));
	if (space_extra > 0 &&
	    (pskb_expand_head(first, 0, space_extra, GFP_ATOMIC) < 0)) {
		/* Free up all buffers of the MSDU */
		while ((skb = __skb_dequeue(msdu_list)) != NULL) {
			rxcb = ATH12K_SKB_RXCB(skb);
			if (!rxcb->is_continuation) {
				dev_kfree_skb_any(skb);
				break;
			}
			dev_kfree_skb_any(skb);
		}
		return -ENOMEM;
	}

	rem_len = msdu_len - buf_first_len;
	while ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {
		rxcb = ATH12K_SKB_RXCB(skb);
		if (rxcb->is_continuation)
			buf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;
		else
			buf_len = rem_len;

		if (buf_len > (DP_RX_BUFFER_SIZE - hal_rx_desc_sz)) {
			WARN_ON_ONCE(1);
			dev_kfree_skb_any(skb);
			return -EINVAL;
		}

		skb_put(skb, buf_len + hal_rx_desc_sz);
		skb_pull(skb, hal_rx_desc_sz);
		skb_copy_from_linear_data(skb, skb_put(first, buf_len),
					  buf_len);
		dev_kfree_skb_any(skb);

		rem_len -= buf_len;
		if (!rxcb->is_continuation)
			break;
	}

	return 0;
}

/* ----- separator ----- */

			WARN_ON_ONCE(1);
			dev_kfree_skb_any(skb);
			return -EINVAL;
		}

		skb_put(skb, buf_len + hal_rx_desc_sz);
		skb_pull(skb, hal_rx_desc_sz);
		skb_copy_from_linear_data(skb, skb_put(first, buf_len),
					  buf_len);
		dev_kfree_skb_any(skb);

		rem_len -= buf_len;
		if (!rxcb->is_continuation)
			break;
	}

	return 0;
}

static struct sk_buff *ath12k_dp_rx_get_msdu_last_buf(struct sk_buff_head *msdu_list,
						      struct sk_buff *first)
{
	struct sk_buff *skb;
	struct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(first);

	if (!rxcb->is_continuation)
		return first;

	skb_queue_walk(msdu_list, skb) {
		rxcb = ATH12K_SKB_RXCB(skb);
		if (!rxcb->is_continuation)
			return skb;
	}

	return NULL;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-after-free (UAF) due to accessing freed sk_buff control block (skb->cb)

3. Root Cause Summary
In ath12k_dp_rx_msdu_coalesce(), the code reads rxcb->is_continuation after calling dev_kfree_skb_any(skb) within the per-buffer processing loop. Since rxcb is derived from ATH12K_SKB_RXCB(skb), accessing rxcb after freeing skb dereferences memory that has already been returned to the allocator, causing a use-after-free. The patch caches is_continuation in a local variable before freeing skb and uses that cached value afterward, eliminating the UAF.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath12k Wi-Fi driver, RX datapath coalescing

2) Pre-Patch Flaw:
Within ath12k_dp_rx_msdu_coalesce(), the loop processing chained RX buffers frees skb and then immediately evaluates “if (!rxcb->is_continuation) break;”. Because rxcb comes from ATH12K_SKB_RXCB(skb), this reads from freed memory (skb->cb). Example pre-patch line: “if (!rxcb->is_continuation)”.

3) Trigger Condition:
When an MSDU spans multiple RX buffers (rem_len > 0 and msdu_list has entries), the function dequeues a buffer, computes buf_len, copies data, calls dev_kfree_skb_any(skb), and then checks rxcb->is_continuation to decide whether to continue or break. This check after free triggers the UAF.

4) Impact Mechanism:
Dereferencing rxcb (stored in the freed sk_buff) may access invalid or reallocated memory, leading to UAF read, potential memory corruption, unpredictable control flow (incorrect loop termination), and possible kernel crash or sanitizer violations.

5. Patch Analysis
1) Fix Approach:
Avoid accessing fields of rxcb after the skb is freed by caching rxcb->is_continuation in a local variable prior to dev_kfree_skb_any(skb) and using that cached value for subsequent logic.

2) Key Code Changes:
- Introduced a local variable: “bool is_continuation;”.
- Before freeing skb, assigned: “is_continuation = rxcb->is_continuation;”.
- Replaced post-free checks from “if (!rxcb->is_continuation)” to “if (!is_continuation)”.
- Also replaced the pre-free conditional branch from “if (rxcb->is_continuation)” to “if (is_continuation)” to consistently use the cached value.
These changes are localized to ath12k_dp_rx_msdu_coalesce() at the loop starting near line ~1889 in the diff.

3) Locking/Concurrency Impact:
No locking changes. The fix removes a UAF by ensuring the loop’s continuation decision does not read from freed memory; it neither adds nor modifies locks or ordering.

6. Broader Kernel Security Implications
This correction eliminates a common class of memory safety bugs in drivers (UAF on skb->cb) that can lead to crashes or potential exploitation when attacker-controlled inputs (RX frames) influence buffer chaining. Ensuring fields needed after freeing are captured before kfree improves robustness of network RX paths and reduces risk of hard-to-diagnose runtime faults under stress or malicious traffic.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}