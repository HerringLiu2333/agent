You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38292

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: fix invalid access to memory
    In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean
    is_continuation is part of rxcb.
    Currently, after freeing the skb, the rxcb->is_continuation accessed
    again which is wrong since the memory is already freed.
    This might lead use-after-free error.
    
    Hence, fix by locally defining bool is_continuation from rxcb,
    so that after freeing skb, is_continuation can be used.
    
    Compile tested only.

[PATCH_DIFF]
    @@ -1841,6 +1841,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	struct hal_rx_desc *ldesc;
     	int space_extra, rem_len, buf_len;
     	u32 hal_rx_desc_sz = ar->ab->hal.hal_desc_sz;
    +	bool is_continuation;
     
     	/* As the msdu is spread across multiple rx buffers,
     	 * find the offset to the start of msdu for computing
    @@ -1889,7 +1890,8 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	rem_len = msdu_len - buf_first_len;
     	while ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {
     		rxcb = ATH12K_SKB_RXCB(skb);
    -		if (rxcb->is_continuation)
    +		is_continuation = rxcb->is_continuation;
    +		if (is_continuation)
     			buf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;
     		else
     			buf_len = rem_len;
    @@ -1907,7 +1909,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     		dev_kfree_skb_any(skb);
     
     		rem_len -= buf_len;
    -		if (!rxcb->is_continuation)
    +		if (!is_continuation)
     			break;
     	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-after-free (UAF)

3. Root Cause Summary
The receive coalescing routine ath12k_dp_rx_msdu_coalesce() caches a pointer to the SKB RX control block (rxcb) and then accesses rxcb->is_continuation after the SKB has been freed with dev_kfree_skb_any(skb). Because ATH12K_SKB_RXCB(skb) refers to memory owned by the freed SKB, dereferencing rxcb post-free is a UAF. The root cause is a lifetime/ordering bug: necessary state (is_continuation) was not captured before freeing the underlying SKB, leading to use of invalid memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver ath12k, data path RX handling (MSDU coalescing).

2) Pre-Patch Flaw:
- In the while-loop processing msdu_list, code does:
  - rxcb = ATH12K_SKB_RXCB(skb);
  - dev_kfree_skb_any(skb);
  - if (!rxcb->is_continuation) break;
- The check “if (!rxcb->is_continuation)” occurs after the SKB is freed, causing rxcb to reference freed memory.

3) Trigger Condition:
- When receiving an MSDU split across multiple RX buffers (rem_len > 0) and the loop dequeues SKBs from msdu_list, the code reaches the post-free check of rxcb->is_continuation. Any path that processes at least one SKB and proceeds to the break decision will trigger the UAF.

4) Impact Mechanism:
- Reading rxcb->is_continuation after dev_kfree_skb_any(skb) is a read from freed memory. This can lead to kernel memory corruption symptoms, including incorrect control flow decisions, crashes, or potential exploitation if the freed memory is reallocated and manipulated.

5. Patch Analysis
1) Fix Approach:
- Capture the continuation flag into a local variable before freeing the SKB, and use that local copy afterward. This eliminates post-free dereferences of the SKB’s control block.

2) Key Code Changes:
- Added local variable: “bool is_continuation;”
- Before freeing, assigned: “is_continuation = rxcb->is_continuation;”
- Replaced both uses of “rxcb->is_continuation” with “is_continuation”, including the post-free break condition.
- Evidence in diff:
  - “dev_kfree_skb_any(skb);”
  - Previously: “if (!rxcb->is_continuation)”
  - Now: “if (!is_continuation)”

3) Locking/Concurrency Impact:
- No locking changes. The fix is purely about variable lifetime; it avoids accessing freed memory without altering synchronization or ordering beyond capturing the flag prior to free.

6. Broader Kernel Security Implications
- UAF in a hot RX path of a wireless driver can be remotely triggerable by crafted network traffic, potentially leading to kernel crashes or controlled memory reads. While this patch prevents the immediate UAF, similar lifetime issues in SKB handling are common sources of kernel vulnerabilities; auditing other post-free accesses and ensuring state is captured before free is critical for robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}