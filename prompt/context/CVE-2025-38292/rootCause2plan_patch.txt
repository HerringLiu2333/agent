You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38292

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: fix invalid access to memory
    In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean
    is_continuation is part of rxcb.
    Currently, after freeing the skb, the rxcb->is_continuation accessed
    again which is wrong since the memory is already freed.
    This might lead use-after-free error.
    
    Hence, fix by locally defining bool is_continuation from rxcb,
    so that after freeing skb, is_continuation can be used.
    
    Compile tested only.

[PATCH_DIFF]
    @@ -1841,6 +1841,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	struct hal_rx_desc *ldesc;
     	int space_extra, rem_len, buf_len;
     	u32 hal_rx_desc_sz = ar->ab->hal.hal_desc_sz;
    +	bool is_continuation;
     
     	/* As the msdu is spread across multiple rx buffers,
     	 * find the offset to the start of msdu for computing
    @@ -1889,7 +1890,8 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     	rem_len = msdu_len - buf_first_len;
     	while ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {
     		rxcb = ATH12K_SKB_RXCB(skb);
    -		if (rxcb->is_continuation)
    +		is_continuation = rxcb->is_continuation;
    +		if (is_continuation)
     			buf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;
     		else
     			buf_len = rem_len;
    @@ -1907,7 +1909,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
     		dev_kfree_skb_any(skb);
     
     		rem_len -= buf_len;
    -		if (!rxcb->is_continuation)
    +		if (!is_continuation)
     			break;
     	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38292

2. Vulnerability Type
Use-after-free (UAF)

3. Root Cause Summary
The receive coalescing routine ath12k_dp_rx_msdu_coalesce() caches a pointer to the SKB RX control block (rxcb) and then accesses rxcb->is_continuation after the SKB has been freed with dev_kfree_skb_any(skb). Because ATH12K_SKB_RXCB(skb) refers to memory owned by the freed SKB, dereferencing rxcb post-free is a UAF. The root cause is a lifetime/ordering bug: necessary state (is_continuation) was not captured before freeing the underlying SKB, leading to use of invalid memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver ath12k, data path RX handling (MSDU coalescing).

2) Pre-Patch Flaw:
- In the while-loop processing msdu_list, code does:
  - rxcb = ATH12K_SKB_RXCB(skb);
  - dev_kfree_skb_any(skb);
  - if (!rxcb->is_continuation) break;
- The check “if (!rxcb->is_continuation)” occurs after the SKB is freed, causing rxcb to reference freed memory.

3) Trigger Condition:
- When receiving an MSDU split across multiple RX buffers (rem_len > 0) and the loop dequeues SKBs from msdu_list, the code reaches the post-free check of rxcb->is_continuation. Any path that processes at least one SKB and proceeds to the break decision will trigger the UAF.

4) Impact Mechanism:
- Reading rxcb->is_continuation after dev_kfree_skb_any(skb) is a read from freed memory. This can lead to kernel memory corruption symptoms, including incorrect control flow decisions, crashes, or potential exploitation if the freed memory is reallocated and manipulated.

5. Patch Analysis
1) Fix Approach:
- Capture the continuation flag into a local variable before freeing the SKB, and use that local copy afterward. This eliminates post-free dereferences of the SKB’s control block.

2) Key Code Changes:
- Added local variable: “bool is_continuation;”
- Before freeing, assigned: “is_continuation = rxcb->is_continuation;”
- Replaced both uses of “rxcb->is_continuation” with “is_continuation”, including the post-free break condition.
- Evidence in diff:
  - “dev_kfree_skb_any(skb);”
  - Previously: “if (!rxcb->is_continuation)”
  - Now: “if (!is_continuation)”

3) Locking/Concurrency Impact:
- No locking changes. The fix is purely about variable lifetime; it avoids accessing freed memory without altering synchronization or ordering beyond capturing the flag prior to free.

6. Broader Kernel Security Implications
- UAF in a hot RX path of a wireless driver can be remotely triggerable by crafted network traffic, potentially leading to kernel crashes or controlled memory reads. While this patch prevents the immediate UAF, similar lifetime issues in SKB handling are common sources of kernel vulnerabilities; auditing other post-free accesses and ensuring state is captured before free is critical for robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.