You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57944

[INFO]
[PATCH_DESCRIPTION]
 iio: adc: ti-ads1298: Add NULL check in ads1298_init
 devm_kasprintf() can return a NULL pointer on failure. A check on the
 return value of such a call in ads1298_init() is missing. Add it.

 Fixes: 00ef7708fa60 ("iio: adc: ti-ads1298: Add driver")

[PATCH_DIFF]
 diff --git a/drivers/iio/adc/ti-ads1298.c b/drivers/iio/adc/ti-ads1298.c
 index 36d43495f603a7…03f762415fa5c3 100644
 --- a/drivers/iio/adc/ti-ads1298.c
 +++ b/drivers/iio/adc/ti-ads1298.c
 @@ -613,6 +613,8 @@ static int ads1298_init(struct iio_dev indio_dev)
 }
   indio_dev->name = devm_kasprintf(dev, GFP_KERNEL, "ads129%u%s",
   indio_dev->num_channels, suffix);
 + if (!indio_dev->name)
 +   return -ENOMEM;
 
   /* Enable internal test signal, double amplitude, double frequency /
   ret = regmap_write(priv->regmap, ADS1298_REG_CONFIG2,



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57944

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation failure (memory allocation error handling bug), leading to potential kernel crash/DoS.

3. Root Cause Summary
The ads1298_init() function in drivers/iio/adc/ti-ads1298.c assigned indio_dev->name using devm_kasprintf() but failed to validate the return value. devm_kasprintf() can return NULL on allocation failure, and the code proceeded as if the allocation succeeded. Subsequent use of indio_dev->name could dereference a NULL pointer. The patch adds a NULL check and returns -ENOMEM on failure, correcting the missing validation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Industrial I/O (IIO) subsystem, ADC driver: ti-ads1298.

2) Pre-Patch Flaw:
- In ads1298_init(), the line “indio_dev->name = devm_kasprintf(dev, GFP_KERNEL, "ads129%u%s", indio_dev->num_channels, suffix);” lacks a check for NULL return. This omission allows execution to continue with indio_dev->name potentially being NULL.

3) Trigger Condition:
- Memory allocation failure during devm_kasprintf() (e.g., under memory pressure) while initializing the ADS1298 device via ads1298_init().

4) Impact Mechanism:
- Subsequent code paths that use indio_dev->name (e.g., device registration or IIO core interactions) may dereference a NULL pointer, causing a kernel NULL pointer dereference and resulting in a denial-of-service (system crash).

5. Patch Analysis
1) Fix Approach:
- Defensive programming: add an explicit NULL check after devm_kasprintf() and return a standard error (-ENOMEM) if allocation fails.

2) Key Code Changes:
- In ads1298_init():
  - Added:
    - if (!indio_dev->name)
      return -ENOMEM;
  - This ensures the function aborts with an error before any use of a NULL indio_dev->name.

3) Locking/Concurrency Impact:
- No locking or concurrency changes. The fix strictly adds error handling for allocation failure and does not alter synchronization, ordering, or lifetime semantics.

6. Broader Kernel Security Implications
- Properly handling allocator failure reduces kernel crash surfaces that could be triggered under low-memory conditions, improving system robustness. Although exploitation for privilege escalation is unlikely, preventing NULL dereferences is important for stability, especially during device initialization paths. The change aligns with standard kernel error-handling patterns, ensuring consistent propagation of -ENOMEM and avoiding undefined behavior from NULL pointer use.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}