You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38341

[INFO]
[PATCH_DESCRIPTION]
    eth: fbnic: avoid double free when failing to DMA-map FW msg
    The semantics are that caller of fbnic_mbx_map_msg() retains
    the ownership of the message on error. All existing callers
    dutifully free the page.

[PATCH_DIFF]
    @@ -127,11 +127,8 @@ static int fbnic_mbx_map_msg(struct fbnic_dev *fbd, int mbx_idx,
     		return -EBUSY;
     
     	addr = dma_map_single(fbd->dev, msg, PAGE_SIZE, direction);
    -	if (dma_mapping_error(fbd->dev, addr)) {
    -		free_page((unsigned long)msg);
    -
    +	if (dma_mapping_error(fbd->dev, addr))
     		return -ENOSPC;
    -	}
     
     	mbx->buf_info[tail].msg = msg;
     	mbx->buf_info[tail].addr = addr;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38341

2. Vulnerability Type
Double free (memory management/ownership violation)

3. Root Cause Summary
fbnic_mbx_map_msg() incorrectly freed the message buffer when dma_map_single() failed, despite the API’s documented semantics that the caller retains ownership of the message on error. This led to a double free because all existing callers already free the page on error. The erroneous free occurred in the dma_mapping_error() branch, violating the ownership contract and corrupting allocator state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking (eth), fbnic driver mailbox/FW message DMA mapping

2) Pre-Patch Flaw:
In fbnic_mbx_map_msg(), the error path after dma_mapping_error() invoked free_page((unsigned long)msg) even though the function should not free caller-owned memory on failure. This contradicted the stated semantics and the behavior of existing callers.

3) Trigger Condition:
DMA mapping failure for the firmware message buffer (dma_mapping_error(fbd->dev, addr) returns true), e.g., due to IOMMU/PCI DMA resource exhaustion or other mapping errors.

4) Impact Mechanism:
The buffer is freed twice: once by fbnic_mbx_map_msg() and again by the caller handling the error, causing page allocator metadata corruption. This can result in kernel crashes, memory corruption, or subsequent misuse of allocator state.

5. Patch Analysis
1) Fix Approach:
Align error handling with ownership semantics by removing the free_page() in the mapping error path so the caller exclusively handles cleanup on failure.

2) Key Code Changes:
- In fbnic_mbx_map_msg():
  - Removed the free_page((unsigned long)msg) call inside the dma_mapping_error() block.
  - Simplified the error branch to just return -ENOSPC when dma_mapping_error() is detected.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix solely adjusts memory ownership in the error path. No changes to synchronization, ordering, or atomicity.

6. Broader Kernel Security Implications
Adhering to clear ownership semantics in driver error paths is critical to prevent double frees and allocator corruption in the kernel. Similar mailbox/DMA mapping routines across drivers should be audited for consistent error handling and cleanup responsibilities. Ensuring callee/caller contracts are respected reduces risks of subtle memory safety bugs that can lead to denial-of-service or facilitate exploitation.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.