You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38341

[INFO]
[PATCH_DESCRIPTION]
    eth: fbnic: avoid double free when failing to DMA-map FW msg
    The semantics are that caller of fbnic_mbx_map_msg() retains
    the ownership of the message on error. All existing callers
    dutifully free the page.

[PATCH_DIFF]
    @@ -127,11 +127,8 @@ static int fbnic_mbx_map_msg(struct fbnic_dev *fbd, int mbx_idx,
     		return -EBUSY;
     
     	addr = dma_map_single(fbd->dev, msg, PAGE_SIZE, direction);
    -	if (dma_mapping_error(fbd->dev, addr)) {
    -		free_page((unsigned long)msg);
    -
    +	if (dma_mapping_error(fbd->dev, addr))
     		return -ENOSPC;
    -	}
     
     	mbx->buf_info[tail].msg = msg;
     	mbx->buf_info[tail].addr = addr;

[FUNCTION_CONTENT]
static int fbnic_mbx_map_msg(struct fbnic_dev *fbd, int mbx_idx,
			     struct fbnic_tlv_msg *msg, u16 length, u8 eom)
{
	struct fbnic_fw_mbx *mbx = &fbd->mbx[mbx_idx];
	u8 tail = mbx->tail;
	dma_addr_t addr;
	int direction;

	if (!mbx->ready || !fbnic_fw_present(fbd))
		return -ENODEV;

	direction = (mbx_idx == FBNIC_IPC_MBX_RX_IDX) ? DMA_FROM_DEVICE :
							DMA_TO_DEVICE;

	if (mbx->head == ((tail + 1) % FBNIC_IPC_MBX_DESC_LEN))
		return -EBUSY;

	addr = dma_map_single(fbd->dev, msg, PAGE_SIZE, direction);
	if (dma_mapping_error(fbd->dev, addr)) {
		free_page((unsigned long)msg);

		return -ENOSPC;
	}

	mbx->buf_info[tail].msg = msg;
	mbx->buf_info[tail].addr = addr;

	mbx->tail = (tail + 1) % FBNIC_IPC_MBX_DESC_LEN;

	fw_wr32(fbd, FBNIC_IPC_MBX(mbx_idx, mbx->tail), 0);

	__fbnic_mbx_wr_desc(fbd, mbx_idx, tail,
			    FIELD_PREP(FBNIC_IPC_MBX_DESC_LEN_MASK, length) |
			    (addr & FBNIC_IPC_MBX_DESC_ADDR_MASK) |
			    (eom ? FBNIC_IPC_MBX_DESC_EOM : 0) |
			    FBNIC_IPC_MBX_DESC_HOST_CMPL);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38341

2. Vulnerability Type
Double free (memory management / ownership violation), potentially leading to memory corruption

3. Root Cause Summary
The function fbnic_mbx_map_msg() erroneously frees the message page on the DMA mapping error path, despite the API semantics that the caller retains ownership and will free the page on error. Specifically, when dma_mapping_error(fbd->dev, addr) is true, the function executed free_page((unsigned long)msg) and then returned an error. Because all callers already free the page on error, this results in a double free of the same page.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking subsystem, fbnic Ethernet driver firmware mailbox messaging (fbnic_mbx_map_msg)

2) Pre-Patch Flaw:
In fbnic_mbx_map_msg(), the error handling after dma_map_single() violates ownership contracts by freeing the msg page in the callee. The pre-patch code included: "free_page((unsigned long)msg);" inside the dma_mapping_error() branch, while still returning -ENOSPC for the caller to handle.

3) Trigger Condition:
When dma_map_single(fbd->dev, msg, PAGE_SIZE, direction) fails and dma_mapping_error(fbd->dev, addr) is true, and the caller (as per driver-wide semantics) subsequently frees the same msg on receiving the error.

4) Impact Mechanism:
The page backing msg is freed twice, corrupting the page allocator’s metadata and potentially leading to memory corruption, kernel crashes, or use-after-free scenarios if the freed memory is reused.

5. Patch Analysis
1) Fix Approach:
Align error handling with the intended ownership semantics by removing the free_page() call in the callee, ensuring only the caller frees the page on error.

2) Key Code Changes:
In fbnic_mbx_map_msg(), the dma_mapping_error() block was changed from:
- if (dma_mapping_error(fbd->dev, addr)) { free_page((unsigned long)msg); return -ENOSPC; }
to:
- if (dma_mapping_error(fbd->dev, addr)) return -ENOSPC;
This removes the premature free and preserves caller ownership.

3) Locking/Concurrency Impact:
No locking or concurrency logic was changed; the patch strictly modifies error-path memory ownership handling. No changes to mbx->buf_info population occur on error, maintaining existing ordering and state.

6. Broader Kernel Security Implications
Correcting the ownership violation prevents allocator corruption from double free, reducing risks of kernel instability and potential exploitation vectors associated with memory corruption. It strengthens error-path robustness in DMA mapping operations within network drivers and enforces consistent API contracts, which is crucial for maintaining safe memory management across subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.