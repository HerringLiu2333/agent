You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38255

[INFO]
[PATCH_DESCRIPTION]
    lib/group_cpus: fix NULL pointer dereference from group_cpus_evenly()
    While testing null_blk with configfs, echo 0 > poll_queues will trigger
    following panic:
    
    BUG: kernel NULL pointer dereference, address: 0000000000000010
    Oops: Oops: 0000 [#1] SMP NOPTI
    CPU: 27 UID: 0 PID: 920 Comm: bash Not tainted 6.15.0-02023-gadbdb95c8696-dirty #1238 PREEMPT(undef)
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014
    RIP: 0010:__bitmap_or+0x48/0x70
    Call Trace:
     <TASK>
     __group_cpus_evenly+0x822/0x8c0
     group_cpus_evenly+0x2d9/0x490
     blk_mq_map_queues+0x1e/0x110
     null_map_queues+0xc9/0x170 [null_blk]
     blk_mq_update_queue_map+0xdb/0x160
     blk_mq_update_nr_hw_queues+0x22b/0x560
     nullb_update_nr_hw_queues+0x71/0xf0 [null_blk]
     nullb_device_poll_queues_store+0xa4/0x130 [null_blk]
     configfs_write_iter+0x109/0x1d0
     vfs_write+0x26e/0x6f0
     ksys_write+0x79/0x180
     __x64_sys_write+0x1d/0x30
     x64_sys_call+0x45c4/0x45f0
     do_syscall_64+0xa5/0x240
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    Root cause is that numgrps is set to 0, and ZERO_SIZE_PTR is returned from
    kcalloc(), and later ZERO_SIZE_PTR will be deferenced.
    
    Fix the problem by checking numgrps first in group_cpus_evenly(), and
    return NULL directly if numgrps is zero.

[PATCH_DIFF]
    @@ -352,6 +352,9 @@ struct cpumask *group_cpus_evenly(unsigned int numgrps)
     	int ret = -ENOMEM;
     	struct cpumask *masks = NULL;
     
     +	if (numgrps == 0)
     +		return NULL;
     +
     	if (!zalloc_cpumask_var(&nmsk, GFP_KERNEL))
     		return NULL;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38255

2. Vulnerability Type
NULL/invalid pointer dereference caused by zero-size allocation (ZERO_SIZE_PTR misuse), leading to kernel denial of service.

3. Root Cause Summary
group_cpus_evenly() did not validate its numgrps argument and proceeded when numgrps == 0. This led to kcalloc() being invoked with a zero count, returning ZERO_SIZE_PTR rather than NULL. The function then treated this non-NULL sentinel as a valid pointer and later dereferenced it (e.g., via bitmap operations), causing a kernel Oops.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
lib/ group_cpus (cpumask grouping utilities), indirectly used by the block layer (blk-mq) and drivers like null_blk.

2) Pre-Patch Flaw:
- In group_cpus_evenly(unsigned int numgrps), there was no early check for numgrps == 0.
- The code path allocated arrays based on numgrps; with zero, kcalloc() returned ZERO_SIZE_PTR, which was subsequently dereferenced.

3) Trigger Condition:
- Passing numgrps == 0 to group_cpus_evenly(), e.g., via null_blk when writing “0” to poll_queues in configfs, which propagates to blk_mq_update_nr_hw_queues() -> blk_mq_map_queues() -> group_cpus_evenly().

4) Impact Mechanism:
- ZERO_SIZE_PTR (0x10) from kcalloc(…, 0, …) is treated as a valid pointer.
- Subsequent operations like __bitmap_or within __group_cpus_evenly() dereference this pointer, causing a NULL/invalid pointer dereference and kernel panic (DoS).

5. Patch Analysis
1) Fix Approach:
Introduce an early return in group_cpus_evenly() to reject numgrps == 0, avoiding zero-sized allocations and subsequent invalid pointer dereferences.

2) Key Code Changes:
- In group_cpus_evenly():
  - Added:
    - if (numgrps == 0)
    -     return NULL;
- This check precedes allocations such as zalloc_cpumask_var(&nmsk, GFP_KERNEL), preventing the ZERO_SIZE_PTR condition entirely.

3) Locking/Concurrency Impact:
None. The change is a simple argument validation and early return; no locking, ordering, or concurrency semantics were modified.

6. Broader Kernel Security Implications
- Prevents a straightforward denial-of-service path where user-configurable parameters (e.g., via configfs) can induce a kernel panic.
- Ensures safer handling of zero-dimensional configurations across subsystems relying on CPU mask grouping.
- Highlights the need for explicit zero-argument validation in utility functions that allocate arrays based on caller-provided sizes to avoid ZERO_SIZE_PTR misuse.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.