You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38255

[INFO]
[PATCH_DESCRIPTION]
    lib/group_cpus: fix NULL pointer dereference from group_cpus_evenly()
    While testing null_blk with configfs, echo 0 > poll_queues will trigger
    following panic:
    
    BUG: kernel NULL pointer dereference, address: 0000000000000010
    Oops: Oops: 0000 [#1] SMP NOPTI
    CPU: 27 UID: 0 PID: 920 Comm: bash Not tainted 6.15.0-02023-gadbdb95c8696-dirty #1238 PREEMPT(undef)
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014
    RIP: 0010:__bitmap_or+0x48/0x70
    Call Trace:
     <TASK>
     __group_cpus_evenly+0x822/0x8c0
     group_cpus_evenly+0x2d9/0x490
     blk_mq_map_queues+0x1e/0x110
     null_map_queues+0xc9/0x170 [null_blk]
     blk_mq_update_queue_map+0xdb/0x160
     blk_mq_update_nr_hw_queues+0x22b/0x560
     nullb_update_nr_hw_queues+0x71/0xf0 [null_blk]
     nullb_device_poll_queues_store+0xa4/0x130 [null_blk]
     configfs_write_iter+0x109/0x1d0
     vfs_write+0x26e/0x6f0
     ksys_write+0x79/0x180
     __x64_sys_write+0x1d/0x30
     x64_sys_call+0x45c4/0x45f0
     do_syscall_64+0xa5/0x240
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    Root cause is that numgrps is set to 0, and ZERO_SIZE_PTR is returned from
    kcalloc(), and later ZERO_SIZE_PTR will be deferenced.
    
    Fix the problem by checking numgrps first in group_cpus_evenly(), and
    return NULL directly if numgrps is zero.

[PATCH_DIFF]
    @@ -352,6 +352,9 @@ struct cpumask *group_cpus_evenly(unsigned int numgrps)
     	int ret = -ENOMEM;
     	struct cpumask *masks = NULL;
     
     +	if (numgrps == 0)
     +		return NULL;
     +
     	if (!zalloc_cpumask_var(&nmsk, GFP_KERNEL))
     		return NULL;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38255

2. Vulnerability Type
NULL/invalid pointer dereference caused by zero-size allocation (ZERO_SIZE_PTR misuse), leading to kernel denial of service.

3. Root Cause Summary
group_cpus_evenly() did not validate its numgrps argument and proceeded when numgrps == 0. This led to kcalloc() being invoked with a zero count, returning ZERO_SIZE_PTR rather than NULL. The function then treated this non-NULL sentinel as a valid pointer and later dereferenced it (e.g., via bitmap operations), causing a kernel Oops.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
lib/ group_cpus (cpumask grouping utilities), indirectly used by the block layer (blk-mq) and drivers like null_blk.

2) Pre-Patch Flaw:
- In group_cpus_evenly(unsigned int numgrps), there was no early check for numgrps == 0.
- The code path allocated arrays based on numgrps; with zero, kcalloc() returned ZERO_SIZE_PTR, which was subsequently dereferenced.

3) Trigger Condition:
- Passing numgrps == 0 to group_cpus_evenly(), e.g., via null_blk when writing “0” to poll_queues in configfs, which propagates to blk_mq_update_nr_hw_queues() -> blk_mq_map_queues() -> group_cpus_evenly().

4) Impact Mechanism:
- ZERO_SIZE_PTR (0x10) from kcalloc(…, 0, …) is treated as a valid pointer.
- Subsequent operations like __bitmap_or within __group_cpus_evenly() dereference this pointer, causing a NULL/invalid pointer dereference and kernel panic (DoS).

5. Patch Analysis
1) Fix Approach:
Introduce an early return in group_cpus_evenly() to reject numgrps == 0, avoiding zero-sized allocations and subsequent invalid pointer dereferences.

2) Key Code Changes:
- In group_cpus_evenly():
  - Added:
    - if (numgrps == 0)
    -     return NULL;
- This check precedes allocations such as zalloc_cpumask_var(&nmsk, GFP_KERNEL), preventing the ZERO_SIZE_PTR condition entirely.

3) Locking/Concurrency Impact:
None. The change is a simple argument validation and early return; no locking, ordering, or concurrency semantics were modified.

6. Broader Kernel Security Implications
- Prevents a straightforward denial-of-service path where user-configurable parameters (e.g., via configfs) can induce a kernel panic.
- Ensures safer handling of zero-dimensional configurations across subsystems relying on CPU mask grouping.
- Highlights the need for explicit zero-argument validation in utility functions that allocate arrays based on caller-provided sizes to avoid ZERO_SIZE_PTR misuse.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}