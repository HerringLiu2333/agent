You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38309

[INFO]
[PATCH_DESCRIPTION]
    drm/xe/vm: move xe_svm_init() earlier
    In xe_vm_close_and_put() we need to be able to call xe_svm_fini(),
    however during vm creation we can call this on the error path, before
    having actually initialised the svm state, leading to various splats
    followed by a fatal NPD.

[PATCH_DIFF]
     @@ -1683,10 +1683,16 @@ struct xe_vm *xe_vm_create(struct xe_device *xe, u32 flags)
     		xe_pm_runtime_get_noresume(xe);
     	}
     
     +	if (flags & XE_VM_FLAG_FAULT_MODE) {
     +		err = xe_svm_init(vm);
     +		if (err)
     +			goto err_no_resv;
     +	}
     +
     	vm_resv_obj = drm_gpuvm_resv_object_alloc(&xe->drm);
     	if (!vm_resv_obj) {
     		err = -ENOMEM;
     -		goto err_no_resv;
     +		goto err_svm_fini;
     	}
     
     	drm_gpuvm_init(&vm->gpuvm, "Xe VM", DRM_GPUVM_RESV_PROTECTED, &xe->drm,
     @@ -1757,12 +1763,6 @@ struct xe_vm *xe_vm_create(struct xe_device *xe, u32 flags)
     		}
     	}
     
     -	if (flags & XE_VM_FLAG_FAULT_MODE) {
     -		err = xe_svm_init(vm);
     -		if (err)
     -			goto err_close;
     -	}
     -
     	if (number_tiles > 1)
     		vm->composite_fence_ctx = dma_fence_context_alloc(1);
     
     @@ -1776,6 +1776,11 @@ err_close:
     	xe_vm_close_and_put(vm);
     	return ERR_PTR(err);
     
     +err_svm_fini:
     +	if (flags & XE_VM_FLAG_FAULT_MODE) {
     +		vm->size = 0; /* close the vm */
     +		xe_svm_fini(vm);
     +	}
      err_no_resv:
     	mutex_destroy(&vm->snap_mutex);
     	for_each_tile(tile, xe, id)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38309

2. Vulnerability Type
Improper initialization/cleanup ordering on error path leading to NULL pointer dereference (kernel DoS)

3. Root Cause Summary
xe_vm_create() could hit an error path that calls xe_vm_close_and_put(), which in turn calls xe_svm_fini(), before xe_svm_init() had been executed. This asymmetric init/fini sequencing meant xe_svm_fini() operated on uninitialized SVM state when XE_VM_FLAG_FAULT_MODE was set, causing “splats” and a fatal NULL pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM Xe driver VM handling (drm/xe/vm), specifically SVM lifecycle within xe_vm_create()/xe_vm_close_and_put().

2) Pre-Patch Flaw:
- In xe_vm_create(), xe_svm_init(vm) was performed late (previously near the end of setup), after several allocations/initializations.
- Early failures (e.g., reservation object allocation) jumped to an error path that invoked xe_vm_close_and_put(), which expects xe_svm_fini() to be callable, even if xe_svm_init() had not run yet.
- Removed code shows the late init block: “err = xe_svm_init(vm); if (err) goto err_close;” at ~1757.

3) Trigger Condition:
- Creation of a VM with XE_VM_FLAG_FAULT_MODE set, followed by an error prior to reaching xe_svm_init(), such as failure of drm_gpuvm_resv_object_alloc(&xe->drm) or other earlier steps that lead to xe_vm_close_and_put() being called.

4) Impact Mechanism:
- xe_svm_fini() dereferenced or cleaned up uninitialized SVM fields, leading to kernel “splats” and a fatal NULL pointer dereference, resulting in a kernel crash/DoS.

5. Patch Analysis
1) Fix Approach:
- Ensure xe_svm_init() is executed early in xe_vm_create() whenever XE_VM_FLAG_FAULT_MODE is set, before any error path can trigger xe_vm_close_and_put().
- Add a dedicated error-unwind label to properly finalize SVM when early steps fail after SVM is initialized.
- Remove the late xe_svm_init() call to eliminate the ordering hole.

2) Key Code Changes:
- Added early SVM init:
  - If (flags & XE_VM_FLAG_FAULT_MODE) { err = xe_svm_init(vm); if (err) goto err_no_resv; }
- Adjusted error path for early failures after SVM init:
  - On vm_resv_obj allocation failure, jump to new err_svm_fini instead of err_no_resv.
  - New err_svm_fini label: if (FAULT_MODE) { vm->size = 0; xe_svm_fini(vm); }
- Removed the late xe_svm_init() block previously located around line ~1757 that did “err = xe_svm_init(vm); if (err) goto err_close;”.

3) Locking/Concurrency Impact:
- No locking primitives or ordering changed; the fix strictly reorders initialization and augments error cleanup.
- The addition of vm->size = 0 before xe_svm_fini() enforces a “closed” state prior to finalization, but no new synchronization mechanisms were introduced.

6. Broader Kernel Security Implications
- Highlights the importance of symmetric init/fini semantics in complex error paths: finalizers must only run after successful initialization, or be guarded by clear initialization state.
- Early initialization plus explicit unwind labels reduce the risk of NPDs and other lifetime bugs that attackers could exploit to crash the kernel via accessible ioctls.
- Reinforces a pattern for multi-stage device setup: either initialize components before any potential finalizer calls or gate finalizers on explicit “initialized” state to prevent similar crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}