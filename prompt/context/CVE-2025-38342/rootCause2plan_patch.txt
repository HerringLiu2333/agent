You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38342

[INFO]
[PATCH_DESCRIPTION]
    software node: Correct a OOB check in software_node_get_reference_args()
    software_node_get_reference_args() wants to get @index-th element, so
    the property value requires at least '(index + 1) * sizeof(*ref)' bytes
    but that can not be guaranteed by current OOB check, and may cause OOB
    for malformed property.
    
    Fix by using as OOB check '((index + 1) * sizeof(*ref) > prop->length)'.

[PATCH_DIFF]
    @@ -529,7 +529,7 @@ software_node_get_reference_args(const struct fwnode_handle *fwnode,
     	if (prop->is_inline)
     		return -EINVAL;
     
    -	if (index * sizeof(*ref) >= prop->length)
    +	if ((index + 1) * sizeof(*ref) > prop->length)
     		return -ENOENT;
     
     	ref_array = prop->pointer;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38342

2. Vulnerability Type
Out-of-bounds read due to incorrect bounds check (off-by-one/length validation error)

3. Root Cause Summary
software_node_get_reference_args() validated only that the starting offset of the requested element was within the property buffer, not that the entire element fit. The pre-patch check "if (index * sizeof(*ref) >= prop->length)" failed to account for the full size of the element at index, allowing access when the buffer ended with a partial element. For malformed properties where prop->length is not a multiple of sizeof(*ref), this leads to reading past the end of the buffer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Device property software nodes (firmware node handling) in the software node subsystem

2) Pre-Patch Flaw:
An incorrect out-of-bounds check in software_node_get_reference_args() only verified the start offset (index * sizeof(*ref)) against prop->length, instead of requiring that (index + 1) * sizeof(*ref) be within prop->length. This permitted indexing into an incomplete trailing element and dereferencing beyond the allocated buffer.

3) Trigger Condition:
A malformed property where prop->length does not provide a full element for the requested index (e.g., prop->length not a multiple of sizeof(*ref)), such that index * sizeof(*ref) < prop->length but (index + 1) * sizeof(*ref) > prop->length.

4) Impact Mechanism:
Dereferencing ref_array[index] reads memory past prop->pointer’s allocated length, causing an out-of-bounds read, which can lead to kernel memory exposure or a crash.

5. Patch Analysis
1) Fix Approach:
Strengthened the bounds check to ensure the entire element at the requested index fits within the property value by verifying "(index + 1) * sizeof(*ref) > prop->length" and returning -ENOENT if true.

2) Key Code Changes:
In software_node_get_reference_args():
- Replaced "if (index * sizeof(*ref) >= prop->length)" with "if ((index + 1) * sizeof(*ref) > prop->length)" to require sufficient bytes for a full element.
- No other logic changes; error returns and is_inline check remain.

3) Locking/Concurrency Impact:
None; the change is a pure arithmetic bounds check adjustment with no locking or ordering modifications.

6. Broader Kernel Security Implications
Correct element-size-aware bounds checking is critical when parsing variable-length properties to prevent OOB reads. This fix reduces the attack surface where malformed data can trigger memory violations in property processing routines. It highlights the importance of validating both the start offset and the full size of accessed elements, avoiding off-by-one errors and size miscalculations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.