You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38342

[INFO]
[PATCH_DESCRIPTION]
    software node: Correct a OOB check in software_node_get_reference_args()
    software_node_get_reference_args() wants to get @index-th element, so
    the property value requires at least '(index + 1) * sizeof(*ref)' bytes
    but that can not be guaranteed by current OOB check, and may cause OOB
    for malformed property.
    
    Fix by using as OOB check '((index + 1) * sizeof(*ref) > prop->length)'.

[PATCH_DIFF]
    @@ -529,7 +529,7 @@ software_node_get_reference_args(const struct fwnode_handle *fwnode,
     	if (prop->is_inline)
     		return -EINVAL;
     
    -	if (index * sizeof(*ref) >= prop->length)
    +	if ((index + 1) * sizeof(*ref) > prop->length)
     		return -ENOENT;
     
     	ref_array = prop->pointer;

[FUNCTION_CONTENT]
static int
software_node_get_reference_args(const struct fwnode_handle *fwnode,
				 const char *propname, const char *nargs_prop,
				 unsigned int nargs, unsigned int index,
				 struct fwnode_reference_args *args)
{
	struct swnode *swnode = to_swnode(fwnode);
	const struct software_node_ref_args *ref_array;
	const struct software_node_ref_args *ref;
	const struct property_entry *prop;
	struct fwnode_handle *refnode;
	u32 nargs_prop_val;
	int error;
	int i;

	prop = property_entry_get(swnode->node->properties, propname);
	if (!prop)
		return -ENOENT;

	if (prop->type != DEV_PROP_REF)
		return -EINVAL;

	/*
	 * We expect that references are never stored inline, even
	 * single ones, as they are too big.
	 */
	if (prop->is_inline)
		return -EINVAL;

	if (index * sizeof(*ref) >= prop->length)
		return -ENOENT;

	ref_array = prop->pointer;
	ref = &ref_array[index];

	refnode = software_node_fwnode(ref->node);
	if (!refnode)
		return -ENOENT;

	if (nargs_prop) {
		error = property_entry_read_int_array(ref->node->properties,
						      nargs_prop, sizeof(u32),
						      &nargs_prop_val, 1);
		if (error)
			return error;

		nargs = nargs_prop_val;
	}

	if (nargs > NR_FWNODE_REFERENCE_ARGS)
		return -EINVAL;

	if (!args)
		return 0;

	args->fwnode = software_node_get(refnode);
	args->nargs = nargs;

	for (i = 0; i < nargs; i++)
		args->args[i] = ref->args[i];

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38342

2. Vulnerability Type
Out-of-bounds read due to incorrect bounds validation

3. Root Cause Summary
The function software_node_get_reference_args() used an insufficient length check when accessing the index-th element of a reference array stored in a property. The pre-patch condition “if (index * sizeof(*ref) >= prop->length)” only ensured the starting offset was within bounds, but did not guarantee that the entire element (index + 1 elements worth) fit within prop->length. For malformed properties (e.g., lengths not a multiple of sizeof(*ref) or truncated), this allowed ref = &ref_array[index] and subsequent dereferences of ref->node/args to read past the property buffer, causing an out-of-bounds read and potentially invalid pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Device property framework (software nodes) in the firmware node (fwnode) handling path

2) Pre-Patch Flaw:
In software_node_get_reference_args(), the bounds check used “index * sizeof(*ref) >= prop->length” (pre-patch code) instead of verifying that (index + 1) elements fit, permitting selection of an element whose end extends beyond prop->length.

3) Trigger Condition:
A DEV_PROP_REF property that is not inline, with a malformed length (e.g., not a multiple of sizeof(struct software_node_ref_args) or shorter than expected), combined with an index such that index * sizeof(*ref) < prop->length but (index + 1) * sizeof(*ref) > prop->length.

4) Impact Mechanism:
The function computes ref = &ref_array[index] and reads ref->node and ref->args[i]; if the property buffer does not contain a complete element, this results in out-of-bounds reads and may lead to an invalid pointer dereference when calling software_node_fwnode(ref->node) or copying args, potentially causing a kernel crash.

5. Patch Analysis
1) Fix Approach:
Strengthen the bounds check to ensure the full index-th element fits within the property’s length, preventing any partial-element access.

2) Key Code Changes:
In software_node_get_reference_args(), replace the check:
- Pre-patch: if (index * sizeof(*ref) >= prop->length) return -ENOENT;
- Post-patch: if ((index + 1) * sizeof(*ref) > prop->length) return -ENOENT;
This guarantees at least (index + 1) * sizeof(*ref) bytes are present before accessing ref_array[index].

3) Locking/Concurrency Impact:
No locking or concurrency logic was changed; the fix is purely a bounds validation correction.

6. Broader Kernel Security Implications
Correct bounds validation in property parsing prevents out-of-bounds reads that can lead to kernel crashes or unintended memory exposure via invalid pointer dereferences. Ensuring complete-element checks when indexing structured arrays reduces the attack surface from malformed firmware node properties. This change hardens the device property framework’s resilience against malformed or corrupted inputs, improving overall kernel robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.