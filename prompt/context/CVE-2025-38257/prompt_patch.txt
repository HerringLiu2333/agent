You are a senior Linux kernel vulnerability analyst.
Task: Identify the minimal root cause code snippet that directly enabled the vulnerability BEFORE the patch.

Rules:
1. Root cause = flawed or missing logic the patch fixes (missing check, wrong locking, unsafe access, race window, integer/length misuse, etc.).
2. Prefer removed (-) lines or original versions of modified lines. If issue is absence of code, show the surrounding code where it should have been.
3. Output ONLY vulnerable original code (before patch). No explanations.
4. Keep snippet minimal (≈3–25 lines). Preserve original indentation.
5. If multiple disjoint regions are required, separate them with a single blank line.
6. Do NOT include added '+' lines unless absolutely necessary for minimal context.
7. If nothing identifiable: output exactly NO_ROOT_CAUSE_FOUND.
8. Return strictly between the tags below.

[META]
CVE_NAME: CVE-2025-38257

[PATCH_DESCRIPTION]


[PATCH_DIFF]
    @@ -86,7 +86,7 @@ static void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)
     	if (!uapqns || nr_apqns == 0)
     		return NULL;
     
    -	return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));
    +	return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));
     }
     
     static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)

[OUTPUT FORMAT]
<<<ROOT_CAUSE_CODE_START>>>
<root cause original code here>
<<<ROOT_CAUSE_CODE_END>>>