You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38257

[INFO]
[PATCH_DESCRIPTION]
    s390/pkey: Prevent overflow in size calculation for memdup_user()
    Number of apqn target list entries contained in 'nr_apqns' variable is
    determined by userspace via an ioctl call so the result of the product in
    calculation of size passed to memdup_user() may overflow.
    
    In this case the actual size of the allocated area and the value
    describing it won't be in sync leading to various types of unpredictable
    behaviour later.
    
    Use a proper memdup_array_user() helper which returns an error if an
    overflow is detected. Note that it is different from when nr_apqns is
    initially zero - that case is considered valid and should be handled in
    subsequent pkey_handler implementations.
    
    Found by Linux Verification Center (linuxtesting.org).
    
    Fixes: f2bbc96e7cfa ("s390/pkey: add CCA AES cipher key support")

[PATCH_DIFF]
    @@ -86,7 +86,7 @@ static void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)
     	if (!uapqns || nr_apqns == 0)
     		return NULL;
     
    -	return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));
    +	return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));
     }
     
     static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38257

2. Vulnerability Type
Integer overflow in user-controlled allocation size leading to potential out-of-bounds access/memory corruption.

3. Root Cause Summary
The function _copy_apqns_from_user computed the byte size for memdup_user using nr_apqns * sizeof(struct pkey_apqn) without checking for integer overflow. Because nr_apqns is user-controlled via an ioctl, the multiplication could wrap, causing a too-small allocation while the logic later still treats the buffer as containing nr_apqns entries. This mismatch between the allocated size and the logical element count can lead to out-of-bounds accesses and unpredictable behavior in subsequent pkey handlers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
s390/pkey (s390 CCA AES key support and APQN list handling)

2) Pre-Patch Flaw:
In _copy_apqns_from_user(void __user *uapqns, size_t nr_apqns), the code passed nr_apqns * sizeof(struct pkey_apqn) to memdup_user without overflow protection. Specifically: “return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));”.

3) Trigger Condition:
A userspace process issues the relevant ioctl and supplies a large nr_apqns such that the product nr_apqns * sizeof(struct pkey_apqn) overflows size_t, with uapqns non-NULL and nr_apqns != 0.

4) Impact Mechanism:
The overflow results in a smaller-than-required allocation and copy. Subsequent code paths treat the buffer as containing nr_apqns entries, which can cause out-of-bounds reads/writes or other undefined behavior when iterating/accessing beyond the allocated memory.

5. Patch Analysis
1) Fix Approach:
Replace memdup_user with memdup_array_user to perform array-size multiplication with overflow detection and fail safely on overflow, differentiating that overflow is an error while a zero nr_apqns remains a valid case to be handled later.

2) Key Code Changes:
In _copy_apqns_from_user:
- Before: “return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));”
- After: “return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));”
The existing NULL/zero check “if (!uapqns || nr_apqns == 0) return NULL;” remains unchanged.

3) Locking/Concurrency Impact:
None. The change is confined to safe size computation and allocation-from-user; no locking or ordering adjustments were introduced.

6. Broader Kernel Security Implications
This fix reinforces the need to guard all user-controlled array length computations with overflow-safe helpers (e.g., memdup_array_user, array_size) to prevent allocation-size mismatches that can lead to memory corruption. Similar patterns across ioctl and user buffer handling are common; adopting these helpers systematically reduces the risk of integer overflow-driven vulnerabilities.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.