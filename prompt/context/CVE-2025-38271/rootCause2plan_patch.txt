You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38271

[INFO]
[PATCH_DESCRIPTION]
    net: prevent a NULL deref in rtnl_create_link()
    At the time rtnl_create_link() is running, dev->netdev_ops is NULL,
    we must not use netdev_lock_ops() or risk a NULL deref if
    CONFIG_NET_SHAPER is defined.
    
    Use netif_set_group() instead of dev_set_group().
    
     RIP: 0010:netdev_need_ops_lock include/net/netdev_lock.h:33 [inline]
     RIP: 0010:netdev_lock_ops include/net/netdev_lock.h:41 [inline]
     RIP: 0010:dev_set_group+0xc0/0x230 net/core/dev_api.c:82
    Call Trace:
     <TASK>
      rtnl_create_link+0x748/0xd10 net/core/rtnetlink.c:3674
      rtnl_newlink_create+0x25c/0xb00 net/core/rtnetlink.c:3813
      __rtnl_newlink net/core/rtnetlink.c:3940 [inline]
      rtnl_newlink+0x16d6/0x1c70 net/core/rtnetlink.c:4055
      rtnetlink_rcv_msg+0x7cf/0xb70 net/core/rtnetlink.c:6944
      netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2534
      netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]
      netlink_unicast+0x75b/0x8d0 net/netlink/af_netlink.c:1339
      netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1883
      sock_sendmsg_nosec net/socket.c:712 [inline]

[PATCH_DIFF]
    @@ -3671,7 +3671,7 @@ struct net_device *rtnl_create_link(struct net *net, const char *ifname,
     	if (tb[IFLA_LINKMODE])
     		dev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);
     	if (tb[IFLA_GROUP])
    -		dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
    +		netif_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
     	if (tb[IFLA_GSO_MAX_SIZE])
     		netif_set_gso_max_size(dev, nla_get_u32(tb[IFLA_GSO_MAX_SIZE]));
     	if (tb[IFLA_GSO_MAX_SEGS])



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38271

2. Vulnerability Type
NULL pointer dereference leading to kernel crash/denial-of-service (lifecycle/state misuse with improper locking based on uninitialized netdev_ops)

3. Root Cause Summary
During rtnl_create_link(), the new net_device has not yet had dev->netdev_ops initialized (it is NULL). The code incorrectly calls dev_set_group(), which, under CONFIG_NET_SHAPER, uses netdev_lock_ops()/netdev_need_ops_lock and dereferences dev->netdev_ops, causing a NULL pointer dereference. The correct API for this initialization phase is netif_set_group(), which does not depend on netdev_ops or the ops lock. The patch replaces dev_set_group() with netif_set_group() to avoid dereferencing a NULL ops pointer during device creation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking core, rtnetlink newlink creation path (net/core/rtnetlink.c), dev API (net/core/dev_api.c), and netdev lock helpers (include/net/netdev_lock.h).

2) Pre-Patch Flaw:
- In rtnl_create_link(), when parsing IFLA_GROUP, the code called dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP])) while dev->netdev_ops is still NULL.
- dev_set_group() may invoke netdev_lock_ops()/netdev_need_ops_lock, which expects a non-NULL dev->netdev_ops.

3) Trigger Condition:
- RTM_NEWLINK request that includes IFLA_GROUP reaches rtnl_create_link() before netdev_ops is set.
- Kernel built with CONFIG_NET_SHAPER, which causes dev_set_group() to take the ops lock via netdev_lock_ops, leading to dereference of dev->netdev_ops.

4) Impact Mechanism:
- netdev_lock_ops dereferences dev->netdev_ops through netdev_need_ops_lock, resulting in a NULL pointer dereference.
- This causes a kernel oops/panic in the newlink creation path (DoS), as evidenced by the stack trace through dev_set_group -> rtnl_create_link.

5. Patch Analysis
1) Fix Approach:
- Avoid ops-dependent locking during early device initialization by switching to an API that does not require netdev_ops to be set.
- Replace dev_set_group() with netif_set_group(), which safely sets the device group without touching netdev_ops.

2) Key Code Changes:
- In net/core/rtnetlink.c around line 3671:
  - Changed: dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
  - To:      netif_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
- This change removes the path through netdev_lock_ops that dereferenced dev->netdev_ops.

3) Locking/Concurrency Impact:
- Eliminates use of netdev_lock_ops during device creation, preventing a lock acquisition that relies on an uninitialized ops pointer.
- Ensures correct ordering: group assignment is performed without ops-based locking while the device is not fully initialized, aligning with initialization-time expectations.

6. Broader Kernel Security Implications
- Highlights the risk of using APIs that assume fully initialized net_device state (e.g., non-NULL netdev_ops) during early creation paths.
- Configuration-dependent code paths (e.g., CONFIG_NET_SHAPER) can expose latent NULL-deref bugs; careful API selection is required across configurations.
- Reinforces the need for strict initialization ordering and using netif_* helpers that are safe before registration/ops assignment.
- Similar issues may exist where helper functions implicitly rely on ops or registered state; audits should verify safe usage during rtnl_create_link and related setup flows.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.