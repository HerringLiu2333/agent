You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38260

[INFO]
[PATCH_DESCRIPTION]
    btrfs: handle csum tree error with rescue=ibadroots correctly
    [BUG]
    There is syzbot based reproducer that can crash the kernel, with the
    following call trace: (With some debug output added)
    
     DEBUG: rescue=ibadroots parsed
     BTRFS: device fsid 14d642db-7b15-43e4-81e6-4b8fac6a25f8 devid 1 transid 8 /dev/loop0 (7:0) scanned by repro (1010)
     BTRFS info (device loop0): first mount of filesystem 14d642db-7b15-43e4-81e6-4b8fac6a25f8
     BTRFS info (device loop0): using blake2b (blake2b-256-generic) checksum algorithm
     BTRFS info (device loop0): using free-space-tree
     BTRFS warning (device loop0): checksum verify failed on logical 5312512 mirror 1 wanted 0xb043382657aede36608fd3386d6b001692ff406164733d94e2d9a180412c6003 found 0x810ceb2bacb7f0f9eb2bf3b2b15c02af867cb35ad450898169f3b1f0bd818651 level 0
     DEBUG: read tree root path failed for tree csum, ret=-5
     BTRFS warning (device loop0): checksum verify failed on logical 5328896 mirror 1 wanted 0x51be4e8b303da58e6340226815b70e3a93592dac3f30dd510c7517454de8567a found 0x51be4e8b303da58e634022a315b70e3a93592dac3f30dd510c7517454de8567a level 0
     BTRFS warning (device loop0): checksum verify failed on logical 5292032 mirror 1 wanted 0x1924ccd683be9efc2fa98582ef58760e3848e9043db8649ee382681e220cdee4 found 0x0cb6184f6e8799d9f8cb335dccd1d1832da1071d12290dab3b85b587ecacca6e level 0
     process 'repro' launched './file2' with NULL argv: empty string added
     DEBUG: no csum root, idatacsums=0 ibadroots=134217728
     Oops: general protection fault, probably for non-canonical address 0xdffffc0000000041: 0000 [#1] SMP KASAN NOPTI
     KASAN: null-ptr-deref in range [0x0000000000000208-0x000000000000020f]
     CPU: 5 UID: 0 PID: 1010 Comm: repro Tainted: G           OE       6.15.0-custom+ #249 PREEMPT(full)
     Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS unknown 02/02/2022
     RIP: 0010:btrfs_lookup_csum+0x93/0x3d0 [btrfs]
     Call Trace:
      <TASK>
      btrfs_lookup_bio_sums+0x47a/0xdf0 [btrfs]
      btrfs_submit_bbio+0x43e/0x1a80 [btrfs]
      submit_one_bio+0xde/0x160 [btrfs]
      btrfs_readahead+0x498/0x6a0 [btrfs]
      read_pages+0x1c3/0xb20
      page_cache_ra_order+0x4b5/0xc20
      filemap_get_pages+0x2d3/0x19e0
      filemap_read+0x314/0xde0
      __kernel_read+0x35b/0x900
      bprm_execve+0x62e/0x1140
      do_execveat_common.isra.0+0x3fc/0x520
      __x64_sys_execveat+0xdc/0x130
      do_syscall_64+0x54/0x1d0
      entry_SYSCALL_64_after_hwframe+0x76/0x7e
     ---[ end trace 0000000000000000 ]---
    
    [CAUSE]
    Firstly the fs has a corrupted csum tree root, thus to mount the fs we
    have to go "ro,rescue=ibadroots" mount option.
    
    Normally with that mount option, a bad csum tree root should set
    BTRFS_FS_STATE_NO_DATA_CSUMS flag, so that any future data read will
    ignore csum search.
    
    But in this particular case, we have the following call trace that
    caused NULL csum root, but not setting BTRFS_FS_STATE_NO_DATA_CSUMS:
    
    load_global_roots_objectid():
    
    		ret = btrfs_search_slot();
    		/* Succeeded */
    		btrfs_item_key_to_cpu()
    		found = true;
    		/* We found the root item for csum tree. */
    		root = read_tree_root_path();
    		if (IS_ERR(root)) {
    			if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))
    			/*
    			 * Since we have rescue=ibadroots mount option,
    			 * @ret is still 0.
    			 */
    			break;
    	if (!found || ret) {
    		/* @found is true, @ret is 0, error handling for csum
    		 * tree is skipped.
    		 */
    	}
    
    This means we completely skipped to set BTRFS_FS_STATE_NO_DATA_CSUMS if
    the csum tree is corrupted, which results unexpected later csum lookup.
    
    [FIX]
    If read_tree_root_path() failed, always populate @ret to the error
    number.
    
    As at the end of the function, we need @ret to determine if we need to
    do the extra error handling for csum tree.
    
    Fixes: abed4aaae4f7 ("btrfs: track the csum, extent, and free space trees in a rb tree")

[PATCH_DIFF]
    diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
    index f48f9d924a6216..0d6ad7512f217c 100644
    --- a/fs/btrfs/disk-io.c
    +++ b/fs/btrfs/disk-io.c
    @@ -2158,8 +2158,7 @@ static int load_global_roots_objectid(struct btrfs_root *tree_root,
     		found = true;
     		root = read_tree_root_path(tree_root, path, &key);
     		if (IS_ERR(root)) {
    -			if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))
    -				ret = PTR_ERR(root);
    +			ret = PTR_ERR(root);
     			break;
     		}
     		set_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);

[FUNCTION_CONTENT]
static int load_global_roots_objectid(struct btrfs_root *tree_root,
				      struct btrfs_path *path, u64 objectid,
				      const char *name)
{
	struct btrfs_fs_info *fs_info = tree_root->fs_info;
	struct btrfs_root *root;
	u64 max_global_id = 0;
	int ret;
	struct btrfs_key key = {
		.objectid = objectid,
		.type = BTRFS_ROOT_ITEM_KEY,
		.offset = 0,
	};
	bool found = false;

	/* If we have IGNOREDATACSUMS skip loading these roots. */
	if (objectid == BTRFS_CSUM_TREE_OBJECTID &&
	    btrfs_test_opt(fs_info, IGNOREDATACSUMS)) {
		set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state);
		return 0;
	}

	while (1) {
		ret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);
		if (ret < 0)
			break;

		if (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {
			ret = btrfs_next_leaf(tree_root, path);
			if (ret) {
				if (ret > 0)
					ret = 0;
				break;
			}
		}
		ret = 0;

		btrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);
		if (key.objectid != objectid)
			break;
		btrfs_release_path(path);

		/*
		 * Just worry about this for extent tree, it'll be the same for
		 * everybody.
		 */
		if (objectid == BTRFS_EXTENT_TREE_OBJECTID)
			max_global_id = max(max_global_id, key.offset);

		found = true;
		root = read_tree_root_path(tree_root, path, &key);
		if (IS_ERR(root)) {
			if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))
				ret = PTR_ERR(root);
			break;
		}
		set_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);
		ret = btrfs_global_root_insert(root);
		if (ret) {
			btrfs_put_root(root);
			break;
		}
		key.offset++;
	}
	btrfs_release_path(path);

	if (objectid == BTRFS_EXTENT_TREE_OBJECTID)
		fs_info->nr_global_roots = max_global_id + 1;

	if (!found || ret) {
		if (objectid == BTRFS_CSUM_TREE_OBJECTID)
			set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state);

		if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))
			ret = ret ? ret : -ENOENT;
		else
			ret = 0;
		btrfs_err(fs_info, "failed to load root %s", name);
	}
	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38260

2. Vulnerability Type
NULL pointer dereference due to missing error propagation/incorrect error handling

3. Root Cause Summary
The function load_global_roots_objectid() failed to propagate an error when read_tree_root_path() returned an ERR_PTR for the checksum (csum) tree while the rescue=ibadroots (IGNOREBADROOTS) mount option was set. Because ret remained 0 and found was set true, the end-of-function error handling block did not execute, leaving BTRFS_FS_STATE_NO_DATA_CSUMS unset despite a missing/invalid csum root. Subsequent I/O paths attempted to look up checksums via btrfs_lookup_csum without the NO_DATA_CSUMS safeguard, dereferencing a NULL csum root and crashing the kernel.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Btrfs filesystem, global roots loading in fs/btrfs/disk-io.c

2) Pre-Patch Flaw:
In load_global_roots_objectid(), after setting found = true, the error path:
“if (IS_ERR(root)) { if (!btrfs_test_opt(fs_info, IGNOREBADROOTS)) ret = PTR_ERR(root); break; }”
left ret as 0 under IGNOREBADROOTS, even though the csum root load failed. This caused the condition “if (!found || ret)” to be false and skipped setting BTRFS_FS_STATE_NO_DATA_CSUMS for a corrupted/missing csum tree.

3) Trigger Condition:
Mounting a filesystem with a corrupted csum tree root using rescue=ibadroots (IGNOREBADROOTS) and then performing a data read (e.g., file read/exec) that triggers checksum lookup. The call trace shows btrfs_lookup_bio_sums → btrfs_lookup_csum invoked after mount.

4) Impact Mechanism:
Because NO_DATA_CSUMS was not set, the read path attempted to access the csum tree and dereferenced a NULL root in btrfs_lookup_csum, leading to a KASAN-detected NULL pointer dereference and kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Unconditionally propagate the error from read_tree_root_path() by setting ret = PTR_ERR(root) regardless of IGNOREBADROOTS. This ensures the final error handling block runs and sets BTRFS_FS_STATE_NO_DATA_CSUMS for the csum tree when the root cannot be loaded.

2) Key Code Changes:
In fs/btrfs/disk-io.c within load_global_roots_objectid():
- Removed the guard:
  “if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))”
- Now always do:
  “ret = PTR_ERR(root);”
This change guarantees that “if (!found || ret)” evaluates true and triggers:
- set_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state) for BTRFS_CSUM_TREE_OBJECTID
- Appropriate return handling under IGNOREBADROOTS (ret set to 0) while still setting the flag.

3) Locking/Concurrency Impact:
None. The change is purely in error propagation and state-setting logic, with no modifications to locking or concurrency primitives.

6. Broader Kernel Security Implications
Ensuring consistent error handling and state flags prevents kernel crashes on corrupted filesystems even with rescue options enabled, reducing the potential for denial-of-service via crafted images. Properly setting NO_DATA_CSUMS when the csum root is unavailable avoids unsafe accesses in the I/O path, strengthening robustness of btrfs mount and read paths under failure conditions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}