You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-40014

[INFO]
[PATCH_DESCRIPTION]
    objtool, spi: amd: Fix out-of-bounds stack access in amd_set_spi_freq()
    If speed_hz < AMD_SPI_MIN_HZ, amd_set_spi_freq() iterates over the
    entire amd_spi_freq array without breaking out early, causing 'i' to go
    beyond the array bounds.
    
    Fix that by stopping the loop when it gets to the last entry, so the low
    speed_hz value gets clamped up to AMD_SPI_MIN_HZ.
    
    Fixes the following warning with an UBSAN kernel:
    
      drivers/spi/spi-amd.o: error: objtool: amd_set_spi_freq() falls through to next function amd_spi_set_opcode()

[PATCH_DIFF]
    @@ -302,7 +302,7 @@ static void amd_set_spi_freq(struct amd_spi *amd_spi, u32 speed_hz)
     {
     	unsigned int i, spd7_val, alt_spd;
     
    -	for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
    +	for (i = 0; i < ARRAY_SIZE(amd_spi_freq)-1; i++)
     		if (speed_hz >= amd_spi_freq[i].speed_hz)
     			break;

[FUNCTION_CONTENT]
static void amd_set_spi_freq(struct amd_spi *amd_spi, u32 speed_hz)
{
	unsigned int i, spd7_val, alt_spd;

	for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
		if (speed_hz >= amd_spi_freq[i].speed_hz)
			break;

	if (amd_spi->speed_hz == amd_spi_freq[i].speed_hz)
		return;

	amd_spi->speed_hz = amd_spi_freq[i].speed_hz;

	alt_spd = (amd_spi_freq[i].enable_val << AMD_SPI_ALT_SPD_SHIFT)
		   & AMD_SPI_ALT_SPD_MASK;
	amd_spi_setclear_reg32(amd_spi, AMD_SPI_ENA_REG, alt_spd,
			       AMD_SPI_ALT_SPD_MASK);

	if (amd_spi->speed_hz == AMD_SPI_MAX_HZ)
		amd_spi_setclear_reg32(amd_spi, AMD_SPI_ENA_REG, 1,
				       AMD_SPI_SPI100_MASK);

	if (amd_spi_freq[i].spd7_val) {
		spd7_val = (amd_spi_freq[i].spd7_val << AMD_SPI_SPD7_SHIFT)
			    & AMD_SPI_SPD7_MASK;
		amd_spi_setclear_reg32(amd_spi, AMD_SPI_SPEED_REG, spd7_val,
				       AMD_SPI_SPD7_MASK);
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-40014

2. Vulnerability Type
Out-of-bounds array access (OOB read) due to improper loop bounds and missing clamping/bounds validation

3. Root Cause Summary
amd_set_spi_freq() linearly scans the amd_spi_freq[] table using “for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)” and then unconditionally uses amd_spi_freq[i] after the loop. When speed_hz is below the minimum table entry, the loop never breaks, leaving i == ARRAY_SIZE(amd_spi_freq), and subsequent accesses like “amd_spi_freq[i].speed_hz” are out-of-bounds. The function lacks a guard to clamp to the minimum supported frequency or to cap i to the last valid index before indexing. This results in out-of-bounds stack access and undefined behavior, flagged by objtool/UBSAN.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SPI subsystem; AMD SPI driver (drivers/spi/spi-amd)

2) Pre-Patch Flaw:
In amd_set_spi_freq(), the loop over amd_spi_freq[] assumes a match will be found and does not cap the index, then uses i to index the array without verifying i < ARRAY_SIZE. The missing early stop/clamp for the smallest supported speed allows i to increment past the last valid element.

3) Trigger Condition:
Caller provides speed_hz < AMD_SPI_MIN_HZ, i.e., lower than the smallest entry in amd_spi_freq[], so the “if (speed_hz >= amd_spi_freq[i].speed_hz)” condition never becomes true and the loop completes without break.

4) Impact Mechanism:
With i == ARRAY_SIZE(amd_spi_freq), subsequent reads of amd_spi_freq[i].speed_hz/enable_val/spd7_val are out-of-bounds, causing OOB stack access and undefined behavior; observed as an objtool warning “amd_set_spi_freq() falls through to next function amd_spi_set_opcode()” and UBSAN errors. The erroneous values may lead to incorrect register programming and potential system instability.

5. Patch Analysis
1) Fix Approach:
Clamp the iteration to the last valid index by limiting the loop to ARRAY_SIZE(amd_spi_freq) - 1, ensuring i never reaches an out-of-range value and low speed_hz values are clamped up to AMD_SPI_MIN_HZ.

2) Key Code Changes:
Changed loop bound from “for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)” to “for (i = 0; i < ARRAY_SIZE(amd_spi_freq) - 1; i++)”, preventing i from becoming equal to ARRAY_SIZE when no break occurs.

3) Locking/Concurrency Impact:
None. The patch solely adjusts loop bounds and does not alter locking, concurrency control, or ordering.

6. Broader Kernel Security Implications
Array indexing based on search loops must enforce bounds or provide clamping to avoid OOB access, especially in driver tables. Even read-only OOB access in kernel space can cause undefined behavior, crashes, or tool-detected control-flow anomalies, and may propagate faulty register programming. This fix exemplifies defensive programming: validate indices post-search or constrain loops to prevent OOB, a pattern applicable across hardware driver parameter-selection logic.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}