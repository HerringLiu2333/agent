You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-40014

[INFO]
[PATCH_DESCRIPTION]
    objtool, spi: amd: Fix out-of-bounds stack access in amd_set_spi_freq()
    If speed_hz < AMD_SPI_MIN_HZ, amd_set_spi_freq() iterates over the
    entire amd_spi_freq array without breaking out early, causing 'i' to go
    beyond the array bounds.
    
    Fix that by stopping the loop when it gets to the last entry, so the low
    speed_hz value gets clamped up to AMD_SPI_MIN_HZ.
    
    Fixes the following warning with an UBSAN kernel:
    
      drivers/spi/spi-amd.o: error: objtool: amd_set_spi_freq() falls through to next function amd_spi_set_opcode()

[PATCH_DIFF]
    @@ -302,7 +302,7 @@ static void amd_set_spi_freq(struct amd_spi *amd_spi, u32 speed_hz)
     {
     	unsigned int i, spd7_val, alt_spd;
     
    -	for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
    +	for (i = 0; i < ARRAY_SIZE(amd_spi_freq)-1; i++)
     		if (speed_hz >= amd_spi_freq[i].speed_hz)
     			break;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-40014

2. Vulnerability Type
Out-of-bounds stack access (array index out-of-bounds leading to stack corruption)

3. Root Cause Summary
amd_set_spi_freq() iterated up to ARRAY_SIZE(amd_spi_freq) and, when no entry matched (speed_hz < AMD_SPI_MIN_HZ), the loop completed with i == ARRAY_SIZE. The code then used i without clamping or revalidation, causing an out-of-bounds access. The missing lower-bound clamping/guard on the frequency table index allowed an invalid index to be used, resulting in stack OOB access and control-flow anomalies (as evidenced by objtool warning).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SPI subsystem, AMD SPI controller driver (drivers/spi, function amd_set_spi_freq)

2) Pre-Patch Flaw:
- The loop condition used “for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)” and relied on an early break when speed_hz >= amd_spi_freq[i].speed_hz.
- For speed_hz values below AMD_SPI_MIN_HZ, the loop never broke, leaving i == ARRAY_SIZE, after which i was used to access data tied to the frequency table without bounds check.
- This constitutes missing clamping/validation of the computed index when no table entry matches.

3) Trigger Condition:
- Caller passes speed_hz < AMD_SPI_MIN_HZ to amd_set_spi_freq().
- Under this condition, the loop iterates over the entire amd_spi_freq array without breaking, producing i == ARRAY_SIZE.

4) Impact Mechanism:
- Using i == ARRAY_SIZE to index/access data led to an out-of-bounds stack access, which can corrupt adjacent stack data or cause undefined behavior.
- Objtool/UBSAN reported: “amd_set_spi_freq() falls through to next function amd_spi_set_opcode()”, indicating corrupted control flow analysis consistent with stack OOB.

5. Patch Analysis
1) Fix Approach:
- Clamp the search loop to stop at the last valid index by changing the upper bound to ARRAY_SIZE(amd_spi_freq) - 1, ensuring i never exceeds the final valid entry when no match occurs.
- This effectively clamps too-low speed_hz up to AMD_SPI_MIN_HZ.

2) Key Code Changes:
- Loop bound changed:
  - From: for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
  - To:   for (i = 0; i < ARRAY_SIZE(amd_spi_freq)-1; i++)
- This guards against i becoming ARRAY_SIZE when no break happens, eliminating the OOB access.

3) Locking/Concurrency Impact:
- None. The change is purely bounds logic; no locks or ordering were added or modified.

6. Broader Kernel Security Implications
- Prevents potential stack corruption in the SPI driver when userspace or other kernel components request very low SPI speeds.
- Eliminates a class of table-lookup bugs where loop completion without a match yields an invalid index subsequently used without validation.
- Improves robustness of controller configuration paths, reducing risks of crashes or exploit primitives stemming from stack memory corruption in kernel drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.