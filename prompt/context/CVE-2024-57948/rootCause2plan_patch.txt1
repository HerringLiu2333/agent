You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57948

[INFO]
[PATCH_DESCRIPTION]
 mac802154: check local interfaces before deleting sdata list
 syzkaller reported a corrupted list in ieee802154_if_remove. [1]

 Remove an IEEE 802.15.4 network interface after unregister an IEEE 802.15.4
 hardware device from the system.

 CPU0					CPU1
 ====					====
 genl_family_rcv_msg_doit		ieee802154_unregister_hw
 ieee802154_del_iface			ieee802154_remove_interfaces
 rdev_del_virtual_intf_deprecated	list_del(&sdata->list)
 ieee802154_if_remove
 list_del_rcu

 The net device has been unregistered, since the rcu grace period,
 unregistration must be run before ieee802154_if_remove.
 
 To avoid this issue, add a check for local->interfaces before deleting
 sdata list.

 [1]
 kernel BUG at lib/list_debug.c:58!
 Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI
 CPU: 0 UID: 0 PID: 6277 Comm: syz-executor157 Not tainted 6.12.0-rc6-syzkaller-00005-g557329bcecc2 #0
 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
 RIP: 0010:__list_del_entry_valid_or_report+0xf4/0x140 lib/list_debug.c:56
 Code: e8 a1 7e 00 07 90 0f 0b 48 c7 c7 e0 37 60 8c 4c 89 fe e8 8f 7e 00 07 90 0f 0b 48 c7 c7 40 38 60 8c 4c 89 fe e8 7d 7e 00 07 90 <0f> 0b 48 c7 c7 a0 38 60 8c 4c 89 fe e8 6b 7e 00 07 90 0f 0b 48 c7
 RSP: 0018:ffffc9000490f3d0 EFLAGS: 00010246
 RAX: 000000000000004e RBX: dead000000000122 RCX: d211eee56bb28d00
 RDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000
 RBP: ffff88805b278dd8 R08: ffffffff8174a12c R09: 1ffffffff2852f0d
 R10: dffffc0000000000 R11: fffffbfff2852f0e R12: dffffc0000000000
 R13: dffffc0000000000 R14: dead000000000100 R15: ffff88805b278cc0
 FS:  0000555572f94380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 000056262e4a3000 CR3: 0000000078496000 CR4: 00000000003526f0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 Call Trace:
  <TASK>
  __list_del_entry_valid include/linux/list.h:124 [inline]
  __list_del_entry include/linux/list.h:215 [inline]
  list_del_rcu include/linux/rculist.h:157 [inline]
  ieee802154_if_remove+0x86/0x1e0 net/mac802154/iface.c:687
  rdev_del_virtual_intf_deprecated net/ieee802154/rdev-ops.h:24 [inline]
  ieee802154_del_iface+0x2c0/0x5c0 net/ieee802154/nl-phy.c:323
  genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]
  genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]
  genl_rcv_msg+0xb14/0xec0 net/netlink/genetlink.c:1210
  netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2551
  genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219
  netlink_unicast_kernel net/netlink/af_netlink.c:1331 [inline]
  netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1357
  netlink_sendmsg+0x8e4/0xcb0 net/netlink/af_netlink.c:1901
  sock_sendmsg_nosec net/socket.c:729 [inline]
  __sock_sendmsg+0x221/0x270 net/socket.c:744
  ____sys_sendmsg+0x52a/0x7e0 net/socket.c:2607
  __sys_sendmsg+0x292/0x380 net/socket.c:2690
  do_syscall_x64 arch/x86/entry/common.c:52 [inline]
  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
  entry_SYSCALL_64_after_hwframe+0x77/0x7f

[PATCH_DIFF]
 diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
 index c0e2da5072bea2…9e4631fade90c9 100644
 --- a/net/mac802154/iface.c
 +++ b/net/mac802154/iface.c
 @@ -684,6 +684,10 @@ void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)
   ASSERT_RTNL();

   mutex_lock(&sdata->local->iflist_mtx);
+  if (list_empty(&sdata->local->interfaces)) {
+    mutex_unlock(&sdata->local->iflist_mtx);
+    return;
+  }
   list_del_rcu(&sdata->list);
   mutex_unlock(&sdata->local->iflist_mtx)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57948

2. Vulnerability Type
Race condition leading to double list unlink and list corruption (kernel BUG/DoS)

3. Root Cause Summary
ieee802154_if_remove() unconditionally executed list_del_rcu(&sdata->list) even when the IEEE 802.15.4 hardware unregister path had already removed all interfaces (including sdata) from local->interfaces. This caused a double unlink of sdata->list: one via ieee802154_remove_interfaces() (list_del) and a second via ieee802154_if_remove() (list_del_rcu). The absence of a membership/emptiness check and coordination with the unregister sequence led to list corruption detected by __list_del_entry_valid_or_report(), triggering a kernel BUG.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IEEE 802.15.4 (mac802154) networking stack, interface management (net/mac802154/iface.c)

2) Pre-Patch Flaw:
ieee802154_if_remove() performed list_del_rcu(&sdata->list) under iflist_mtx without verifying that local->interfaces still contained any entries or that sdata remained linked. This unconditional deletion allowed a second unlink of sdata after ieee802154_remove_interfaces() had already done list_del(&sdata->list) during hardware unregistration.

3) Trigger Condition:
Concurrent interface deletion via generic netlink (CPU0: genl_family_rcv_msg_doit → ieee802154_del_iface → rdev_del_virtual_intf_deprecated → ieee802154_if_remove → list_del_rcu) and hardware device unregister (CPU1: ieee802154_unregister_hw → ieee802154_remove_interfaces → list_del(&sdata->list)). With the interfaces list already cleared, the subsequent list_del_rcu on an entry no longer in a list tripped list_debug assertions.

4) Impact Mechanism:
Double unlink corrupts the kernel’s list pointers, causing __list_del_entry_valid_or_report() to BUG (invalid prev/next invariants), leading to an immediate kernel crash (DoS). Given the use of RCU, improper unlinking could also expose readers to inconsistent state, but the observed impact is a hard BUG/oops.

5. Patch Analysis
1) Fix Approach:
Introduce a guard to avoid unlinking when the local interface list has already been emptied by the unregister path. This prevents double deletion of sdata->list.

2) Key Code Changes:
In ieee802154_if_remove():
- Added:
  if (list_empty(&sdata->local->interfaces)) {
    mutex_unlock(&sdata->local->iflist_mtx);
    return;
  }
- Retained the existing list_del_rcu(&sdata->list) only when the interfaces list is non-empty.

3) Locking/Concurrency Impact:
The patch keeps the existing mutex (iflist_mtx) but adds an early return under the lock, ensuring atomic check-and-decide behavior. It does not alter lock ordering; instead, it gates the unsafe operation based on container state, reducing the race window where a post-unregister list could be manipulated. It also implicitly harmonizes the RCU and non-RCU unlink paths by ensuring ieee802154_if_remove() does not perform list_del_rcu after ieee802154_remove_interfaces() has done list_del.

6. Broader Kernel Security Implications
This fix underscores the necessity of validating object/container state before performing unlink/free operations, especially when multiple teardown paths (netlink-driven interface removal vs. hardware unregister) can interact. Proper guarding prevents list corruption and kernel crashes, improving robustness against race conditions in subsystem teardown. The change also highlights careful coordination between RCU list operations and conventional list operations to avoid double unlinks and lifetime violations during concurrent removal.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}