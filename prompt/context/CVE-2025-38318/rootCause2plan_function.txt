You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38318

[INFO]
[PATCH_DESCRIPTION]
    perf: arm-ni: Fix missing platform_set_drvdata()
    Add missing platform_set_drvdata in arm_ni_probe(), otherwise
    calling platform_get_drvdata() in remove returns NULL.

[PATCH_DIFF]
    @@ -660,6 +660,7 @@ static int arm_ni_probe(struct platform_device *pdev)
     	ni->num_cds = num_cds;
     	ni->part = part;
     	ni->id = atomic_fetch_inc(&id);
    +	platform_set_drvdata(pdev, ni);
     
     	for (int v = 0; v < cfg.num_components; v++) {
     		reg = readl_relaxed(cfg.base + NI_CHILD_PTR(v));

[FUNCTION_CONTENT]
static int arm_ni_probe(struct platform_device *pdev)
{
	struct arm_ni_node cfg, vd, pd, cd;
	struct arm_ni *ni;
	struct resource *res;
	void __iomem *base;
	static atomic_t id;
	int num_cds;
	u32 reg, part;

	/*
	 * We want to map the whole configuration space for ease of discovery,
	 * but the PMU pages are the only ones for which we can honestly claim
	 * exclusive ownership, so we'll request them explicitly once found.
	 */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
	if (!base)
		return -ENOMEM;

	arm_ni_probe_domain(base, &cfg);
	if (cfg.type != NI_GLOBAL)
		return -ENODEV;

	reg = readl_relaxed(cfg.base + NI_PERIPHERAL_ID0);
	part = FIELD_GET(NI_PIDR0_PART_7_0, reg);
	reg = readl_relaxed(cfg.base + NI_PERIPHERAL_ID1);
	part |= FIELD_GET(NI_PIDR1_PART_11_8, reg) << 8;

	switch (part) {
	case PART_NI_700:
	case PART_NI_710AE:
		break;
	default:
		dev_WARN(&pdev->dev, "Unknown part number: 0x%03x, this may go badly\n", part);
		break;
	}

	num_cds = 0;
	for (int v = 0; v < cfg.num_components; v++) {
		reg = readl_relaxed(cfg.base + NI_CHILD_PTR(v));
		arm_ni_probe_domain(base + reg, &vd);
		for (int p = 0; p < vd.num_components; p++) {
			reg = readl_relaxed(vd.base + NI_CHILD_PTR(p));
			arm_ni_probe_domain(base + reg, &pd);
			num_cds += pd.num_components;
		}
	}

	ni = devm_kzalloc(&pdev->dev, struct_size(ni, cds, num_cds), GFP_KERNEL);
	if (!ni)
		return -ENOMEM;

	ni->dev = &pdev->dev;
	ni->base = base;
	ni->num_cds = num_cds;
	ni->part = part;
	ni->id = atomic_fetch_inc(&id);

	for (int v = 0; v < cfg.num_components; v++) {
		reg = readl_relaxed(cfg.base + NI_CHILD_PTR(v));
		arm_ni_probe_domain(base + reg, &vd);
		for (int p = 0; p < vd.num_components; p++) {
			reg = readl_relaxed(vd.base + NI_CHILD_PTR(p));
			arm_ni_probe_domain(base + reg, &pd);
			for (int c = 0; c < pd.num_components; c++) {
				int ret;

				reg = readl_relaxed(pd.base + NI_CHILD_PTR(c));
				arm_ni_probe_domain(base + reg, &cd);
				ret = arm_ni_init_cd(ni, &cd, res->start);
				if (ret) {
					ni->cds[cd.id].pmu_base = NULL;
					arm_ni_remove(pdev);
					return ret;
				}
			}
		}
	}

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38318

2. Vulnerability Type
NULL pointer dereference (error-path cleanup bug in platform driver)

3. Root Cause Summary
The probe routine arm_ni_probe() failed to associate its allocated device state (struct arm_ni *ni) with the platform device via platform_set_drvdata(). On initialization failure, arm_ni_probe() called arm_ni_remove(pdev), which in turn uses platform_get_drvdata(pdev). Because drvdata was never set, platform_get_drvdata() returned NULL and arm_ni_remove() dereferenced it, causing a kernel NULL pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
perf: ARM Network Interconnect (arm-ni) PMU platform driver

2) Pre-Patch Flaw:
arm_ni_probe() allocated and initialized ni but did not call platform_set_drvdata(pdev, ni) before any path that invokes arm_ni_remove(). The cleanup path inside probe executes arm_ni_remove(pdev) on failure without a valid drvdata to retrieve.

3) Trigger Condition:
Any failure in initializing a child component during probe, specifically when arm_ni_init_cd(ni, &cd, res->start) returns non-zero, leading to the error path that calls arm_ni_remove(pdev) before drvdata was set.

4) Impact Mechanism:
arm_ni_remove() calls platform_get_drvdata(pdev), receives NULL, and dereferences it, resulting in a kernel NULL pointer dereference and crash (denial of service) during device bind/probe or removal.

5. Patch Analysis
1) Fix Approach:
Ensure the driver’s private state is registered with the platform device early in probe so that any subsequent remove/cleanup path can safely retrieve it.

2) Key Code Changes:
Added a single line in arm_ni_probe() after initializing ni fields:
- platform_set_drvdata(pdev, ni);
This guarantees arm_ni_remove() can obtain a valid ni via platform_get_drvdata() even on early failures.

3) Locking/Concurrency Impact:
No locking or concurrency changes. The fix is purely an initialization ordering correction ensuring drvdata is set before any potential cleanup calls.

6. Broader Kernel Security Implications
This bug highlights the importance of establishing device-driver associations (drvdata) before any operation that might invoke remove/cleanup paths, especially in complex probe sequences with multiple failure points. Similar missing drvdata initializations in other drivers can lead to systemic NULL dereferences and easy denial-of-service conditions during device probing. Ensuring consistent driver core patterns (set drvdata immediately after allocation) improves robustness and reduces attack surface tied to error handling paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.