You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38318

[INFO]
[PATCH_DESCRIPTION]
    perf: arm-ni: Fix missing platform_set_drvdata()
    Add missing platform_set_drvdata in arm_ni_probe(), otherwise
    calling platform_get_drvdata() in remove returns NULL.

[PATCH_DIFF]
    @@ -660,6 +660,7 @@ static int arm_ni_probe(struct platform_device *pdev)
     	ni->num_cds = num_cds;
     	ni->part = part;
     	ni->id = atomic_fetch_inc(&id);
    +	platform_set_drvdata(pdev, ni);
     
     	for (int v = 0; v < cfg.num_components; v++) {
     		reg = readl_relaxed(cfg.base + NI_CHILD_PTR(v));



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38318

2. Vulnerability Type
NULL pointer dereference in device remove/unbind path due to missing driver data association

3. Root Cause Summary
The arm-ni perf driver failed to associate its per-device state (struct ni) with the platform_device during probe. Specifically, arm_ni_probe() initialized ni but did not call platform_set_drvdata(pdev, ni). As a result, the remove path’s platform_get_drvdata() returned NULL, leading to a NULL dereference or incomplete cleanup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux perf subsystem, ARM NI (arm-ni) platform driver

2) Pre-Patch Flaw:
arm_ni_probe() allocated/initialized ni (setting ni->num_cds, ni->part, ni->id via atomic_fetch_inc(&id)) but omitted platform_set_drvdata(), leaving no reference to ni attached to the platform device.

3) Trigger Condition:
Invoking the driver’s remove/unbind path (e.g., device hot-unplug, driver unbind, or module unload) which calls platform_get_drvdata() expecting a valid ni pointer.

4) Impact Mechanism:
platform_get_drvdata() returns NULL and the remove routine, which expects a valid ni, may dereference it, causing a kernel oops/panic (DoS); at minimum, proper resource teardown cannot occur, risking leaks or inconsistent state.

5. Patch Analysis
1) Fix Approach:
Bind the driver’s private data to the platform_device during probe by calling platform_set_drvdata(pdev, ni) after ni is initialized.

2) Key Code Changes:
In arm_ni_probe(), immediately after setting ni->num_cds, ni->part, and ni->id = atomic_fetch_inc(&id), the patch adds:
- platform_set_drvdata(pdev, ni);
This ensures subsequent platform_get_drvdata() calls in remove return the correct ni.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is a one-time association established in probe and consumed in remove, preserving existing ordering and atomicity semantics.

6. Broader Kernel Security Implications
Cleanup-path bugs from missing platform_set_drvdata() can convert routine unbind/remove operations into kernel crashes, undermining system stability. This pattern highlights the need for consistent driver data registration in probe to ensure safe teardown. While typically triggered by privileged operations, such faults can still lead to denial-of-service conditions during device hotplug events or driver lifecycle management.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}