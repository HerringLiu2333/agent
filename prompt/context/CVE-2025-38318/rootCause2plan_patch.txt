You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38318

[INFO]
[PATCH_DESCRIPTION]
    perf: arm-ni: Fix missing platform_set_drvdata()
    Add missing platform_set_drvdata in arm_ni_probe(), otherwise
    calling platform_get_drvdata() in remove returns NULL.

[PATCH_DIFF]
    @@ -660,6 +660,7 @@ static int arm_ni_probe(struct platform_device *pdev)
     	ni->num_cds = num_cds;
     	ni->part = part;
     	ni->id = atomic_fetch_inc(&id);
    +	platform_set_drvdata(pdev, ni);
     
     	for (int v = 0; v < cfg.num_components; v++) {
     		reg = readl_relaxed(cfg.base + NI_CHILD_PTR(v));



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38318

2. Vulnerability Type
NULL pointer dereference in device remove/unbind path due to missing driver data association

3. Root Cause Summary
The arm-ni perf driver failed to associate its per-device state (struct ni) with the platform_device during probe. Specifically, arm_ni_probe() initialized ni but did not call platform_set_drvdata(pdev, ni). As a result, the remove path’s platform_get_drvdata() returned NULL, leading to a NULL dereference or incomplete cleanup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux perf subsystem, ARM NI (arm-ni) platform driver

2) Pre-Patch Flaw:
arm_ni_probe() allocated/initialized ni (setting ni->num_cds, ni->part, ni->id via atomic_fetch_inc(&id)) but omitted platform_set_drvdata(), leaving no reference to ni attached to the platform device.

3) Trigger Condition:
Invoking the driver’s remove/unbind path (e.g., device hot-unplug, driver unbind, or module unload) which calls platform_get_drvdata() expecting a valid ni pointer.

4) Impact Mechanism:
platform_get_drvdata() returns NULL and the remove routine, which expects a valid ni, may dereference it, causing a kernel oops/panic (DoS); at minimum, proper resource teardown cannot occur, risking leaks or inconsistent state.

5. Patch Analysis
1) Fix Approach:
Bind the driver’s private data to the platform_device during probe by calling platform_set_drvdata(pdev, ni) after ni is initialized.

2) Key Code Changes:
In arm_ni_probe(), immediately after setting ni->num_cds, ni->part, and ni->id = atomic_fetch_inc(&id), the patch adds:
- platform_set_drvdata(pdev, ni);
This ensures subsequent platform_get_drvdata() calls in remove return the correct ni.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is a one-time association established in probe and consumed in remove, preserving existing ordering and atomicity semantics.

6. Broader Kernel Security Implications
Cleanup-path bugs from missing platform_set_drvdata() can convert routine unbind/remove operations into kernel crashes, undermining system stability. This pattern highlights the need for consistent driver data registration in probe to ensure safe teardown. While typically triggered by privileged operations, such faults can still lead to denial-of-service conditions during device hotplug events or driver lifecycle management.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.