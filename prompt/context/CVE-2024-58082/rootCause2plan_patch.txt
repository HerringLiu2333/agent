You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58082

[INFO]
[PATCH_DESCRIPTION]
 media: nuvoton: Fix an error check in npcm_video_ece_init()
 When function of_find_device_by_node() fails, it returns NULL instead of
 an error code. So the corresponding error check logic should be modified
 to check whether the return value is NULL and set the error code to be
 returned as -ENODEV.
 
 Fixes: 46c15a4ff1f4 ("media: nuvoton: Add driver for NPCM video capture and encoding engine")

[PATCH_DIFF]
 diff --git a/drivers/media/platform/nuvoton/npcm-video.c b/drivers/media/platform/nuvoton/npcm-video.c
 index 4f5d75645b2bb9…024cd8ee17098d 100644
 --- a/drivers/media/platform/nuvoton/npcm-video.c
 +++ b/drivers/media/platform/nuvoton/npcm-video.c
 @@ -1665,9 +1665,9 @@ static int npcm_video_ece_init(struct npcm_video *video)
 dev_info(dev, “Support HEXTILE pixel format\n”);

   ece_pdev = of_find_device_by_node(ece_node);
 - if (IS_ERR(ece_pdev)) {
 + if (!ece_pdev) {
   dev_err(dev, “Failed to find ECE device\n”);
 - return PTR_ERR(ece_pdev);
 + return -ENODEV;
 }
   of_node_put(ece_node);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58082

2. Vulnerability Type
NULL pointer dereference due to improper error handling/API misuse (ERR_PTR vs NULL)

3. Root Cause Summary
The function npcm_video_ece_init() incorrectly treated the return value of of_find_device_by_node() as an ERR_PTR and checked it with IS_ERR(), then used PTR_ERR() for the return code. of_find_device_by_node() returns NULL on failure, not an ERR_PTR, so the failure path was never taken when ece_pdev was NULL. This allowed subsequent code to proceed with a NULL ece_pdev, leading to a potential NULL pointer dereference and incorrect error propagation (PTR_ERR(NULL) semantics).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
media platform driver for Nuvoton NPCM video capture and encoding engine (drivers/media/platform/nuvoton/npcm-video.c)

2) Pre-Patch Flaw:
In npcm_video_ece_init(), the code performed “ece_pdev = of_find_device_by_node(ece_node); if (IS_ERR(ece_pdev)) … return PTR_ERR(ece_pdev);”. This is incompatible with the API, which returns NULL on failure, not an ERR_PTR, resulting in missed error detection.

3) Trigger Condition:
of_find_device_by_node() fails to find/associate a device for the provided device-tree node (ece_node) and returns NULL (e.g., missing ECE device node or unbound device).

4) Impact Mechanism:
Because IS_ERR(NULL) is false, the function did not return on failure and continued assuming ece_pdev was valid. Subsequent use of ece_pdev in initialization could dereference NULL, causing a kernel oops/DoS; additionally, any attempted error return via PTR_ERR(ece_pdev) would be incorrect if reached, potentially yielding 0 and masking the failure.

5. Patch Analysis
1) Fix Approach:
Correct the error handling to match the API contract: check for a NULL return from of_find_device_by_node() and return a defined error (-ENODEV).

2) Key Code Changes:
- Replaced “if (IS_ERR(ece_pdev))” with “if (!ece_pdev)”.
- Replaced “return PTR_ERR(ece_pdev)” with “return -ENODEV”.
These changes ensure failure is detected and a proper error code is returned.

3) Locking/Concurrency Impact:
No locking or concurrency changes were made or required; the fix strictly corrects error detection and return value handling.

6. Broader Kernel Security Implications
Consistent adherence to API return conventions (ERR_PTR vs NULL) is critical to avoid kernel crashes from NULL dereferences, especially during device initialization paths. Such mischecks can lead to denial-of-service if an attacker or misconfiguration causes the referenced device to be absent, crashing the subsystem at probe/init. The fix reinforces robust error handling patterns across drivers, reducing the risk of similar failures and improving system stability.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.