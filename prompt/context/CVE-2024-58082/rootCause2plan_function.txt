You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58082

[INFO]
[PATCH_DESCRIPTION]
 media: nuvoton: Fix an error check in npcm_video_ece_init()
 When function of_find_device_by_node() fails, it returns NULL instead of
 an error code. So the corresponding error check logic should be modified
 to check whether the return value is NULL and set the error code to be
 returned as -ENODEV.
 
 Fixes: 46c15a4ff1f4 ("media: nuvoton: Add driver for NPCM video capture and encoding engine")

[PATCH_DIFF]
 diff --git a/drivers/media/platform/nuvoton/npcm-video.c b/drivers/media/platform/nuvoton/npcm-video.c
 index 4f5d75645b2bb9…024cd8ee17098d 100644
 --- a/drivers/media/platform/nuvoton/npcm-video.c
 +++ b/drivers/media/platform/nuvoton/npcm-video.c
 @@ -1665,9 +1665,9 @@ static int npcm_video_ece_init(struct npcm_video *video)
 dev_info(dev, “Support HEXTILE pixel format\n”);

   ece_pdev = of_find_device_by_node(ece_node);
 - if (IS_ERR(ece_pdev)) {
 + if (!ece_pdev) {
   dev_err(dev, “Failed to find ECE device\n”);
 - return PTR_ERR(ece_pdev);
 + return -ENODEV;
 }
   of_node_put(ece_node);

[FUNCTION_CONTENT]
static int npcm_video_ece_init(struct npcm_video *video)
{
	struct device *dev = video->dev;
	struct device_node *ece_node;
	struct platform_device *ece_pdev;
	void __iomem *regs;

	ece_node = of_parse_phandle(video->dev->of_node, "nuvoton,ece", 0);
	if (!ece_node) {
		dev_err(dev, "Failed to get ECE phandle in DTS\n");
		return -ENODEV;
	}

	video->ece.enable = of_device_is_available(ece_node);

	if (video->ece.enable) {
		dev_info(dev, "Support HEXTILE pixel format\n");

		ece_pdev = of_find_device_by_node(ece_node);
		if (IS_ERR(ece_pdev)) {
			dev_err(dev, "Failed to find ECE device\n");
			return PTR_ERR(ece_pdev);
		}
		of_node_put(ece_node);

		regs = devm_platform_ioremap_resource(ece_pdev, 0);
		if (IS_ERR(regs)) {
			dev_err(dev, "Failed to parse ECE reg in DTS\n");
			return PTR_ERR(regs);
		}

		video->ece.regmap = devm_regmap_init_mmio(dev, regs,
							  &npcm_video_ece_regmap_cfg);
		if (IS_ERR(video->ece.regmap)) {
			dev_err(dev, "Failed to initialize ECE regmap\n");
			return PTR_ERR(video->ece.regmap);
		}

		video->ece.reset = devm_reset_control_get(&ece_pdev->dev, NULL);
		if (IS_ERR(video->ece.reset)) {
			dev_err(dev, "Failed to get ECE reset control in DTS\n");
			return PTR_ERR(video->ece.reset);
		}
	}

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58082

2. Vulnerability Type
NULL pointer dereference due to incorrect error handling (pointer misuse)

3. Root Cause Summary
The function npcm_video_ece_init() incorrectly assumed of_find_device_by_node() returns an ERR_PTR on failure and used IS_ERR/PTR_ERR to handle errors. In reality, of_find_device_by_node() returns NULL on failure. Because the code did not check for NULL, a NULL ece_pdev was later dereferenced (e.g., in devm_platform_ioremap_resource(ece_pdev, 0)), causing a kernel crash.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux media subsystem, Nuvoton NPCM video capture and encoding engine driver (drivers/media/platform/nuvoton/npcm-video.c).

2) Pre-Patch Flaw:
In npcm_video_ece_init(), the pre-patch code used "if (IS_ERR(ece_pdev))" after calling of_find_device_by_node(ece_node). Since that API returns NULL on failure (not ERR_PTR), the error path was never taken, and subsequent code used ece_pdev without validating it was non-NULL.

3) Trigger Condition:
An ECE device node exists and is marked available (of_device_is_available(ece_node) true), but of_find_device_by_node(ece_node) fails and returns NULL (e.g., the platform device is not registered/bound yet or missing).

4) Impact Mechanism:
The function proceeds with a NULL ece_pdev and dereferences it in devm_platform_ioremap_resource(ece_pdev, 0) and later accesses ece_pdev->dev for reset control, resulting in a NULL pointer dereference and kernel crash (denial of service).

5. Patch Analysis
1) Fix Approach:
Adjust the error handling to detect NULL return values from of_find_device_by_node() and return a proper error code (-ENODEV) instead of attempting PTR_ERR().

2) Key Code Changes:
- Replace "if (IS_ERR(ece_pdev))" with "if (!ece_pdev)" to correctly detect failure.
- Replace "return PTR_ERR(ece_pdev);" with "return -ENODEV;" to return a meaningful error when the device is not found.

3) Locking/Concurrency Impact:
None. The patch only corrects error-path logic and does not alter locking, ordering, or concurrency mechanisms.

6. Broader Kernel Security Implications
Correctly handling NULL vs. ERR_PTR returns from OF and device discovery APIs prevents common crash paths in drivers, especially during probe sequences or with incomplete/misalconfigured device trees. This fix reduces the risk of denial-of-service conditions caused by improper error checks and reinforces the need for consistent API usage patterns in kernel drivers. Auditing similar error-handling patterns across drivers can prevent comparable vulnerabilities.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.