You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38486

[INFO]
[PATCH_DESCRIPTION]
    soundwire: Revert "soundwire: qcom: Add set_channel_map api support"
    This reverts commit 7796c97df6b1b2206681a07f3c80f6023a6593d5.
    
    This patch broke Dragonboard 845c (sdm845). I see:
    
        Unexpected kernel BRK exception at EL1
        Internal error: BRK handler: 00000000f20003e8 [#1]  SMP
        pc : qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom]
        lr : snd_soc_dai_set_channel_map+0x34/0x78
        Call trace:
         qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] (P)
         sdm845_dai_init+0x18c/0x2e0 [snd_soc_sdm845]
         snd_soc_link_init+0x28/0x6c
         snd_soc_bind_card+0x5f4/0xb0c
         snd_soc_register_card+0x148/0x1a4
         devm_snd_soc_register_card+0x50/0xb0
         sdm845_snd_platform_probe+0x124/0x148 [snd_soc_sdm845]
         platform_probe+0x6c/0xd0
         really_probe+0xc0/0x2a4
         __driver_probe_device+0x7c/0x130
         driver_probe_device+0x40/0x118
         __device_attach_driver+0xc4/0x108
         bus_for_each_drv+0x8c/0xf0
         __device_attach+0xa4/0x198
         device_initial_probe+0x18/0x28
         bus_probe_device+0xb8/0xbc
         deferred_probe_work_func+0xac/0xfc
         process_one_work+0x244/0x658
         worker_thread+0x1b4/0x360
         kthread+0x148/0x228
         ret_from_fork+0x10/0x20
        Kernel panic - not syncing: BRK handler: Fatal exception
    
    Dan has also reported following issues with the original patch
    https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/
    
    Bug #1:
    The zeroeth element of ctrl->pconfig[] is supposed to be unused.  We
    start counting at 1.  However this code sets ctrl->pconfig[0].ch_mask = 128.
    
    Bug #2:
    There are SLIM_MAX_TX_PORTS (16) elements in tx_ch[] array but only
    QCOM_SDW_MAX_PORTS + 1 (15) in the ctrl->pconfig[] array so it corrupts
    memory like Yongqin Liu pointed out.
    
    Bug 3:
    Like Jie Gan pointed out, it erases all the tx information with the rx
    information.

[PATCH_DIFF]
    @@ -1275,26 +1270,6 @@ static void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)
     	return ctrl->sruntime[dai->id];
     }
     
    -static int qcom_swrm_set_channel_map(struct snd_soc_dai *dai,
    -				     unsigned int tx_num, const unsigned int *tx_slot,
    -				     unsigned int rx_num, const unsigned int *rx_slot)
    -{
    -	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
    -	int i;
    -
    -	if (tx_slot) {
    -		for (i = 0; i < tx_num; i++)
    -			ctrl->pconfig[i].ch_mask = tx_slot[i];
    -	}
    -
    -	if (rx_slot) {
    -		for (i = 0; i < rx_num; i++)
    -			ctrl->pconfig[i].ch_mask = rx_slot[i];
    -	}
    -
    -	return 0;
    -}
    -
     static int qcom_swrm_startup(struct snd_pcm_substream *substream,
     			     struct snd_soc_dai *dai)
     {
    @@ -1331,7 +1306,6 @@ static const struct snd_soc_dai_ops qcom_swrm_pdm_dai_ops = {
     	.shutdown = qcom_swrm_shutdown,
     	.set_stream = qcom_swrm_set_sdw_stream,
     	.get_stream = qcom_swrm_get_sdw_stream,
    -	.set_channel_map = qcom_swrm_set_channel_map,
     };
     
     static const struct snd_soc_component_driver qcom_swrm_dai_component = {



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38486

2. Vulnerability Type
Out-of-bounds array write and improper index handling (memory corruption), plus logic error overwriting TX configuration with RX configuration. Resulting in kernel panic (denial-of-service).

3. Root Cause Summary
The pre-patch implementation of qcom_swrm_set_channel_map wrote channel masks into ctrl->pconfig[] starting at index 0 and without any bounds checking, despite pconfig[0] being reserved/unused and the array being smaller than the potential number of TX slots. Specifically, it performed:
- for TX: “for (i = 0; i < tx_num; i++) ctrl->pconfig[i].ch_mask = tx_slot[i];”
- for RX: “for (i = 0; i < rx_num; i++) ctrl->pconfig[i].ch_mask = rx_slot[i];”
This introduced multiple defects: writing to pconfig[0]; possible overflow when tx_num=SLIM_MAX_TX_PORTS (16) while ctrl->pconfig has only QCOM_SDW_MAX_PORTS + 1 (15) elements; and overwriting previously written TX configuration with RX configuration. These unsafe writes corrupted kernel memory and triggered a BRK exception and panic during board initialization.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SoundWire Qualcomm ASoC driver (soundwire: qcom), specifically the DAI ops and channel mapping in soundwire_qcom.

2) Pre-Patch Flaw:
qcom_swrm_set_channel_map directly wrote tx_slot[] and rx_slot[] into ctrl->pconfig[i].ch_mask with i starting at 0, no capacity checks against ctrl->pconfig[], and no separation between TX and RX mappings. It violated the invariant that pconfig[0] must remain unused and allowed i to exceed the array length (QCOM_SDW_MAX_PORTS + 1) when tx_num/rx_num were larger.

3) Trigger Condition:
Invocation of snd_soc_dai_set_channel_map during DAI initialization (sdm845_dai_init) with tx_num up to SLIM_MAX_TX_PORTS (16) and corresponding slot arrays, causing the TX loop to write beyond ctrl->pconfig[] bounds and to pconfig[0]. Any subsequent RX mapping call further overwrote the same array entries.

4) Impact Mechanism:
Out-of-bounds writes and reserved-index writes corrupt adjacent kernel memory within the driver’s control structure, leading to a fatal exception (BRK) and kernel panic, as observed on Dragonboard 845c (sdm845). Overwriting TX with RX also destroys configuration state, contributing to instability.

5. Patch Analysis
1) Fix Approach:
Full revert of the faulty API addition. The patch removes qcom_swrm_set_channel_map and unregisters the .set_channel_map DAI op, eliminating the unsafe code path.

2) Key Code Changes:
- Deleted qcom_swrm_set_channel_map implementation.
- Removed “.set_channel_map = qcom_swrm_set_channel_map,” from qcom_swrm_pdm_dai_ops, preventing snd_soc_dai_set_channel_map from reaching this driver.

3) Locking/Concurrency Impact:
None. The vulnerability was due to incorrect memory access and logic; no locking or concurrency primitives were involved or changed by the revert.

6. Broader Kernel Security Implications
Kernel drivers must rigorously validate indices and lengths, preserve invariants (e.g., reserved array slots), and avoid conflating directional configurations to prevent memory corruption. Exposing unsafe DAI ops can allow user space or topology configuration to trigger kernel crashes, undermining system stability. The revert reduces attack surface; any future reintroduction must add strict bounds checks, respect pconfig[0] being unused, maintain separate TX/RX mappings, and ensure array size alignment with SLIM/SDW port counts.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}