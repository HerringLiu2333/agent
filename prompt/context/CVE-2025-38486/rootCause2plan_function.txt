You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38486

[INFO]
[PATCH_DESCRIPTION]
    soundwire: Revert "soundwire: qcom: Add set_channel_map api support"
    This reverts commit 7796c97df6b1b2206681a07f3c80f6023a6593d5.
    
    This patch broke Dragonboard 845c (sdm845). I see:
    
        Unexpected kernel BRK exception at EL1
        Internal error: BRK handler: 00000000f20003e8 [#1]  SMP
        pc : qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom]
        lr : snd_soc_dai_set_channel_map+0x34/0x78
        Call trace:
         qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] (P)
         sdm845_dai_init+0x18c/0x2e0 [snd_soc_sdm845]
         snd_soc_link_init+0x28/0x6c
         snd_soc_bind_card+0x5f4/0xb0c
         snd_soc_register_card+0x148/0x1a4
         devm_snd_soc_register_card+0x50/0xb0
         sdm845_snd_platform_probe+0x124/0x148 [snd_soc_sdm845]
         platform_probe+0x6c/0xd0
         really_probe+0xc0/0x2a4
         __driver_probe_device+0x7c/0x130
         driver_probe_device+0x40/0x118
         __device_attach_driver+0xc4/0x108
         bus_for_each_drv+0x8c/0xf0
         __device_attach+0xa4/0x198
         device_initial_probe+0x18/0x28
         bus_probe_device+0xb8/0xbc
         deferred_probe_work_func+0xac/0xfc
         process_one_work+0x244/0x658
         worker_thread+0x1b4/0x360
         kthread+0x148/0x228
         ret_from_fork+0x10/0x20
        Kernel panic - not syncing: BRK handler: Fatal exception
    
    Dan has also reported following issues with the original patch
    https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/
    
    Bug #1:
    The zeroeth element of ctrl->pconfig[] is supposed to be unused.  We
    start counting at 1.  However this code sets ctrl->pconfig[0].ch_mask = 128.
    
    Bug #2:
    There are SLIM_MAX_TX_PORTS (16) elements in tx_ch[] array but only
    QCOM_SDW_MAX_PORTS + 1 (15) in the ctrl->pconfig[] array so it corrupts
    memory like Yongqin Liu pointed out.
    
    Bug 3:
    Like Jie Gan pointed out, it erases all the tx information with the rx
    information.

[PATCH_DIFF]
    @@ -1275,26 +1270,6 @@ static void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)
     	return ctrl->sruntime[dai->id];
     }
     
    -static int qcom_swrm_set_channel_map(struct snd_soc_dai *dai,
    -				     unsigned int tx_num, const unsigned int *tx_slot,
    -				     unsigned int rx_num, const unsigned int *rx_slot)
    -{
    -	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
    -	int i;
    -
    -	if (tx_slot) {
    -		for (i = 0; i < tx_num; i++)
    -			ctrl->pconfig[i].ch_mask = tx_slot[i];
    -	}
    -
    -	if (rx_slot) {
    -		for (i = 0; i < rx_num; i++)
    -			ctrl->pconfig[i].ch_mask = rx_slot[i];
    -	}
    -
    -	return 0;
    -}
    -
     static int qcom_swrm_startup(struct snd_pcm_substream *substream,
     			     struct snd_soc_dai *dai)
     {
    @@ -1331,7 +1306,6 @@ static const struct snd_soc_dai_ops qcom_swrm_pdm_dai_ops = {
     	.shutdown = qcom_swrm_shutdown,
     	.set_stream = qcom_swrm_set_sdw_stream,
     	.get_stream = qcom_swrm_get_sdw_stream,
    -	.set_channel_map = qcom_swrm_set_channel_map,
     };
     
     static const struct snd_soc_component_driver qcom_swrm_dai_component = {

[FUNCTION_CONTENT]
static void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)
{
	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);

	return ctrl->sruntime[dai->id];
}

/* ----- separator ----- */

static int qcom_swrm_set_channel_map(struct snd_soc_dai *dai,
				     unsigned int tx_num, const unsigned int *tx_slot,
				     unsigned int rx_num, const unsigned int *rx_slot)
{
	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
	int i;

	if (tx_slot) {
		for (i = 0; i < tx_num; i++)
			ctrl->pconfig[i].ch_mask = tx_slot[i];
	}

	if (rx_slot) {
		for (i = 0; i < rx_num; i++)
			ctrl->pconfig[i].ch_mask = rx_slot[i];
	}

	return 0;
}

/* ----- separator ----- */

static int qcom_swrm_startup(struct snd_pcm_substream *substream,
			     struct snd_soc_dai *dai)
{
	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
	int ret;

	ret = pm_runtime_get_sync(ctrl->dev);
	if (ret < 0 && ret != -EACCES) {
		dev_err_ratelimited(ctrl->dev,
				    "pm_runtime_get_sync failed in %s, ret %d\n",
				    __func__, ret);
		pm_runtime_put_noidle(ctrl->dev);
		return ret;
	}

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38486

2. Vulnerability Type
Out-of-bounds write due to incorrect indexing and missing bounds validation; state corruption from overlapping data writes.

3. Root Cause Summary
The pre-patch qcom_swrm_set_channel_map function wrote channel masks into ctrl->pconfig[] starting at index 0 and iterating up to tx_num/rx_num without validating array bounds. Element 0 of ctrl->pconfig[] is reserved/unused, but the code still wrote to it (off-by-one start index). The function did not cap writes to the size of ctrl->pconfig[] (QCOM_SDW_MAX_PORTS + 1), while tx_num could be SLIM_MAX_TX_PORTS (16), causing out-of-bounds writes. The same pconfig[] array was used for both TX and RX loops, so RX writes overwrote previously set TX values, corrupting driver state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ASoC SoundWire Qualcomm controller driver (soundwire: qcom)

2) Pre-Patch Flaw:
qcom_swrm_set_channel_map used “for (i = 0; i < tx_num; i++) ctrl->pconfig[i].ch_mask = tx_slot[i];” (and similarly for RX) without:
- Starting from index 1 as required (element 0 is unused).
- Any bounds checks against ctrl->pconfig[] length (QCOM_SDW_MAX_PORTS + 1).
- Separation of TX and RX storage, causing RX writes to overwrite TX configuration.

3) Trigger Condition:
Invocation of snd_soc_dai_set_channel_map during ASoC card initialization (seen in the call trace via sdm845_dai_init → snd_soc_dai_set_channel_map), with tx_num/rx_num and slot arrays provided by the platform, including cases where tx_num == SLIM_MAX_TX_PORTS (16) and RX mapping also present.

4) Impact Mechanism:
- Out-of-bounds writes into ctrl->pconfig[] corrupt adjacent kernel memory, leading to a BRK exception and kernel panic (as observed on Dragonboard 845c).
- Overwriting TX configuration with RX values corrupts channel mapping state, potentially breaking audio routing and stability.

5. Patch Analysis
1) Fix Approach:
Full revert of the set_channel_map support, removing the flawed function and its registration from DAI ops to eliminate the unsafe path entirely.

2) Key Code Changes:
- Deleted qcom_swrm_set_channel_map implementation that wrote to ctrl->pconfig[] based on tx_slot/rx_slot.
- Removed .set_channel_map assignment from qcom_swrm_pdm_dai_ops, preventing calls to the removed function.

3) Locking/Concurrency Impact:
No locking changes; the issue was not concurrency-related. The revert removes unsafe memory writes, eliminating the corruption risk without affecting synchronization primitives.

6. Broader Kernel Security Implications
Unchecked indices and size mismatches in kernel drivers can produce exploitable memory corruption, not just crashes. Audio drivers must rigorously validate array bounds, respect reserved indices, and avoid overlapping buffers for different data directions (TX/RX). The revert mitigates immediate risk; any future reintroduction must include bounds checks, correct index start (1-based), and separate or properly indexed TX/RX mappings to preserve memory safety and system stability.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.