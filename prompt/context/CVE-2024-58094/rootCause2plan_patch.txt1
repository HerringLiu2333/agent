You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58094

[INFO]
[PATCH_DESCRIPTION]
 jfs: add check read-only before truncation in jfs_truncate_nolock()
 [ Upstream commit b5799dd77054c1ec49b0088b006c9908e256843b ]
 
 Added a check for "read-only" mode in the `jfs_truncate_nolock`
 function to avoid errors related to writing to a read-only
 filesystem.
 
 Call stack:
 
 block_write_begin() {
   jfs_write_failed() {
     jfs_truncate() {
       jfs_truncate_nolock() {
         txEnd() {
           ...
           log = JFS_SBI(tblk->sb)->log;
           // (log == NULL)
 
 If the `isReadOnly(ip)` condition is triggered in
 `jfs_truncate_nolock`, the function execution will stop, and no
 further data modification will occur. Instead, the `xtTruncate`
 function will be called with the "COMMIT_WMAP" flag, preventing
 modifications in "read-only" mode.

 Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")

[PATCH_DIFF]
 diff --git a/fs/jfs/inode.c b/fs/jfs/inode.c
 index 07cfdc4405968b…60fc92dee24d20 100644
 --- a/fs/jfs/inode.c
 +++ b/fs/jfs/inode.c
 @@ -369,7 +369,7 @@ void jfs_truncate_nolock(struct inode *ip, loff_t length)

   ASSERT(length >= 0);

 - if (test_cflag(COMMIT_Nolink, ip)) {
 + if (test_cflag(COMMIT_Nolink, ip) || isReadOnly(ip)) {
   xtTruncate(0, ip, length, COMMIT_WMAP);
   return;
 }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58094

2. Vulnerability Type
Improper state validation leading to NULL pointer dereference and kernel crash (DoS) during truncate on a read-only JFS filesystem.

3. Root Cause Summary
jfs_truncate_nolock() did not check whether the inode/filesystem was read-only before proceeding with truncate-related journaling/commit logic. On read-only mounts, the JFS journal/log pointer is NULL, so continuing into transactional cleanup (e.g., txEnd()) dereferenced a NULL log pointer, causing a crash. The patch adds isReadOnly(ip) to the early-return condition, ensuring a safe truncate path using COMMIT_WMAP that does not perform write/journal operations on read-only filesystems.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem (fs/jfs), truncate/journaling path in jfs_truncate_nolock().

2) Pre-Patch Flaw:
jfs_truncate_nolock() only checked test_cflag(COMMIT_Nolink, ip) and lacked a read-only check, allowing a truncate path that initiates transactional/journal operations even when the filesystem is read-only. In the read-only case, JFS_SBI(tblk->sb)->log is NULL, and subsequent transaction completion (txEnd()) assumes a valid log.

3) Trigger Condition:
Calling jfs_truncate_nolock() on a read-only JFS filesystem, e.g., via the sequence block_write_begin() -> jfs_write_failed() -> jfs_truncate() -> jfs_truncate_nolock() on a read-only mount.

4) Impact Mechanism:
Proceeding without a read-only guard leads to accessing the NULL journal/log pointer during transaction end, causing a NULL pointer dereference and kernel oops/crash (denial of service). It also risks unintended write attempts on a read-only filesystem.

5. Patch Analysis
1) Fix Approach:
Add a read-only state check and bail out early to a truncate path that uses COMMIT_WMAP, which avoids journal/log writes on read-only mounts.

2) Key Code Changes:
In fs/jfs/inode.c jfs_truncate_nolock():
- Original: if (test_cflag(COMMIT_Nolink, ip)) { xtTruncate(..., COMMIT_WMAP); return; }
- Patched: if (test_cflag(COMMIT_Nolink, ip) || isReadOnly(ip)) { xtTruncate(..., COMMIT_WMAP); return; }
This ensures read-only mode triggers the safe, non-writing truncate path.

3) Locking/Concurrency Impact:
No locking or concurrency changes were made; the patch strictly adds a state validation guard and early return, preventing entry into journaling/txEnd on read-only mounts.

6. Broader Kernel Security Implications
This change enforces proper state validation before invoking filesystem journal/commit operations, reducing a class of local DoS issues where read-only mounts could trigger NULL dereferences in write paths. It highlights the need for consistent read-only checks across filesystem write/modify flows. Ensuring journal/log availability is validated before use improves robustness and prevents crashes from routine VFS callbacks that may reach truncate logic even when writes are disallowed.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}