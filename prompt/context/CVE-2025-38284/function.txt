static bool rtw89_pci_is_dac_compatible_bridge(struct rtw89_dev *rtwdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;
	struct pci_dev *bridge = pci_upstream_bridge(rtwpci->pdev);

	if (!rtw89_pci_chip_is_manual_dac(rtwdev))
		return true;

	if (!bridge)
		return false;

	switch (bridge->vendor) {
	case PCI_VENDOR_ID_INTEL:
		return true;
	case PCI_VENDOR_ID_ASMEDIA:
		if (bridge->device == 0x2806)
			return true;
		break;
	}

	return false;
}

/* ----- separator ----- */

static void rtw89_pci_cfg_dac(struct rtw89_dev *rtwdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;

	if (!rtwpci->enable_dac)
		return;

	if (!rtw89_pci_chip_is_manual_dac(rtwdev))
		return;

	rtw89_pci_config_byte_set(rtwdev, RTW89_PCIE_L1_CTRL, RTW89_PCIE_BIT_EN_64BITS);
}

/* ----- separator ----- */

static int rtw89_pci_setup_mapping(struct rtw89_dev *rtwdev,
				   struct pci_dev *pdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;
	unsigned long resource_len;
	u8 bar_id = 2;
	int ret;

	ret = pci_request_regions(pdev, KBUILD_MODNAME);
	if (ret) {
		rtw89_err(rtwdev, "failed to request pci regions\n");
		goto err;
	}

	if (!rtw89_pci_is_dac_compatible_bridge(rtwdev))
		goto no_dac;

	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));
	if (!ret) {
		rtwpci->enable_dac = true;
		rtw89_pci_cfg_dac(rtwdev);
	} else {
		ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
		if (ret) {
			rtw89_err(rtwdev,
				  "failed to set dma and consistent mask to 32/36-bit\n");
			goto err_release_regions;
		}
	}
no_dac:

	resource_len = pci_resource_len(pdev, bar_id);
	rtwpci->mmap = pci_iomap(pdev, bar_id, resource_len);
	if (!rtwpci->mmap) {
		rtw89_err(rtwdev, "failed to map pci io\n");
		ret = -EIO;
		goto err_release_regions;
	}

	return 0;

err_release_regions:
	pci_release_regions(pdev);
err:
	return ret;
}

/* ----- separator ----- */

void rtw89_pci_basic_cfg(struct rtw89_dev *rtwdev, bool resume)
{
	if (resume)
		rtw89_pci_cfg_dac(rtwdev);

	rtw89_pci_disable_eq(rtwdev);
	rtw89_pci_filter_out(rtwdev);
	rtw89_pci_cpl_timeout_cfg(rtwdev);
	rtw89_pci_link_cfg(rtwdev);
	rtw89_pci_l1ss_cfg(rtwdev);
}