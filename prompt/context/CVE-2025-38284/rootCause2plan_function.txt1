You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38284

[INFO]
[PATCH_DESCRIPTION]
    wifi: rtw89: pci: configure manual DAC mode via PCI config API only
    To support 36-bit DMA, configure chip proprietary bit via PCI config API
    or chip DBI interface. However, the PCI device mmap isn't set yet and
    the DBI is also inaccessible via mmap, so only if the bit can be accessible
    via PCI config API, chip can support 36-bit DMA. Otherwise, fallback to
    32-bit DMA.
    
    With NULL mmap address, kernel throws trace:
    
      BUG: unable to handle page fault for address: 0000000000001090
      #PF: supervisor write access in kernel mode
      #PF: error_code(0x0002) - not-present page
      PGD 0 P4D 0
      Oops: Oops: 0002 [#1] PREEMPT SMP PTI
      CPU: 1 UID: 0 PID: 71 Comm: irq/26-pciehp Tainted: G           OE      6.14.2-061402-generic #202504101348
      Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
      RIP: 0010:rtw89_pci_ops_write16+0x12/0x30 [rtw89_pci]
      RSP: 0018:ffffb0ffc0acf9d8 EFLAGS: 00010206
      RAX: ffffffffc158f9c0 RBX: ffff94865e702020 RCX: 0000000000000000
      RDX: 0000000000000718 RSI: 0000000000001090 RDI: ffff94865e702020
      RBP: ffffb0ffc0acf9d8 R08: 0000000000000000 R09: 0000000000000000
      R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000015
      R13: 0000000000000719 R14: ffffb0ffc0acfa1f R15: ffffffffc1813060
      FS:  0000000000000000(0000) GS:ffff9486f3480000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: 0000000000001090 CR3: 0000000090440001 CR4: 00000000000626f0
      Call Trace:
       <TASK>
       rtw89_pci_read_config_byte+0x6d/0x120 [rtw89_pci]
       rtw89_pci_cfg_dac+0x5b/0xb0 [rtw89_pci]
       rtw89_pci_probe+0xa96/0xbd0 [rtw89_pci]
       ? __pfx___device_attach_driver+0x10/0x10
       ? __pfx___device_attach_driver+0x10/0x10
       local_pci_probe+0x47/0xa0
       pci_call_probe+0x5d/0x190
       pci_device_probe+0xa7/0x160
       really_probe+0xf9/0x370
       ? pm_runtime_barrier+0x55/0xa0
       __driver_probe_device+0x8c/0x140
       driver_probe_device+0x24/0xd0
       __device_attach_driver+0xcd/0x170
       bus_for_each_drv+0x99/0x100
       __device_attach+0xb4/0x1d0
       device_attach+0x10/0x20
       pci_bus_add_device+0x59/0x90
       pci_bus_add_devices+0x31/0x80
       pciehp_configure_device+0xaa/0x170
       pciehp_enable_slot+0xd6/0x240
       pciehp_handle_presence_or_link_change+0xf1/0x180
       pciehp_ist+0x162/0x1c0
       irq_thread_fn+0x24/0x70
       irq_thread+0xef/0x1c0
       ? __pfx_irq_thread_fn+0x10/0x10
       ? __pfx_irq_thread_dtor+0x10/0x10
       ? __pfx_irq_thread+0x10/0x10
       kthread+0xfc/0x230
       ? __pfx_kthread+0x10/0x10
       ret_from_fork+0x47/0x70
       ? __pfx_kthread+0x10/0x10
       ret_from_fork_asm+0x1a/0x30
       </TASK>

[PATCH_DIFF]
    @@ -3105,17 +3105,26 @@ static bool rtw89_pci_is_dac_compatible_bridge(struct rtw89_dev *rtwdev)
     	return false;
     }
     
    -static void rtw89_pci_cfg_dac(struct rtw89_dev *rtwdev)
    +static int rtw89_pci_cfg_dac(struct rtw89_dev *rtwdev, bool force)
     {
     	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;
    +	struct pci_dev *pdev = rtwpci->pdev;
    +	int ret;
    +	u8 val;
     
    -	if (!rtwpci->enable_dac)
    -		return;
    +	if (!rtwpci->enable_dac && !force)
    +		return 0;
     
     	if (!rtw89_pci_chip_is_manual_dac(rtwdev))
    -		return;
    +		return 0;
     
    -	rtw89_pci_config_byte_set(rtwdev, RTW89_PCIE_L1_CTRL, RTW89_PCIE_BIT_EN_64BITS);
    +	/* Configure DAC only via PCI config API, not DBI interfaces */
    +	ret = pci_read_config_byte(pdev, RTW89_PCIE_L1_CTRL, &val);
    +	if (ret)
    +		return ret;
    +
    +	val |= RTW89_PCIE_BIT_EN_64BITS;
    +	return pci_write_config_byte(pdev, RTW89_PCIE_L1_CTRL, val);
     }
     
     static int rtw89_pci_setup_mapping(struct rtw89_dev *rtwdev,
    @@ -3133,13 +3142,16 @@ static int rtw89_pci_setup_mapping(struct rtw89_dev *rtwdev,
     	}
     
     	if (!rtw89_pci_is_dac_compatible_bridge(rtwdev))
    -		goto no_dac;
    +		goto try_dac_done;
     
     	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));
     	if (!ret) {
    -		rtwpci->enable_dac = true;
    -		rtw89_pci_cfg_dac(rtwdev);
    -	} else {
    +		ret = rtw89_pci_cfg_dac(rtwdev, true);
    +		if (!ret) {
    +			rtwpci->enable_dac = true;
    +			goto try_dac_done;
    +		}
    +
     		ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
     		if (ret) {
     			rtw89_err(rtwdev,
    @@ -3147,7 +3159,7 @@ static int rtw89_pci_setup_mapping(struct rtw89_dev *rtwdev,
     			goto err_release_regions;
     		}
     	}
    -no_dac:
    +try_dac_done:
     
     	resource_len = pci_resource_len(pdev, bar_id);
     	rtwpci->mmap = pci_iomap(pdev, bar_id, resource_len);
    @@ -4302,7 +4314,7 @@ static void rtw89_pci_l2_hci_ldo(struct rtw89_dev *rtwdev)
     void rtw89_pci_basic_cfg(struct rtw89_dev *rtwdev, bool resume)
     {
     	if (resume)
    -		rtw89_pci_cfg_dac(rtwdev);
    +		rtw89_pci_cfg_dac(rtwdev, false);
     
     	rtw89_pci_disable_eq(rtwdev);
     	rtw89_pci_filter_out(rtwdev);

[FUNCTION_CONTENT]
static bool rtw89_pci_is_dac_compatible_bridge(struct rtw89_dev *rtwdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;
	struct pci_dev *bridge = pci_upstream_bridge(rtwpci->pdev);

	if (!rtw89_pci_chip_is_manual_dac(rtwdev))
		return true;

	if (!bridge)
		return false;

	switch (bridge->vendor) {
	case PCI_VENDOR_ID_INTEL:
		return true;
	case PCI_VENDOR_ID_ASMEDIA:
		if (bridge->device == 0x2806)
			return true;
		break;
	}

	return false;
}

/* ----- separator ----- */

static void rtw89_pci_cfg_dac(struct rtw89_dev *rtwdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;

	if (!rtwpci->enable_dac)
		return;

	if (!rtw89_pci_chip_is_manual_dac(rtwdev))
		return;

	rtw89_pci_config_byte_set(rtwdev, RTW89_PCIE_L1_CTRL, RTW89_PCIE_BIT_EN_64BITS);
}

/* ----- separator ----- */

static int rtw89_pci_setup_mapping(struct rtw89_dev *rtwdev,
				   struct pci_dev *pdev)
{
	struct rtw89_pci *rtwpci = (struct rtw89_pci *)rtwdev->priv;
	unsigned long resource_len;
	u8 bar_id = 2;
	int ret;

	ret = pci_request_regions(pdev, KBUILD_MODNAME);
	if (ret) {
		rtw89_err(rtwdev, "failed to request pci regions\n");
		goto err;
	}

	if (!rtw89_pci_is_dac_compatible_bridge(rtwdev))
		goto no_dac;

	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));
	if (!ret) {
		rtwpci->enable_dac = true;
		rtw89_pci_cfg_dac(rtwdev);
	} else {
		ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
		if (ret) {
			rtw89_err(rtwdev,
				  "failed to set dma and consistent mask to 32/36-bit\n");
			goto err_release_regions;
		}
	}
no_dac:

	resource_len = pci_resource_len(pdev, bar_id);
	rtwpci->mmap = pci_iomap(pdev, bar_id, resource_len);
	if (!rtwpci->mmap) {
		rtw89_err(rtwdev, "failed to map pci io\n");
		ret = -EIO;
		goto err_release_regions;
	}

	return 0;

err_release_regions:
	pci_release_regions(pdev);
err:
	return ret;
}

/* ----- separator ----- */

void rtw89_pci_basic_cfg(struct rtw89_dev *rtwdev, bool resume)
{
	if (resume)
		rtw89_pci_cfg_dac(rtwdev);

	rtw89_pci_disable_eq(rtwdev);
	rtw89_pci_filter_out(rtwdev);
	rtw89_pci_cpl_timeout_cfg(rtwdev);
	rtw89_pci_link_cfg(rtwdev);
	rtw89_pci_l1ss_cfg(rtwdev);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38284

2. Vulnerability Type
Null pointer dereference due to incorrect initialization ordering and unsafe MMIO/DBI access

3. Root Cause Summary
The driver configured the manual DAC bit via a DBI/MMIO helper before the PCI BAR was mapped, causing dereference of a NULL mmap pointer. Specifically, rtw89_pci_cfg_dac() called rtw89_pci_config_byte_set(rtwdev, RTW89_PCIE_L1_CTRL, RTW89_PCIE_BIT_EN_64BITS) while rtwpci->mmap had not yet been set by pci_iomap(). In rtw89_pci_setup_mapping(), the call to rtw89_pci_cfg_dac(rtwdev) occurs immediately after enabling 36-bit DMA and before rtwpci->mmap = pci_iomap(...), leading to a page fault when accessing unmapped registers. There was no validation of rtwpci->mmap or use of the safe PCI config-space API at this stage, and no fallback to 32-bit DMA if the proprietary bit could not be set safely. This resulted in an OOPS during device probe/hotplug or resume when manual DAC was required.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 PCI Wi-Fi driver (DMA/DAC configuration path), drivers/net/wireless/realtek/rtw89/pci

2) Pre-Patch Flaw:
rtw89_pci_cfg_dac() wrote to a proprietary register via DBI/MMIO using rtw89_pci_config_byte_set() before the BAR was mapped, relying on rtwpci->mmap being valid. In rtw89_pci_setup_mapping(), the sequence was:
- “rtw89_pci_cfg_dac(rtwdev);”
- followed later by “rtwpci->mmap = pci_iomap(pdev, bar_id, resource_len);”
No check ensured that mmap was non-NULL, nor was the PCI config API used, despite DBI being inaccessible until mapping exists.

3) Trigger Condition:
When rtw89_pci_chip_is_manual_dac(rtwdev) returns true and the upstream bridge is deemed DAC-compatible, the driver sets a 36-bit DMA mask and sets rtwpci->enable_dac = true, then immediately calls rtw89_pci_cfg_dac() before pci_iomap() runs. This can occur during probe/hotplug (pciehp path) or resume. The NULL rtwpci->mmap leads to an invalid MMIO write to address 0x1090, as evidenced by the provided OOPS trace with RIP in rtw89_pci_ops_write16.

4) Impact Mechanism:
A supervisor-mode page fault occurs due to writing through a NULL/unmapped BAR, crashing the kernel thread (irq/pciehp) and producing an OOPS. This constitutes a denial-of-service and system instability during device enumeration or power management events. No locking or concurrency primitives are implicated; the fault is purely due to premature MMIO access.

5. Patch Analysis
1) Fix Approach:
The patch reworks DAC configuration to use only the PCI config-space API (pci_read_config_byte/pci_write_config_byte), which is safe before BAR mapping. It introduces error handling: if config-space access fails, the driver falls back to a 32-bit DMA mask rather than attempting unsafe DBI/MMIO access. The call sites are guarded with a ‘force’ parameter and enable_dac checks to ensure DAC configuration is attempted at the correct time and only when necessary.

2) Key Code Changes:
- rtw89_pci_cfg_dac() signature changed to return int and accept ‘bool force’; it now reads RTW89_PCIE_L1_CTRL via pci_read_config_byte and sets RTW89_PCIE_BIT_EN_64BITS via pci_write_config_byte.
- In rtw89_pci_setup_mapping(), after successfully setting DMA_BIT_MASK(36), the driver calls rtw89_pci_cfg_dac(rtwdev, true) and sets enable_dac only if that succeeds; otherwise it falls back to DMA_BIT_MASK(32). The flow label changed from no_dac to try_dac_done, ensuring pci_iomap() happens after any config-space DAC attempt, not dependent on DBI.
- In rtw89_pci_basic_cfg(), resume path calls rtw89_pci_cfg_dac(rtwdev, false), respecting enable_dac gating and using safe config-space access.

3) Locking/Concurrency Impact:
No locking primitives were added or altered. The patch eliminates the unsafe early MMIO/DBI access that previously executed in hotplug/IRQ contexts, thereby preventing a crash without changing concurrency or ordering beyond safe re-sequencing of configuration operations.

6. Broader Kernel Security Implications
This fix underscores the necessity of avoiding MMIO/DBI access before BARs are mapped and preferring PCI config-space for early device configuration. It adds robust error handling and graceful fallback to a safer DMA mode when proprietary bits are not accessible, improving stability under hotplug and resume. Other drivers with similar manual hardware configuration stages should audit initialization order and access methods to prevent NULL dereferences and kernel faults. Ensuring that device-specific register programming is deferred until mappings are valid or performed via universally safe interfaces reduces systemic DoS risks.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}