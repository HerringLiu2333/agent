You are a senior Linux kernel vulnerability analyst.
Task: Produce a structured root-cause analysis of the vulnerability that existed BEFORE the patch, strictly following the [OUTPUT FORMAT] below.

Rules:
1. Follow the [OUTPUT FORMAT] exactly and populate every field. Use evidence from [PATCH_DIFF], [PATCH_DESCRIPTION], and [FUNCTION_CONTENT].
2. Root cause = the flawed or missing pre-patch logic that the patch corrects (e.g., missing validation, incorrect locking/ordering, race window, unsafe access, integer/length misuse, lifetime/refcount bug, pointer misuse).
3. Be evidence-driven: reference function names, local context, and hunk scope in the diff; you may quote 1–3 lines of original (pre-patch) code only when necessary to support claims; avoid long code dumps.
4. Patch analysis must map each fix to the identified root cause (e.g., added checks, lock adjustments, lifetime/RCU changes, bounds fixes, condition rewrites).
5. Concurrency/locking: when relevant, explicitly state missing/incorrect locks, RCU usage, atomicity, or ordering and what the patch changed (lock/unlock points, ordering changes).
6. Memory/safety: when relevant, specify trigger conditions and impact (UAF, OOB, double free, uninitialized use, integer overflow/underflow, length miscalculation, TOCTOU, etc.).
7. Use only the provided materials ([PATCH_DIFF], [PATCH_DESCRIPTION], [FUNCTION_CONTENT]). Do not speculate; when uncertain, state “Unknown/Not determinable”.
8. Keep it concise and technical: 3–8 clear sentences or bullet points per subsection.
9. Output nothing beyond the [OUTPUT FORMAT]; no extra headers, prefaces, or trailing notes.
10. If the root cause cannot be identified, state “Unknown/Not determinable” in the relevant subsection, but complete the remaining sections using available evidence.

[META]
CVE_NAME: CVE-2024-58004

[PATCH_DESCRIPTION]
 media: intel/ipu6: remove cpu latency qos request on error
 Fix cpu latency qos list corruption like below. It happens when
 we do not remove cpu latency request on error path and free
 corresponding memory.

 [   30.634378] l7 kernel: list_add corruption. prev->next should be next (ffffffff9645e960), but was 0000000100100001. (prev=ffff8e9e877e20a8).
 [   30.634388] l7 kernel: WARNING: CPU: 2 PID: 2008 at lib/list_debug.c:32 __list_add_valid_or_report+0x83/0xa0
 [   30.634678] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634690] l7 kernel:  ? report_bug+0xff/0x140
 [   30.634702] l7 kernel:  ? handle_bug+0x58/0x90
 [   30.634712] l7 kernel:  ? exc_invalid_op+0x17/0x70
 [   30.634723] l7 kernel:  ? asm_exc_invalid_op+0x1a/0x20
 [   30.634733] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634742] l7 kernel:  plist_add+0xdd/0x140
 [   30.634754] l7 kernel:  pm_qos_update_target+0xa0/0x1f0
 [   30.634764] l7 kernel:  cpu_latency_qos_update_request+0x61/0xc0
 [   30.634773] l7 kernel:  intel_dp_aux_xfer+0x4c7/0x6e0 [i915 1f824655ed04687c2b0d23dbce759fa785f6d033]
 
 Reported-by: Genes Lists <lists@sapience.com>
 Closes: https://lore.kernel.org/linux-media/c0e94be466b367f1a3cfdc3cb7b1a4f47e5953ae.camel@sapience.com/
 Fixes: f50c4ca0a820 ("media: intel/ipu6: add the main input system driver")

[PATCH_DIFF]
 diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys.c b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 index 7148f8fe23f535…8d7a1ad19ead59 100644
 --- a/drivers/media/pci/intel/ipu6/ipu6-isys.c
 +++ b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 @@ -1133,6 +1133,7 @@ static int isys_probe(struct auxiliary_device *auxdev,
   free_fw_msg_bufs:
   free_fw_msg_bufs(isys);
   out_remove_pkg_dir_shared_buffer:
 + cpu_latency_qos_remove_request(&isys->pm_qos);
   if (!isp->secure_mode)
   ipu6_cpd_free_pkg_dir(adev);
   remove_shared_buffer:

[FUNCTION_CONTENT]
static int isys_probe(struct auxiliary_device *auxdev,
		      const struct auxiliary_device_id *auxdev_id)
{
	const struct ipu6_isys_internal_csi2_pdata *csi2_pdata;
	struct ipu6_bus_device *adev = auxdev_to_adev(auxdev);
	struct ipu6_device *isp = adev->isp;
	const struct firmware *fw;
	struct ipu6_isys *isys;
	unsigned int i;
	int ret;

	if (!isp->bus_ready_to_probe)
		return -EPROBE_DEFER;

	isys = devm_kzalloc(&auxdev->dev, sizeof(*isys), GFP_KERNEL);
	if (!isys)
		return -ENOMEM;

	adev->auxdrv_data =
		(const struct ipu6_auxdrv_data *)auxdev_id->driver_data;
	adev->auxdrv = to_auxiliary_drv(auxdev->dev.driver);
	isys->adev = adev;
	isys->pdata = adev->pdata;
	csi2_pdata = &isys->pdata->ipdata->csi2;

	isys->csi2 = devm_kcalloc(&auxdev->dev, csi2_pdata->nports,
				  sizeof(*isys->csi2), GFP_KERNEL);
	if (!isys->csi2)
		return -ENOMEM;

	ret = ipu6_mmu_hw_init(adev->mmu);
	if (ret)
		return ret;

	/* initial sensor type */
	isys->sensor_type = isys->pdata->ipdata->sensor_type_start;

	spin_lock_init(&isys->streams_lock);
	spin_lock_init(&isys->power_lock);
	isys->power = 0;
	isys->phy_termcal_val = 0;

	mutex_init(&isys->mutex);
	mutex_init(&isys->stream_mutex);

	spin_lock_init(&isys->listlock);
	INIT_LIST_HEAD(&isys->framebuflist);
	INIT_LIST_HEAD(&isys->framebuflist_fw);

	isys->line_align = IPU6_ISYS_2600_MEM_LINE_ALIGN;
	isys->icache_prefetch = 0;

	dev_set_drvdata(&auxdev->dev, isys);

	isys_stream_init(isys);

	if (!isp->secure_mode) {
		fw = isp->cpd_fw;
		ret = ipu6_buttress_map_fw_image(adev, fw, &adev->fw_sgt);
		if (ret)
			goto release_firmware;

		ret = ipu6_cpd_create_pkg_dir(adev, isp->cpd_fw->data);
		if (ret)
			goto remove_shared_buffer;
	}

	cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);

	ret = alloc_fw_msg_bufs(isys, 20);
	if (ret < 0)
		goto out_remove_pkg_dir_shared_buffer;

	isys_iwake_watermark_init(isys);

	if (is_ipu6se(adev->isp->hw_ver))
		isys->phy_set_power = ipu6_isys_jsl_phy_set_power;
	else if (is_ipu6ep_mtl(adev->isp->hw_ver))
		isys->phy_set_power = ipu6_isys_dwc_phy_set_power;
	else
		isys->phy_set_power = ipu6_isys_mcd_phy_set_power;

	ret = isys_register_devices(isys);
	if (ret)
		goto free_fw_msg_bufs;

	ipu6_mmu_hw_cleanup(adev->mmu);

	return 0;

free_fw_msg_bufs:
	free_fw_msg_bufs(isys);
out_remove_pkg_dir_shared_buffer:
	if (!isp->secure_mode)
		ipu6_cpd_free_pkg_dir(adev);
remove_shared_buffer:
	if (!isp->secure_mode)
		ipu6_buttress_unmap_fw_image(adev, &adev->fw_sgt);
release_firmware:
	if (!isp->secure_mode)
		release_firmware(adev->fw);

	for (i = 0; i < IPU6_ISYS_MAX_STREAMS; i++)
		mutex_destroy(&isys->streams[i].mutex);

	mutex_destroy(&isys->mutex);
	mutex_destroy(&isys->stream_mutex);

	ipu6_mmu_hw_cleanup(adev->mmu);

	return ret;
}

[OUTPUT FORMAT]
1. CVE Identifier
{{CVE Identifier}}

2. Vulnerability Type
{{Vulnerability Type}}

3. Root Cause Summary
{{Root Cause Summary}}

4. Kernel Subsystem Analysis
1) Affected Subsystem:
{{Affected Subsystem}}
2) Pre-Patch Flaw:
{{Pre-Patch Flaw}}
3) Trigger Condition:
{{Trigger Condition}}
4) Impact Mechanism:
{{Impact Mechanism}}

5. Patch Analysis
1) Fix Approach:
{{Fix Approach}}
2) Key Code Changes:
{{Key Code Changes}}
3) Locking/Concurrency Impact:
{{Locking/Concurrency Impact}}

6. Broader Kernel Security Implications
{{Broader Kernel Security Implications}}