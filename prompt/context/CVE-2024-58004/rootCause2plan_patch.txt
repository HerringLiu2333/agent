You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58004

[INFO]
[PATCH_DESCRIPTION]
 media: intel/ipu6: remove cpu latency qos request on error
 Fix cpu latency qos list corruption like below. It happens when
 we do not remove cpu latency request on error path and free
 corresponding memory.

 [   30.634378] l7 kernel: list_add corruption. prev->next should be next (ffffffff9645e960), but was 0000000100100001. (prev=ffff8e9e877e20a8).
 [   30.634388] l7 kernel: WARNING: CPU: 2 PID: 2008 at lib/list_debug.c:32 __list_add_valid_or_report+0x83/0xa0
 [   30.634678] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634690] l7 kernel:  ? report_bug+0xff/0x140
 [   30.634702] l7 kernel:  ? handle_bug+0x58/0x90
 [   30.634712] l7 kernel:  ? exc_invalid_op+0x17/0x70
 [   30.634723] l7 kernel:  ? asm_exc_invalid_op+0x1a/0x20
 [   30.634733] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634742] l7 kernel:  plist_add+0xdd/0x140
 [   30.634754] l7 kernel:  pm_qos_update_target+0xa0/0x1f0
 [   30.634764] l7 kernel:  cpu_latency_qos_update_request+0x61/0xc0
 [   30.634773] l7 kernel:  intel_dp_aux_xfer+0x4c7/0x6e0 [i915 1f824655ed04687c2b0d23dbce759fa785f6d033]
 
 Reported-by: Genes Lists <lists@sapience.com>
 Closes: https://lore.kernel.org/linux-media/c0e94be466b367f1a3cfdc3cb7b1a4f47e5953ae.camel@sapience.com/
 Fixes: f50c4ca0a820 ("media: intel/ipu6: add the main input system driver")

[PATCH_DIFF]
 diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys.c b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 index 7148f8fe23f535…8d7a1ad19ead59 100644
 --- a/drivers/media/pci/intel/ipu6/ipu6-isys.c
 +++ b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 @@ -1133,6 +1133,7 @@ static int isys_probe(struct auxiliary_device *auxdev,
   free_fw_msg_bufs:
   free_fw_msg_bufs(isys);
   out_remove_pkg_dir_shared_buffer:
 + cpu_latency_qos_remove_request(&isys->pm_qos);
   if (!isp->secure_mode)
   ipu6_cpd_free_pkg_dir(adev);
   remove_shared_buffer:



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58004

2. Vulnerability Type
Use-after-free leading to kernel list corruption (dangling pm_qos request)

3. Root Cause Summary
The isys_probe error path in drivers/media/pci/intel/ipu6 failed to deregister a CPU latency PM QoS request before freeing the associated driver structures. This left a plist entry (isys->pm_qos) in the global pm_qos list pointing to freed memory. Subsequent pm_qos operations (e.g., pm_qos_update_target via cpu_latency_qos_update_request) acted on the corrupted list, triggering list_add corruption warnings and potential kernel instability.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Media subsystem, Intel IPU6 input system driver (drivers/media/pci/intel/ipu6), interacting with PM QoS CPU latency infrastructure.

2) Pre-Patch Flaw:
- isys_probe’s error unwind path did not call cpu_latency_qos_remove_request(&isys->pm_qos) before freeing resources, leaving a registered QoS request with its backing memory freed.

3) Trigger Condition:
- Probe failure after a CPU latency QoS request was created/registered, followed by freeing isys-related memory; later, any CPU latency QoS update (cpu_latency_qos_update_request → pm_qos_update_target → plist_add) touches the corrupted list node.

4) Impact Mechanism:
- The stale list node causes invalid prev/next pointers in the pm_qos plist, producing “list_add corruption” warnings (as in list_debug.c) and risking kernel memory corruption or crashes during QoS updates.

5. Patch Analysis
1) Fix Approach:
- Ensure proper cleanup on the error path by explicitly removing the CPU latency QoS request prior to freeing resources, preventing a dangling list node.

2) Key Code Changes:
- In isys_probe(), at the error label out_remove_pkg_dir_shared_buffer, added:
  - cpu_latency_qos_remove_request(&isys->pm_qos);
- This aligns cleanup order so the pm_qos request is deregistered before memory associated with isys is released.

3) Locking/Concurrency Impact:
- No driver-local locking changes. The fix relies on PM QoS infrastructure’s internal synchronization within cpu_latency_qos_remove_request to safely remove the request, correcting the previous ordering bug (deregistration now precedes memory free).

6. Broader Kernel Security Implications
- Error-path resource deregistration is critical; omissions can corrupt shared kernel data structures and propagate instability across subsystems. This case shows that leaving global registrations (like PM QoS requests) active after freeing device memory can lead to cross-subsystem crashes and denial-of-service. The fix highlights the need to audit probe/remove error paths for proper teardown of registered objects (lists, notifiers, QoS requests, work items).

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.