You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58004

[INFO]
[PATCH_DESCRIPTION]
 media: intel/ipu6: remove cpu latency qos request on error
 Fix cpu latency qos list corruption like below. It happens when
 we do not remove cpu latency request on error path and free
 corresponding memory.

 [   30.634378] l7 kernel: list_add corruption. prev->next should be next (ffffffff9645e960), but was 0000000100100001. (prev=ffff8e9e877e20a8).
 [   30.634388] l7 kernel: WARNING: CPU: 2 PID: 2008 at lib/list_debug.c:32 __list_add_valid_or_report+0x83/0xa0
 [   30.634678] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634690] l7 kernel:  ? report_bug+0xff/0x140
 [   30.634702] l7 kernel:  ? handle_bug+0x58/0x90
 [   30.634712] l7 kernel:  ? exc_invalid_op+0x17/0x70
 [   30.634723] l7 kernel:  ? asm_exc_invalid_op+0x1a/0x20
 [   30.634733] l7 kernel:  ? __list_add_valid_or_report+0x83/0xa0
 [   30.634742] l7 kernel:  plist_add+0xdd/0x140
 [   30.634754] l7 kernel:  pm_qos_update_target+0xa0/0x1f0
 [   30.634764] l7 kernel:  cpu_latency_qos_update_request+0x61/0xc0
 [   30.634773] l7 kernel:  intel_dp_aux_xfer+0x4c7/0x6e0 [i915 1f824655ed04687c2b0d23dbce759fa785f6d033]
 
 Reported-by: Genes Lists <lists@sapience.com>
 Closes: https://lore.kernel.org/linux-media/c0e94be466b367f1a3cfdc3cb7b1a4f47e5953ae.camel@sapience.com/
 Fixes: f50c4ca0a820 ("media: intel/ipu6: add the main input system driver")

[PATCH_DIFF]
 diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys.c b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 index 7148f8fe23f535…8d7a1ad19ead59 100644
 --- a/drivers/media/pci/intel/ipu6/ipu6-isys.c
 +++ b/drivers/media/pci/intel/ipu6/ipu6-isys.c
 @@ -1133,6 +1133,7 @@ static int isys_probe(struct auxiliary_device *auxdev,
   free_fw_msg_bufs:
   free_fw_msg_bufs(isys);
   out_remove_pkg_dir_shared_buffer:
 + cpu_latency_qos_remove_request(&isys->pm_qos);
   if (!isp->secure_mode)
   ipu6_cpd_free_pkg_dir(adev);
   remove_shared_buffer:

[FUNCTION_CONTENT]
static int isys_probe(struct auxiliary_device *auxdev,
		      const struct auxiliary_device_id *auxdev_id)
{
	const struct ipu6_isys_internal_csi2_pdata *csi2_pdata;
	struct ipu6_bus_device *adev = auxdev_to_adev(auxdev);
	struct ipu6_device *isp = adev->isp;
	const struct firmware *fw;
	struct ipu6_isys *isys;
	unsigned int i;
	int ret;

	if (!isp->bus_ready_to_probe)
		return -EPROBE_DEFER;

	isys = devm_kzalloc(&auxdev->dev, sizeof(*isys), GFP_KERNEL);
	if (!isys)
		return -ENOMEM;

	adev->auxdrv_data =
		(const struct ipu6_auxdrv_data *)auxdev_id->driver_data;
	adev->auxdrv = to_auxiliary_drv(auxdev->dev.driver);
	isys->adev = adev;
	isys->pdata = adev->pdata;
	csi2_pdata = &isys->pdata->ipdata->csi2;

	isys->csi2 = devm_kcalloc(&auxdev->dev, csi2_pdata->nports,
				  sizeof(*isys->csi2), GFP_KERNEL);
	if (!isys->csi2)
		return -ENOMEM;

	ret = ipu6_mmu_hw_init(adev->mmu);
	if (ret)
		return ret;

	/* initial sensor type */
	isys->sensor_type = isys->pdata->ipdata->sensor_type_start;

	spin_lock_init(&isys->streams_lock);
	spin_lock_init(&isys->power_lock);
	isys->power = 0;
	isys->phy_termcal_val = 0;

	mutex_init(&isys->mutex);
	mutex_init(&isys->stream_mutex);

	spin_lock_init(&isys->listlock);
	INIT_LIST_HEAD(&isys->framebuflist);
	INIT_LIST_HEAD(&isys->framebuflist_fw);

	isys->line_align = IPU6_ISYS_2600_MEM_LINE_ALIGN;
	isys->icache_prefetch = 0;

	dev_set_drvdata(&auxdev->dev, isys);

	isys_stream_init(isys);

	if (!isp->secure_mode) {
		fw = isp->cpd_fw;
		ret = ipu6_buttress_map_fw_image(adev, fw, &adev->fw_sgt);
		if (ret)
			goto release_firmware;

		ret = ipu6_cpd_create_pkg_dir(adev, isp->cpd_fw->data);
		if (ret)
			goto remove_shared_buffer;
	}

	cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);

	ret = alloc_fw_msg_bufs(isys, 20);
	if (ret < 0)
		goto out_remove_pkg_dir_shared_buffer;

	isys_iwake_watermark_init(isys);

	if (is_ipu6se(adev->isp->hw_ver))
		isys->phy_set_power = ipu6_isys_jsl_phy_set_power;
	else if (is_ipu6ep_mtl(adev->isp->hw_ver))
		isys->phy_set_power = ipu6_isys_dwc_phy_set_power;
	else
		isys->phy_set_power = ipu6_isys_mcd_phy_set_power;

	ret = isys_register_devices(isys);
	if (ret)
		goto free_fw_msg_bufs;

	ipu6_mmu_hw_cleanup(adev->mmu);

	return 0;

free_fw_msg_bufs:
	free_fw_msg_bufs(isys);
out_remove_pkg_dir_shared_buffer:
	if (!isp->secure_mode)
		ipu6_cpd_free_pkg_dir(adev);
remove_shared_buffer:
	if (!isp->secure_mode)
		ipu6_buttress_unmap_fw_image(adev, &adev->fw_sgt);
release_firmware:
	if (!isp->secure_mode)
		release_firmware(adev->fw);

	for (i = 0; i < IPU6_ISYS_MAX_STREAMS; i++)
		mutex_destroy(&isys->streams[i].mutex);

	mutex_destroy(&isys->mutex);
	mutex_destroy(&isys->stream_mutex);

	ipu6_mmu_hw_cleanup(adev->mmu);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58004

2. Vulnerability Type
Use-after-free leading to linked-list corruption (lifetime/cleanup bug)

3. Root Cause Summary
The driver added a CPU latency PM QoS request during probe but failed to remove it on error paths before freeing the associated memory. In isys_probe(), cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE) registers isys->pm_qos in a global plist, yet no cpu_latency_qos_remove_request() was called when probe failed and the isys structure and its fields were torn down. This left a dangling plist node pointing to freed memory, corrupting the PM QoS request list when subsequent QoS operations occurred.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
media: intel/ipu6 Input System (ipu6-isys), interacting with PM QoS (CPU latency QoS)

2) Pre-Patch Flaw:
isys_probe() added a PM QoS request but did not remove it on failure paths (labels free_fw_msg_bufs and out_remove_pkg_dir_shared_buffer). The original code included "cpu_latency_qos_add_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);" without a corresponding remove during cleanup.

3) Trigger Condition:
Any probe failure occurring after cpu_latency_qos_add_request(), such as alloc_fw_msg_bufs(isys, 20) returning <0 (goto out_remove_pkg_dir_shared_buffer) or isys_register_devices(isys) failing (goto free_fw_msg_bufs), causes the function to unwind and free related resources while leaving the PM QoS request registered.

4) Impact Mechanism:
The global PM QoS plist contained a node (isys->pm_qos) whose backing memory was freed, leading to list corruption when other components (e.g., i915 calling cpu_latency_qos_update_request) manipulate the list. This manifested as list_add corruption warnings in list_debug (__list_add_valid_or_report), indicating a dangling next pointer and potential kernel instability.

5. Patch Analysis
1) Fix Approach:
Ensure proper lifetime management by removing the CPU latency QoS request on error paths before freeing resources, preventing dangling list entries.

2) Key Code Changes:
Added a call to cpu_latency_qos_remove_request(&isys->pm_qos) at the out_remove_pkg_dir_shared_buffer cleanup label in isys_probe(), ensuring the previously added request is deregistered during probe failure unwinding.

3) Locking/Concurrency Impact:
No explicit locking changes; PM QoS APIs handle internal synchronization. The fix addresses object lifetime consistency rather than lock ordering.

6. Broader Kernel Security Implications
Improper cleanup of globally linked resources (like PM QoS requests) can corrupt shared kernel data structures, potentially leading to crashes, undefined behavior, or avenues for exploitation via memory corruption. This highlights the need for drivers to strictly pair resource registration with deregistration across all error paths, especially for global subsystems used by multiple drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.