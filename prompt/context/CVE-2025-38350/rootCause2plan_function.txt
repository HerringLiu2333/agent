You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38350

[INFO]
[PATCH_DESCRIPTION]
    net/sched: Always pass notifications when child class becomes empty
    Certain classful qdiscs may invoke their classes' dequeue handler on an
    enqueue operation. This may unexpectedly empty the child qdisc and thus
    make an in-flight class passive via qlen_notify(). Most qdiscs do not
    expect such behaviour at this point in time and may re-activate the
    class eventually anyways which will lead to a use-after-free.
    
    The referenced fix commit attempted to fix this behavior for the HFSC
    case by moving the backlog accounting around, though this turned out to
    be incomplete since the parent's parent may run into the issue too.
    The following reproducer demonstrates this use-after-free:
    
        tc qdisc add dev lo root handle 1: drr
        tc filter add dev lo parent 1: basic classid 1:1
        tc class add dev lo parent 1: classid 1:1 drr
        tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1
        tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0
        tc qdisc add dev lo parent 2:1 handle 3: netem
        tc qdisc add dev lo parent 3:1 handle 4: blackhole
    
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
        tc class delete dev lo classid 1:1
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
    
    Since backlog accounting issues leading to a use-after-frees on stale
    class pointers is a recurring pattern at this point, this patch takes
    a different approach. Instead of trying to fix the accounting, the patch
    ensures that qdisc_tree_reduce_backlog always calls qlen_notify when
    the child qdisc is empty. This solves the problem because deletion of
    qdiscs always involves a call to qdisc_reset() and / or
    qdisc_purge_queue() which ultimately resets its qlen to 0 thus causing
    the following qdisc_tree_reduce_backlog() to report to the parent. Note
    that this may call qlen_notify on passive classes multiple times. This
    is not a problem after the recent patch series that made all the
    classful qdiscs qlen_notify() handlers idempotent.

[PATCH_DIFF]
    @@ -783,21 +783,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     {
    -	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
     	const struct Qdisc_class_ops *cops;
     	unsigned long cl;
     	u32 parentid;
     	bool notify;
     	int drops;
    -
    -	if (n == 0 && len == 0)
    -		return;
     	drops = max_t(int, n, 0);
     	rcu_read_lock();
     	while ((parentid = sch->parent)) {
    @@ -808,17 +796,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     
     		if (sch->flags & TCQ_F_NOPARENT)
     			break;
    -		/* Notify parent qdisc only if child qdisc becomes empty.
    -		 *
    -		 * If child was empty even before update then backlog
    -		 * counter is screwed and we skip notification because
    -		 * parent class is already passive.
    -		 *
    -		 * If the original child was offloaded then it is allowed
    -		 * to be seem as empty, so the parent is notified anyway.
    -		 */
    -		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
    -						       !qdisc_is_offloaded);
    +		/* Notify parent qdisc only if child qdisc becomes empty. */
    +		notify = !sch->q.qlen;
     		/* TODO: perform the search on a per txq basis */
     		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
     		if (sch == NULL) {
    @@ -827,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     		}
     		cops = sch->ops->cl_ops;
     		if (notify && cops->qlen_notify) {
    +			/* Note that qlen_notify must be idempotent as it may get called
    +			 * multiple times.
    +			 */
     			cl = cops->find(sch, parentid);
     			cops->qlen_notify(sch, cl);
     		}

[FUNCTION_CONTENT]
void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
{
	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
	const struct Qdisc_class_ops *cops;
	unsigned long cl;
	u32 parentid;
	bool notify;
	int drops;

	if (n == 0 && len == 0)
		return;
	drops = max_t(int, n, 0);
	rcu_read_lock();
	while ((parentid = sch->parent)) {
		if (parentid == TC_H_ROOT)
			break;

		if (sch->flags & TCQ_F_NOPARENT)
			break;
		/* Notify parent qdisc only if child qdisc becomes empty.
		 *
		 * If child was empty even before update then backlog
		 * counter is screwed and we skip notification because
		 * parent class is already passive.
		 *
		 * If the original child was offloaded then it is allowed
		 * to be seem as empty, so the parent is notified anyway.
		 */
		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
						       !qdisc_is_offloaded);
		/* TODO: perform the search on a per txq basis */
		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
		if (sch == NULL) {
			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}
		sch->q.qlen -= n;
		sch->qstats.backlog -= len;
		__qdisc_qstats_drop(sch, drops);
	}
	rcu_read_unlock();
}

/* ----- separator ----- */

			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}

/* ----- separator ----- */

int qdisc_offload_dump_helper(struct Qdisc *sch, enum tc_setup_type type,
			      void *type_data)
{
	struct net_device *dev = qdisc_dev(sch);
	int err;

	sch->flags &= ~TCQ_F_OFFLOADED;
	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
		return 0;

	err = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);
	if (err == -EOPNOTSUPP)
		return 0;

	if (!err)
		sch->flags |= TCQ_F_OFFLOADED;

	return err;
}

/* ----- separator ----- */

EXPORT_SYMBOL(qdisc_tree_reduce_backlog);

int qdisc_offload_dump_helper(struct Qdisc *sch, enum tc_setup_type type,
			      void *type_data)
{
	struct net_device *dev = qdisc_dev(sch);
	int err;

	sch->flags &= ~TCQ_F_OFFLOADED;
	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
		return 0;

	err = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);
	if (err == -EOPNOTSUPP)
		return 0;

	if (!err)
		sch->flags |= TCQ_F_OFFLOADED;

	return err;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38350

2. Vulnerability Type
Use-after-free due to missed state notification in classful qdisc hierarchy

3. Root Cause Summary
qdisc_tree_reduce_backlog() suppressed parent notifications when a child qdisc became empty if no packet count/length deltas were provided (n == 0 && len == 0) and the qdisc was not offloaded. Specifically, the function returned early on (n == 0 && len == 0) and computed notify as “!sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)”, thereby skipping cops->qlen_notify() in common cases where qlen transitioned to 0 without explicit n/len updates. This left parent classes unaware that the child emptied/reset, allowing them to keep or re-activate classes that had been deleted, leading to use-after-free on stale class pointers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking traffic-control scheduler (net/sched), classful qdisc hierarchy handling

2) Pre-Patch Flaw:
- In qdisc_tree_reduce_backlog(), parent notification was tied to n/len updates and offload state instead of the actual empty state of the child qdisc:
  - Early exit: “if (n == 0 && len == 0) return;”
  - notify gating: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
- As a result, when a child became empty via qdisc_reset()/qdisc_purge_queue() or dequeue-during-enqueue paths, parents were not notified, desynchronizing class state.

3) Trigger Condition:
- Classful qdisc stacks where a child qdisc becomes empty without nonzero n/len, e.g., during class deletion or when enqueue invokes a dequeue handler that empties the child. The provided reproducer (DRR -> HFSC -> netem -> blackhole, then delete class and send another packet) triggers the missed notification and subsequent stale class handling.

4) Impact Mechanism:
- Without qlen_notify() propagation, the parent (and potentially its parent) may re-activate or continue referencing a class whose child qdisc has been reset/deleted. Subsequent scheduling accesses freed class structures, resulting in a use-after-free.

5. Patch Analysis
1) Fix Approach:
- Decouple notification from n/len changes and offload status; always notify when the child qdisc is empty. Ensure notification is propagated up the hierarchy even when n == 0 && len == 0.

2) Key Code Changes:
- Removed the early return on zero deltas:
  - Deleted: “if (n == 0 && len == 0) return;”
- Simplified and strengthened the notify condition:
  - Replaced: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
  - With: “notify = !sch->q.qlen;”
- Removed qdisc_is_offloaded logic entirely and added a note that qlen_notify must be idempotent since it may be called multiple times.
- No functional change to the RCU traversal; the loop continues to walk parents and call cops->qlen_notify() whenever sch->q.qlen == 0.

3) Locking/Concurrency Impact:
- RCU read-side locking remains unchanged (rcu_read_lock()/rcu_read_unlock()).
- The change increases the frequency of qlen_notify() calls (including multiple notifications on passive classes), but the code and recent series ensure handlers are idempotent, avoiding concurrency hazards.
- No new locks or ordering changes; the fix removes a race window created by conditional notification by guaranteeing timely state propagation based solely on qlen.

6. Broader Kernel Security Implications
- Hierarchical scheduler correctness depends on precise, unconditional state propagation; conditioning notifications on accounting deltas is brittle and can cause lifetime bugs. This fix reduces reliance on fragile backlog accounting and prevents cascaded desynchronization across parent levels. The approach underscores the need for idempotent notifications and may guide similar robustness improvements in other classful qdisc handlers and hierarchical subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.