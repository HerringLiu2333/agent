You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38350

[INFO]
[PATCH_DESCRIPTION]
    net/sched: Always pass notifications when child class becomes empty
    Certain classful qdiscs may invoke their classes' dequeue handler on an
    enqueue operation. This may unexpectedly empty the child qdisc and thus
    make an in-flight class passive via qlen_notify(). Most qdiscs do not
    expect such behaviour at this point in time and may re-activate the
    class eventually anyways which will lead to a use-after-free.
    
    The referenced fix commit attempted to fix this behavior for the HFSC
    case by moving the backlog accounting around, though this turned out to
    be incomplete since the parent's parent may run into the issue too.
    The following reproducer demonstrates this use-after-free:
    
        tc qdisc add dev lo root handle 1: drr
        tc filter add dev lo parent 1: basic classid 1:1
        tc class add dev lo parent 1: classid 1:1 drr
        tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1
        tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0
        tc qdisc add dev lo parent 2:1 handle 3: netem
        tc qdisc add dev lo parent 3:1 handle 4: blackhole
    
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
        tc class delete dev lo classid 1:1
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
    
    Since backlog accounting issues leading to a use-after-frees on stale
    class pointers is a recurring pattern at this point, this patch takes
    a different approach. Instead of trying to fix the accounting, the patch
    ensures that qdisc_tree_reduce_backlog always calls qlen_notify when
    the child qdisc is empty. This solves the problem because deletion of
    qdiscs always involves a call to qdisc_reset() and / or
    qdisc_purge_queue() which ultimately resets its qlen to 0 thus causing
    the following qdisc_tree_reduce_backlog() to report to the parent. Note
    that this may call qlen_notify on passive classes multiple times. This
    is not a problem after the recent patch series that made all the
    classful qdiscs qlen_notify() handlers idempotent.

[PATCH_DIFF]
    @@ -783,21 +783,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     {
    -	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
     	const struct Qdisc_class_ops *cops;
     	unsigned long cl;
     	u32 parentid;
     	bool notify;
     	int drops;
    -
    -	if (n == 0 && len == 0)
    -		return;
     	drops = max_t(int, n, 0);
     	rcu_read_lock();
     	while ((parentid = sch->parent)) {
    @@ -808,17 +796,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     
     		if (sch->flags & TCQ_F_NOPARENT)
     			break;
    -		/* Notify parent qdisc only if child qdisc becomes empty.
    -		 *
    -		 * If child was empty even before update then backlog
    -		 * counter is screwed and we skip notification because
    -		 * parent class is already passive.
    -		 *
    -		 * If the original child was offloaded then it is allowed
    -		 * to be seem as empty, so the parent is notified anyway.
    -		 */
    -		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
    -						       !qdisc_is_offloaded);
    +		/* Notify parent qdisc only if child qdisc becomes empty. */
    +		notify = !sch->q.qlen;
     		/* TODO: perform the search on a per txq basis */
     		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
     		if (sch == NULL) {
    @@ -827,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     		}
     		cops = sch->ops->cl_ops;
     		if (notify && cops->qlen_notify) {
    +			/* Note that qlen_notify must be idempotent as it may get called
    +			 * multiple times.
    +			 */
     			cl = cops->find(sch, parentid);
     			cops->qlen_notify(sch, cl);
     		}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38350

2. Vulnerability Type
Use-after-free due to incorrect lifetime/state handling (missing/incorrect parent notification when child qdisc becomes empty)

3. Root Cause Summary
qdisc_tree_reduce_backlog suppressed parent notification unless certain backlog parameters were non-zero or the qdisc was offloaded. Specifically, it had an early return when n==0 && len==0 and computed notify using “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)”. When a child qdisc became empty outside of those accounting paths (e.g., during deletion/reset or via dequeue-on-enqueue behavior), the parent was not notified, leaving stale active class state that could later be reactivated and dereference freed child structures, causing a use-after-free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking traffic control (net/sched), classful qdiscs; function qdisc_tree_reduce_backlog()

2) Pre-Patch Flaw:
- The function returned early if (n == 0 && len == 0), skipping parent traversal and notification entirely.
- Notification was gated by backlog/offload checks: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)”, meaning emptiness without accompanying n/len updates would suppress qlen_notify().
- This relied on backlog accounting being aligned with actual queue emptiness, which is not guaranteed when classes dequeue on enqueue or during reset/purge paths.

3) Trigger Condition:
- Child qdisc becomes empty without corresponding n/len reductions, such as:
  - qdisc deletion/reset/purge (qdisc_reset()/qdisc_purge_queue() set qlen to 0),
  - classful qdisc invoking a class’s dequeue during enqueue (empties child unexpectedly).
- Example from reproducer: delete a class under DRR/HFSC stack and then send another packet, which runs qdisc_tree_reduce_backlog without n/len updates but with qlen==0.

4) Impact Mechanism:
- Parent is not notified via cops->qlen_notify when the child becomes empty, so parent’s class may remain or be reactivated with stale pointers to the freed child.
- Subsequent scheduling or reactivation dereferences freed class/qdisc memory, resulting in a use-after-free.

5. Patch Analysis
1) Fix Approach:
Always notify the parent when the child qdisc is empty, independent of backlog counters or offload status, ensuring parent class state is updated/neutralized whenever qlen hits zero. This relies on idempotent qlen_notify handlers to safely handle multiple notifications.

2) Key Code Changes:
- Removed early return: “if (n == 0 && len == 0) return;”
- Removed offload gating and WARN_ON logic; simplified notification condition to “notify = !sch->q.qlen”.
- Eliminated qdisc_is_offloaded variable and special-casing.
- Added comment clarifying qlen_notify must be idempotent; left RCU traversal intact and unchanged.

3) Locking/Concurrency Impact:
- RCU read-side locking remains as before; no changes to lock/unlock points or ordering.
- The change narrows the race window by ensuring state convergence (notification) whenever qlen==0; multiple notifications are now safe due to idempotent qlen_notify, reducing lifetime mismatches that previously led to UAF.

6. Broader Kernel Security Implications
By making parent notification unconditional on child emptiness, the patch hardens classful qdisc teardown and unusual dequeue-on-enqueue paths against stale state and lifetime mismatches, a recurring source of UAFs in net/sched. It removes fragile dependence on backlog counters and offload-specific behavior, promoting consistent parent-child state updates. With idempotent qlen_notify across classful qdiscs, duplicate notifications no longer pose a risk, improving robustness against complex qdisc stacks and reducing opportunities for memory safety violations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}