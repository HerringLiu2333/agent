You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38350

[INFO]
[PATCH_DESCRIPTION]
    net/sched: Always pass notifications when child class becomes empty
    Certain classful qdiscs may invoke their classes' dequeue handler on an
    enqueue operation. This may unexpectedly empty the child qdisc and thus
    make an in-flight class passive via qlen_notify(). Most qdiscs do not
    expect such behaviour at this point in time and may re-activate the
    class eventually anyways which will lead to a use-after-free.
    
    The referenced fix commit attempted to fix this behavior for the HFSC
    case by moving the backlog accounting around, though this turned out to
    be incomplete since the parent's parent may run into the issue too.
    The following reproducer demonstrates this use-after-free:
    
        tc qdisc add dev lo root handle 1: drr
        tc filter add dev lo parent 1: basic classid 1:1
        tc class add dev lo parent 1: classid 1:1 drr
        tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1
        tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0
        tc qdisc add dev lo parent 2:1 handle 3: netem
        tc qdisc add dev lo parent 3:1 handle 4: blackhole
    
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
        tc class delete dev lo classid 1:1
        echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888
    
    Since backlog accounting issues leading to a use-after-frees on stale
    class pointers is a recurring pattern at this point, this patch takes
    a different approach. Instead of trying to fix the accounting, the patch
    ensures that qdisc_tree_reduce_backlog always calls qlen_notify when
    the child qdisc is empty. This solves the problem because deletion of
    qdiscs always involves a call to qdisc_reset() and / or
    qdisc_purge_queue() which ultimately resets its qlen to 0 thus causing
    the following qdisc_tree_reduce_backlog() to report to the parent. Note
    that this may call qlen_notify on passive classes multiple times. This
    is not a problem after the recent patch series that made all the
    classful qdiscs qlen_notify() handlers idempotent.

[PATCH_DIFF]
    @@ -783,21 +783,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     {
    -	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
     	const struct Qdisc_class_ops *cops;
     	unsigned long cl;
     	u32 parentid;
     	bool notify;
     	int drops;
    -
    -	if (n == 0 && len == 0)
    -		return;
     	drops = max_t(int, n, 0);
     	rcu_read_lock();
     	while ((parentid = sch->parent)) {
    @@ -808,17 +796,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     
     		if (sch->flags & TCQ_F_NOPARENT)
     			break;
    -		/* Notify parent qdisc only if child qdisc becomes empty.
    -		 *
    -		 * If child was empty even before update then backlog
    -		 * counter is screwed and we skip notification because
    -		 * parent class is already passive.
    -		 *
    -		 * If the original child was offloaded then it is allowed
    -		 * to be seem as empty, so the parent is notified anyway.
    -		 */
    -		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
    -						       !qdisc_is_offloaded);
    +		/* Notify parent qdisc only if child qdisc becomes empty. */
    +		notify = !sch->q.qlen;
     		/* TODO: perform the search on a per txq basis */
     		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
     		if (sch == NULL) {
    @@ -827,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     		}
     		cops = sch->ops->cl_ops;
     		if (notify && cops->qlen_notify) {
    +			/* Note that qlen_notify must be idempotent as it may get called
    +			 * multiple times.
    +			 */
     			cl = cops->find(sch, parentid);
     			cops->qlen_notify(sch, cl);
     		}

[FUNCTION_CONTENT]
void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
{
	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
	const struct Qdisc_class_ops *cops;
	unsigned long cl;
	u32 parentid;
	bool notify;
	int drops;

	if (n == 0 && len == 0)
		return;
	drops = max_t(int, n, 0);
	rcu_read_lock();
	while ((parentid = sch->parent)) {
		if (parentid == TC_H_ROOT)
			break;

		if (sch->flags & TCQ_F_NOPARENT)
			break;
		/* Notify parent qdisc only if child qdisc becomes empty.
		 *
		 * If child was empty even before update then backlog
		 * counter is screwed and we skip notification because
		 * parent class is already passive.
		 *
		 * If the original child was offloaded then it is allowed
		 * to be seem as empty, so the parent is notified anyway.
		 */
		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
						       !qdisc_is_offloaded);
		/* TODO: perform the search on a per txq basis */
		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
		if (sch == NULL) {
			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}
		sch->q.qlen -= n;
		sch->qstats.backlog -= len;
		__qdisc_qstats_drop(sch, drops);
	}
	rcu_read_unlock();
}

/* ----- separator ----- */

			WARN_ON_ONCE(parentid != TC_H_ROOT);
			break;
		}
		cops = sch->ops->cl_ops;
		if (notify && cops->qlen_notify) {
			cl = cops->find(sch, parentid);
			cops->qlen_notify(sch, cl);
		}

/* ----- separator ----- */

int qdisc_offload_dump_helper(struct Qdisc *sch, enum tc_setup_type type,
			      void *type_data)
{
	struct net_device *dev = qdisc_dev(sch);
	int err;

	sch->flags &= ~TCQ_F_OFFLOADED;
	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
		return 0;

	err = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);
	if (err == -EOPNOTSUPP)
		return 0;

	if (!err)
		sch->flags |= TCQ_F_OFFLOADED;

	return err;
}

/* ----- separator ----- */

EXPORT_SYMBOL(qdisc_tree_reduce_backlog);

int qdisc_offload_dump_helper(struct Qdisc *sch, enum tc_setup_type type,
			      void *type_data)
{
	struct net_device *dev = qdisc_dev(sch);
	int err;

	sch->flags &= ~TCQ_F_OFFLOADED;
	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
		return 0;

	err = dev->netdev_ops->ndo_setup_tc(dev, type, type_data);
	if (err == -EOPNOTSUPP)
		return 0;

	if (!err)
		sch->flags |= TCQ_F_OFFLOADED;

	return err;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38350

2. Vulnerability Type
Use-after-free due to missed state notification in classful qdisc hierarchy

3. Root Cause Summary
qdisc_tree_reduce_backlog() suppressed parent notifications when a child qdisc became empty if no packet count/length deltas were provided (n == 0 && len == 0) and the qdisc was not offloaded. Specifically, the function returned early on (n == 0 && len == 0) and computed notify as “!sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded)”, thereby skipping cops->qlen_notify() in common cases where qlen transitioned to 0 without explicit n/len updates. This left parent classes unaware that the child emptied/reset, allowing them to keep or re-activate classes that had been deleted, leading to use-after-free on stale class pointers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking traffic-control scheduler (net/sched), classful qdisc hierarchy handling

2) Pre-Patch Flaw:
- In qdisc_tree_reduce_backlog(), parent notification was tied to n/len updates and offload state instead of the actual empty state of the child qdisc:
  - Early exit: “if (n == 0 && len == 0) return;”
  - notify gating: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
- As a result, when a child became empty via qdisc_reset()/qdisc_purge_queue() or dequeue-during-enqueue paths, parents were not notified, desynchronizing class state.

3) Trigger Condition:
- Classful qdisc stacks where a child qdisc becomes empty without nonzero n/len, e.g., during class deletion or when enqueue invokes a dequeue handler that empties the child. The provided reproducer (DRR -> HFSC -> netem -> blackhole, then delete class and send another packet) triggers the missed notification and subsequent stale class handling.

4) Impact Mechanism:
- Without qlen_notify() propagation, the parent (and potentially its parent) may re-activate or continue referencing a class whose child qdisc has been reset/deleted. Subsequent scheduling accesses freed class structures, resulting in a use-after-free.

5. Patch Analysis
1) Fix Approach:
- Decouple notification from n/len changes and offload status; always notify when the child qdisc is empty. Ensure notification is propagated up the hierarchy even when n == 0 && len == 0.

2) Key Code Changes:
- Removed the early return on zero deltas:
  - Deleted: “if (n == 0 && len == 0) return;”
- Simplified and strengthened the notify condition:
  - Replaced: “notify = !sch->q.qlen && !WARN_ON_ONCE(!n && !qdisc_is_offloaded);”
  - With: “notify = !sch->q.qlen;”
- Removed qdisc_is_offloaded logic entirely and added a note that qlen_notify must be idempotent since it may be called multiple times.
- No functional change to the RCU traversal; the loop continues to walk parents and call cops->qlen_notify() whenever sch->q.qlen == 0.

3) Locking/Concurrency Impact:
- RCU read-side locking remains unchanged (rcu_read_lock()/rcu_read_unlock()).
- The change increases the frequency of qlen_notify() calls (including multiple notifications on passive classes), but the code and recent series ensure handlers are idempotent, avoiding concurrency hazards.
- No new locks or ordering changes; the fix removes a race window created by conditional notification by guaranteeing timely state propagation based solely on qlen.

6. Broader Kernel Security Implications
- Hierarchical scheduler correctness depends on precise, unconditional state propagation; conditioning notifications on accounting deltas is brittle and can cause lifetime bugs. This fix reduces reliance on fragile backlog accounting and prevents cascaded desynchronization across parent levels. The approach underscores the need for idempotent notifications and may guide similar robustness improvements in other classful qdisc handlers and hierarchical subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}