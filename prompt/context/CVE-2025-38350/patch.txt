    @@ -783,21 +783,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     {
    -	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
     	const struct Qdisc_class_ops *cops;
     	unsigned long cl;
     	u32 parentid;
     	bool notify;
     	int drops;
    -
    -	if (n == 0 && len == 0)
    -		return;
     	drops = max_t(int, n, 0);
     	rcu_read_lock();
     	while ((parentid = sch->parent)) {
    @@ -808,17 +796,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     
     		if (sch->flags & TCQ_F_NOPARENT)
     			break;
    -		/* Notify parent qdisc only if child qdisc becomes empty.
    -		 *
    -		 * If child was empty even before update then backlog
    -		 * counter is screwed and we skip notification because
    -		 * parent class is already passive.
    -		 *
    -		 * If the original child was offloaded then it is allowed
    -		 * to be seem as empty, so the parent is notified anyway.
    -		 */
    -		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
    -						       !qdisc_is_offloaded);
    +		/* Notify parent qdisc only if child qdisc becomes empty. */
    +		notify = !sch->q.qlen;
     		/* TODO: perform the search on a per txq basis */
     		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
     		if (sch == NULL) {
    @@ -827,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
     		}
     		cops = sch->ops->cl_ops;
     		if (notify && cops->qlen_notify) {
    +			/* Note that qlen_notify must be idempotent as it may get called
    +			 * multiple times.
    +			 */
     			cl = cops->find(sch, parentid);
     			cops->qlen_notify(sch, cl);
     		}