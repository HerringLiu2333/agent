You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38493

[INFO]
[PATCH_DESCRIPTION]
    tracing/osnoise: Fix crash in timerlat_dump_stack()
    We have observed kernel panics when using timerlat with stack saving,
    with the following dmesg output:
    
    memcpy: detected buffer overflow: 88 byte write of buffer size 0
    WARNING: CPU: 2 PID: 8153 at lib/string_helpers.c:1032 __fortify_report+0x55/0xa0
    CPU: 2 UID: 0 PID: 8153 Comm: timerlatu/2 Kdump: loaded Not tainted 6.15.3-200.fc42.x86_64 #1 PREEMPT(lazy)
    Call Trace:
     <TASK>
     ? trace_buffer_lock_reserve+0x2a/0x60
     __fortify_panic+0xd/0xf
     __timerlat_dump_stack.cold+0xd/0xd
     timerlat_dump_stack.part.0+0x47/0x80
     timerlat_fd_read+0x36d/0x390
     vfs_read+0xe2/0x390
     ? syscall_exit_to_user_mode+0x1d5/0x210
     ksys_read+0x73/0xe0
     do_syscall_64+0x7b/0x160
     ? exc_page_fault+0x7e/0x1a0
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    __timerlat_dump_stack() constructs the ftrace stack entry like this:
    
    struct stack_entry *entry;
    ...
    memcpy(&entry->caller, fstack->calls, size);
    entry->size = fstack->nr_entries;
    
    Since commit e7186af7fb26 ("tracing: Add back FORTIFY_SOURCE logic to
    kernel_stack event structure"), struct stack_entry marks its caller
    field with __counted_by(size). At the time of the memcpy, entry->size
    contains garbage from the ringbuffer, which under some circumstances is
    zero, triggering a kernel panic by buffer overflow.
    
    Populate the size field before the memcpy so that the out-of-bounds
    check knows the correct size. This is analogous to
    __ftrace_trace_stack().

[PATCH_DIFF]
     @@ -637,8 +637,8 @@ __timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, u
      
      	entry = ring_buffer_event_data(event);
      
     -	memcpy(&entry->caller, fstack->calls, size);
      	entry->size = fstack->nr_entries;
     +	memcpy(&entry->caller, fstack->calls, size);
      
      	trace_buffer_unlock_commit_nostack(buffer, event);
      }

[FUNCTION_CONTENT]
static void
__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)
{
	struct ring_buffer_event *event;
	struct stack_entry *entry;

	event = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,
					  tracing_gen_ctx());
	if (!event)
		return;

	entry = ring_buffer_event_data(event);

	memcpy(&entry->caller, fstack->calls, size);
	entry->size = fstack->nr_entries;

	trace_buffer_unlock_commit_nostack(buffer, event);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38493

2. Vulnerability Type
Out-of-bounds write / unsafe memcpy due to uninitialized counted-by length field, resulting in kernel crash (DoS)

3. Root Cause Summary
The function __timerlat_dump_stack() performed memcpy into struct stack_entry->caller, which is annotated with __counted_by(size), before initializing entry->size. Because entry->size contained uninitialized data from the ring buffer (often zero), the FORTIFY_SOURCE bounds check interpreted the destination buffer length as 0 and triggered a kernel panic. The flawed logic was the incorrect initialization order: “memcpy(&entry->caller, fstack->calls, size); entry->size = fstack->nr_entries;” should have set entry->size before the memcpy. This is analogous to __ftrace_trace_stack(), which initializes the counted length prior to copying.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
tracing/osnoise (timerlat stack saving path)

2) Pre-Patch Flaw:
In __timerlat_dump_stack(), entry->size (the length driving __counted_by for entry->caller) was set after the memcpy, leaving FORTIFY to see a zero/garbage size during the copy and flag the write as out-of-bounds.

3) Trigger Condition:
Using timerlat with stack saving and reading from the timerlat fd (timerlat_fd_read path) when ring_buffer_event_data() returns an entry whose size field is still uninitialized at the time of memcpy; FORTIFY then computes the destination size as 0 while “size” > 0.

4) Impact Mechanism:
FORTIFY’s destination-bound check detects “88 byte write of buffer size 0” and calls __fortify_panic, causing a kernel WARN/panic (DoS). Without the check, the memcpy would write past the actual caller array bounds determined by nr_entries, risking memory corruption.

5. Patch Analysis
1) Fix Approach:
Initialize the counted-by length (entry->size) before performing the memcpy so the FORTIFY bounds check uses the correct destination size.

2) Key Code Changes:
In __timerlat_dump_stack():
- Pre-patch order:
  memcpy(&entry->caller, fstack->calls, size);
  entry->size = fstack->nr_entries;
- Post-patch order:
  entry->size = fstack->nr_entries;
  memcpy(&entry->caller, fstack->calls, size);
This reordering ensures entry->size is set prior to the copy.

3) Locking/Concurrency Impact:
No changes to locking or concurrency. The existing trace_buffer_lock_reserve() and trace_buffer_unlock_commit_nostack() usage remains unchanged; the fix strictly adjusts assignment order within the reserved event.

6. Broader Kernel Security Implications
This highlights the need to initialize __counted_by fields before any memory operations that rely on them, especially under FORTIFY_SOURCE. Similar patterns in tracing or other subsystems can lead to crashes or memory corruption if initialization order is wrong. Ensuring correct field initialization and copy ordering improves robustness against DoS and latent buffer overflows in kernel instrumentation paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.