You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38314

[INFO]
[PATCH_DESCRIPTION]
    virtio-pci: Fix result size returned for the admin command completion
    The result size returned by virtio_pci_admin_dev_parts_get() is 8 bytes
    larger than the actual result data size. This occurs because the
    result_sg_size field of the command is filled with the result length
    from virtqueue_get_buf(), which includes both the data size and an
    additional 8 bytes of status.
    
    This oversized result size causes two issues:
    1. The state transferred to the destination includes 8 bytes of extra
       data at the end.
    2. The allocated buffer in the kernel may be smaller than the returned
       size, leading to failures when reading beyond the allocated size.
    
    The commit fixes this by subtracting the status size from the result of
    virtqueue_get_buf().
    
    This fix has been tested through live migrations with virtio-net,
    virtio-net-transitional, and virtio-blk devices.

[PATCH_DIFF]
    @@ -48,6 +48,7 @@ void vp_modern_avq_done(struct virtqueue *vq)
     {
     	struct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);
     	struct virtio_pci_admin_vq *admin_vq = &vp_dev->admin_vq;
    +	unsigned int status_size = sizeof(struct virtio_admin_cmd_status);
     	struct virtio_admin_cmd *cmd;
     	unsigned long flags;
     	unsigned int len;
    @@ -56,7 +57,17 @@ void vp_modern_avq_done(struct virtqueue *vq)
     	do {
     		virtqueue_disable_cb(vq);
     		while ((cmd = virtqueue_get_buf(vq, &len))) {
    -			cmd->result_sg_size = len;
    +			/* If the number of bytes written by the device is less
    +			 * than the size of struct virtio_admin_cmd_status, the
    +			 * remaining status bytes will remain zero-initialized,
    +			 * since the buffer was zeroed during allocation.
    +			 * In this case, set the size of command_specific_result
    +			 * to 0.
    +			 */
    +			if (len < status_size)
    +				cmd->result_sg_size = 0;
    +			else
    +				cmd->result_sg_size = len - status_size;
     			complete(&cmd->completion);
     		}
     	} while (!virtqueue_enable_cb(vq));



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38314

2. Vulnerability Type
Length miscalculation causing out-of-bounds read (buffer over-read) and protocol/state corruption

3. Root Cause Summary
The completion handler for the virtio-pci admin queue misinterpreted the length returned by virtqueue_get_buf(). It used the total bytes written (which include an additional sizeof(struct virtio_admin_cmd_status) status trailer) as the size of the command-specific result buffer. Pre-patch code set “cmd->result_sg_size = len;” in vp_modern_avq_done(), over-reporting the result size by 8 bytes. Subsequent consumers treated result_sg_size as data length, leading to reads beyond the allocated result buffer and inclusion of the trailing status into the migrated state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
virtio-pci admin virtqueue completion handling (vp_modern_avq_done)

2) Pre-Patch Flaw:
- In vp_modern_avq_done(), the code directly assigned the virtqueue_get_buf() return length (data + status) to cmd->result_sg_size, e.g., “cmd->result_sg_size = len;”.
- The field cmd->result_sg_size represents only the command-specific result data, not including the trailing status structure, so this was a size/protocol confusion.

3) Trigger Condition:
- Any admin command completion on the admin virtqueue where virtqueue_get_buf() returns a length that includes both data and the mandatory status trailer (typically 8 bytes).
- Downstream code reads or copies cmd->result_sg_size bytes from the result buffer under the assumption it reflects only the data payload size.

4) Impact Mechanism:
- The kernel may read 8 bytes beyond the allocated result buffer (out-of-bounds read), causing failures and potential crashes.
- Migrated/serialized state included an extra 8 trailing bytes (the status area), violating the expected wire/state format and corrupting state at the destination.
- If the device wrote fewer than status_size bytes, the old logic still reported a positive size, risking further inconsistencies (now mitigated by zero-length clamping).

5. Patch Analysis
1) Fix Approach:
- Correct the result size accounting by subtracting the status trailer size from the total bytes reported by virtqueue_get_buf().
- Clamp to zero when fewer than status_size bytes were written, leveraging zero-initialized buffers to avoid spurious data exposure.

2) Key Code Changes:
- Introduced “unsigned int status_size = sizeof(struct virtio_admin_cmd_status);”.
- Replaced “cmd->result_sg_size = len;” with:
  - If (len < status_size) set cmd->result_sg_size = 0;
  - Else set cmd->result_sg_size = len - status_size.
- Added a comment explaining zero-initialization and the short-status case.

3) Locking/Concurrency Impact:
- No locking or concurrency semantics changed. The logic remains within vp_modern_avq_done()’s completion loop (with virtqueue_disable_cb/enable_cb bracketing) and only adjusts size arithmetic.

6. Broader Kernel Security Implications
- Length miscalculations around virtqueue_get_buf() are subtle and may recur when multiple scatterlist elements (data + control/status) are used; similar paths should be audited for proper separation of payload and metadata lengths.
- Over-reported lengths can lead to kernel buffer over-reads, protocol/state corruption, and potential info exposure; standardizing helpers to compute payload length (excluding trailers) would reduce risk.
- The explicit clamp for short writes improves robustness against malformed or malicious device behavior, preventing misuse of partially written status as data.
- Ensuring buffers are zero-initialized mitigates information disclosure but does not prevent over-read-induced crashes; correctness of size accounting remains critical for virtio admin command handling and live migration reliability.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.