You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38314

[INFO]
[PATCH_DESCRIPTION]
    virtio-pci: Fix result size returned for the admin command completion
    The result size returned by virtio_pci_admin_dev_parts_get() is 8 bytes
    larger than the actual result data size. This occurs because the
    result_sg_size field of the command is filled with the result length
    from virtqueue_get_buf(), which includes both the data size and an
    additional 8 bytes of status.
    
    This oversized result size causes two issues:
    1. The state transferred to the destination includes 8 bytes of extra
       data at the end.
    2. The allocated buffer in the kernel may be smaller than the returned
       size, leading to failures when reading beyond the allocated size.
    
    The commit fixes this by subtracting the status size from the result of
    virtqueue_get_buf().
    
    This fix has been tested through live migrations with virtio-net,
    virtio-net-transitional, and virtio-blk devices.

[PATCH_DIFF]
    @@ -48,6 +48,7 @@ void vp_modern_avq_done(struct virtqueue *vq)
     {
     	struct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);
     	struct virtio_pci_admin_vq *admin_vq = &vp_dev->admin_vq;
    +	unsigned int status_size = sizeof(struct virtio_admin_cmd_status);
     	struct virtio_admin_cmd *cmd;
     	unsigned long flags;
     	unsigned int len;
    @@ -56,7 +57,17 @@ void vp_modern_avq_done(struct virtqueue *vq)
     	do {
     		virtqueue_disable_cb(vq);
     		while ((cmd = virtqueue_get_buf(vq, &len))) {
    -			cmd->result_sg_size = len;
    +			/* If the number of bytes written by the device is less
    +			 * than the size of struct virtio_admin_cmd_status, the
    +			 * remaining status bytes will remain zero-initialized,
    +			 * since the buffer was zeroed during allocation.
    +			 * In this case, set the size of command_specific_result
    +			 * to 0.
    +			 */
    +			if (len < status_size)
    +				cmd->result_sg_size = 0;
    +			else
    +				cmd->result_sg_size = len - status_size;
     			complete(&cmd->completion);
     		}
     	} while (!virtqueue_enable_cb(vq));

[FUNCTION_CONTENT]
void vp_modern_avq_done(struct virtqueue *vq)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);
	struct virtio_pci_admin_vq *admin_vq = &vp_dev->admin_vq;
	struct virtio_admin_cmd *cmd;
	unsigned long flags;
	unsigned int len;

	spin_lock_irqsave(&admin_vq->lock, flags);
	do {
		virtqueue_disable_cb(vq);
		while ((cmd = virtqueue_get_buf(vq, &len))) {
			cmd->result_sg_size = len;
			complete(&cmd->completion);
		}
	} while (!virtqueue_enable_cb(vq));
	spin_unlock_irqrestore(&admin_vq->lock, flags);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38314

2. Vulnerability Type
Length miscalculation leading to out-of-bounds read/copy and protocol/state corruption

3. Root Cause Summary
The completion handler vp_modern_avq_done wrote the total bytes returned by virtqueue_get_buf (which include both command-specific result data and an 8-byte status trailer) directly into cmd->result_sg_size. Pre-patch code: “cmd->result_sg_size = len;”. This inflated result_sg_size by sizeof(struct virtio_admin_cmd_status), causing consumers to treat the status bytes as part of the result and potentially read/copy past the buffer allocated for the result. This led to erroneous state transfers and read-beyond-allocation failures when processing admin command completion data.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
virtio-pci admin virtqueue completion handling (vp_modern_avq_done in virtio-pci)

2) Pre-Patch Flaw:
In vp_modern_avq_done, cmd->result_sg_size was set to the total bytes written (len) by the device via virtqueue_get_buf, which includes the trailing struct virtio_admin_cmd_status, instead of only the command-specific result length.

3) Trigger Condition:
Any admin command completion on the virtio-pci admin virtqueue where the device returns result data plus the status structure; notably during live migrations (e.g., virtio-net, virtio-net-transitional, virtio-blk) when using virtio_pci_admin_dev_parts_get.

4) Impact Mechanism:
- The oversized result_sg_size causes the migration code to transfer 8 extraneous status bytes appended to the result, corrupting the destination state.
- Kernel consumers may attempt to read/copy result_sg_size bytes from a buffer allocated only for the true result size, resulting in reads past the allocation boundary and failures (out-of-bounds read/copy).

5. Patch Analysis
1) Fix Approach:
Correct the result length accounting by excluding the status trailer from the size returned to higher layers and guard against short writes.

2) Key Code Changes:
- Introduced status_size = sizeof(struct virtio_admin_cmd_status).
- Replaced “cmd->result_sg_size = len;” with:
  - If len < status_size: set cmd->result_sg_size = 0 (short write, buffer zero-initialized).
  - Else: set cmd->result_sg_size = len - status_size.
This aligns result_sg_size with the actual command-specific result length.

3) Locking/Concurrency Impact:
No changes to locking or concurrency; spin_lock_irqsave on admin_vq->lock and virtqueue_disable_cb/enable_cb usage remain as before. The fix is purely a size calculation correction within the protected region.

6. Broader Kernel Security Implications
Length accounting errors in virtio data paths can propagate to state transfer and buffer management, risking out-of-bounds accesses and corrupted device state during live migration. Correctly separating protocol status metadata from payload sizes reduces the attack surface for malicious or misbehaving devices and prevents kernel read/copy overruns. This change improves robustness of admin command handling and mitigates subtle memory-safety and data-integrity issues in virtio-pci.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.