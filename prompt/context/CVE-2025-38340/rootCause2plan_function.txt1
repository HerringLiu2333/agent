You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38340

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test
    KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(),
    because the source string length was rounded up to the allocation size.

[PATCH_DIFF]
    @@ -96,10 +96,11 @@ static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *bui
     
     	if (info_len % 4) {
     		/* Create a padded string with length a multiple of 4 */
    +		size_t copy_len = info_len;
     		info_len = round_up(info_len, 4);
     		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
     		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
    -		memcpy(tmp, info, info_len);
    +		memcpy(tmp, info, copy_len);
     		info = tmp;
     	}

[FUNCTION_CONTENT]
static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *builder,
					     const char *info, int type)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_bin_add_raw_block(builder, 0, 0, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */


	KUNIT_ASSERT_TRUE(builder->test_priv->test,
			  (builder->write_p + bytes_needed) <
			  (builder->buf + CS_DSP_MOCK_BIN_BUF_SIZE));

	item = builder->write_p;

	item->offset = cpu_to_le16(offset);
	item->type = cpu_to_le16(type);
	item->id = cpu_to_le32(alg_id);
	item->ver = cpu_to_le32(alg_ver << 8);
	item->len = cpu_to_le32(payload_len_bytes);

	if (payload_len_bytes)
		memcpy(item->data, payload_data, payload_len_bytes);

	builder->write_p += bytes_needed;
	builder->bytes_used += bytes_needed;
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_raw_block, "FW_CS_DSP_KUNIT_TEST_UTILS");

static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *builder,
					     const char *info, int type)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_bin_add_raw_block(builder, 0, 0, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */

EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_raw_block, "FW_CS_DSP_KUNIT_TEST_UTILS");

static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *builder,
					     const char *info, int type)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_bin_add_raw_block(builder, 0, 0, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/* ----- separator ----- */

		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_bin_add_raw_block(builder, 0, 0, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/**
 * cs_dsp_mock_bin_add_info() - Add an info block to the bin file.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 * @info:	Pointer to info string to be copied into the file.
 *
 * The string will be padded to a length that is a multiple of 4 bytes.
 */
void cs_dsp_mock_bin_add_info(struct cs_dsp_mock_bin_builder *builder,
			      const char *info)
{
	cs_dsp_mock_bin_add_name_or_info(builder, info, WMFW_INFO_TEXT);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds read

3. Root Cause Summary
The function cs_dsp_mock_bin_add_name_or_info rounded the string length up to a multiple of 4 and then used that padded length as the memcpy source size, i.e., “memcpy(tmp, info, info_len)” after info_len had been increased. This caused memcpy to read past the end of the original source string when the original length was not a multiple of 4. The bug stems from using the destination’s padded size instead of preserving and using the original source length for the copy.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware test utilities for Cirrus Logic DSP (FW_CS_DSP_KUNIT_TEST_UTILS) within cs_dsp KUnit tests.

2) Pre-Patch Flaw:
In cs_dsp_mock_bin_add_name_or_info, info_len was set to strlen(info), then rounded up to a multiple of 4, and used directly in “memcpy(tmp, info, info_len)”, causing the copy to read beyond the true length of the source string.

3) Trigger Condition:
Any info string whose length is not divisible by 4 (info_len % 4 != 0), which activates the padding path and the incorrect memcpy length.

4) Impact Mechanism:
memcpy performs an out-of-bounds read from the source pointer (info), potentially accessing adjacent memory and triggering KASAN OOB read reports; in non-sanitized builds this could lead to information exposure or faults depending on memory layout.

5. Patch Analysis
1) Fix Approach:
Preserve the original string length separately and use it as the memcpy size, while keeping the padded destination size for allocation and payload length.

2) Key Code Changes:
- Introduced “size_t copy_len = info_len;” before rounding.
- Changed “memcpy(tmp, info, info_len);” to “memcpy(tmp, info, copy_len);”.
This ensures only the original string length is read from the source, and the extra padded bytes remain zero-initialized by kunit_kzalloc.

3) Locking/Concurrency Impact:
None; the change is purely in copy length logic within a test utility function and does not alter locking or ordering.

6. Broader Kernel Security Implications
This fix reinforces a common pattern for safe padding: round up only the destination allocation and payload length, but copy the exact source length. Avoiding OOB reads prevents subtle information leaks and sanitizer-detected faults, even within test code that can be reused or serve as reference for production paths. Similar string-padding/copy routines elsewhere should be audited to ensure source copy sizes are not derived from padded destination lengths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}