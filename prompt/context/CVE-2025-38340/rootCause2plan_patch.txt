You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38340

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test
    KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(),
    because the source string length was rounded up to the allocation size.

[PATCH_DIFF]
    @@ -96,10 +96,11 @@ static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *bui
     
     	if (info_len % 4) {
     		/* Create a padded string with length a multiple of 4 */
    +		size_t copy_len = info_len;
     		info_len = round_up(info_len, 4);
     		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
     		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
    -		memcpy(tmp, info, info_len);
    +		memcpy(tmp, info, copy_len);
     		info = tmp;
     	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds memory read due to length miscalculation/padding

3. Root Cause Summary
In cs_dsp_mock_bin_add_name_or_info(), the code rounded the source string length (info_len) up to a 4-byte multiple and then used this padded length as the memcpy copy size. The original code “memcpy(tmp, info, info_len)” executed after “info_len = round_up(info_len, 4)”, causing memcpy to read past the end of the source buffer when the original length was not a multiple of 4. The flaw was a length misuse: failing to preserve and use the original source length for the copy, leading to OOB read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test code), function cs_dsp_mock_bin_add_name_or_info

2) Pre-Patch Flaw:
The function rounded info_len upward and reused the modified value as the memcpy count, instead of copying only the original length. This conflated allocation size (padded) with data length (actual), resulting in reading beyond the source buffer.

3) Trigger Condition:
Any input where info_len % 4 != 0 (i.e., source string length not a multiple of 4), triggering the padding logic and subsequent oversized memcpy.

4) Impact Mechanism:
memcpy reads beyond the bounds of the source buffer, leading to KASAN-reported OOB read. In kernel context—even KUnit—this can access unintended memory, potentially causing faults or information exposure.

5. Patch Analysis
1) Fix Approach:
Separate the original data length from the padded allocation length and use the original length for memcpy. Preserve info_len before rounding, allocate the padded size, and copy only the unpadded length; zero-initialization provides the padding content.

2) Key Code Changes:
- Introduced a new variable: “size_t copy_len = info_len;” before rounding.
- Changed memcpy to use the original length: from “memcpy(tmp, info, info_len)” to “memcpy(tmp, info, copy_len)”.
- Retained “info_len = round_up(info_len, 4);” solely for allocation size.

3) Locking/Concurrency Impact:
None. The change is confined to bounds handling; no locking or ordering modifications are involved.

6. Broader Kernel Security Implications
This fix reinforces the need to distinguish between logical data length and allocation/padding size, a common source of memory safety bugs in kernel code. Even within test code, OOB reads can mask real issues, destabilize tests, or indicate patterns that, if present in production paths, would lead to information disclosure or crashes. Adopting clear length management and zero-initialized padding avoids read-overruns and improves robustness against subtle memory errors detected by tools like KASAN.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.