You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38340

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test
    KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(),
    because the source string length was rounded up to the allocation size.

[PATCH_DIFF]
    @@ -96,10 +96,11 @@ static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *bui
     
     	if (info_len % 4) {
     		/* Create a padded string with length a multiple of 4 */
    +		size_t copy_len = info_len;
     		info_len = round_up(info_len, 4);
     		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
     		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
    -		memcpy(tmp, info, info_len);
    +		memcpy(tmp, info, copy_len);
     		info = tmp;
     	}

[FILE_CONTENT]
// SPDX-License-Identifier: GPL-2.0-only
//
// bin file builder for cs_dsp KUnit tests.
//
// Copyright (C) 2024 Cirrus Logic, Inc. and
//                    Cirrus Logic International Semiconductor Ltd.

#include <kunit/resource.h>
#include <kunit/test.h>
#include <linux/firmware/cirrus/cs_dsp.h>
#include <linux/firmware/cirrus/cs_dsp_test_utils.h>
#include <linux/firmware/cirrus/wmfw.h>
#include <linux/firmware.h>
#include <linux/math.h>
#include <linux/overflow.h>
#include <linux/string.h>
#include <linux/vmalloc.h>

/* Buffer large enough for bin file content */
#define CS_DSP_MOCK_BIN_BUF_SIZE	32768

KUNIT_DEFINE_ACTION_WRAPPER(vfree_action_wrapper, vfree, void *)

struct cs_dsp_mock_bin_builder {
	struct cs_dsp_test *test_priv;
	void *buf;
	void *write_p;
	size_t bytes_used;
};

/**
 * cs_dsp_mock_bin_get_firmware() - Get struct firmware wrapper for data.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 *
 * Return: Pointer to a struct firmware wrapper for the data.
 */
struct firmware *cs_dsp_mock_bin_get_firmware(struct cs_dsp_mock_bin_builder *builder)
{
	struct firmware *fw;

	fw = kunit_kzalloc(builder->test_priv->test, sizeof(*fw), GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, fw);

	fw->data = builder->buf;
	fw->size = builder->bytes_used;

	return fw;
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_get_firmware, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_bin_add_raw_block() - Add a data block to the bin file.
 *
 * @builder:		Pointer to struct cs_dsp_mock_bin_builder.
 * @alg_id:		Algorithm ID.
 * @alg_ver:		Algorithm version.
 * @type:		Type of the block.
 * @offset:		Offset.
 * @payload_data:	Pointer to buffer containing the payload data.
 * @payload_len_bytes:	Length of payload data in bytes.
 */
void cs_dsp_mock_bin_add_raw_block(struct cs_dsp_mock_bin_builder *builder,
				   unsigned int alg_id, unsigned int alg_ver,
				   int type, unsigned int offset,
				   const void *payload_data, size_t payload_len_bytes)
{
	struct wmfw_coeff_item *item;
	size_t bytes_needed = struct_size_t(struct wmfw_coeff_item, data, payload_len_bytes);

	KUNIT_ASSERT_TRUE(builder->test_priv->test,
			  (builder->write_p + bytes_needed) <
			  (builder->buf + CS_DSP_MOCK_BIN_BUF_SIZE));

	item = builder->write_p;

	item->offset = cpu_to_le16(offset);
	item->type = cpu_to_le16(type);
	item->id = cpu_to_le32(alg_id);
	item->ver = cpu_to_le32(alg_ver << 8);
	item->len = cpu_to_le32(payload_len_bytes);

	if (payload_len_bytes)
		memcpy(item->data, payload_data, payload_len_bytes);

	builder->write_p += bytes_needed;
	builder->bytes_used += bytes_needed;
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_raw_block, "FW_CS_DSP_KUNIT_TEST_UTILS");

static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *builder,
					     const char *info, int type)
{
	size_t info_len = strlen(info);
	char *tmp = NULL;

	if (info_len % 4) {
		/* Create a padded string with length a multiple of 4 */
		info_len = round_up(info_len, 4);
		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
		memcpy(tmp, info, info_len);
		info = tmp;
	}

	cs_dsp_mock_bin_add_raw_block(builder, 0, 0, WMFW_INFO_TEXT, 0, info, info_len);
	kunit_kfree(builder->test_priv->test, tmp);
}

/**
 * cs_dsp_mock_bin_add_info() - Add an info block to the bin file.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 * @info:	Pointer to info string to be copied into the file.
 *
 * The string will be padded to a length that is a multiple of 4 bytes.
 */
void cs_dsp_mock_bin_add_info(struct cs_dsp_mock_bin_builder *builder,
			      const char *info)
{
	cs_dsp_mock_bin_add_name_or_info(builder, info, WMFW_INFO_TEXT);
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_info, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_bin_add_name() - Add a name block to the bin file.
 *
 * @builder:	Pointer to struct cs_dsp_mock_bin_builder.
 * @name:	Pointer to name string to be copied into the file.
 */
void cs_dsp_mock_bin_add_name(struct cs_dsp_mock_bin_builder *builder,
			      const char *name)
{
	cs_dsp_mock_bin_add_name_or_info(builder, name, WMFW_NAME_TEXT);
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_name, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_bin_add_patch() - Add a patch data block to the bin file.
 *
 * @builder:		Pointer to struct cs_dsp_mock_bin_builder.
 * @alg_id:		Algorithm ID for the patch.
 * @alg_ver:		Algorithm version for the patch.
 * @mem_region:		Memory region for the patch.
 * @reg_addr_offset:	Offset to start of data in register addresses.
 * @payload_data:	Pointer to buffer containing the payload data.
 * @payload_len_bytes:	Length of payload data in bytes.
 */
void cs_dsp_mock_bin_add_patch(struct cs_dsp_mock_bin_builder *builder,
			       unsigned int alg_id, unsigned int alg_ver,
			       int mem_region, unsigned int reg_addr_offset,
			       const void *payload_data, size_t payload_len_bytes)
{
	/* Payload length must be a multiple of 4 */
	KUNIT_ASSERT_EQ(builder->test_priv->test, payload_len_bytes % 4, 0);

	cs_dsp_mock_bin_add_raw_block(builder, alg_id, alg_ver,
				      mem_region, reg_addr_offset,
				      payload_data, payload_len_bytes);
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_add_patch, "FW_CS_DSP_KUNIT_TEST_UTILS");

/**
 * cs_dsp_mock_bin_init() - Initialize a struct cs_dsp_mock_bin_builder.
 *
 * @priv:		Pointer to struct cs_dsp_test.
 * @format_version:	Required bin format version.
 * @fw_version:		Firmware version to put in bin file.
 *
 * Return: Pointer to created struct cs_dsp_mock_bin_builder.
 */
struct cs_dsp_mock_bin_builder *cs_dsp_mock_bin_init(struct cs_dsp_test *priv,
						     int format_version,
						     unsigned int fw_version)
{
	struct cs_dsp_mock_bin_builder *builder;
	struct wmfw_coeff_hdr *hdr;

	KUNIT_ASSERT_LE(priv->test, format_version, 0xff);
	KUNIT_ASSERT_LE(priv->test, fw_version, 0xffffff);

	builder = kunit_kzalloc(priv->test, sizeof(*builder), GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(priv->test, builder);
	builder->test_priv = priv;

	builder->buf = vmalloc(CS_DSP_MOCK_BIN_BUF_SIZE);
	KUNIT_ASSERT_NOT_NULL(priv->test, builder->buf);
	kunit_add_action_or_reset(priv->test, vfree_action_wrapper, builder->buf);

	/* Create header */
	hdr = builder->buf;
	memcpy(hdr->magic, "WMDR", sizeof(hdr->magic));
	hdr->len = cpu_to_le32(offsetof(struct wmfw_coeff_hdr, data));
	hdr->ver = cpu_to_le32(fw_version | (format_version << 24));
	hdr->core_ver = cpu_to_le32(((u32)priv->dsp->type << 24) | priv->dsp->rev);

	builder->write_p = hdr->data;
	builder->bytes_used = offsetof(struct wmfw_coeff_hdr, data);

	return builder;
}
EXPORT_SYMBOL_NS_GPL(cs_dsp_mock_bin_init, "FW_CS_DSP_KUNIT_TEST_UTILS");




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38340

2. Vulnerability Type
Out-of-bounds read (length miscalculation during memcpy)

3. Root Cause Summary
In cs_dsp_mock_bin_add_name_or_info(), the code rounded the string length up to a 4-byte boundary for padding and then used this padded length as the memcpy() size from the original source string. This caused memcpy() to read past the end of the source buffer when padding was required (up to 3 extra bytes), leading to an out-of-bounds read detected by KASAN.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Firmware: Cirrus Logic cs_dsp KUnit test utilities (linux/firmware/cirrus/cs_dsp_test_utils)

2) Pre-Patch Flaw:
- Function: cs_dsp_mock_bin_add_name_or_info()
- The variable info_len was updated to a padded value (round_up(info_len, 4)) and then used as the length in memcpy(tmp, info, info_len), causing the copy to read beyond the actual source string length.

3) Trigger Condition:
- Any call where strlen(info) % 4 != 0, i.e., when the input string length is not a multiple of 4 and padding is performed.

4) Impact Mechanism:
- memcpy() reads up to 3 bytes beyond the end of the source string pointer (info), resulting in an out-of-bounds read. This can trigger KASAN/OOB-read reports and potentially copy unintended adjacent kernel memory into the constructed test buffer.

5. Patch Analysis
1) Fix Approach:
- Separate the original string length from the padded length. Copy only the original length into a zero-initialized (kzalloc) padded buffer, leaving the padding bytes as zeros.

2) Key Code Changes:
- Added size_t copy_len = info_len; before rounding.
- Changed memcpy(tmp, info, info_len); to memcpy(tmp, info, copy_len); ensuring no over-read from the source.
- Evidence (diff hunk in cs_dsp_mock_bin_add_name_or_info()):
  - Introduces copy_len holding the pre-rounded length.
  - Uses copy_len as the memcpy length while keeping info_len for allocation and payload length.

3) Locking/Concurrency Impact:
- None. The issue is a pure length/logic error in test code; no locking or concurrency changes were made or needed.

6. Broader Kernel Security Implications
- Highlights a common pitfall: reusing a padded/aligned length for source-buffer memcpy leads to OOB reads. Similar patterns in production code (alignment/padding of payloads) can cause data leaks or crashes. Maintaining distinct variables for original vs. padded lengths and using zero-initialized buffers for padding are safer patterns that prevent OOB reads and inadvertent information disclosure.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.