You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57949

[INFO]
[PATCH_DESCRIPTION]
 irqchip/gic-v3-its: Don't enable interrupts in its_irq_set_vcpu_affinity()
 commit 35cb2c6ce7da545f3b5cb1e6473ad7c3a6f08310 upstream.
 
 The following call-chain leads to enabling interrupts in a nested interrupt
 disabled section:

 irq_set_vcpu_affinity()
   irq_get_desc_lock()
      raw_spin_lock_irqsave()   <--- Disable interrupts
   its_irq_set_vcpu_affinity()
      guard(raw_spinlock_irq)   <--- Enables interrupts when leaving the guard()
   irq_put_desc_unlock()        <--- Warns because interrupts are enabled

 This was broken in commit b97e8a2f7130, which replaced the original
 raw_spin_[un]lock() pair with guard(raw_spinlock_irq).

 Fix the issue by using guard(raw_spinlock).

 [ tglx: Massaged change log ]
 
 Fixes: b97e8a2f7130 ("irqchip/gic-v3-its: Fix potential race condition in its_vlpi_prop_update()")

[PATCH_DIFF]
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 30e60bcc3b4e0b...4f8512385870a8 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1967,7 +1967,7 @@ static int its_irq_set_vcpu_affinity(struct irq_data *d, void vcpu_info)
	if (!is_v4(its_dev->its))
		return -EINVAL;

-	guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);
+	guard(raw_spinlock)(&its_dev->event_map.vlpi_lock);

	/* Unmap request? /
	if (!info)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57949

2. Vulnerability Type
Concurrency/locking bug due to incorrect interrupt-state management

3. Root Cause Summary
its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq) to protect vlpi_lock while being called in a context where interrupts had already been disabled by irq_get_desc_lock() via raw_spin_lock_irqsave(). On scope exit, guard(raw_spinlock_irq) restored (enabled) interrupts, violating the caller’s expectation that interrupts remain disabled until irq_put_desc_unlock(). This premature re-enablement created a race window and triggered a warning when irq_put_desc_unlock() observed interrupts enabled.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IRQ chip driver for ARM GICv3 ITS (drivers/irqchip/irq-gic-v3-its.c)

2) Pre-Patch Flaw:
Within its_irq_set_vcpu_affinity(), the code used an IRQ-disabling guard on vlpi_lock:
“guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);”
This was incorrect because the function is invoked under irq_set_vcpu_affinity() → irq_get_desc_lock() which already disables interrupts. The guard’s unlock path re-enabled interrupts, breaking nested interrupt-disabled semantics.

3) Trigger Condition:
Calling irq_set_vcpu_affinity() leads to irq_get_desc_lock() (raw_spin_lock_irqsave()), then into its_irq_set_vcpu_affinity() where guard(raw_spinlock_irq) is used; upon leaving the guard scope, interrupts are enabled before irq_put_desc_unlock() runs.

4) Impact Mechanism:
Interrupts become enabled in the middle of a nested critical section, allowing interrupt handlers or concurrent code to run and potentially access ITS event_map/IRQ descriptor state without proper serialization. This violates lock/IRQ nesting invariants, produces kernel warnings in irq_put_desc_unlock(), and opens a race window with possible state inconsistencies; specific memory-safety impacts are Unknown/Not determinable.

5. Patch Analysis
1) Fix Approach:
Stop manipulating interrupt state in the nested lock; use a plain spinlock guard so the outer irqsave-disabled state is preserved.

2) Key Code Changes:
In its_irq_set_vcpu_affinity():
- Replaced guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock) with guard(raw_spinlock)(&its_dev->event_map.vlpi_lock).

3) Locking/Concurrency Impact:
The inner lock no longer re-enables interrupts on scope exit, maintaining the caller’s interrupt-disabled state until irq_put_desc_unlock(). This removes the race window and prevents warnings by restoring correct lock/IRQ nesting and ordering.

6. Broader Kernel Security Implications
Correct preservation of interrupt state across nested locking is critical in IRQ management paths; misuse of IRQ-disabling guards inside already IRQ-disabled contexts can introduce subtle races and deadlocks. This fix highlights the need to choose lock primitives that match the calling context, and to avoid irq-restoring lock variants in functions potentially invoked with interrupts disabled. Similar patterns elsewhere should be audited to prevent concurrency violations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.