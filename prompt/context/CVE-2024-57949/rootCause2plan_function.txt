You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57949

[INFO]
[PATCH_DESCRIPTION]
 irqchip/gic-v3-its: Don't enable interrupts in its_irq_set_vcpu_affinity()
 commit 35cb2c6ce7da545f3b5cb1e6473ad7c3a6f08310 upstream.
 
 The following call-chain leads to enabling interrupts in a nested interrupt
 disabled section:

 irq_set_vcpu_affinity()
   irq_get_desc_lock()
      raw_spin_lock_irqsave()   <--- Disable interrupts
   its_irq_set_vcpu_affinity()
      guard(raw_spinlock_irq)   <--- Enables interrupts when leaving the guard()
   irq_put_desc_unlock()        <--- Warns because interrupts are enabled

 This was broken in commit b97e8a2f7130, which replaced the original
 raw_spin_[un]lock() pair with guard(raw_spinlock_irq).

 Fix the issue by using guard(raw_spinlock).

 [ tglx: Massaged change log ]
 
 Fixes: b97e8a2f7130 ("irqchip/gic-v3-its: Fix potential race condition in its_vlpi_prop_update()")

[PATCH_DIFF]
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 30e60bcc3b4e0b...4f8512385870a8 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1967,7 +1967,7 @@ static int its_irq_set_vcpu_affinity(struct irq_data *d, void vcpu_info)
	if (!is_v4(its_dev->its))
		return -EINVAL;

-	guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);
+	guard(raw_spinlock)(&its_dev->event_map.vlpi_lock);

	/* Unmap request? /
	if (!info)

[FUNCTION_CONTENT]
static int its_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)
{
	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
	struct its_cmd_info *info = vcpu_info;

	/* Need a v4 ITS */
	if (!is_v4(its_dev->its))
		return -EINVAL;

	guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);

	/* Unmap request? */
	if (!info)
		return its_vlpi_unmap(d);

	switch (info->cmd_type) {
	case MAP_VLPI:
		return its_vlpi_map(d, info);

	case GET_VLPI:
		return its_vlpi_get(d, info);

	case PROP_UPDATE_VLPI:
	case PROP_UPDATE_AND_INV_VLPI:
		return its_vlpi_prop_update(d, info);

	default:
		return -EINVAL;
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57949

2. Vulnerability Type
Incorrect interrupt state/locking misuse leading to premature interrupt enable (concurrency bug)

3. Root Cause Summary
its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq) on vlpi_lock, which unlocks with raw_spin_unlock_irq and unconditionally enables interrupts. The function is invoked under irq_set_vcpu_affinity() after irq_get_desc_lock() has disabled interrupts using raw_spin_lock_irqsave(), so enabling interrupts inside this nested critical section violates the interrupt-disabled nesting invariant. This creates a window where interrupts may run while the IRQ descriptor lock is still active, and causes irq_put_desc_unlock() to warn due to the unexpected interrupt state. The root cause was introduced by commit b97e8a2f7130, which replaced a raw_spin_[un]lock pair with guard(raw_spinlock_irq) in this path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IRQ subsystem, ARM GICv3 ITS (drivers/irqchip/irq-gic-v3-its.c)

2) Pre-Patch Flaw:
Within its_irq_set_vcpu_affinity(), the code used guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock), causing raw_spin_unlock_irq on scope exit and enabling interrupts regardless of prior state.

3) Trigger Condition:
When irq_set_vcpu_affinity() calls its_irq_set_vcpu_affinity() while holding the IRQ descriptor lock obtained via irq_get_desc_lock(), which disables interrupts using raw_spin_lock_irqsave().

4) Impact Mechanism:
Interrupts are re-enabled inside a nested interrupt-disabled section, violating locking expectations and opening a race window in vLPI map/unmap/prop_update operations and IRQ descriptor handling; additionally, irq_put_desc_unlock() detects and warns about the incorrect interrupt state.

5. Patch Analysis
1) Fix Approach:
Prevent any modification of interrupt state in its_irq_set_vcpu_affinity() by switching from guard(raw_spinlock_irq) to guard(raw_spinlock), preserving the outer interrupt-disabled context.

2) Key Code Changes:
One-line change in its_irq_set_vcpu_affinity(): guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock); replaced with guard(raw_spinlock)(&its_dev->event_map.vlpi_lock); (PATCH_DIFF hunk at drivers/irqchip/irq-gic-v3-its.c:1967).

3) Locking/Concurrency Impact:
The lock now uses raw_spin_lock/unlock without toggling interrupts, maintaining proper interrupt-disabled nesting established by irq_get_desc_lock() and eliminating the race window and warning on irq_put_desc_unlock(); overall lock ordering and atomicity are preserved without unintended interrupt enable.

6. Broader Kernel Security Implications
Incorrect use of _irq locking variants inside nested interrupt-disabled sections can inadvertently enable interrupts and break locking invariants, risking race conditions in low-level IRQ/chip paths. This fix highlights the need to match lock variants (_irq/_irqsave vs plain) to calling context to avoid interrupt state corruption. Similar patterns elsewhere could lead to subtle concurrency bugs affecting interrupt handling, virtual LPI management, and kernel stability under KVM/ITS operations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.