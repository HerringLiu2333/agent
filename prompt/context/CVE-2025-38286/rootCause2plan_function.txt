You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38286

[INFO]
[PATCH_DESCRIPTION]
    pinctrl: at91: Fix possible out-of-boundary access
    at91_gpio_probe() doesn't check that given OF alias is not available or
    something went wrong when trying to get it. This might have consequences
    when accessing gpio_chips array with that value as an index. Note, that
    BUG() can be compiled out and hence won't actually perform the required
    checks.

[PATCH_DIFF]
    @@ -1822,12 +1822,16 @@ static int at91_gpio_probe(struct platform_device *pdev)
     	struct gpio_chip *chip;
     	struct pinctrl_gpio_range *range;
    +	int alias_idx;
     	int ret = 0;
     	int irq, i;
    -	int alias_idx = of_alias_get_id(np, "gpio");
     	uint32_t ngpio;
     	char **names;
     
    +	alias_idx = of_alias_get_id(np, "gpio");
    +	if (alias_idx < 0)
    +		return alias_idx;
    +
     	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
     	if (gpio_chips[alias_idx])
     		return dev_err_probe(dev, -EBUSY, "%d slot is occupied.\n", alias_idx);

[FUNCTION_CONTENT]
static int at91_gpio_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct device_node *np = dev->of_node;
	struct at91_gpio_chip *at91_chip = NULL;
	struct gpio_chip *chip;
	struct pinctrl_gpio_range *range;
	int ret = 0;
	int irq, i;
	int alias_idx = of_alias_get_id(np, "gpio");
	uint32_t ngpio;
	char **names;

	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
	if (gpio_chips[alias_idx])
		return dev_err_probe(dev, -EBUSY, "%d slot is occupied.\n", alias_idx);

	irq = platform_get_irq(pdev, 0);
	if (irq < 0)
		return irq;

	at91_chip = devm_kzalloc(dev, sizeof(*at91_chip), GFP_KERNEL);
	if (!at91_chip)
		return -ENOMEM;

	at91_chip->regbase = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(at91_chip->regbase))
		return PTR_ERR(at91_chip->regbase);

	at91_chip->ops = device_get_match_data(dev);
	at91_chip->pioc_virq = irq;

	at91_chip->clock = devm_clk_get_enabled(dev, NULL);
	if (IS_ERR(at91_chip->clock))
		return dev_err_probe(dev, PTR_ERR(at91_chip->clock), "failed to get clock, ignoring.\n");

	at91_chip->chip = at91_gpio_template;
	at91_chip->id = alias_idx;

	chip = &at91_chip->chip;
	chip->label = dev_name(dev);
	chip->parent = dev;
	chip->owner = THIS_MODULE;
	chip->base = alias_idx * MAX_NB_GPIO_PER_BANK;

	if (!of_property_read_u32(np, "#gpio-lines", &ngpio)) {
		if (ngpio >= MAX_NB_GPIO_PER_BANK)
			dev_err(dev, "at91_gpio.%d, gpio-nb >= %d failback to %d\n",
				alias_idx, MAX_NB_GPIO_PER_BANK, MAX_NB_GPIO_PER_BANK);
		else
			chip->ngpio = ngpio;
	}

	names = devm_kasprintf_strarray(dev, "pio", chip->ngpio);
	if (IS_ERR(names))
		return PTR_ERR(names);

	for (i = 0; i < chip->ngpio; i++)
		strreplace(names[i], '-', alias_idx + 'A');

	chip->names = (const char *const *)names;

	range = &at91_chip->range;
	range->name = chip->label;
	range->id = alias_idx;
	range->pin_base = range->base = range->id * MAX_NB_GPIO_PER_BANK;

	range->npins = chip->ngpio;
	range->gc = chip;

	ret = at91_gpio_of_irq_setup(pdev, at91_chip);
	if (ret)
		return ret;

	ret = gpiochip_add_data(chip, at91_chip);
	if (ret)
		return ret;

	gpio_chips[alias_idx] = at91_chip;
	platform_set_drvdata(pdev, at91_chip);
	gpio_banks = max(gpio_banks, alias_idx + 1);

	dev_info(dev, "at address %p\n", at91_chip->regbase);

	return 0;
}

/* ----- separator ----- */


	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
	if (gpio_chips[alias_idx])
		return dev_err_probe(dev, -EBUSY, "%d slot is occupied.\n", alias_idx);

	irq = platform_get_irq(pdev, 0);
	if (irq < 0)
		return irq;

	at91_chip = devm_kzalloc(dev, sizeof(*at91_chip), GFP_KERNEL);
	if (!at91_chip)
		return -ENOMEM;

	at91_chip->regbase = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(at91_chip->regbase))
		return PTR_ERR(at91_chip->regbase);

	at91_chip->ops = device_get_match_data(dev);
	at91_chip->pioc_virq = irq;

	at91_chip->clock = devm_clk_get_enabled(dev, NULL);
	if (IS_ERR(at91_chip->clock))
		return dev_err_probe(dev, PTR_ERR(at91_chip->clock), "failed to get clock, ignoring.\n");

	at91_chip->chip = at91_gpio_template;
	at91_chip->id = alias_idx;

	chip = &at91_chip->chip;
	chip->label = dev_name(dev);
	chip->parent = dev;
	chip->owner = THIS_MODULE;
	chip->base = alias_idx * MAX_NB_GPIO_PER_BANK;

	if (!of_property_read_u32(np, "#gpio-lines", &ngpio)) {
		if (ngpio >= MAX_NB_GPIO_PER_BANK)
			dev_err(dev, "at91_gpio.%d, gpio-nb >= %d failback to %d\n",
				alias_idx, MAX_NB_GPIO_PER_BANK, MAX_NB_GPIO_PER_BANK);
		else
			chip->ngpio = ngpio;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38286

2. Vulnerability Type
Out-of-bounds array access due to missing input validation (negative index handling)

3. Root Cause Summary
at91_gpio_probe() used the return value of of_alias_get_id(np, "gpio") directly as an array index without validating for negative errors. With a missing/invalid OF alias, alias_idx could be < 0, leading to gpio_chips[alias_idx] access with a negative index and subsequent writes, causing out-of-bounds memory access. The only bound check present was BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)), which neither covers the negative case nor is reliable because BUG() can be compiled out and cannot serve as runtime validation.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
pinctrl/gpio driver for AT91 (function at91_gpio_probe in the pinctrl-at91 driver)

2) Pre-Patch Flaw:
- Direct use of alias_idx from of_alias_get_id without checking for < 0.
- Early array access: "if (gpio_chips[alias_idx])" and later "gpio_chips[alias_idx] = at91_chip" performed without ensuring alias_idx is within [0, ARRAY_SIZE(gpio_chips)).
- Reliance on BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) which does not catch negative indices and may be compiled out.

3) Trigger Condition:
of_alias_get_id(np, "gpio") returns a negative error (e.g., alias not present or retrieval failure) during device probe.

4) Impact Mechanism:
- Negative alias_idx results in out-of-bounds read/write to the global gpio_chips array, corrupting adjacent memory or causing a crash.
- Additional downstream misuse (e.g., chip->base = alias_idx * MAX_NB_GPIO_PER_BANK) propagates invalid state if execution continues.

5. Patch Analysis
1) Fix Approach:
Add explicit validation for alias_idx < 0 and return the error early, preventing any subsequent use of an invalid index.

2) Key Code Changes:
- Introduced a separate alias_idx variable assignment and immediate check:
  "alias_idx = of_alias_get_id(np, "gpio");"
  "if (alias_idx < 0) return alias_idx;"
- Retained existing BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) for upper-bound enforcement; the new check covers the missing negative-bound case.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely input validation and early error handling.

6. Broader Kernel Security Implications
Strengthens robustness against malformed or missing device-tree aliases by preventing memory corruption during probe. Eliminates dependence on BUG_ON for runtime validation, ensuring safety in production builds where BUG() may be disabled. Reduces risk of kernel crashes or silent corruption stemming from DT configuration errors or malicious overlays affecting GPIO registration.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.