You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38286

[INFO]
[PATCH_DESCRIPTION]
    pinctrl: at91: Fix possible out-of-boundary access
    at91_gpio_probe() doesn't check that given OF alias is not available or
    something went wrong when trying to get it. This might have consequences
    when accessing gpio_chips array with that value as an index. Note, that
    BUG() can be compiled out and hence won't actually perform the required
    checks.

[PATCH_DIFF]
    @@ -1822,12 +1822,16 @@ static int at91_gpio_probe(struct platform_device *pdev)
     	struct gpio_chip *chip;
     	struct pinctrl_gpio_range *range;
    +	int alias_idx;
     	int ret = 0;
     	int irq, i;
    -	int alias_idx = of_alias_get_id(np, "gpio");
     	uint32_t ngpio;
     	char **names;
     
    +	alias_idx = of_alias_get_id(np, "gpio");
    +	if (alias_idx < 0)
    +		return alias_idx;
    +
     	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
     	if (gpio_chips[alias_idx])
     		return dev_err_probe(dev, -EBUSY, "%d slot is occupied.\n", alias_idx);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38286

2. Vulnerability Type
Out-of-bounds array access due to missing input validation

3. Root Cause Summary
at91_gpio_probe() used the value returned by of_alias_get_id(np, "gpio") directly as an index into gpio_chips without validating that it was non-negative. When of_alias_get_id() failed (e.g., missing DT alias or other error) and returned a negative value, subsequent access like gpio_chips[alias_idx] became a negative index, causing out-of-bounds access before the start of the array. The only bound check present was BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)), which can be compiled out, leaving no runtime protection.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
pinctrl: AT91 GPIO driver

2) Pre-Patch Flaw:
- Missing lower-bound check for alias_idx returned by of_alias_get_id().
- Reliance on BUG_ON for upper-bound checking, which may be disabled at build time.
- Direct use of alias_idx as an array index: “if (gpio_chips[alias_idx])” without ensuring alias_idx >= 0.

3) Trigger Condition:
- The device tree lacks a valid “gpio” alias or of_alias_get_id(np, "gpio") returns a negative error code.
- Additionally, if BUG_ON is compiled out, an alias index greater than the array size could also proceed unchecked.

4) Impact Mechanism:
- Negative or excessively large alias_idx leads to out-of-bounds read/write on gpio_chips, causing memory corruption, kernel crashes, or undefined behavior during probe.

5. Patch Analysis
1) Fix Approach:
Add explicit validation of the alias index returned by of_alias_get_id() and abort probe early on error, preventing negative indexing into gpio_chips.

2) Key Code Changes:
- Introduced a separate declaration and assignment:
  - alias_idx = of_alias_get_id(np, "gpio");
- Added a lower-bound error check:
  - if (alias_idx < 0) return alias_idx;
- Kept the existing BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips)) and subsequent gpio_chips[alias_idx] access, which now only occurs with a non-negative alias_idx.

3) Locking/Concurrency Impact:
None. The change is purely input validation in the probe path and does not modify locking or ordering.

6. Broader Kernel Security Implications
Strengthening input validation at probe time prevents malformed or adversarial device trees from triggering memory-safety violations in early driver initialization. Reliance on BUG_ON for bounds checking is fragile in production builds; robust runtime checks should complement or replace BUG_ON to avoid silent OOB accesses when BUG is compiled out. This patch reduces a class of DT-driven OOB vulnerabilities by ensuring lower-bound validity, though comprehensive bounds validation (both lower and upper) at runtime remains advisable.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.