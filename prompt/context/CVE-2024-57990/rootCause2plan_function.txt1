You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57990

[INFO]
[PATCH_DESCRIPTION]
 wifi: mt76: mt7925: fix off by one in mt7925_load_clc()
 [ Upstream commit 08fa656c91fd5fdf47ba393795b9c0d1e97539ed ]
 
 This comparison should be >= instead of > to prevent an out of bounds
 read and write.

 Fixes: 9679ca7326e5 ("wifi: mt76: mt7925: fix a potential array-index-out-of-bounds issue for clc")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    index 748ea6adbc6b39..0c2a2337c313db 100644
    --- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    +++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    @@ -638,7 +638,7 @@ static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
     	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
     		clc = (const struct mt7925_clc *)(clc_base + offset);
     
    -		if (clc->idx > ARRAY_SIZE(phy->clc))
    +		if (clc->idx >= ARRAY_SIZE(phy->clc))
     			break;
     
     		/* do not init buf again if chip reset triggered /

[FUNCTION_CONTENT]
static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
{
	const struct mt76_connac2_fw_trailer *hdr;
	const struct mt76_connac2_fw_region *region;
	const struct mt7925_clc *clc;
	struct mt76_dev *mdev = &dev->mt76;
	struct mt792x_phy *phy = &dev->phy;
	const struct firmware *fw;
	int ret, i, len, offset = 0;
	u8 *clc_base = NULL;

	if (mt7925_disable_clc ||
	    mt76_is_usb(&dev->mt76))
		return 0;

	ret = request_firmware(&fw, fw_name, mdev->dev);
	if (ret)
		return ret;

	if (!fw || !fw->data || fw->size < sizeof(*hdr)) {
		dev_err(mdev->dev, "Invalid firmware\n");
		ret = -EINVAL;
		goto out;
	}

	hdr = (const void *)(fw->data + fw->size - sizeof(*hdr));
	for (i = 0; i < hdr->n_region; i++) {
		region = (const void *)((const u8 *)hdr -
					(hdr->n_region - i) * sizeof(*region));
		len = le32_to_cpu(region->len);

		/* check if we have valid buffer size */
		if (offset + len > fw->size) {
			dev_err(mdev->dev, "Invalid firmware region\n");
			ret = -EINVAL;
			goto out;
		}

		if ((region->feature_set & FW_FEATURE_NON_DL) &&
		    region->type == FW_TYPE_CLC) {
			clc_base = (u8 *)(fw->data + offset);
			break;
		}
		offset += len;
	}

	if (!clc_base)
		goto out;

	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
		clc = (const struct mt7925_clc *)(clc_base + offset);

		if (clc->idx > ARRAY_SIZE(phy->clc))
			break;

		/* do not init buf again if chip reset triggered */
		if (phy->clc[clc->idx])
			continue;

		phy->clc[clc->idx] = devm_kmemdup(mdev->dev, clc,
						  le32_to_cpu(clc->len),
						  GFP_KERNEL);

		if (!phy->clc[clc->idx]) {
			ret = -ENOMEM;
			goto out;
		}
	}

	ret = mt7925_mcu_set_clc(dev, "00", ENVIRON_INDOOR);
out:
	release_firmware(fw);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Out-of-bounds array access (read and write) due to off-by-one bounds check

3. Root Cause Summary
The function mt7925_load_clc in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c incorrectly validated the firmware-provided index clc->idx using “> ARRAY_SIZE(phy->clc)”. This off-by-one check allowed clc->idx == ARRAY_SIZE(phy->clc) to pass, causing one-past-the-end access to phy->clc[clc->idx]. As a result, the code could read and then write beyond the clc pointer array, leading to memory corruption.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 Wi-Fi driver (mt7925), firmware parsing/CLC loading logic in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c.

2) Pre-Patch Flaw:
An off-by-one bounds check in mt7925_load_clc used “if (clc->idx > ARRAY_SIZE(phy->clc))” instead of “>=”, failing to reject index equal to the array size. Subsequent lines accessed phy->clc[clc->idx] for both read (“if (phy->clc[clc->idx])”) and write (“phy->clc[clc->idx] = …”), enabling one-past-the-end access.

3) Trigger Condition:
A CLC entry in the firmware with clc->idx equal to ARRAY_SIZE(phy->clc) during the loop “for (offset = 0; offset < len; offset += le32_to_cpu(clc->len))”.

4) Impact Mechanism:
OOB read occurs when evaluating “if (phy->clc[clc->idx])”; OOB write occurs when assigning “phy->clc[clc->idx] = devm_kmemdup(…)”. This can corrupt adjacent kernel memory, potentially leading to crashes or arbitrary memory modification depending on layout.

5. Patch Analysis
1) Fix Approach:
Tighten the bounds check to correctly disallow indices equal to the array size, eliminating the off-by-one error that enabled OOB accesses.

2) Key Code Changes:
Changed in mt7925_load_clc: “if (clc->idx > ARRAY_SIZE(phy->clc))” to “if (clc->idx >= ARRAY_SIZE(phy->clc))”, ensuring clc->idx is strictly within [0, ARRAY_SIZE(phy->clc) - 1].

3) Locking/Concurrency Impact:
None. The patch solely adjusts a validation check; no locking or ordering changes are involved.

6. Broader Kernel Security Implications
Firmware-derived indices and lengths must be rigorously validated to prevent memory safety violations in drivers parsing untrusted blobs. Off-by-one mistakes are common and can turn otherwise protective checks into exploitable conditions, especially in pointer arrays. Ensuring consistent use of “>= ARRAY_SIZE()” for upper-bound checks is a defensive coding standard that helps prevent both OOB reads and writes in kernel-space parsers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}