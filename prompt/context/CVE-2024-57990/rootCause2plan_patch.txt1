You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57990

[INFO]
[PATCH_DESCRIPTION]
 wifi: mt76: mt7925: fix off by one in mt7925_load_clc()
 [ Upstream commit 08fa656c91fd5fdf47ba393795b9c0d1e97539ed ]
 
 This comparison should be >= instead of > to prevent an out of bounds
 read and write.

 Fixes: 9679ca7326e5 ("wifi: mt76: mt7925: fix a potential array-index-out-of-bounds issue for clc")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    index 748ea6adbc6b39..0c2a2337c313db 100644
    --- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    +++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    @@ -638,7 +638,7 @@ static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
     	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
     		clc = (const struct mt7925_clc *)(clc_base + offset);
     
    -		if (clc->idx > ARRAY_SIZE(phy->clc))
    +		if (clc->idx >= ARRAY_SIZE(phy->clc))
     			break;
     
     		/* do not init buf again if chip reset triggered /



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Off-by-one bounds check error causing out-of-bounds array access (read and write)

3. Root Cause Summary
The function mt7925_load_clc() validated clc->idx with a strict greater-than check against ARRAY_SIZE(phy->clc) instead of a greater-than-or-equal check. This allowed clc->idx == ARRAY_SIZE(phy->clc) to pass validation and be used as an array index, which is one past the last valid element. As a result, subsequent accesses to phy->clc[clc->idx] could read from or write to memory beyond the allocated array bounds.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver: MediaTek mt76 mt7925 (drivers/net/wireless/mediatek/mt76/mt7925)

2) Pre-Patch Flaw:
- In mt7925_load_clc(), the code used "if (clc->idx > ARRAY_SIZE(phy->clc))" to guard array indexing.
- This off-by-one check failed to reject the boundary case where clc->idx equals the array size, enabling an invalid index.

3) Trigger Condition:
- While parsing CLC entries from firmware in the loop over offset < len, if any CLC entry supplies clc->idx == ARRAY_SIZE(phy->clc), the code proceeds and uses that index.
- The clc structure is obtained from clc_base + offset and its fields (idx, len) are used to control parsing and indexing.

4) Impact Mechanism:
- Using index == ARRAY_SIZE(phy->clc) results in out-of-bounds access to phy->clc, causing both potential reads and writes past the end of the array.
- This can lead to kernel memory corruption, crashes (e.g., Oops), and possible information disclosure.

5. Patch Analysis
1) Fix Approach:
- Tighten the upper-bound validation for clc->idx by changing the comparison to reject indices equal to the array size.

2) Key Code Changes:
- In mt7925_load_clc() (mcu.c around line 638), the condition was changed from:
  "if (clc->idx > ARRAY_SIZE(phy->clc))"
  to:
  "if (clc->idx >= ARRAY_SIZE(phy->clc))"
- This ensures only indices in the valid range [0, ARRAY_SIZE(phy->clc) - 1] are accepted before using them to index phy->clc.

3) Locking/Concurrency Impact:
- No locking or concurrency logic was changed; the fix solely corrects the bounds check.

6. Broader Kernel Security Implications
- Off-by-one errors in array bounds checks during firmware or descriptor parsing can introduce severe memory safety vulnerabilities in kernel drivers.
- Similar patterns should be audited across driver code to ensure inclusive upper-bound checks (>=) are used when comparing indices against ARRAY_SIZE.
- Proper validation of data derived from firmware or external inputs is critical to prevent OOB accesses that can compromise kernel stability and security.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}