You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57990

[INFO]
[PATCH_DESCRIPTION]
 wifi: mt76: mt7925: fix off by one in mt7925_load_clc()
 [ Upstream commit 08fa656c91fd5fdf47ba393795b9c0d1e97539ed ]
 
 This comparison should be >= instead of > to prevent an out of bounds
 read and write.

 Fixes: 9679ca7326e5 ("wifi: mt76: mt7925: fix a potential array-index-out-of-bounds issue for clc")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    index 748ea6adbc6b39..0c2a2337c313db 100644
    --- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    +++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    @@ -638,7 +638,7 @@ static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
     	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
     		clc = (const struct mt7925_clc *)(clc_base + offset);
     
    -		if (clc->idx > ARRAY_SIZE(phy->clc))
    +		if (clc->idx >= ARRAY_SIZE(phy->clc))
     			break;
     
     		/* do not init buf again if chip reset triggered /



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Off-by-one bounds check error causing out-of-bounds array access (read and write)

3. Root Cause Summary
The function mt7925_load_clc() validated clc->idx with a strict greater-than check against ARRAY_SIZE(phy->clc) instead of a greater-than-or-equal check. This allowed clc->idx == ARRAY_SIZE(phy->clc) to pass validation and be used as an array index, which is one past the last valid element. As a result, subsequent accesses to phy->clc[clc->idx] could read from or write to memory beyond the allocated array bounds.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking driver: MediaTek mt76 mt7925 (drivers/net/wireless/mediatek/mt76/mt7925)

2) Pre-Patch Flaw:
- In mt7925_load_clc(), the code used "if (clc->idx > ARRAY_SIZE(phy->clc))" to guard array indexing.
- This off-by-one check failed to reject the boundary case where clc->idx equals the array size, enabling an invalid index.

3) Trigger Condition:
- While parsing CLC entries from firmware in the loop over offset < len, if any CLC entry supplies clc->idx == ARRAY_SIZE(phy->clc), the code proceeds and uses that index.
- The clc structure is obtained from clc_base + offset and its fields (idx, len) are used to control parsing and indexing.

4) Impact Mechanism:
- Using index == ARRAY_SIZE(phy->clc) results in out-of-bounds access to phy->clc, causing both potential reads and writes past the end of the array.
- This can lead to kernel memory corruption, crashes (e.g., Oops), and possible information disclosure.

5. Patch Analysis
1) Fix Approach:
- Tighten the upper-bound validation for clc->idx by changing the comparison to reject indices equal to the array size.

2) Key Code Changes:
- In mt7925_load_clc() (mcu.c around line 638), the condition was changed from:
  "if (clc->idx > ARRAY_SIZE(phy->clc))"
  to:
  "if (clc->idx >= ARRAY_SIZE(phy->clc))"
- This ensures only indices in the valid range [0, ARRAY_SIZE(phy->clc) - 1] are accepted before using them to index phy->clc.

3) Locking/Concurrency Impact:
- No locking or concurrency logic was changed; the fix solely corrects the bounds check.

6. Broader Kernel Security Implications
- Off-by-one errors in array bounds checks during firmware or descriptor parsing can introduce severe memory safety vulnerabilities in kernel drivers.
- Similar patterns should be audited across driver code to ensure inclusive upper-bound checks (>=) are used when comparing indices against ARRAY_SIZE.
- Proper validation of data derived from firmware or external inputs is critical to prevent OOB accesses that can compromise kernel stability and security.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.