You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57990

[INFO]
[PATCH_DESCRIPTION]
 wifi: mt76: mt7925: fix off by one in mt7925_load_clc()
 [ Upstream commit 08fa656c91fd5fdf47ba393795b9c0d1e97539ed ]
 
 This comparison should be >= instead of > to prevent an out of bounds
 read and write.

 Fixes: 9679ca7326e5 ("wifi: mt76: mt7925: fix a potential array-index-out-of-bounds issue for clc")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    index 748ea6adbc6b39..0c2a2337c313db 100644
    --- a/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    +++ b/drivers/net/wireless/mediatek/mt76/mt7925/mcu.c
    @@ -638,7 +638,7 @@ static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
     	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
     		clc = (const struct mt7925_clc *)(clc_base + offset);
     
    -		if (clc->idx > ARRAY_SIZE(phy->clc))
    +		if (clc->idx >= ARRAY_SIZE(phy->clc))
     			break;
     
     		/* do not init buf again if chip reset triggered /

[FUNCTION_CONTENT]
static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
{
	const struct mt76_connac2_fw_trailer *hdr;
	const struct mt76_connac2_fw_region *region;
	const struct mt7925_clc *clc;
	struct mt76_dev *mdev = &dev->mt76;
	struct mt792x_phy *phy = &dev->phy;
	const struct firmware *fw;
	int ret, i, len, offset = 0;
	u8 *clc_base = NULL;

	if (mt7925_disable_clc ||
	    mt76_is_usb(&dev->mt76))
		return 0;

	ret = request_firmware(&fw, fw_name, mdev->dev);
	if (ret)
		return ret;

	if (!fw || !fw->data || fw->size < sizeof(*hdr)) {
		dev_err(mdev->dev, "Invalid firmware\n");
		ret = -EINVAL;
		goto out;
	}

	hdr = (const void *)(fw->data + fw->size - sizeof(*hdr));
	for (i = 0; i < hdr->n_region; i++) {
		region = (const void *)((const u8 *)hdr -
					(hdr->n_region - i) * sizeof(*region));
		len = le32_to_cpu(region->len);

		/* check if we have valid buffer size */
		if (offset + len > fw->size) {
			dev_err(mdev->dev, "Invalid firmware region\n");
			ret = -EINVAL;
			goto out;
		}

		if ((region->feature_set & FW_FEATURE_NON_DL) &&
		    region->type == FW_TYPE_CLC) {
			clc_base = (u8 *)(fw->data + offset);
			break;
		}
		offset += len;
	}

	if (!clc_base)
		goto out;

	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
		clc = (const struct mt7925_clc *)(clc_base + offset);

		if (clc->idx > ARRAY_SIZE(phy->clc))
			break;

		/* do not init buf again if chip reset triggered */
		if (phy->clc[clc->idx])
			continue;

		phy->clc[clc->idx] = devm_kmemdup(mdev->dev, clc,
						  le32_to_cpu(clc->len),
						  GFP_KERNEL);

		if (!phy->clc[clc->idx]) {
			ret = -ENOMEM;
			goto out;
		}
	}

	ret = mt7925_mcu_set_clc(dev, "00", ENVIRON_INDOOR);
out:
	release_firmware(fw);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57990

2. Vulnerability Type
Out-of-bounds array access (read and write) due to off-by-one bounds check

3. Root Cause Summary
The function mt7925_load_clc in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c incorrectly validated the firmware-provided index clc->idx using “> ARRAY_SIZE(phy->clc)”. This off-by-one check allowed clc->idx == ARRAY_SIZE(phy->clc) to pass, causing one-past-the-end access to phy->clc[clc->idx]. As a result, the code could read and then write beyond the clc pointer array, leading to memory corruption.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 Wi-Fi driver (mt7925), firmware parsing/CLC loading logic in drivers/net/wireless/mediatek/mt76/mt7925/mcu.c.

2) Pre-Patch Flaw:
An off-by-one bounds check in mt7925_load_clc used “if (clc->idx > ARRAY_SIZE(phy->clc))” instead of “>=”, failing to reject index equal to the array size. Subsequent lines accessed phy->clc[clc->idx] for both read (“if (phy->clc[clc->idx])”) and write (“phy->clc[clc->idx] = …”), enabling one-past-the-end access.

3) Trigger Condition:
A CLC entry in the firmware with clc->idx equal to ARRAY_SIZE(phy->clc) during the loop “for (offset = 0; offset < len; offset += le32_to_cpu(clc->len))”.

4) Impact Mechanism:
OOB read occurs when evaluating “if (phy->clc[clc->idx])”; OOB write occurs when assigning “phy->clc[clc->idx] = devm_kmemdup(…)”. This can corrupt adjacent kernel memory, potentially leading to crashes or arbitrary memory modification depending on layout.

5. Patch Analysis
1) Fix Approach:
Tighten the bounds check to correctly disallow indices equal to the array size, eliminating the off-by-one error that enabled OOB accesses.

2) Key Code Changes:
Changed in mt7925_load_clc: “if (clc->idx > ARRAY_SIZE(phy->clc))” to “if (clc->idx >= ARRAY_SIZE(phy->clc))”, ensuring clc->idx is strictly within [0, ARRAY_SIZE(phy->clc) - 1].

3) Locking/Concurrency Impact:
None. The patch solely adjusts a validation check; no locking or ordering changes are involved.

6. Broader Kernel Security Implications
Firmware-derived indices and lengths must be rigorously validated to prevent memory safety violations in drivers parsing untrusted blobs. Off-by-one mistakes are common and can turn otherwise protective checks into exploitable conditions, especially in pointer arrays. Ensuring consistent use of “>= ARRAY_SIZE()” for upper-bound checks is a defensive coding standard that helps prevent both OOB reads and writes in kernel-space parsers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.