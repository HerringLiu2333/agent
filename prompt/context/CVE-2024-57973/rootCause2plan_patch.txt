You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57973

[INFO]
[PATCH_DESCRIPTION]
 rdma/cxgb4: Prevent potential integer overflow on 32bit
 [ Upstream commit bd96a3935e89486304461a21752f824fc25e0f0b ]
 
 The "gl->tot_len" variable is controlled by the user.  It comes from
 process_responses().  On 32bit systems, the "gl->tot_len + sizeof(struct
 cpl_pass_accept_req) + sizeof(struct rss_header)" addition could have an
 integer wrapping bug.  Use size_add() to prevent this.

 Fixes: 1cab775c3e75 ("RDMA/cxgb4: Fix LE hash collision bug for passive open connection")

[PATCH_DIFF]
 diff --git a/drivers/infiniband/hw/cxgb4/device.c b/drivers/infiniband/hw/cxgb4/device.c
 index 541dbcf22d0ebf…13e4b2c40d835a 100644
 --- a/drivers/infiniband/hw/cxgb4/device.c
 +++ b/drivers/infiniband/hw/cxgb4/device.c
 @@ -1114,8 +1114,10 @@ static inline struct sk_buff *copy_gl_to_skb_pkt(const struct pkt_gl *gl,
   * The math here assumes sizeof cpl_pass_accept_req >= sizeof
   * cpl_rx_pkt.
   /
 - skb = alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) +
 - sizeof(struct rss_header) - pktshift, GFP_ATOMIC);
 + skb = alloc_skb(size_add(gl->tot_len,
 + sizeof(struct cpl_pass_accept_req) +
 + sizeof(struct rss_header)) - pktshift,
 + GFP_ATOMIC);
   if (unlikely(!skb))
     return NULL;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57973

2. Vulnerability Type
Integer overflow in allocation size calculation leading to potential heap-based buffer overflow (undersized allocation)

3. Root Cause Summary
The function copy_gl_to_skb_pkt computed the skb allocation size using plain addition: gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift. On 32-bit systems, gl->tot_len (user-controlled via process_responses()) could be large enough that the additive terms overflow and wrap, producing a much smaller allocation than required. Subsequent packet/header data copying into the skb would then overrun the allocated buffer. The pre-patch logic lacked overflow-safe arithmetic for size_t additions when deriving allocation sizes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
RDMA Chelsio cxgb4 driver (drivers/infiniband/hw/cxgb4), function copy_gl_to_skb_pkt in device.c

2) Pre-Patch Flaw:
Unprotected size calculation using native 32-bit arithmetic for the skb allocation length in copy_gl_to_skb_pkt, directly summing user-influenced gl->tot_len with header sizes without overflow checks.

3) Trigger Condition:
On 32-bit kernels, if gl->tot_len from process_responses() is large enough that gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) exceeds SIZE_MAX/UINT_MAX, the addition wraps around to a smaller value before subtracting pktshift.

4) Impact Mechanism:
The wrapped result causes alloc_skb() to allocate an undersized buffer. The function then proceeds to populate the skb with gl data and headers, potentially writing beyond the end of the allocated buffer, leading to memory corruption and kernel crash or other undefined behavior.

5. Patch Analysis
1) Fix Approach:
Introduce overflow-safe size computation using size_add() to prevent integer wrapping when adding gl->tot_len and the combined header sizes, ensuring alloc_skb() receives either a correct size or an overflow-saturated value that causes allocation to fail safely.

2) Key Code Changes:
- Replaced:
  skb = alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header) - pktshift, GFP_ATOMIC);
- With:
  skb = alloc_skb(size_add(gl->tot_len, sizeof(struct cpl_pass_accept_req) + sizeof(struct rss_header)) - pktshift, GFP_ATOMIC);
This directly targets the overflow-prone addition by using size_add() for gl->tot_len + headers.

3) Locking/Concurrency Impact:
None. The change is purely arithmetic for allocation size computation; no locks or ordering were introduced or modified.

6. Broader Kernel Security Implications
This fix reinforces the use of overflow-safe helpers for allocation size computations, particularly critical in network/RDMA paths where user-controlled lengths can reach kernel code. Ensuring size_t arithmetic cannot wrap prevents undersized allocations and subsequent overflows, a common class of memory safety vulnerabilities. Adopting helpers like size_add() reduces risk across 32-bit builds and improves robustness against malformed or hostile inputs reaching low-level drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.