You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38258

[INFO]
[PATCH_DESCRIPTION]
    mm/damon/sysfs-schemes: free old damon_sysfs_scheme_filter->memcg_path on write
    memcg_path_store() assigns a newly allocated memory buffer to
    filter->memcg_path, without deallocating the previously allocated and
    assigned memory buffer.  As a result, users can leak kernel memory by
    continuously writing a data to memcg_path DAMOS sysfs file.  Fix the leak
    by deallocating the previously set memory buffer.```

[PATCH_DIFF]
    @@ -472,6 +472,7 @@ static ssize_t memcg_path_store(struct kobject *kobj,
     		return -ENOMEM;
     
     	strscpy(path, buf, count + 1);
    +	kfree(filter->memcg_path);
     	filter->memcg_path = path;
     	return count;
     }

[FUNCTION_CONTENT]
static ssize_t memcg_path_store(struct kobject *kobj,
		struct kobj_attribute *attr, const char *buf, size_t count)
{
	struct damon_sysfs_scheme_filter *filter = container_of(kobj,
			struct damon_sysfs_scheme_filter, kobj);
	char *path = kmalloc_array(size_add(count, 1), sizeof(*path),
				   GFP_KERNEL);

	if (!path)
		return -ENOMEM;

	strscpy(path, buf, count + 1);
	filter->memcg_path = path;
	return count;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38258

2. Vulnerability Type
Kernel memory leak via sysfs attribute writes leading to potential denial-of-service (resource exhaustion)

3. Root Cause Summary
memcg_path_store() allocated a new buffer for filter->memcg_path on every write and overwrote the pointer without deallocating the previously allocated buffer. The pre-patch logic performed kmalloc_array() and strscpy(), then directly assigned “filter->memcg_path = path;” with no preceding kfree(), causing each write to leak count+1 bytes. This missing deallocation in the sysfs store path allowed unprivileged users to steadily leak kernel memory by repeatedly writing to the memcg_path attribute.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
mm/damon/sysfs-schemes (DAMOS sysfs interface for memory cgroup path filter)

2) Pre-Patch Flaw:
In memcg_path_store(), the previous filter->memcg_path was not freed before assigning a newly allocated string, resulting in orphaned allocations and a cumulative memory leak.

3) Trigger Condition:
Repeated writes to the memcg_path DAMOS sysfs file (e.g., echoing strings to the attribute) cause successive allocations and pointer overwrites without freeing the old buffer.

4) Impact Mechanism:
Each write allocates a new buffer of size count+1 and replaces filter->memcg_path, losing the reference to the old buffer. Over time, unbounded kernel memory consumption can occur, potentially leading to memory pressure, OOM conditions, and system instability or denial-of-service.

5. Patch Analysis
1) Fix Approach:
Introduce explicit deallocation of the previously assigned buffer by calling kfree(filter->memcg_path) before updating the pointer with the newly allocated path.

2) Key Code Changes:
A single line addition in memcg_path_store():
- Added “kfree(filter->memcg_path);” between strscpy(path, buf, count + 1); and filter->memcg_path = path;

3) Locking/Concurrency Impact:
No locking or concurrency changes were made. The patch strictly corrects memory lifecycle management; concurrent access semantics remain unchanged. Any concurrent use of filter->memcg_path outside this function is not addressed by the patch and is unknown/not determinable from the provided materials.

6. Broader Kernel Security Implications
Fixing this leak prevents unprivileged users from exhausting kernel memory via a simple sysfs write pattern, reducing the risk of OOM events and system-wide service disruption. It reinforces proper resource management in sysfs interfaces, which are commonly accessible and thus sensitive to misuse. Ensuring deallocation on attribute updates improves the robustness of DAMON configuration paths and sets a precedent for careful memory lifecycle handling in similar kernel subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.