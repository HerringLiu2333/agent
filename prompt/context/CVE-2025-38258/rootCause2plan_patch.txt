You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38258

[INFO]
[PATCH_DESCRIPTION]
    mm/damon/sysfs-schemes: free old damon_sysfs_scheme_filter->memcg_path on write
    memcg_path_store() assigns a newly allocated memory buffer to
    filter->memcg_path, without deallocating the previously allocated and
    assigned memory buffer.  As a result, users can leak kernel memory by
    continuously writing a data to memcg_path DAMOS sysfs file.  Fix the leak
    by deallocating the previously set memory buffer.```

[PATCH_DIFF]
    @@ -472,6 +472,7 @@ static ssize_t memcg_path_store(struct kobject *kobj,
     		return -ENOMEM;
     
     	strscpy(path, buf, count + 1);
    +	kfree(filter->memcg_path);
     	filter->memcg_path = path;
     	return count;
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38258

2. Vulnerability Type
Memory leak leading to kernel resource exhaustion (Denial of Service)

3. Root Cause Summary
memcg_path_store() allocated a new buffer for filter->memcg_path on each write but failed to free the previously allocated buffer, causing a persistent kernel memory leak. The missing deallocation of the old pointer resulted in lost references and unbounded accumulation of leaked memory upon repeated writes to the sysfs attribute.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
mm/damon/sysfs-schemes (DAMOS sysfs interface), function: memcg_path_store()

2) Pre-Patch Flaw:
The function assigned a newly allocated buffer directly to filter->memcg_path (“filter->memcg_path = path;”) after strscpy() without freeing the old filter->memcg_path, resulting in leaked memory for each write.

3) Trigger Condition:
Repeated writes by users to the memcg_path DAMOS sysfs file, each providing a new path string that causes a fresh allocation.

4) Impact Mechanism:
Each write causes allocation of a new path string while the previously allocated buffer becomes unreachable (no kfree), leaking kernel memory; sustained writes can exhaust kernel memory and lead to system instability or denial of service.

5. Patch Analysis
1) Fix Approach:
Introduce proper lifetime management by freeing the previously stored buffer before overwriting the pointer, preventing memory leaks.

2) Key Code Changes:
Added “kfree(filter->memcg_path);” immediately before “filter->memcg_path = path;” in memcg_path_store(), ensuring the old buffer is deallocated prior to reassigning the pointer.

3) Locking/Concurrency Impact:
No locking or ordering changes are introduced; the patch exclusively adds a deallocation call. Concurrency behavior is not modified or determinable from the provided diff.

6. Broader Kernel Security Implications
Improper memory management in sysfs store paths can enable straightforward resource exhaustion attacks, potentially by low-complexity repeated writes. Ensuring all prior allocations are freed when replacing pointers is critical to prevent kernel memory leaks that can degrade system reliability or cause denial of service. This fix reinforces the need for robust memory lifetime handling in configuration interfaces like sysfs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.