You are a senior Linux kernel vulnerability analyst.
Task: Produce a structured root-cause analysis of the vulnerability that existed BEFORE the patch, strictly following the [OUTPUT FORMAT] below.

Rules:
1. Follow the [OUTPUT FORMAT] exactly and populate every field. Use evidence from [PATCH_DIFF], [PATCH_DESCRIPTION], and [FUNCTION_CONTENT].
2. Root cause = the flawed or missing pre-patch logic that the patch corrects (e.g., missing validation, incorrect locking/ordering, race window, unsafe access, integer/length misuse, lifetime/refcount bug, pointer misuse).
3. Be evidence-driven: reference function names, local context, and hunk scope in the diff; you may quote 1–3 lines of original (pre-patch) code only when necessary to support claims; avoid long code dumps.
4. Patch analysis must map each fix to the identified root cause (e.g., added checks, lock adjustments, lifetime/RCU changes, bounds fixes, condition rewrites).
5. Concurrency/locking: when relevant, explicitly state missing/incorrect locks, RCU usage, atomicity, or ordering and what the patch changed (lock/unlock points, ordering changes).
6. Memory/safety: when relevant, specify trigger conditions and impact (UAF, OOB, double free, uninitialized use, integer overflow/underflow, length miscalculation, TOCTOU, etc.).
7. Use only the provided materials ([PATCH_DIFF], [PATCH_DESCRIPTION], [FUNCTION_CONTENT]). Do not speculate; when uncertain, state “Unknown/Not determinable”.
8. Keep it concise and technical: 3–8 clear sentences or bullet points per subsection.
9. Output nothing beyond the [OUTPUT FORMAT]; no extra headers, prefaces, or trailing notes.
10. If the root cause cannot be identified, state “Unknown/Not determinable” in the relevant subsection, but complete the remaining sections using available evidence.

[META]
CVE_NAME: CVE-2025-38346

[PATCH_DESCRIPTION]
    ftrace: Fix UAF when lookup kallsym after ftrace disabled
    The following issue happens with a buggy module:
    
    BUG: unable to handle page fault for address: ffffffffc05d0218
    PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0
    Oops: Oops: 0000 [#1] SMP KASAN PTI
    Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    RIP: 0010:sized_strscpy+0x81/0x2f0
    RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000
    RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d
    RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68
    R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038
    R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff
    FS:  00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <TASK>
     ftrace_mod_get_kallsym+0x1ac/0x590
     update_iter_mod+0x239/0x5b0
     s_next+0x5b/0xa0
     seq_read_iter+0x8c9/0x1070
     seq_read+0x249/0x3b0
     proc_reg_read+0x1b0/0x280
     vfs_read+0x17f/0x920
     ksys_read+0xf3/0x1c0
     do_syscall_64+0x5f/0x2e0
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    The above issue may happen as follows:
    (1) Add kprobe tracepoint;
    (2) insmod test.ko;
    (3)  Module triggers ftrace disabled;
    (4) rmmod test.ko;
    (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed;
    ftrace_mod_get_kallsym()
    ...
    strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    ...
    
    The problem is when a module triggers an issue with ftrace and
    sets ftrace_disable. The ftrace_disable is set when an anomaly is
    discovered and to prevent any more damage, ftrace stops all text
    modification. The issue that happened was that the ftrace_disable stops
    more than just the text modification.
    
    When a module is loaded, its init functions can also be traced. Because
    kallsyms deletes the init functions after a module has loaded, ftrace
    saves them when the module is loaded and function tracing is enabled. This
    allows the output of the function trace to show the init function names
    instead of just their raw memory addresses.
    
    When a module is removed, ftrace_release_mod() is called, and if
    ftrace_disable is set, it just returns without doing anything more. The
    problem here is that it leaves the mod_list still around and if kallsyms
is called, it will call into this code and access the module memory that
    has already been freed as it will return:
    
      strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    
    Where the "mod" no longer exists and triggers a UAF bug.

[PATCH_DIFF]
    @@ -7438,9 +7438,10 @@ void ftrace_release_mod(struct module *mod)
     
     	mutex_lock(&ftrace_lock);
     
    -	if (ftrace_disabled)
    -		goto out_unlock;
    -
    +	/*
    +	 * To avoid the UAF problem after the module is unloaded, the
    +	 * 'mod_map' resource needs to be released unconditionally.
    +	 */
     	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
     		if (mod_map->mod == mod) {
     			list_del_rcu(&mod_map->list);
    @@ -7449,6 +7450,9 @@ void ftrace_release_mod(struct module *mod)
     		}
     	}
     
    +	if (ftrace_disabled)
    +		goto out_unlock;
    +
     	/*
     	 * Each module has its own ftrace_pages, remove
     	 * them from the list.

[FUNCTION_CONTENT]
void ftrace_release_mod(struct module *mod)
{
	struct ftrace_mod_map *mod_map;
	struct ftrace_mod_map *n;
	struct dyn_ftrace *rec;
	struct ftrace_page **last_pg;
	struct ftrace_page *tmp_page = NULL;
	struct ftrace_page *pg;

	mutex_lock(&ftrace_lock);

	if (ftrace_disabled)
		goto out_unlock;

	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
		if (mod_map->mod == mod) {
			list_del_rcu(&mod_map->list);
			call_rcu(&mod_map->rcu, ftrace_free_mod_map);
			break;
		}
	}

	/*
	 * Each module has its own ftrace_pages, remove
	 * them from the list.
	 */
	last_pg = &ftrace_pages_start;
	for (pg = ftrace_pages_start; pg; pg = *last_pg) {
		rec = &pg->records[0];
		if (within_module(rec->ip, mod)) {
			/*
			 * As core pages are first, the first
			 * page should never be a module page.
			 */
			if (WARN_ON(pg == ftrace_pages_start))
				goto out_unlock;

			/* Check if we are deleting the last page */
			if (pg == ftrace_pages)
				ftrace_pages = next_to_ftrace_page(last_pg);

			ftrace_update_tot_cnt -= pg->index;
			*last_pg = pg->next;

			pg->next = tmp_page;
			tmp_page = pg;
		} else
			last_pg = &pg->next;
	}
 out_unlock:
	mutex_unlock(&ftrace_lock);

	/* Need to synchronize with ftrace_location_range() */
	if (tmp_page)
		synchronize_rcu();
	for (pg = tmp_page; pg; pg = tmp_page) {

		/* Needs to be called outside of ftrace_lock */
		clear_mod_from_hashes(pg);

		if (pg->records) {
			free_pages((unsigned long)pg->records, pg->order);
			ftrace_number_of_pages -= 1 << pg->order;
		}
		tmp_page = pg->next;
		kfree(pg);
		ftrace_number_of_groups--;
	}
}

[OUTPUT FORMAT]
1. CVE Identifier
{{CVE Identifier}}

2. Vulnerability Type
{{Vulnerability Type}}

3. Root Cause Summary
{{Root Cause Summary}}

4. Kernel Subsystem Analysis
1) Affected Subsystem:
{{Affected Subsystem}}
2) Pre-Patch Flaw:
{{Pre-Patch Flaw}}
3) Trigger Condition:
{{Trigger Condition}}
4) Impact Mechanism:
{{Impact Mechanism}}

5. Patch Analysis
1) Fix Approach:
{{Fix Approach}}
2) Key Code Changes:
{{Key Code Changes}}
3) Locking/Concurrency Impact:
{{Locking/Concurrency Impact}}

6. Broader Kernel Security Implications
{{Broader Kernel Security Implications}}