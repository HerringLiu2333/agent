You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38346

[INFO]
[PATCH_DESCRIPTION]
    ftrace: Fix UAF when lookup kallsym after ftrace disabled
    The following issue happens with a buggy module:
    
    BUG: unable to handle page fault for address: ffffffffc05d0218
    PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0
    Oops: Oops: 0000 [#1] SMP KASAN PTI
    Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    RIP: 0010:sized_strscpy+0x81/0x2f0
    RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000
    RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d
    RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68
    R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038
    R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff
    FS:  00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <TASK>
     ftrace_mod_get_kallsym+0x1ac/0x590
     update_iter_mod+0x239/0x5b0
     s_next+0x5b/0xa0
     seq_read_iter+0x8c9/0x1070
     seq_read+0x249/0x3b0
     proc_reg_read+0x1b0/0x280
     vfs_read+0x17f/0x920
     ksys_read+0xf3/0x1c0
     do_syscall_64+0x5f/0x2e0
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    The above issue may happen as follows:
    (1) Add kprobe tracepoint;
    (2) insmod test.ko;
    (3)  Module triggers ftrace disabled;
    (4) rmmod test.ko;
    (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed;
    ftrace_mod_get_kallsym()
    ...
    strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    ...
    
    The problem is when a module triggers an issue with ftrace and
    sets ftrace_disable. The ftrace_disable is set when an anomaly is
    discovered and to prevent any more damage, ftrace stops all text
    modification. The issue that happened was that the ftrace_disable stops
    more than just the text modification.
    
    When a module is loaded, its init functions can also be traced. Because
    kallsyms deletes the init functions after a module has loaded, ftrace
    saves them when the module is loaded and function tracing is enabled. This
    allows the output of the function trace to show the init function names
    instead of just their raw memory addresses.
    
    When a module is removed, ftrace_release_mod() is called, and if
    ftrace_disable is set, it just returns without doing anything more. The
    problem here is that it leaves the mod_list still around and if kallsyms
is called, it will call into this code and access the module memory that
    has already been freed as it will return:
    
      strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    
    Where the "mod" no longer exists and triggers a UAF bug.

[PATCH_DIFF]
    @@ -7438,9 +7438,10 @@ void ftrace_release_mod(struct module *mod)
     
     	mutex_lock(&ftrace_lock);
     
    -	if (ftrace_disabled)
    -		goto out_unlock;
    -
    +	/*
    +	 * To avoid the UAF problem after the module is unloaded, the
    +	 * 'mod_map' resource needs to be released unconditionally.
    +	 */
     	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
     		if (mod_map->mod == mod) {
     			list_del_rcu(&mod_map->list);
    @@ -7449,6 +7450,9 @@ void ftrace_release_mod(struct module *mod)
     		}
     	}
     
    +	if (ftrace_disabled)
    +		goto out_unlock;
    +
     	/*
     	 * Each module has its own ftrace_pages, remove
     	 * them from the list.

[FUNCTION_CONTENT]
void ftrace_release_mod(struct module *mod)
{
	struct ftrace_mod_map *mod_map;
	struct ftrace_mod_map *n;
	struct dyn_ftrace *rec;
	struct ftrace_page **last_pg;
	struct ftrace_page *tmp_page = NULL;
	struct ftrace_page *pg;

	mutex_lock(&ftrace_lock);

	if (ftrace_disabled)
		goto out_unlock;

	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
		if (mod_map->mod == mod) {
			list_del_rcu(&mod_map->list);
			call_rcu(&mod_map->rcu, ftrace_free_mod_map);
			break;
		}
	}

	/*
	 * Each module has its own ftrace_pages, remove
	 * them from the list.
	 */
	last_pg = &ftrace_pages_start;
	for (pg = ftrace_pages_start; pg; pg = *last_pg) {
		rec = &pg->records[0];
		if (within_module(rec->ip, mod)) {
			/*
			 * As core pages are first, the first
			 * page should never be a module page.
			 */
			if (WARN_ON(pg == ftrace_pages_start))
				goto out_unlock;

			/* Check if we are deleting the last page */
			if (pg == ftrace_pages)
				ftrace_pages = next_to_ftrace_page(last_pg);

			ftrace_update_tot_cnt -= pg->index;
			*last_pg = pg->next;

			pg->next = tmp_page;
			tmp_page = pg;
		} else
			last_pg = &pg->next;
	}
 out_unlock:
	mutex_unlock(&ftrace_lock);

	/* Need to synchronize with ftrace_location_range() */
	if (tmp_page)
		synchronize_rcu();
	for (pg = tmp_page; pg; pg = tmp_page) {

		/* Needs to be called outside of ftrace_lock */
		clear_mod_from_hashes(pg);

		if (pg->records) {
			free_pages((unsigned long)pg->records, pg->order);
			ftrace_number_of_pages -= 1 << pg->order;
		}
		tmp_page = pg->next;
		kfree(pg);
		ftrace_number_of_groups--;
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38346

2. Vulnerability Type
Use-after-free (lifetime/cleanup bug causing stale pointer exposure)

3. Root Cause Summary
ftrace_release_mod() returned early when ftrace_disabled was set, skipping removal of the module’s ftrace_mod_map entry from ftrace_mod_maps. This left a stale mod_map->mod pointer referencing freed module memory after module unload. Subsequent kallsyms lookups (via ftrace_mod_get_kallsym) dereferenced mod_map->mod->name, triggering a UAF read and crash. The patch makes the mod_map cleanup unconditional, removing the stale reference even when ftrace is disabled.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ftrace subsystem integration with modules and kallsyms (module symbol preservation for tracing)

2) Pre-Patch Flaw:
- In ftrace_release_mod(), the code did:
  - if (ftrace_disabled) goto out_unlock;
  - This bypassed the list_for_each_entry_safe loop that performs list_del_rcu(&mod_map->list) and schedules ftrace_free_mod_map.
- As a result, ftrace_mod_maps retained entries pointing to modules that had been unloaded.

3) Trigger Condition:
- A module triggers an ftrace anomaly causing ftrace_disable to be set.
- The module is then removed, invoking ftrace_release_mod() which returns early due to ftrace_disabled, leaving its mod_map in ftrace_mod_maps.
- Reading /proc/kallsyms causes ftrace_mod_get_kallsym to access mod_map->mod->name after the module memory has been freed.

4) Impact Mechanism:
- UAF read occurs when ftrace_mod_get_kallsym performs strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN) with mod_map->mod pointing to freed memory.
- This leads to a page fault and kernel oops; potential for crash or information exposure depending on memory reuse patterns.

5. Patch Analysis
1) Fix Approach:
- Ensure mod_map resources are released unconditionally on module removal, regardless of ftrace_disabled, to prevent stale references.
- Preserve the early-exit behavior for the remaining ftrace resource teardown (pages) when disabled.

2) Key Code Changes:
- Moved the ftrace_disabled check to occur after the mod_map removal:
  - Previously: if (ftrace_disabled) goto out_unlock; before list_for_each_entry_safe over ftrace_mod_maps.
  - Now: Always iterate and remove matching mod_map via list_del_rcu(&mod_map->list) and call_rcu(&mod_map->rcu, ftrace_free_mod_map); only then, if (ftrace_disabled) goto out_unlock.
- Added comment clarifying that mod_map must be released unconditionally to avoid UAF after module unload.

3) Locking/Concurrency Impact:
- list manipulation remains under mutex_lock(&ftrace_lock), maintaining mutual exclusion during removal.
- mod_map removal continues to use RCU (list_del_rcu + call_rcu) to protect readers traversing ftrace_mod_maps.
- By guaranteeing deletion even when disabled, readers no longer observe stale mod_map entries; the RCU discipline ensures safe reclamation timing.

6. Broader Kernel Security Implications
- Early-return paths for “disabled” or “error” states must still perform essential cleanup of cross-subsystem references to avoid dangling pointers and UAFs.
- Proper use of RCU for list entries is insufficient if deletion is skipped; correctness depends on ensuring deletion happens in all teardown scenarios.
- The fix reduces kernel crash and potential info-leak vectors during tracing anomalies, reinforcing robustness of tracing/kallsyms interactions under fault conditions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.