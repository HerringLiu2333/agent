You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38346

[INFO]
[PATCH_DESCRIPTION]
    ftrace: Fix UAF when lookup kallsym after ftrace disabled
    The following issue happens with a buggy module:
    
    BUG: unable to handle page fault for address: ffffffffc05d0218
    PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0
    Oops: Oops: 0000 [#1] SMP KASAN PTI
    Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    RIP: 0010:sized_strscpy+0x81/0x2f0
    RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000
    RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d
    RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68
    R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038
    R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff
    FS:  00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <TASK>
     ftrace_mod_get_kallsym+0x1ac/0x590
     update_iter_mod+0x239/0x5b0
     s_next+0x5b/0xa0
     seq_read_iter+0x8c9/0x1070
     seq_read+0x249/0x3b0
     proc_reg_read+0x1b0/0x280
     vfs_read+0x17f/0x920
     ksys_read+0xf3/0x1c0
     do_syscall_64+0x5f/0x2e0
     entry_SYSCALL_64_after_hwframe+0x76/0x7e
    
    The above issue may happen as follows:
    (1) Add kprobe tracepoint;
    (2) insmod test.ko;
    (3)  Module triggers ftrace disabled;
    (4) rmmod test.ko;
    (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed;
    ftrace_mod_get_kallsym()
    ...
    strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    ...
    
    The problem is when a module triggers an issue with ftrace and
    sets ftrace_disable. The ftrace_disable is set when an anomaly is
    discovered and to prevent any more damage, ftrace stops all text
    modification. The issue that happened was that the ftrace_disable stops
    more than just the text modification.
    
    When a module is loaded, its init functions can also be traced. Because
    kallsyms deletes the init functions after a module has loaded, ftrace
    saves them when the module is loaded and function tracing is enabled. This
    allows the output of the function trace to show the init function names
    instead of just their raw memory addresses.
    
    When a module is removed, ftrace_release_mod() is called, and if
    ftrace_disable is set, it just returns without doing anything more. The
    problem here is that it leaves the mod_list still around and if kallsyms
is called, it will call into this code and access the module memory that
    has already been freed as it will return:
    
      strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
    
    Where the "mod" no longer exists and triggers a UAF bug.

[PATCH_DIFF]
    @@ -7438,9 +7438,10 @@ void ftrace_release_mod(struct module *mod)
     
     	mutex_lock(&ftrace_lock);
     
    -	if (ftrace_disabled)
    -		goto out_unlock;
    -
    +	/*
    +	 * To avoid the UAF problem after the module is unloaded, the
    +	 * 'mod_map' resource needs to be released unconditionally.
    +	 */
     	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
     		if (mod_map->mod == mod) {
     			list_del_rcu(&mod_map->list);
    @@ -7449,6 +7450,9 @@ void ftrace_release_mod(struct module *mod)
     		}
     	}
     
    +	if (ftrace_disabled)
    +		goto out_unlock;
    +
     	/*
     	 * Each module has its own ftrace_pages, remove
     	 * them from the list.



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38346

2. Vulnerability Type
Use-after-free (UAF) / dangling pointer dereference

3. Root Cause Summary
ftrace_release_mod() returned early when ftrace_disabled was set, skipping the removal of the module’s mod_map entry from ftrace_mod_maps. This left a stale mod_map pointing to the unloaded module, and later kallsyms lookup (via ftrace_mod_get_kallsym) dereferenced mod_map->mod->name after the module memory had been freed, triggering a UAF.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- ftrace module integration with kallsyms (function tracing state associated with modules)

2) Pre-Patch Flaw:
- In ftrace_release_mod(struct module *mod), the code checked ftrace_disabled and immediately jumped to out_unlock before executing the list_for_each_entry_safe() that removes and frees the mod_map for the module.
- Consequently, the mod_map remained on ftrace_mod_maps, retaining a pointer to the now-freed struct module.

3) Trigger Condition:
- A module triggers an ftrace anomaly, causing ftrace_disabled to be set.
- The module is then unloaded (rmmod), which calls ftrace_release_mod() but skips mod_map cleanup due to ftrace_disabled.
- A kallsyms lookup (e.g., cat /proc/kallsyms) invokes ftrace_mod_get_kallsym(), which accesses mod_map->mod for the unloaded module.

4) Impact Mechanism:
- ftrace_mod_get_kallsym() runs strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN) using a dangling mod_map->mod pointer, causing a kernel UAF and page fault (as shown in the provided Oops backtrace).

5. Patch Analysis
1) Fix Approach:
- Ensure mod_map resources are released unconditionally during module release, even when ftrace is disabled, to prevent stale references.
- Only short-circuit the remaining ftrace release steps when ftrace_disabled is set, after mod_map cleanup has been performed.

2) Key Code Changes:
- In ftrace_release_mod():
  - Removed the early:
    if (ftrace_disabled)
        goto out_unlock;
  - Performed list_for_each_entry_safe() over ftrace_mod_maps to find the entry for the module, then list_del_rcu(&mod_map->list) and kfree_rcu(mod_map, rcu) unconditionally.
  - Reintroduced the ftrace_disabled guard after the mod_map removal block:
    if (ftrace_disabled)
        goto out_unlock;
- Added a comment clarifying that mod_map must be released unconditionally to avoid UAF.

3) Locking/Concurrency Impact:
- No new locks introduced; mutex_lock(&ftrace_lock) still protects list operations.
- mod_map removal continues to use list_del_rcu and kfree_rcu, maintaining RCU safety for concurrent readers.
- By moving the ftrace_disabled check, the code guarantees that the stale mod_map is removed under the lock, preventing readers from finding a dangling pointer beyond the RCU grace period.

6. Broader Kernel Security Implications
- “Fail-safe” states like ftrace_disabled must still perform essential teardown to avoid dangling references that cross subsystem boundaries (here, tracing and kallsyms).
- UAFs in tracing paths can be triggered by unprivileged reads (e.g., /proc/kallsyms) after module unload, leading to kernel crashes.
- The fix underscores the need to decouple resource cleanup from operational disablement and to maintain proper RCU/list hygiene to prevent post-unload dereferences.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.