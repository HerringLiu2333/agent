You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58021

[INFO]
[PATCH_DESCRIPTION]
 HID: winwing: Add NULL check in winwing_init_led()
 [ Upstream commit 45ab5166a82d038c898985b0ad43ead69c1f9573 ]
 
 devm_kasprintf() can return a NULL pointer on failure,but this
 returned value in winwing_init_led() is not checked.
 Add NULL check in winwing_init_led(), to handle kernel NULL
 pointer dereference error.

 Fixes: 266c990debad ("HID: Add WinWing Orion2 throttle support")

[PATCH_DIFF]
 diff --git a/drivers/hid/hid-winwing.c b/drivers/hid/hid-winwing.c
 index 831b760c66ea72…d4afbbd2780797 100644
 --- a/drivers/hid/hid-winwing.c
 +++ b/drivers/hid/hid-winwing.c
 @@ -106,6 +106,8 @@ static int winwing_init_led(struct hid_device *hdev,
 "%s::%s",
   dev_name(&input->dev),
   info->led_name);
 + if (!led->cdev.name)
 + return -ENOMEM;

   ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
   if (ret)

[FUNCTION_CONTENT]
static int winwing_init_led(struct hid_device *hdev,
		struct input_dev *input)
{
	struct winwing_drv_data *data;
	struct winwing_led *led;
	int ret;
	int i;

	size_t data_size = struct_size(data, leds, 3);

	data = devm_kzalloc(&hdev->dev, data_size, GFP_KERNEL);

	if (!data)
		return -ENOMEM;

	data->report_buf = devm_kmalloc(&hdev->dev, MAX_REPORT, GFP_KERNEL);

	if (!data->report_buf)
		return -ENOMEM;

	for (i = 0; i < 3; i += 1) {
		const struct winwing_led_info *info = &led_info[i];

		led = &data->leds[i];
		led->hdev = hdev;
		led->number = info->number;
		led->cdev.max_brightness = info->max_brightness;
		led->cdev.brightness_set_blocking = winwing_led_write;
		led->cdev.flags = LED_HW_PLUGGABLE;
		led->cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
						"%s::%s",
						dev_name(&input->dev),
						info->led_name);

		ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
		if (ret)
			return ret;
	}

	hid_set_drvdata(hdev, data);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58021

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation result

3. Root Cause Summary
In drivers/hid/hid-winwing.c, function winwing_init_led(), the driver assigns led->cdev.name using devm_kasprintf() but does not check for a NULL return on allocation failure. The subsequent call to devm_led_classdev_register(&hdev->dev, &led->cdev) proceeds with led->cdev.name potentially NULL, allowing the LED core to dereference a NULL pointer. This omission was introduced in the WinWing Orion2 throttle support (Fixes: 266c990debad) and can lead to a kernel crash when memory allocation fails.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID driver (drivers/hid/hid-winwing.c) interacting with the LED class device subsystem.

2) Pre-Patch Flaw:
winwing_init_led() sets cdev.name with devm_kasprintf(...) and immediately calls devm_led_classdev_register() without validating that cdev.name is non-NULL. Pre-patch code: led->cdev.name = devm_kasprintf(...); ret = devm_led_classdev_register(...);

3) Trigger Condition:
devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s::%s", ...) returns NULL (e.g., under memory pressure or allocation failure) while initializing any of the three LEDs in the for-loop.

4) Impact Mechanism:
devm_led_classdev_register() (and downstream LED core paths) expect cdev.name to be a valid string; a NULL name leads to a NULL pointer dereference in kernel space, causing an OOPS/panic and denial of service.

5. Patch Analysis
1) Fix Approach:
Introduce a defensive NULL check after devm_kasprintf() and return -ENOMEM on failure, preventing registration with an invalid cdev.name.

2) Key Code Changes:
In winwing_init_led(), immediately after setting led->cdev.name:
+ if (!led->cdev.name)
+     return -ENOMEM;
This ensures the subsequent devm_led_classdev_register() is only called with a valid name.

3) Locking/Concurrency Impact:
None. The change is limited to error handling during device initialization; no locks or ordering were added or modified.

6. Broader Kernel Security Implications
Unchecked allocation results in initialization paths are a common source of kernel NULL dereferences and system instability. Ensuring all devm_* and *_kasprintf() returns are validated before use strengthens robustness against low-memory conditions and reduces denial-of-service risks across drivers. This fix exemplifies necessary defensive checks when interfacing with core subsystems (LED classdev) that assume non-NULL fields.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.