You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58021

[INFO]
[PATCH_DESCRIPTION]
 HID: winwing: Add NULL check in winwing_init_led()
 [ Upstream commit 45ab5166a82d038c898985b0ad43ead69c1f9573 ]
 
 devm_kasprintf() can return a NULL pointer on failure,but this
 returned value in winwing_init_led() is not checked.
 Add NULL check in winwing_init_led(), to handle kernel NULL
 pointer dereference error.

 Fixes: 266c990debad ("HID: Add WinWing Orion2 throttle support")

[PATCH_DIFF]
 diff --git a/drivers/hid/hid-winwing.c b/drivers/hid/hid-winwing.c
 index 831b760c66ea72…d4afbbd2780797 100644
 --- a/drivers/hid/hid-winwing.c
 +++ b/drivers/hid/hid-winwing.c
 @@ -106,6 +106,8 @@ static int winwing_init_led(struct hid_device *hdev,
 "%s::%s",
   dev_name(&input->dev),
   info->led_name);
 + if (!led->cdev.name)
 + return -ENOMEM;

   ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
   if (ret)

[FUNCTION_CONTENT]
static int winwing_init_led(struct hid_device *hdev,
		struct input_dev *input)
{
	struct winwing_drv_data *data;
	struct winwing_led *led;
	int ret;
	int i;

	size_t data_size = struct_size(data, leds, 3);

	data = devm_kzalloc(&hdev->dev, data_size, GFP_KERNEL);

	if (!data)
		return -ENOMEM;

	data->report_buf = devm_kmalloc(&hdev->dev, MAX_REPORT, GFP_KERNEL);

	if (!data->report_buf)
		return -ENOMEM;

	for (i = 0; i < 3; i += 1) {
		const struct winwing_led_info *info = &led_info[i];

		led = &data->leds[i];
		led->hdev = hdev;
		led->number = info->number;
		led->cdev.max_brightness = info->max_brightness;
		led->cdev.brightness_set_blocking = winwing_led_write;
		led->cdev.flags = LED_HW_PLUGGABLE;
		led->cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
						"%s::%s",
						dev_name(&input->dev),
						info->led_name);

		ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
		if (ret)
			return ret;
	}

	hid_set_drvdata(hdev, data);

	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58021

2. Vulnerability Type
NULL pointer dereference due to unchecked allocation result

3. Root Cause Summary
In drivers/hid/hid-winwing.c, function winwing_init_led(), the driver assigns led->cdev.name using devm_kasprintf() but does not check for a NULL return on allocation failure. The subsequent call to devm_led_classdev_register(&hdev->dev, &led->cdev) proceeds with led->cdev.name potentially NULL, allowing the LED core to dereference a NULL pointer. This omission was introduced in the WinWing Orion2 throttle support (Fixes: 266c990debad) and can lead to a kernel crash when memory allocation fails.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID driver (drivers/hid/hid-winwing.c) interacting with the LED class device subsystem.

2) Pre-Patch Flaw:
winwing_init_led() sets cdev.name with devm_kasprintf(...) and immediately calls devm_led_classdev_register() without validating that cdev.name is non-NULL. Pre-patch code: led->cdev.name = devm_kasprintf(...); ret = devm_led_classdev_register(...);

3) Trigger Condition:
devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s::%s", ...) returns NULL (e.g., under memory pressure or allocation failure) while initializing any of the three LEDs in the for-loop.

4) Impact Mechanism:
devm_led_classdev_register() (and downstream LED core paths) expect cdev.name to be a valid string; a NULL name leads to a NULL pointer dereference in kernel space, causing an OOPS/panic and denial of service.

5. Patch Analysis
1) Fix Approach:
Introduce a defensive NULL check after devm_kasprintf() and return -ENOMEM on failure, preventing registration with an invalid cdev.name.

2) Key Code Changes:
In winwing_init_led(), immediately after setting led->cdev.name:
+ if (!led->cdev.name)
+     return -ENOMEM;
This ensures the subsequent devm_led_classdev_register() is only called with a valid name.

3) Locking/Concurrency Impact:
None. The change is limited to error handling during device initialization; no locks or ordering were added or modified.

6. Broader Kernel Security Implications
Unchecked allocation results in initialization paths are a common source of kernel NULL dereferences and system instability. Ensuring all devm_* and *_kasprintf() returns are validated before use strengthens robustness against low-memory conditions and reduces denial-of-service risks across drivers. This fix exemplifies necessary defensive checks when interfacing with core subsystems (LED classdev) that assume non-NULL fields.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}