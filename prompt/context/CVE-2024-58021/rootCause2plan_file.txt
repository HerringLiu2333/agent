You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58021

[INFO]
[PATCH_DESCRIPTION]
 HID: winwing: Add NULL check in winwing_init_led()
 [ Upstream commit 45ab5166a82d038c898985b0ad43ead69c1f9573 ]
 
 devm_kasprintf() can return a NULL pointer on failure,but this
 returned value in winwing_init_led() is not checked.
 Add NULL check in winwing_init_led(), to handle kernel NULL
 pointer dereference error.

 Fixes: 266c990debad ("HID: Add WinWing Orion2 throttle support")

[PATCH_DIFF]
 diff --git a/drivers/hid/hid-winwing.c b/drivers/hid/hid-winwing.c
 index 831b760c66ea72…d4afbbd2780797 100644
 --- a/drivers/hid/hid-winwing.c
 +++ b/drivers/hid/hid-winwing.c
 @@ -106,6 +106,8 @@ static int winwing_init_led(struct hid_device *hdev,
 "%s::%s",
   dev_name(&input->dev),
   info->led_name);
 + if (!led->cdev.name)
 + return -ENOMEM;

   ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
   if (ret)

[FILE_CONTENT]
// SPDX-License-Identifier: GPL-2.0

/*
 * HID driver for WinWing Orion 2 throttle
 *
 * Copyright (c) 2023 Ivan Gorinov
 */

#include <linux/device.h>
#include <linux/hid.h>
#include <linux/hidraw.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/mutex.h>

#define MAX_REPORT 16

struct winwing_led {
	struct led_classdev cdev;
	struct hid_device *hdev;
	int number;
};

struct winwing_led_info {
	int number;
	int max_brightness;
	const char *led_name;
};

static const struct winwing_led_info led_info[3] = {
	{ 0, 255, "backlight" },
	{ 1, 1, "a-a" },
	{ 2, 1, "a-g" },
};

struct winwing_drv_data {
	struct hid_device *hdev;
	__u8 *report_buf;
	struct mutex lock;
	unsigned int num_leds;
	struct winwing_led leds[];
};

static int winwing_led_write(struct led_classdev *cdev,
		enum led_brightness br)
{
	struct winwing_led *led = (struct winwing_led *) cdev;
	struct winwing_drv_data *data = hid_get_drvdata(led->hdev);
	__u8 *buf = data->report_buf;
	int ret;

	mutex_lock(&data->lock);

	buf[0] = 0x02;
	buf[1] = 0x60;
	buf[2] = 0xbe;
	buf[3] = 0x00;
	buf[4] = 0x00;
	buf[5] = 0x03;
	buf[6] = 0x49;
	buf[7] = led->number;
	buf[8] = br;
	buf[9] = 0x00;
	buf[10] = 0;
	buf[11] = 0;
	buf[12] = 0;
	buf[13] = 0;

	ret = hid_hw_output_report(led->hdev, buf, 14);

	mutex_unlock(&data->lock);

	return ret;
}

static int winwing_init_led(struct hid_device *hdev,
		struct input_dev *input)
{
	struct winwing_drv_data *data;
	struct winwing_led *led;
	int ret;
	int i;

	size_t data_size = struct_size(data, leds, 3);

	data = devm_kzalloc(&hdev->dev, data_size, GFP_KERNEL);

	if (!data)
		return -ENOMEM;

	data->report_buf = devm_kmalloc(&hdev->dev, MAX_REPORT, GFP_KERNEL);

	if (!data->report_buf)
		return -ENOMEM;

	for (i = 0; i < 3; i += 1) {
		const struct winwing_led_info *info = &led_info[i];

		led = &data->leds[i];
		led->hdev = hdev;
		led->number = info->number;
		led->cdev.max_brightness = info->max_brightness;
		led->cdev.brightness_set_blocking = winwing_led_write;
		led->cdev.flags = LED_HW_PLUGGABLE;
		led->cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
						"%s::%s",
						dev_name(&input->dev),
						info->led_name);

		ret = devm_led_classdev_register(&hdev->dev, &led->cdev);
		if (ret)
			return ret;
	}

	hid_set_drvdata(hdev, data);

	return ret;
}

static int winwing_probe(struct hid_device *hdev,
		const struct hid_device_id *id)
{
	int ret;

	ret = hid_parse(hdev);
	if (ret) {
		hid_err(hdev, "parse failed\n");
		return ret;
	}

	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
	if (ret) {
		hid_err(hdev, "hw start failed\n");
		return ret;
	}

	return 0;
}

static int winwing_input_configured(struct hid_device *hdev,
		struct hid_input *hidinput)
{
	int ret;

	ret = winwing_init_led(hdev, hidinput->input);

	if (ret)
		hid_err(hdev, "led init failed\n");

	return ret;
}

static const __u8 original_rdesc_buttons[] = {
	0x05, 0x09, 0x19, 0x01, 0x29, 0x6F,
	0x15, 0x00, 0x25, 0x01, 0x35, 0x00,
	0x45, 0x01, 0x75, 0x01, 0x95, 0x6F,
	0x81, 0x02, 0x75, 0x01, 0x95, 0x01,
	0x81, 0x01
};

/*
 * HID report descriptor shows 111 buttons, which exceeds maximum
 * number of buttons (80) supported by Linux kernel HID subsystem.
 *
 * This module skips numbers 32-63, unused on some throttle grips.
 */

static const __u8 *winwing_report_fixup(struct hid_device *hdev, __u8 *rdesc,
		unsigned int *rsize)
{
	int sig_length = sizeof(original_rdesc_buttons);
	int unused_button_numbers = 32;

	if (*rsize < 34)
		return rdesc;

	if (memcmp(rdesc + 8, original_rdesc_buttons, sig_length) == 0) {

		/* Usage Maximum */
		rdesc[13] -= unused_button_numbers;

		/*  Report Count for buttons */
		rdesc[25] -= unused_button_numbers;

		/*  Report Count for padding [HID1_11, 6.2.2.9] */
		rdesc[31] += unused_button_numbers;

		hid_info(hdev, "winwing descriptor fixed\n");
	}

	return rdesc;
}

static int winwing_raw_event(struct hid_device *hdev,
		struct hid_report *report, u8 *raw_data, int size)
{
	if (size >= 15) {
		/* Skip buttons 32 .. 63 */
		memmove(raw_data + 5, raw_data + 9, 6);

		/* Clear the padding */
		memset(raw_data + 11, 0, 4);
	}

	return 0;
}

static const struct hid_device_id winwing_devices[] = {
	{ HID_USB_DEVICE(0x4098, 0xbe62) },  /* TGRIP-18 */
	{ HID_USB_DEVICE(0x4098, 0xbe68) },  /* TGRIP-16EX */
	{}
};

MODULE_DEVICE_TABLE(hid, winwing_devices);

static struct hid_driver winwing_driver = {
	.name = "winwing",
	.id_table = winwing_devices,
	.probe = winwing_probe,
	.input_configured = winwing_input_configured,
	.report_fixup = winwing_report_fixup,
	.raw_event = winwing_raw_event,
};
module_hid_driver(winwing_driver);

MODULE_DESCRIPTION("HID driver for WinWing Orion 2 throttle");
MODULE_LICENSE("GPL");




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58021

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (denial of service) due to missing allocation failure handling.

3. Root Cause Summary
winwing_init_led() assigned led->cdev.name using devm_kasprintf() without checking for a NULL return on allocation failure. The code immediately proceeded to devm_led_classdev_register(&hdev->dev, &led->cdev), which relies on cdev.name and could dereference it unconditionally. Under low-memory conditions, devm_kasprintf() returns NULL, causing a kernel NULL pointer dereference during LED class device registration.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
HID driver for WinWing Orion 2 throttle (drivers/hid/hid-winwing.c), interacting with the LED subsystem.

2) Pre-Patch Flaw:
In winwing_init_led(), the line “led->cdev.name = devm_kasprintf(...);” was not followed by a NULL check, leaving led->cdev.name potentially NULL when passed to devm_led_classdev_register().

3) Trigger Condition:
Memory allocation failure in devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s::%s", dev_name(&input->dev), info->led_name) while initializing any of the three LEDs during HID input configuration.

4) Impact Mechanism:
A NULL led->cdev.name propagates into devm_led_classdev_register() or subsequent LED core usage, leading to a NULL pointer dereference and kernel oops/panic, resulting in denial of service.

5. Patch Analysis
1) Fix Approach:
Add defensive checking for the devm_kasprintf() return value and abort LED initialization with an error when led->cdev.name is NULL.

2) Key Code Changes:
Inserted:
“if (!led->cdev.name)
    return -ENOMEM;”
immediately after the devm_kasprintf() assignment in winwing_init_led().

3) Locking/Concurrency Impact:
None. The patch introduces no locking changes; it only adds an early error return to avoid unsafe use of a NULL pointer.

6. Broader Kernel Security Implications
Unchecked allocation results are a common source of kernel crashes in device drivers, especially in initialization paths where subsequent framework registration assumes valid pointers. Ensuring all devm_* allocations (including devm_kasprintf) are validated prevents plug-in-time crashes under memory pressure and improves robustness of HID/LED integration. This fix exemplifies the need for systematic audits of error handling in driver init code to avoid denial-of-service conditions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.