You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38294

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: fix NULL access in assign channel context handler
    Currently, when ath12k_mac_assign_vif_to_vdev() fails, the radio handle
    (ar) gets accessed from the link VIF handle (arvif) for debug logging, This
    is incorrect. In the fail scenario, radio handle is NULL. Fix the NULL
    access, avoid radio handle access by moving to the hardware debug logging
    helper function (ath12k_hw_warn).
    
    Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
    Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3

[PATCH_DIFF]
    @@ -9614,8 +9614,8 @@ ath12k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
     
     	ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx);
     	if (!ar) {
-		ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started",
-			    vif->addr, link_id);
+		ath12k_hw_warn(ah, "failed to assign chanctx for vif %pM link id %u link vif is already started",
+			       vif->addr, link_id);
     		return -EINVAL;
     	}

[FUNCTION_CONTENT]
static int
ath12k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
				 struct ieee80211_vif *vif,
				 struct ieee80211_bss_conf *link_conf,
				 struct ieee80211_chanctx_conf *ctx)
{
	struct ath12k_hw *ah = ath12k_hw_to_ah(hw);
	struct ath12k *ar;
	struct ath12k_base *ab;
	struct ath12k_vif *ahvif = ath12k_vif_to_ahvif(vif);
	u8 link_id = link_conf->link_id;
	struct ath12k_link_vif *arvif;
	int ret;

	lockdep_assert_wiphy(hw->wiphy);

	/* For multi radio wiphy, the vdev was not created during add_interface
	 * create now since we have a channel ctx now to assign to a specific ar/fw
	 */
	arvif = ath12k_mac_assign_link_vif(ah, vif, link_id);
	if (!arvif) {
		WARN_ON(1);
		return -ENOMEM;
	}

	ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx);
	if (!ar) {
		ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started",
			    vif->addr, link_id);
		return -EINVAL;
	}

	ab = ar->ab;

	ath12k_dbg(ab, ATH12K_DBG_MAC,
		   "mac chanctx assign ptr %p vdev_id %i\n",
		   ctx, arvif->vdev_id);

	arvif->punct_bitmap = ctx->def.punctured;

	/* for some targets bss peer must be created before vdev_start */
	if (ab->hw_params->vdev_start_delay &&
	    ahvif->vdev_type != WMI_VDEV_TYPE_AP &&
	    ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&
	    !ath12k_peer_exist_by_vdev_id(ab, arvif->vdev_id)) {
		ret = 0;
		goto out;
	}

	if (WARN_ON(arvif->is_started)) {
		ret = -EBUSY;
		goto out;
	}

	if (ahvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
		ret = ath12k_mac_monitor_start(ar);
		if (ret)
			goto out;

		arvif->is_started = true;
		goto out;
	}

	ret = ath12k_mac_vdev_start(arvif, ctx);
	if (ret) {
		ath12k_warn(ab, "failed to start vdev %i addr %pM on freq %d: %d\n",
			    arvif->vdev_id, vif->addr,
			    ctx->def.chan->center_freq, ret);
		goto out;
	}

	if (ahvif->vdev_type != WMI_VDEV_TYPE_MONITOR && ar->monitor_vdev_created)
		ath12k_mac_monitor_start(ar);

	arvif->is_started = true;

	/* TODO: Setup ps and cts/rts protection */

out:
	return ret;
}

/* ----- separator ----- */

		WARN_ON(1);
		return -ENOMEM;
	}

	ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx);
	if (!ar) {
		ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started",
			    vif->addr, link_id);
		return -EINVAL;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38294

2. Vulnerability Type
NULL pointer dereference leading to kernel Denial of Service (DoS)

3. Root Cause Summary
In ath12k_mac_op_assign_vif_chanctx(), the error path after ath12k_mac_assign_vif_to_vdev() failed unconditionally dereferenced arvif->ar->ab to print a warning. In the failure scenario, the radio handle (ar) associated with the link vif (arvif->ar) can be NULL, making arvif->ar->ab a NULL pointer dereference. The patch replaces the warn helper to one that does not require dereferencing a potentially NULL radio handle, eliminating the unsafe access.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking, Qualcomm ath12k driver (mac layer)

2) Pre-Patch Flaw:
- In ath12k_mac_op_assign_vif_chanctx(), when ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx) returns NULL, the code executed:
  ath12k_warn(arvif->ar->ab, ...)
  without validating arvif->ar, causing a NULL dereference in the logging path.

3) Trigger Condition:
- ath12k_mac_assign_vif_to_vdev() returns NULL (e.g., as hinted by the message text “link vif is already started” in the pre-patch warning), leaving arvif->ar unset/NULL in that error path, and then the warning attempts to use arvif->ar->ab.

4) Impact Mechanism:
- Dereferencing arvif->ar when it is NULL triggers a kernel NULL pointer dereference during error logging, resulting in an oops/panic and a Denial of Service.

5. Patch Analysis
1) Fix Approach:
- Avoid dereferencing the potentially NULL radio handle by switching the logging to a helper that uses the hardware context (ah) rather than arvif->ar->ab.

2) Key Code Changes:
- Replaced:
  ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started", vif->addr, link_id);
  with:
  ath12k_hw_warn(ah, "failed to assign chanctx for vif %pM link id %u link vif is already started", vif->addr, link_id);
- This change removes the dereference of arvif->ar and uses the already-available ah pointer for logging.

3) Locking/Concurrency Impact:
- None. No locking changes; the fix solely alters the logging call to avoid unsafe pointer access.

6. Broader Kernel Security Implications
- Error paths and logging must not dereference pointers that may be NULL, especially after partial initialization failures. Using context-appropriate logging helpers (that do not rely on objects that may not be set) prevents trivial DoS conditions reachable via configuration/state transitions in wireless interfaces. This reinforces robust error handling in drivers and reduces attack surface from user-triggerable control flows.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.