You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38294

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: fix NULL access in assign channel context handler
    Currently, when ath12k_mac_assign_vif_to_vdev() fails, the radio handle
    (ar) gets accessed from the link VIF handle (arvif) for debug logging, This
    is incorrect. In the fail scenario, radio handle is NULL. Fix the NULL
    access, avoid radio handle access by moving to the hardware debug logging
    helper function (ath12k_hw_warn).
    
    Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
    Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3

[PATCH_DIFF]
    @@ -9614,8 +9614,8 @@ ath12k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,
     
     	ar = ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx);
     	if (!ar) {
-		ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started",
-			    vif->addr, link_id);
+		ath12k_hw_warn(ah, "failed to assign chanctx for vif %pM link id %u link vif is already started",
+			       vif->addr, link_id);
     		return -EINVAL;
     	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38294

2. Vulnerability Type
NULL pointer dereference leading to kernel crash/denial-of-service

3. Root Cause Summary
The error path in ath12k_mac_op_assign_vif_chanctx dereferenced a NULL radio handle via arvif->ar->ab when ath12k_mac_assign_vif_to_vdev() failed and returned NULL. The code attempted to emit a warning using ath12k_warn(arvif->ar->ab, …) despite the radio handle not being established in the failure scenario. This missing NULL validation in the logging path caused a NULL pointer dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm ath12k Wi-Fi driver (mac80211 operations)

2) Pre-Patch Flaw:
In ath12k_mac_op_assign_vif_chanctx, when ath12k_mac_assign_vif_to_vdev(hw, arvif, ctx) returned NULL, the code logged using ath12k_warn(arvif->ar->ab, …), dereferencing arvif->ar despite the failed assignment. Pre-patch snippet: “ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started", …);”.

3) Trigger Condition:
ath12k_mac_assign_vif_to_vdev() fails (returns NULL), for example when “link vif is already started” as indicated by the log message, leading the subsequent error logging to access arvif->ar->ab.

4) Impact Mechanism:
Dereferencing arvif->ar when it is NULL causes a kernel NULL pointer dereference, resulting in an oops and potential system crash, enabling denial-of-service via a problematic channel context assignment operation.

5. Patch Analysis
1) Fix Approach:
Redirect error logging to a helper that does not rely on the radio handle, avoiding NULL dereferences in the failure path. Specifically replace ath12k_warn(arvif->ar->ab, …) with ath12k_hw_warn(ah, …), where ah remains valid regardless of the assignment outcome.

2) Key Code Changes:
- Before: ath12k_warn(arvif->ar->ab, "failed to assign chanctx for vif %pM link id %u link vif is already started", vif->addr, link_id);
- After: ath12k_hw_warn(ah, "failed to assign chanctx for vif %pM link id %u link vif is already started", vif->addr, link_id);
This change occurs in ath12k_mac_op_assign_vif_chanctx around the NULL-check branch for the return of ath12k_mac_assign_vif_to_vdev().

3) Locking/Concurrency Impact:
Unknown/Not determinable. The patch does not introduce or modify locking; it strictly changes the logging helper to avoid dereferencing a NULL pointer.

6. Broader Kernel Security Implications
This fix removes a straightforward kernel crash vector triggered by driver error paths, improving robustness against denial-of-service conditions caused by malformed or unexpected Wi-Fi interface/channel context operations. Ensuring that error handling does not dereference invalid pointers is critical in drivers exposed to complex state transitions initiated by user space (mac80211/cfg80211) or firmware interactions. The change exemplifies safer logging practices that avoid relying on objects that may be NULL after failed setup paths.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.