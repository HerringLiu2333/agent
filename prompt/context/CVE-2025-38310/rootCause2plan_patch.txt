You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38310

[INFO]
[PATCH_DESCRIPTION]
    seg6: Fix validation of nexthop addresses
    The kernel currently validates that the length of the provided nexthop
    address does not exceed the specified length. This can lead to the
    kernel reading uninitialized memory if user space provided a shorter
    length than the specified one.
    
    Fix by validating that the provided length exactly matches the specified
    one.

[PATCH_DIFF]
    @@ -1644,10 +1644,8 @@ static const struct nla_policy seg6_local_policy[SEG6_LOCAL_MAX + 1] = {
     	[SEG6_LOCAL_SRH]	= { .type = NLA_BINARY },
     	[SEG6_LOCAL_TABLE]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_VRFTABLE]	= { .type = NLA_U32 },
    -	[SEG6_LOCAL_NH4]	= { .type = NLA_BINARY,
    -				    .len = sizeof(struct in_addr) },
    -	[SEG6_LOCAL_NH6]	= { .type = NLA_BINARY,
    -				    .len = sizeof(struct in6_addr) },
    +	[SEG6_LOCAL_NH4]	= NLA_POLICY_EXACT_LEN(sizeof(struct in_addr)),
    +	[SEG6_LOCAL_NH6]	= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
     	[SEG6_LOCAL_IIF]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_OIF]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_BPF]	= { .type = NLA_NESTED },



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38310

2. Vulnerability Type
Insufficient length validation leading to uninitialized memory read (information disclosure)

3. Root Cause Summary
The netlink attribute policy for SEG6_LOCAL_NH4 and SEG6_LOCAL_NH6 used NLA_BINARY with .len set to sizeof(struct in_addr)/sizeof(struct in6_addr), which only enforces a maximum length. This allowed attributes shorter than the fixed-size address structures to pass validation. Subsequent code expects an exact-sized IPv4/IPv6 address and can read beyond the provided payload or use uninitialized bytes, resulting in the kernel reading uninitialized memory.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Networking, IPv6 Segment Routing (SEG6) local processing (netlink attribute parsing via seg6_local_policy)

2) Pre-Patch Flaw:
- seg6_local_policy defined:
  - [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }
  - [SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }
- For NLA_BINARY, .len is a maximum, not an exact size, permitting undersized nexthop attributes.

3) Trigger Condition:
- A user space netlink request sets SEG6_LOCAL_NH4 or SEG6_LOCAL_NH6 with a payload shorter than sizeof(struct in_addr)/sizeof(struct in6_addr) (but not exceeding it). The validator accepts it due to the max-length policy.

4) Impact Mechanism:
- Kernel code that treats these attributes as fixed-size addresses can read beyond the provided data or read uninitialized bytes when accessing the nexthop address, resulting in an uninitialized memory read (as described in the patch description). This can cause information disclosure and potentially incorrect nexthop configuration.

5. Patch Analysis
1) Fix Approach:
- Strengthen netlink attribute validation to enforce exact-length requirements, preventing undersized attributes from being accepted.

2) Key Code Changes:
- Replaced:
  - [SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }
  - [SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }
- With:
  - [SEG6_LOCAL_NH4] = NLA_POLICY_EXACT_LEN(sizeof(struct in_addr))
  - [SEG6_LOCAL_NH6] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr))
- This enforces equality rather than “<=” semantics for attribute lengths.

3) Locking/Concurrency Impact:
- None. The change is limited to netlink attribute policy validation; no locking or ordering changes.

6. Broader Kernel Security Implications
- Enforcing exact-length policies for fixed-size netlink attributes prevents a class of uninitialized read and potential info-leak bugs across networking subsystems.
- Tightened validation reduces kernel attack surface from malformed netlink inputs (including from namespaces with CAP_NET_ADMIN), improving robustness and preventing subtle data leaks or misconfigurations tied to length mismatches.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.