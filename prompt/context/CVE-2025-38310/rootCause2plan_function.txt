You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38310

[INFO]
[PATCH_DESCRIPTION]
    seg6: Fix validation of nexthop addresses
    The kernel currently validates that the length of the provided nexthop
    address does not exceed the specified length. This can lead to the
    kernel reading uninitialized memory if user space provided a shorter
    length than the specified one.
    
    Fix by validating that the provided length exactly matches the specified
    one.

[PATCH_DIFF]
    @@ -1644,10 +1644,8 @@ static const struct nla_policy seg6_local_policy[SEG6_LOCAL_MAX + 1] = {
     	[SEG6_LOCAL_SRH]	= { .type = NLA_BINARY },
     	[SEG6_LOCAL_TABLE]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_VRFTABLE]	= { .type = NLA_U32 },
    -	[SEG6_LOCAL_NH4]	= { .type = NLA_BINARY,
    -				    .len = sizeof(struct in_addr) },
    -	[SEG6_LOCAL_NH6]	= { .type = NLA_BINARY,
    -				    .len = sizeof(struct in6_addr) },
    +	[SEG6_LOCAL_NH4]	= NLA_POLICY_EXACT_LEN(sizeof(struct in_addr)),
    +	[SEG6_LOCAL_NH6]	= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
     	[SEG6_LOCAL_IIF]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_OIF]	= { .type = NLA_U32 },
     	[SEG6_LOCAL_BPF]	= { .type = NLA_NESTED },

[FUNCTION_CONTENT]




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38310

2. Vulnerability Type
Improper input length validation leading to uninitialized memory read

3. Root Cause Summary
The netlink attribute policy for SRv6 local nexthop addresses (SEG6_LOCAL_NH4 and SEG6_LOCAL_NH6) validated that the payload length did not exceed the expected struct size, but did not require an exact match. This allowed user space to supply a shorter attribute that passed validation, while subsequent kernel code treated the payload as a full struct in_addr/in6_addr and read bytes that were never initialized. The patch corrects this by enforcing exact-length validation for these fixed-size attributes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
IPv6 Segment Routing (seg6) local actions netlink parsing (seg6_local_policy)

2) Pre-Patch Flaw:
seg6_local_policy used NLA_BINARY with .len = sizeof(struct in_addr) / sizeof(struct in6_addr), which only ensured attr payload length <= len, not == len. This mismatch permitted shorter-than-expected nexthop attributes to be accepted.

3) Trigger Condition:
A user space netlink message provides SEG6_LOCAL_NH4 or SEG6_LOCAL_NH6 with payload length smaller than sizeof(struct in_addr) or sizeof(struct in6_addr), respectively.

4) Impact Mechanism:
Kernel code subsequently interprets the attribute as a full fixed-size address and reads bytes beyond the initialized payload, resulting in reading uninitialized memory and potentially using undefined nexthop address data during SRv6 local processing.

5. Patch Analysis
1) Fix Approach:
Strengthen netlink attribute validation to require exact payload length for fixed-size nexthop addresses, preventing acceptance of undersized attributes.

2) Key Code Changes:
In seg6_local_policy:
- Replace “[SEG6_LOCAL_NH4] = { .type = NLA_BINARY, .len = sizeof(struct in_addr) }” with “[SEG6_LOCAL_NH4] = NLA_POLICY_EXACT_LEN(sizeof(struct in_addr))”.
- Replace “[SEG6_LOCAL_NH6] = { .type = NLA_BINARY, .len = sizeof(struct in6_addr) }” with “[SEG6_LOCAL_NH6] = NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr))”.

3) Locking/Concurrency Impact:
None; the change is confined to netlink attribute validation and does not modify locking or execution ordering.

6. Broader Kernel Security Implications
Exact-length enforcement is critical when parsing fixed-size structures from user space; allowing shorter lengths can cause uninitialized reads and unpredictable behavior. This fix highlights a common pitfall in netlink policy definitions where “<= len” validation is insufficient for fixed-size types. Auditing other netlink policies for similar patterns can prevent subtle memory-safety issues and potential information leaks or logic corruptions across networking subsystems.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.