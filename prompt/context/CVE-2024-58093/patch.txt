    diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c
    index e0bc90597dcadf..25954cc89bf342 100644
    --- a/drivers/pci/pcie/aspm.c
    +++ b/drivers/pci/pcie/aspm.c
    @@ -1273,16 +1273,16 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     	parent_link = link->parent;
     
     	/*
    -	 * link->downstream is a pointer to the pci_dev of function 0.  If
    -	 * we remove that function, the pci_dev is about to be deallocated,
    -	 * so we can't use link->downstream again.  Free the link state to
    -	 * avoid this.
    +	 * Free the parent link state, no later than function 0 (i.e.
    +	 * link->downstream) being removed.
     	 *
    -	 * If we're removing a non-0 function, it's possible we could
    -	 * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends
    -	 * programming the same ASPM Control value for all functions of
    -	 * multi-function devices, so disable ASPM for all of them.
    +	 * Do not free the link state any earlier. If function 0 is a
    +	 * switch upstream port, this link state is parent_link to all
    +	 * subordinate ones.
     	 /
    +	if (pdev != link->downstream)
    +		goto out;
     	pcie_config_aspm_link(link, 0);
     	list_del(&link->sibling);
     	free_link_state(link);
    @@ -1293,6 +1293,7 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     		pcie_config_aspm_path(parent_link);
     	}
     
    + out:
     	mutex_unlock(&aspm_lock);
     	up_read(&pci_bus_sem);
     }