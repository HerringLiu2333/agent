You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58093

[INFO]
[PATCH_DESCRIPTION]
 PCI/ASPM: Fix link state exit during switch upstream function removal
 Before 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to
 avoid use-after-free"), we would free the ASPM link only after the last
 function on the bus pertaining to the given link was removed.
 
 That was too late. If function 0 is removed before sibling function,
 link->downstream would point to free'd memory after.
 
 After above change, we freed the ASPM parent link state upon any function
 removal on the bus pertaining to a given link.
 
 That is too early. If the link is to a PCIe switch with MFD on the upstream
 port, then removing functions other than 0 first would free a link which
 still remains parent_link to the remaining downstream ports.

 The resulting GPFs are especially frequent during hot-unplug, because
 pciehp removes devices on the link bus in reverse order.

 On that switch, function 0 is the virtual P2P bridge to the internal bus.
 Free exactly when function 0 is removed -- before the parent link is
 obsolete, but after all subordinate links are gone.

 Link: https://lore.kernel.org/r/e12898835f25234561c9d7de4435590d957b85d9.1734924854.git.dns@arista.com
 Fixes: 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free")

[PATCH_DIFF]
    diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c
    index e0bc90597dcadf..25954cc89bf342 100644
    --- a/drivers/pci/pcie/aspm.c
    +++ b/drivers/pci/pcie/aspm.c
    @@ -1273,16 +1273,16 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     	parent_link = link->parent;
     
     	/*
    -	 * link->downstream is a pointer to the pci_dev of function 0.  If
    -	 * we remove that function, the pci_dev is about to be deallocated,
    -	 * so we can't use link->downstream again.  Free the link state to
    -	 * avoid this.
    +	 * Free the parent link state, no later than function 0 (i.e.
    +	 * link->downstream) being removed.
     	 *
    -	 * If we're removing a non-0 function, it's possible we could
    -	 * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends
    -	 * programming the same ASPM Control value for all functions of
    -	 * multi-function devices, so disable ASPM for all of them.
    +	 * Do not free the link state any earlier. If function 0 is a
    +	 * switch upstream port, this link state is parent_link to all
    +	 * subordinate ones.
     	 /
    +	if (pdev != link->downstream)
    +		goto out;
     	pcie_config_aspm_link(link, 0);
     	list_del(&link->sibling);
     	free_link_state(link);
    @@ -1293,6 +1293,7 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     		pcie_config_aspm_path(parent_link);
     	}
     
    + out:
     	mutex_unlock(&aspm_lock);
     	up_read(&pci_bus_sem);
     }

[FUNCTION_CONTENT]
void pcie_aspm_exit_link_state(struct pci_dev *pdev)
{
	struct pci_dev *parent = pdev->bus->self;
	struct pcie_link_state *link, *root, *parent_link;

	if (!parent || !parent->link_state)
		return;

	down_read(&pci_bus_sem);
	mutex_lock(&aspm_lock);

	link = parent->link_state;
	root = link->root;
	parent_link = link->parent;

	/*
	 * link->downstream is a pointer to the pci_dev of function 0.  If
	 * we remove that function, the pci_dev is about to be deallocated,
	 * so we can't use link->downstream again.  Free the link state to
	 * avoid this.
	 *
	 * If we're removing a non-0 function, it's possible we could
	 * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends
	 * programming the same ASPM Control value for all functions of
	 * multi-function devices, so disable ASPM for all of them.
	 */
	pcie_config_aspm_link(link, 0);
	list_del(&link->sibling);
	free_link_state(link);

	/* Recheck latencies and configure upstream links */
	if (parent_link) {
		pcie_update_aspm_capable(root);
		pcie_config_aspm_path(parent_link);
	}

	mutex_unlock(&aspm_lock);
	up_read(&pci_bus_sem);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58093

2. Vulnerability Type
Use-after-free due to premature teardown (lifetime/refcount bug)

3. Root Cause Summary
pcie_aspm_exit_link_state() unconditionally tore down and freed the PCIe ASPM link state for the parent bus on removal of any function of a multi-function upstream port, without verifying that the removed device was function 0 (link->downstream). On PCIe switches with multi-function upstream ports, subordinate downstream ports still referenced this parent link via their parent_link pointer. Freeing it early left those subordinate links holding a dangling pointer, leading to general protection faults during subsequent ASPM operations or hot-unplug sequences.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
PCIe Active State Power Management (ASPM), drivers/pci/pcie/aspm.c

2) Pre-Patch Flaw:
- In pcie_aspm_exit_link_state(), the link state was always freed regardless of which function was being removed.
- Evidence: unconditional sequence:
  - "pcie_config_aspm_link(link, 0);"
  - "list_del(&link->sibling);"
  - "free_link_state(link);"
- This ignored that link->downstream designates function 0, the correct point to retire the parent link.

3) Trigger Condition:
- Removing a non-0 function of a multi-function PCIe switch upstream port (common in hot-unplug where pciehp removes devices in reverse order), while subordinate downstream ports still exist and retain parent_link references to the upstream link state.

4) Impact Mechanism:
- The early free makes parent_link in subordinate links point to freed memory (dangling pointer).
- Subsequent ASPM path/configuration or device removal operations dereference the stale parent_link, causing use-after-free and observed general protection faults (GPFs).

5. Patch Analysis
1) Fix Approach:
- Gate link-state teardown so it occurs no earlier than removal of function 0 (link->downstream).
- For non-0 function removals, skip freeing the parent link state to preserve validity for remaining subordinate links.

2) Key Code Changes:
- Added conditional check and early exit:
  - "if (pdev != link->downstream) goto out;"
- Restricted teardown (pcie_config_aspm_link(), list_del(), free_link_state()) to the case where pdev == link->downstream.
- Updated comment to emphasize correct timing: “Free the parent link state, no later than function 0 … Do not free … earlier.”

3) Locking/Concurrency Impact:
- No changes to locking; existing down_read(&pci_bus_sem) and mutex_lock(&aspm_lock) remain.
- The fix is purely logical: it avoids premature free under the existing lock regime, preventing dangling references while other functions/ports are still present.

6. Broader Kernel Security Implications
- Correct lifetime management of shared link-state structures across multi-function devices prevents kernel crashes during hot-plug/unplug and device removal sequences.
- Eliminates a path for non-privileged device operations (e.g., hot-unplug via pciehp) to induce kernel GPFs via UAF conditions in ASPM.
- Highlights the importance of tying teardown to the canonical function (function 0) on multi-function devices to maintain invariants for subordinate structures.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.