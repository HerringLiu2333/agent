You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58093

[INFO]
[PATCH_DESCRIPTION]
 PCI/ASPM: Fix link state exit during switch upstream function removal
 Before 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to
 avoid use-after-free"), we would free the ASPM link only after the last
 function on the bus pertaining to the given link was removed.
 
 That was too late. If function 0 is removed before sibling function,
 link->downstream would point to free'd memory after.
 
 After above change, we freed the ASPM parent link state upon any function
 removal on the bus pertaining to a given link.
 
 That is too early. If the link is to a PCIe switch with MFD on the upstream
 port, then removing functions other than 0 first would free a link which
 still remains parent_link to the remaining downstream ports.

 The resulting GPFs are especially frequent during hot-unplug, because
 pciehp removes devices on the link bus in reverse order.

 On that switch, function 0 is the virtual P2P bridge to the internal bus.
 Free exactly when function 0 is removed -- before the parent link is
 obsolete, but after all subordinate links are gone.

 Link: https://lore.kernel.org/r/e12898835f25234561c9d7de4435590d957b85d9.1734924854.git.dns@arista.com
 Fixes: 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free")

[PATCH_DIFF]
    diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c
    index e0bc90597dcadf..25954cc89bf342 100644
    --- a/drivers/pci/pcie/aspm.c
    +++ b/drivers/pci/pcie/aspm.c
    @@ -1273,16 +1273,16 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     	parent_link = link->parent;
     
     	/*
    -	 * link->downstream is a pointer to the pci_dev of function 0.  If
    -	 * we remove that function, the pci_dev is about to be deallocated,
    -	 * so we can't use link->downstream again.  Free the link state to
    -	 * avoid this.
    +	 * Free the parent link state, no later than function 0 (i.e.
    +	 * link->downstream) being removed.
     	 *
    -	 * If we're removing a non-0 function, it's possible we could
    -	 * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends
    -	 * programming the same ASPM Control value for all functions of
    -	 * multi-function devices, so disable ASPM for all of them.
    +	 * Do not free the link state any earlier. If function 0 is a
    +	 * switch upstream port, this link state is parent_link to all
    +	 * subordinate ones.
     	 /
    +	if (pdev != link->downstream)
    +		goto out;
     	pcie_config_aspm_link(link, 0);
     	list_del(&link->sibling);
     	free_link_state(link);
    @@ -1293,6 +1293,7 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
     		pcie_config_aspm_path(parent_link);
     	}
     
    + out:
     	mutex_unlock(&aspm_lock);
     	up_read(&pci_bus_sem);
     }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58093

2. Vulnerability Type
Use-after-free due to incorrect lifetime management of ASPM link state (dangling parent_link)

3. Root Cause Summary
The pre-patch logic in pcie_aspm_exit_link_state() freed the ASPM parent link state upon removal of any function on a multi-function device, not just function 0 (link->downstream). On PCIe switches where function 0 is the upstream port, this parent link remains referenced by subordinate link states. Freeing it early leaves subordinate links’ parent_link pointers dangling, leading to general protection faults during subsequent ASPM operations, especially under hot-unplug when pciehp removes non-0 functions first.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
PCIe Active State Power Management (ASPM), drivers/pci/pcie/aspm.c

2) Pre-Patch Flaw:
pcie_aspm_exit_link_state() unconditionally tore down the link state (pcie_config_aspm_link(), list_del(), free_link_state()) on any function removal, based on the change in 456d8aa37d0f intended to avoid UAF when function 0 is removed. It failed to distinguish the special role of function 0 as link->downstream for switch upstream ports, where the parent link must remain valid until function 0 is removed.

3) Trigger Condition:
Removal of a non-0 function on a PCIe switch with a multi-function upstream port, particularly during hot-unplug sequences where pciehp removes devices in reverse order (non-0 functions first).

4) Impact Mechanism:
Early free of the parent link state causes subordinate link states to hold a parent_link pointer to freed memory. Subsequent ASPM path computations or operations (e.g., pcie_config_aspm_path(parent_link)) dereference this dangling pointer, resulting in general protection faults and potential use-after-free behavior in kernel space.

5. Patch Analysis
1) Fix Approach:
Gate the teardown of the ASPM link state so it occurs no earlier than removal of function 0. Specifically, only free the parent link when pdev == link->downstream, ensuring the parent link remains valid while subordinate links exist.

2) Key Code Changes:
- Added a conditional early exit:
  "if (pdev != link->downstream) goto out;"
  preventing link teardown for non-0 functions.
- Kept the teardown sequence (pcie_config_aspm_link(link, 0); list_del(&link->sibling); free_link_state(link);) only for function 0 removal.
- Updated comments to reflect the corrected lifetime semantics: free “no later than” function 0 removal and “not any earlier,” since the link state is parent_link to subordinate ones.

3) Locking/Concurrency Impact:
No changes to locking primitives; aspm_lock (mutex) and pci_bus_sem (read lock) are still held around the operation. The new goto out path ensures proper unlock without premature freeing, improving lifetime safety under concurrent/hot-unplug operations without altering lock order or scope.

6. Broader Kernel Security Implications
Corrects a kernel memory safety bug that could lead to crashes (GPFs) and potentially exploitable UAF scenarios during device removal, especially hot-unplug of PCIe switches. The fix strengthens ASPM link-state lifetime management for multi-function upstream ports, reducing risk from removal order dependencies. Ensuring proper teardown sequencing mitigates classes of bugs tied to dangling pointers in shared link structures, improving overall robustness of PCIe device management.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.