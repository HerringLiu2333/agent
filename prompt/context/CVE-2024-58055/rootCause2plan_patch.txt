You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58055

[INFO]
[PATCH_DESCRIPTION]
 vmxnet3: Fix packet corruption in vmxnet3_xdp_xmit_frame
 [ Upstream commit 4678adf94da4a9e9683817b246b58ce15fb81782 ]
 
 Andrew and Nikolay reported connectivity issues with Cilium's service
 load-balancing in case of vmxnet3.
 
 If a BPF program for native XDP adds an encapsulation header such as
 IPIP and transmits the packet out the same interface, then in case
 of vmxnet3 a corrupted packet is being sent and subsequently dropped
 on the path.

 vmxnet3_xdp_xmit_frame() which is called e.g. via vmxnet3_run_xdp()
 through vmxnet3_xdp_xmit_back() calculates an incorrect DMA address:
 
   page = virt_to_page(xdpf->data);
   tbi->dma_addr = page_pool_get_dma_addr(page) +
                   VMXNET3_XDP_HEADROOM;
   dma_sync_single_for_device(&adapter->pdev->dev,
                              tbi->dma_addr, buf_size,
                              DMA_TO_DEVICE);
 
 The above assumes a fixed offset (VMXNET3_XDP_HEADROOM), but the XDP
 BPF program could have moved xdp->data. While the passed buf_size is
 correct (xdpf->len), the dma_addr needs to have a dynamic offset which
 can be calculated as xdpf->data - (void *)xdpf, that is, xdp->data -
 xdp->data_hard_start.

 Fixes: 54f00cce1178 ("vmxnet3: Add XDP support.")

[PATCH_DIFF]
    diff --git a/drivers/usb/gadget/function/f_tcm.c b/drivers/usb/gadget/function/f_tcm.c
    index 81b6d0d18a8cd6..948888316fbd54 100644
    --- a/drivers/usb/gadget/function/f_tcm.c
    +++ b/drivers/usb/gadget/function/f_tcm.c
    @@ -1066,7 +1066,6 @@ static void usbg_cmd_work(struct work_struct *work)
     out:
     	transport_send_check_condition_and_sense(se_cmd,
     			TCM_UNSUPPORTED_SCSI_OPCODE, 1);
    -	transport_generic_free_cmd(&cmd->se_cmd, 0);
     }
     
     static struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,
    @@ -1195,7 +1194,6 @@ static void bot_cmd_work(struct work_struct *work)
     out:
     	transport_send_check_condition_and_sense(se_cmd,
     				TCM_UNSUPPORTED_SCSI_OPCODE, 1);
    -	transport_generic_free_cmd(&cmd->se_cmd, 0);
     }
     
     static int bot_submit_command(struct f_uas *fu,



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58055

2. Vulnerability Type
Logic error leading to data corruption (incorrect DMA address/offset calculation in XDP TX path)

3. Root Cause Summary
vmxnet3_xdp_xmit_frame used a fixed headroom offset (VMXNET3_XDP_HEADROOM) when computing the DMA address for XDP frames, instead of accounting for the dynamic position of xdpf->data after an XDP program adjusts it. This miscalculation caused the NIC to DMA from the wrong start address, producing corrupted packets despite the correct length being provided. The flaw was introduced with initial XDP support for vmxnet3 (Fixes: 54f00cce1178).

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking driver: vmxnet3 XDP transmit path (vmxnet3_xdp_xmit_frame, invoked via vmxnet3_run_xdp/vmxnet3_xdp_xmit_back)

2) Pre-Patch Flaw:
The code computed tbi->dma_addr as page_pool_get_dma_addr(page) + VMXNET3_XDP_HEADROOM, assuming a static headroom. It did not use the actual offset of the XDP data pointer within the frame (xdpf->data) relative to the frame start/hard start, leading to a mismatch between the DMA start address and the intended packet data.

3) Trigger Condition:
A native XDP BPF program that modifies xdp->data (e.g., by adding an encapsulation header like IPIP) and transmits the packet out the same vmxnet3 interface via XDP_TX.

4) Impact Mechanism:
The NIC reads packet data starting from an incorrect address, resulting in corrupted L2/L3 headers and payload. Downstream devices or stacks drop the malformed packet, causing connectivity issues (as observed with Cilium service load-balancing).

5. Patch Analysis
1) Fix Approach:
Replace the fixed headroom-based DMA address computation with a dynamic offset derived from the current XDP data position, ensuring DMA begins at xdpf->data. The offset is computed as xdpf->data - (void *)xdpf (equivalently xdp->data - xdp->data_hard_start).

2) Key Code Changes:
- In vmxnet3_xdp_xmit_frame, tbi->dma_addr calculation changed from:
  “tbi->dma_addr = page_pool_get_dma_addr(page) + VMXNET3_XDP_HEADROOM”
  to:
  “tbi->dma_addr = page_pool_get_dma_addr(page) + (xdpf->data - (void *)xdpf)” (conceptually, xdp->data - xdp->data_hard_start).
- dma_sync_single_for_device continues to use the correct buf_size (xdpf->len), now paired with a correct start address.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely an address/offset calculation correction for DMA setup.

6. Broader Kernel Security Implications
Incorrect DMA address calculations in network drivers can silently corrupt packets, leading to traffic drops and denial-of-service for affected flows. While not a memory safety issue, such logic errors undermine reliability of XDP-based processing and can disrupt network functions and policies (e.g., load-balancing and encapsulation). Ensuring DMA address correctness is critical when XDP programs adjust data pointers, and similar drivers should validate their XDP TX paths for dynamic headroom handling.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.