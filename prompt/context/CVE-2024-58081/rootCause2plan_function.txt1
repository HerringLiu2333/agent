You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58081

[INFO]
[PATCH_DESCRIPTION]
 clk: mmp2: call pm_genpd_init() only after genpd.name is set
 commit e24b15d4704dcb73920c3d18a6157abd18df08c1 upstream.
 
 Setting the genpd's struct device's name with dev_set_name() is
 happening within pm_genpd_init(). If it remains NULL, things can blow up
 later, such as when crafting the devfs hierarchy for the power domain:
 
   Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read
   ...
   Call trace:
    strlen from start_creating+0x90/0x138
    start_creating from debugfs_create_dir+0x20/0x178
    debugfs_create_dir from genpd_debug_add.part.0+0x4c/0x144
    genpd_debug_add.part.0 from genpd_debug_init+0x74/0x90
    genpd_debug_init from do_one_initcall+0x5c/0x244
    do_one_initcall from kernel_init_freeable+0x19c/0x1f4
    kernel_init_freeable from kernel_init+0x1c/0x12c
    kernel_init from ret_from_fork+0x14/0x28
 
 Bisecting tracks this crash back to commit 899f44531fe6 ("pmdomain: core:
 Add GENPD_FLAG_DEV_NAME_FW flag"), which exchanges use of genpd->name
 with dev_name(&genpd->dev) in genpd_debug_add.part().
 
 Fixes: 899f44531fe6 ("pmdomain: core: Add GENPD_FLAG_DEV_NAME_FW flag")

[PATCH_DIFF]
 diff --git a/drivers/clk/mmp/pwr-island.c b/drivers/clk/mmp/pwr-island.c
 index edaa2433a472ad…eaf5d2c5e59337 100644
 --- a/drivers/clk/mmp/pwr-island.c
 +++ b/drivers/clk/mmp/pwr-island.c
 @@ -106,10 +106,10 @@ struct generic_pm_domain *mmp_pm_domain_register(const char *name,
   pm_domain->flags = flags;
   pm_domain->lock = lock;

 - pm_genpd_init(&pm_domain->genpd, NULL, true);
   pm_domain->genpd.name = name;
   pm_domain->genpd.power_on = mmp_pm_domain_power_on;
   pm_domain->genpd.power_off = mmp_pm_domain_power_off;
 + pm_genpd_init(&pm_domain->genpd, NULL, true);

   return &pm_domain->genpd;
 }

[FUNCTION_CONTENT]
struct generic_pm_domain *mmp_pm_domain_register(const char *name,
		void __iomem *reg,
		u32 power_on, u32 reset, u32 clock_enable,
		unsigned int flags, spinlock_t *lock)
{
	struct mmp_pm_domain *pm_domain;

	pm_domain = kzalloc(sizeof(*pm_domain), GFP_KERNEL);
	if (!pm_domain)
		return ERR_PTR(-ENOMEM);

	pm_domain->reg = reg;
	pm_domain->power_on = power_on;
	pm_domain->reset = reset;
	pm_domain->clock_enable = clock_enable;
	pm_domain->flags = flags;
	pm_domain->lock = lock;

	pm_genpd_init(&pm_domain->genpd, NULL, true);
	pm_domain->genpd.name = name;
	pm_domain->genpd.power_on = mmp_pm_domain_power_on;
	pm_domain->genpd.power_off = mmp_pm_domain_power_off;

	return &pm_domain->genpd;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58081

2. Vulnerability Type
Improper initialization/ordering leading to NULL pointer dereference (kernel crash/DoS)

3. Root Cause Summary
The driver called pm_genpd_init() before setting genpd.name in mmp_pm_domain_register(). pm_genpd_init() uses genpd->name to set the embedded struct device’s name via dev_set_name(). With genpd.name still NULL at that time, the device name remained NULL. Later, core PM-domain debug code (changed by commit 899f44531fe6 to use dev_name(&genpd->dev)) dereferenced this NULL name, causing a NULL pointer dereference in strlen() while creating debugfs/devfs entries.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Clock driver for Marvell MMP power islands (drivers/clk/mmp), integrating with the generic PM domain (pmdomain core) and its debugfs/devfs infrastructure.

2) Pre-Patch Flaw:
In mmp_pm_domain_register(), pm_genpd_init(&pm_domain->genpd, NULL, true) was invoked before pm_domain->genpd.name = name; and before assigning power callbacks. This ordering left genpd->dev without a valid name because pm_genpd_init() performs dev_set_name() based on genpd->name.

3) Trigger Condition:
During PM domain initialization and subsequent debugfs/devfs setup (genpd_debug_init/genpd_debug_add), dev_name(&genpd->dev) was accessed for directory creation. Since the device name was never set (NULL), the debugfs path creation called strlen on a NULL pointer, reproducing the crash described in the patch notes.

4) Impact Mechanism:
A NULL pointer dereference in kernel space (strlen on dev_name == NULL) leads to a kernel oops/panic, causing denial-of-service, typically during boot/initcall when PM domains are initialized.

5. Patch Analysis
1) Fix Approach:
Reorder initialization: set genpd.name and callbacks prior to invoking pm_genpd_init(), ensuring pm_genpd_init() has a valid name to pass to dev_set_name() and thereby avoiding NULL dev_name.

2) Key Code Changes:
- The call to pm_genpd_init(&pm_domain->genpd, NULL, true) was moved after:
  - pm_domain->genpd.name = name;
  - pm_domain->genpd.power_on = mmp_pm_domain_power_on;
  - pm_domain->genpd.power_off = mmp_pm_domain_power_off.
This guarantees that pm_genpd_init() runs with genpd.name populated.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is purely an initialization-order correction. Spinlock assignment (pm_domain->lock = lock) remains unchanged and is unrelated to the fault.

6. Broader Kernel Security Implications
Initialization-order bugs in subsystem integration can lead to system-wide instability and denial-of-service, especially in early boot paths. This case highlights the need to set identifying fields (like genpd.name) before core initialization routines that consume them (pm_genpd_init). Similar drivers using generic PM domains must ensure proper sequencing when flags or core behavior (e.g., GENPD_FLAG_DEV_NAME_FW switching to dev_name usage) change, to prevent latent NULL dereferences in debugfs/devfs creation or other infrastructure relying on device naming.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}