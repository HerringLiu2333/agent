You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38315

[INFO]
[PATCH_DESCRIPTION]
    Bluetooth: btintel: Check dsbr size from EFI variable
    Since the size of struct btintel_dsbr is already known, we can just
    start there instead of querying the EFI variable size. If the final
    result doesn't match what we expect also fail. This fixes a stack buffer
    overflow when the EFI variable is larger than struct btintel_dsbr.

[PATCH_DIFF]
     @@ -2719,7 +2719,7 @@ static int btintel_uefi_get_dsbr(u32 *dsbr_var)
      	} __packed data;
      
      	efi_status_t status;
     -	unsigned long data_size = 0;
     +	unsigned long data_size = sizeof(data);
      	efi_guid_t guid = EFI_GUID(0xe65d8884, 0xd4af, 0x4b20, 0x8d, 0x03,
      				   0x77, 0x2e, 0xcc, 0x3d, 0xa5, 0x31);
      
     @@ -2730,15 +2730,9 @@ static int btintel_uefi_get_dsbr(u32 *dsbr_var)
      		return -EOPNOTSUPP;
      
      	status = efi.get_variable(BTINTEL_EFI_DSBR, &guid, NULL, &data_size,
     -				  NULL);
     -
     -	if (status != EFI_BUFFER_TOO_SMALL || !data_size)
     -		return -EIO;
     -
     -	status = efi.get_variable(BTINTEL_EFI_DSBR, &guid, NULL, &data_size,
      				  &data);
      
     -	if (status != EFI_SUCCESS)
     +	if (status != EFI_SUCCESS || data_size != sizeof(data))
      		return -ENXIO;
      
      	*dsbr_var = data.dsbr;

[FUNCTION_CONTENT]
static int btintel_uefi_get_dsbr(u32 *dsbr_var)
{
	struct btintel_dsbr {
		u8 header;
		u32 dsbr;
	} __packed data;

	efi_status_t status;
	unsigned long data_size = 0;
	efi_guid_t guid = EFI_GUID(0xe65d8884, 0xd4af, 0x4b20, 0x8d, 0x03,
				   0x77, 0x2e, 0xcc, 0x3d, 0xa5, 0x31);

	if (!IS_ENABLED(CONFIG_EFI))
		return -EOPNOTSUPP;

	if (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))
		return -EOPNOTSUPP;

	status = efi.get_variable(BTINTEL_EFI_DSBR, &guid, NULL, &data_size,
				  NULL);

	if (status != EFI_BUFFER_TOO_SMALL || !data_size)
		return -EIO;

	status = efi.get_variable(BTINTEL_EFI_DSBR, &guid, NULL, &data_size,
				  &data);

	if (status != EFI_SUCCESS)
		return -ENXIO;

	*dsbr_var = data.dsbr;
	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38315

2. Vulnerability Type
Stack-based buffer overflow (length/size misuse when reading EFI variable)

3. Root Cause Summary
The function btintel_uefi_get_dsbr() queried the EFI variable size first and then reused that untrusted size as the input length for a second efi.get_variable() call into a fixed-size stack buffer without bounding it. Specifically, after a first call to get the size, it called efi.get_variable(..., &data_size, &data) where data_size could exceed sizeof(data), and there was no check that data_size <= sizeof(data). This allowed the EFI runtime service to write data_size bytes into a buffer of only sizeof(data), causing a stack buffer overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth Intel driver (btintel), EFI variable handling in btintel_uefi_get_dsbr()

2) Pre-Patch Flaw:
- The code trusted the EFI-reported variable size and passed it as the input buffer length for a fixed-size stack struct btintel_dsbr.
- Missing bounds/equality check between the returned EFI size and sizeof(struct btintel_dsbr).
- Evidence: pre-patch sequence in btintel_uefi_get_dsbr():
  - First call: efi.get_variable(..., &data_size, NULL) to fetch size.
  - Second call: efi.get_variable(..., &data_size, &data) with data_size potentially larger than sizeof(data), and no validation “if (status != EFI_SUCCESS) return -ENXIO;”.

3) Trigger Condition:
- The UEFI variable BTINTEL_EFI_DSBR exists and its size is larger than sizeof(struct btintel_dsbr), so the first call returns EFI_BUFFER_TOO_SMALL and sets data_size to a larger value that is then used as the input size for the second call.

4) Impact Mechanism:
- The EFI runtime service uses the input data_size parameter to determine how many bytes to write; since data points to a smaller stack buffer, this results in a stack-based buffer overflow, corrupting adjacent stack memory and potentially leading to kernel crashes or code execution.

5. Patch Analysis
1) Fix Approach:
- Eliminate the two-step “query size then read” pattern for a fixed-size structure.
- Initialize data_size to sizeof(data) and perform a single get_variable call using the known buffer size.
- Validate that the returned data_size equals sizeof(data) and reject any mismatch.

2) Key Code Changes:
- Initialize data_size to sizeof(data) instead of 0:
  - unsigned long data_size = sizeof(data);
- Remove the initial probe call that requested NULL buffer to obtain size.
- Perform one get_variable call with &data and then verify both status and size:
  - if (status != EFI_SUCCESS || data_size != sizeof(data)) return -ENXIO;

3) Locking/Concurrency Impact:
- None. No locking or concurrency changes; the fix is purely a bounds/size validation change for memory safety.

6. Broader Kernel Security Implications
- Demonstrates the risk of trusting external/environment-provided sizes (EFI variables) and passing them as authoritative lengths to kernel copy routines.
- Reinforces the need for strict size validation or controlled fixed-size reads when dealing with firmware interfaces and runtime services.
- Reduces attack surface from malicious or malformed EFI variable stores that could otherwise induce kernel stack corruption via driver variable reads.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}