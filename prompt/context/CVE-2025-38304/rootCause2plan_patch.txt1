You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38304

[INFO]
[PATCH_DESCRIPTION]
    Bluetooth: Fix NULL pointer deference on eir_get_service_data
    The len parameter is considered optional so it can be NULL so it cannot
    be used for skipping to next entry of EIR_SERVICE_DATA.

[PATCH_DIFF]
    @@ -366,17 +366,19 @@ u8 eir_create_scan_rsp(struct hci_dev *hdev, u8 instance, u8 *ptr)
     
     void *eir_get_service_data(u8 *eir, size_t eir_len, u16 uuid, size_t *len)
     {
    -	while ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, len))) {
    +	size_t dlen;
    +
    +	while ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, &dlen))) {
     		u16 value = get_unaligned_le16(eir);
     
     		if (uuid == value) {
     			if (len)
    -				*len -= 2;
    +				*len = dlen - 2;
     			return &eir[2];
     		}
     
    -		eir += *len;
    -		eir_len -= *len;
    +		eir += dlen;
    +		eir_len -= dlen;
     	}
     
     	return NULL;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38304

2. Vulnerability Type
NULL pointer dereference (kernel crash/denial-of-service)

3. Root Cause Summary
- The function eir_get_service_data(u8 *eir, size_t eir_len, u16 uuid, size_t *len) used the caller-provided len pointer as an internal loop increment when scanning EIR_SERVICE_DATA entries.
- The len parameter is optional and may be NULL, but the pre-patch code unconditionally dereferenced it to advance the parsing cursor (“eir += *len; eir_len -= *len;”).
- This misuse caused a NULL pointer dereference whenever len == NULL and the search needed to skip a non-matching service-data element.
- The patch decouples internal iteration state from the optional output parameter by introducing a local size_t dlen used for iteration, copying back to len only if non-NULL.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Bluetooth core, EIR (Extended Inquiry Response) parsing utilities, specifically eir_get_service_data.

2) Pre-Patch Flaw:
- The loop called eir_get_data(..., len) and then used “*len” to move to the next entry, assuming len was non-NULL.
- No guard existed against len == NULL in the loop’s advancement path, despite len being documented/treated as optional.

3) Trigger Condition:
- eir_get_service_data invoked with len == NULL and the EIR buffer contains at least one EIR_SERVICE_DATA element that does not match the requested uuid, causing the loop to attempt “eir += *len; eir_len -= *len”.

4) Impact Mechanism:
- Dereferencing a NULL len pointer causes a kernel NULL pointer dereference, leading to an oops/panic and denial-of-service.

5. Patch Analysis
1) Fix Approach:
- Separate internal iteration bookkeeping from the optional output parameter by using a local variable to hold the current element length.
- Only write to the caller’s len pointer when returning a match, and never rely on it for internal cursor advancement.

2) Key Code Changes:
- Introduced local size_t dlen; and changed the loop to call eir_get_data(..., &dlen) instead of passing the possibly-NULL len.
- On match: if (len) *len = dlen - 2; (preserves previous semantics of excluding the 2-byte UUID from the returned length).
- For iteration: replaced “eir += *len; eir_len -= *len;” with “eir += dlen; eir_len -= dlen;”.

3) Locking/Concurrency Impact:
- No locking or concurrency semantics changed; this is a pure safety/robustness fix within a parsing helper.

6. Broader Kernel Security Implications
- Highlights the risk of using optional output parameters for internal control flow; similar patterns should be audited across parsing helpers.
- Improves robustness of Bluetooth EIR parsing against malformed or unexpected inputs by avoiding NULL dereferences during iteration.
- Reinforces best practice: maintain separate local state for parsing while treating caller-provided pointers as optional outputs only.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}