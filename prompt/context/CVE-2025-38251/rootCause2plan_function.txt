You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38251

[INFO]
[PATCH_DESCRIPTION]
    atm: clip: prevent NULL deref in clip_push()
    Blamed commit missed that vcc_destroy_socket() calls
    clip_push() with a NULL skb.
    
    If clip_devs is NULL, clip_push() then crashes when reading
    skb->truesize.
    
    Fixes: 93a2014afbac ("atm: fix a UAF in lec_arp_clear_vccs()")

[PATCH_DIFF]
    @@ -193,12 +193,6 @@ static void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)
     
     	pr_debug("\n");
     
    -	if (!clip_devs) {
    -		atm_return(vcc, skb->truesize);
    -		kfree_skb(skb);
    -		return;
    -	}
    -
     	if (!skb) {
     		pr_debug("removing VCC %p\n", clip_vcc);
     		if (clip_vcc->entry)
    @@ -208,6 +202,11 @@ static void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)
     		return;
     	}
     	atm_return(vcc, skb->truesize);
    +	if (!clip_devs) {
    +		kfree_skb(skb);
    +		return;
    +	}
    +
     	skb->dev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : clip_devs;
     	if (!skb->dev) {

[FUNCTION_CONTENT]
static void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)
{
	struct clip_vcc *clip_vcc = CLIP_VCC(vcc);

	pr_debug("\n");

	if (!clip_devs) {
		atm_return(vcc, skb->truesize);
		kfree_skb(skb);
		return;
	}

	if (!skb) {
		pr_debug("removing VCC %p\n", clip_vcc);
		if (clip_vcc->entry)
			unlink_clip_vcc(clip_vcc);
		clip_vcc->old_push(vcc, NULL);	/* pass on the bad news */
		kfree(clip_vcc);
		return;
	}
	atm_return(vcc, skb->truesize);
	skb->dev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : clip_devs;
	/* clip_vcc->entry == NULL if we don't have an IP address yet */
	if (!skb->dev) {
		dev_kfree_skb_any(skb);
		return;
	}
	ATM_SKB(skb)->vcc = vcc;
	skb_reset_mac_header(skb);
	if (!clip_vcc->encap ||
	    skb->len < RFC1483LLC_LEN ||
	    memcmp(skb->data, llc_oui, sizeof(llc_oui)))
		skb->protocol = htons(ETH_P_IP);
	else {
		skb->protocol = ((__be16 *)skb->data)[3];
		skb_pull(skb, RFC1483LLC_LEN);
		if (skb->protocol == htons(ETH_P_ARP)) {
			skb->dev->stats.rx_packets++;
			skb->dev->stats.rx_bytes += skb->len;
			clip_arp_rcv(skb);
			return;
		}
	}
	clip_vcc->last_use = jiffies;
	skb->dev->stats.rx_packets++;
	skb->dev->stats.rx_bytes += skb->len;
	memset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));
	netif_rx(skb);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38251

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (Denial of Service)

3. Root Cause Summary
clip_push() dereferenced skb->truesize inside an early if (!clip_devs) block without first validating that skb was non-NULL. vcc_destroy_socket() can call clip_push() with skb == NULL; when clip_devs is also NULL, the pre-patch code executed atm_return(vcc, skb->truesize), causing a NULL dereference. This misordered validation path was introduced by commit 93a2014afbac and resulted in an unsafe access to a potentially NULL sk_buff.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ATM CLIP (Classical IP over ATM), clip_push() in the ATM networking stack.

2) Pre-Patch Flaw:
clip_push() performed an early check for clip_devs being NULL and, within that branch, accessed skb->truesize and kfree_skb(skb) regardless of skb’s validity. The NULL-check for skb occurred only afterward, making the function unsafe when called with a NULL skb.

3) Trigger Condition:
clip_push() invoked with skb == NULL (as in vcc_destroy_socket() teardown paths) while clip_devs == NULL. Under this condition, the function attempted to read skb->truesize before the !skb guard, causing a NULL dereference.

4) Impact Mechanism:
Dereferencing a NULL sk_buff (skb->truesize) in kernel space triggers a kernel oops/panic, resulting in a denial of service. The crash occurs immediately upon entering the !clip_devs branch in clip_push() when skb is NULL.

5. Patch Analysis
1) Fix Approach:
Reorder the control flow to validate skb first and only perform operations on skb when it is guaranteed non-NULL. Move the clip_devs check after the !skb handling and after the atm_return() call that depends on a valid skb, ensuring no dereference occurs on a NULL pointer.

2) Key Code Changes:
- Removed the early block:
  if (!clip_devs) {
      atm_return(vcc, skb->truesize);
      kfree_skb(skb);
      return;
  }
- Ensured the existing !skb branch executes first, returning early when skb is NULL.
- After atm_return(vcc, skb->truesize) (now only reachable with non-NULL skb), added:
  if (!clip_devs) {
      kfree_skb(skb);
      return;
  }
This guarantees that skb->truesize is never read when skb is NULL and that skb is freed safely if no device is present.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch strictly modifies control flow and validation ordering. It eliminates the unsafe dereference without altering synchronization primitives or ordering guarantees.

6. Broader Kernel Security Implications
Pointer validation and correct ordering in teardown/error paths are critical to prevent kernel crashes. Even internal calls (e.g., from vcc_destroy_socket()) can surface vulnerabilities when global pointers (clip_devs) and inputs (skb) are simultaneously NULL. Ensuring consistent NULL checks before dereferences reduces the risk of denial-of-service conditions across networking subsystems, especially in device-less or shutdown scenarios.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.