You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58067

[INFO]
[PATCH_DESCRIPTION]
 clk: mmp: pxa1908-mpmu: Fix a NULL vs IS_ERR() check
 The devm_kzalloc() function returns NULL on error, not error pointers.
 Update the check to match.
 
 Fixes: ebac87cdd230 ("clk: mmp: Add Marvell PXA1908 MPMU driver")

[PATCH_DIFF]
 diff --git a/drivers/clk/mmp/clk-pxa1908-mpmu.c b/drivers/clk/mmp/clk-pxa1908-mpmu.c
 index e3337bacaadd5a…90b4b248857406 100644
 — a/drivers/clk/mmp/clk-pxa1908-mpmu.c
 +++ b/drivers/clk/mmp/clk-pxa1908-mpmu.c
 @@ -78,8 +78,8 @@ static int pxa1908_mpmu_probe(struct platform_device *pdev)
 struct pxa1908_clk_unit *pxa_unit;

 pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
 - if (IS_ERR(pxa_unit))
 - return PTR_ERR(pxa_unit);
 + if (!pxa_unit)
 + return -ENOMEM;

 pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
 if (IS_ERR(pxa_unit->base))

[FUNCTION_CONTENT]
static int pxa1908_mpmu_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, MPMU_NR_CLKS);

	pxa1908_pll_init(pxa_unit);

	return 0;
}

/* ----- separator ----- */

					ARRAY_SIZE(fixed_rate_clks));

	mmp_register_fixed_factor_clks(unit, fixed_factor_clks,
					ARRAY_SIZE(fixed_factor_clks));

	mmp_clk_register_factor("uart_pll", "pll1_d4",
			CLK_SET_RATE_PARENT,
			pxa_unit->base + MPMU_UART_PLL,
			&uart_factor_masks, uart_factor_tbl,
			ARRAY_SIZE(uart_factor_tbl), NULL);
}

static int pxa1908_mpmu_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, MPMU_NR_CLKS);

	pxa1908_pll_init(pxa_unit);

	return 0;
}

/* ----- separator ----- */

					ARRAY_SIZE(fixed_factor_clks));

	mmp_clk_register_factor("uart_pll", "pll1_d4",
			CLK_SET_RATE_PARENT,
			pxa_unit->base + MPMU_UART_PLL,
			&uart_factor_masks, uart_factor_tbl,
			ARRAY_SIZE(uart_factor_tbl), NULL);
}

static int pxa1908_mpmu_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, MPMU_NR_CLKS);

	pxa1908_pll_init(pxa_unit);

	return 0;
}

/* ----- separator ----- */

			ARRAY_SIZE(uart_factor_tbl), NULL);
}

static int pxa1908_mpmu_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, MPMU_NR_CLKS);

	pxa1908_pll_init(pxa_unit);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58067

2. Vulnerability Type
NULL pointer dereference due to incorrect error handling (NULL vs ERR_PTR misuse)

3. Root Cause Summary
The probe routine pxa1908_mpmu_probe() incorrectly checked the result of devm_kzalloc() with IS_ERR() and propagated PTR_ERR(), despite devm_kzalloc() returning NULL on failure. As a result, a failed allocation (pxa_unit == NULL) was treated as success, leading to immediate dereference of a NULL pointer (pxa_unit->base) and a kernel crash. The patch replaces the erroneous IS_ERR/PTR_ERR handling with a NULL check and returns -ENOMEM, aligning with the allocator’s contract.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Marvell MMP clock driver (drivers/clk/mmp), specifically the PXA1908 MPMU driver.

2) Pre-Patch Flaw:
In pxa1908_mpmu_probe(), the code used:
- "if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);" after devm_kzalloc().
Since devm_kzalloc() returns NULL on failure (not ERR_PTR), NULL was not recognized as an error.

3) Trigger Condition:
devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL) fails and returns NULL (e.g., under memory pressure or allocation constraints).

4) Impact Mechanism:
The subsequent dereference of pxa_unit (e.g., "pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);") operates on a NULL pointer, causing a kernel NULL pointer dereference and denial of service during device probe.

5. Patch Analysis
1) Fix Approach:
Correct the error-handling contract by changing the post-allocation check to test for NULL and return -ENOMEM, eliminating the NULL dereference path.

2) Key Code Changes:
- Replaced:
  - "if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);"
- With:
  - "if (!pxa_unit) return -ENOMEM;"
This aligns the check with devm_kzalloc() semantics. No other functional changes were made; existing IS_ERR checks for devm_platform_ioremap_resource() remain valid.

3) Locking/Concurrency Impact:
None. The issue is purely error-path validation; no locking, ordering, or concurrency primitives were involved or modified.

6. Broader Kernel Security Implications
Misusing IS_ERR() for allocators that return NULL is a common pattern leading to unchecked NULL dereferences in probe paths across drivers. Such mistakes can cause reliable kernel crashes during device initialization, resulting in denial of service and system instability, especially under low-memory conditions. Ensuring consistent use of NULL checks for memory allocators and reserving IS_ERR/PTR_ERR for ERR_PTR-returning APIs is critical for kernel robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.