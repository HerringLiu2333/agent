You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38281

[INFO]
[PATCH_DESCRIPTION]
    wifi: mt76: mt7996: Add NULL check in mt7996_thermal_init
    devm_kasprintf() can return a NULL pointer on failure,but this
    returned value in mt7996_thermal_init() is not checked.
    Add NULL check in mt7996_thermal_init(), to handle kernel NULL
    pointer dereference error.

[PATCH_DIFF]
    @@ -217,6 +217,9 @@ static int mt7996_thermal_init(struct mt7996_phy *phy)
     
     	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
     			      wiphy_name(wiphy), phy->mt76->band_idx);
    +	if (!name)
    +		return -ENOMEM;
    +
     	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);
     
     	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);

[FUNCTION_CONTENT]
static int mt7996_thermal_init(struct mt7996_phy *phy)
{
	struct wiphy *wiphy = phy->mt76->hw->wiphy;
	char cname[sizeof("cooling_deviceXXX")];
	struct thermal_cooling_device *cdev;
	struct device *hwmon;
	const char *name;

	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
			      wiphy_name(wiphy), phy->mt76->band_idx);
	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);

	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);
	if (!IS_ERR(cdev)) {
		if (sysfs_create_link(&wiphy->dev.kobj, &cdev->device.kobj,
				      cname) < 0)
			thermal_cooling_device_unregister(cdev);
		else
			phy->cdev = cdev;
	}

	/* initialize critical/maximum high temperature */
	phy->throttle_temp[MT7996_CRIT_TEMP_IDX] = MT7996_CRIT_TEMP;
	phy->throttle_temp[MT7996_MAX_TEMP_IDX] = MT7996_MAX_TEMP;

	if (!IS_REACHABLE(CONFIG_HWMON))
		return 0;

	hwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,
						       mt7996_hwmon_groups);

	if (IS_ERR(hwmon))
		return PTR_ERR(hwmon);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38281

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (Denial of Service)

3. Root Cause Summary
The function mt7996_thermal_init() fails to validate the return value of devm_kasprintf() when constructing the device name. On allocation failure, devm_kasprintf() returns NULL, but the code immediately uses this NULL pointer as the name argument for thermal_cooling_device_register() and devm_hwmon_device_register_with_groups(), resulting in a kernel NULL pointer dereference. The patch adds a NULL check and returns -ENOMEM early, preventing subsequent unsafe use.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
wifi: mt76 mt7996 driver thermal/hwmon initialization

2) Pre-Patch Flaw:
In mt7996_thermal_init(), the code assigns “name = devm_kasprintf(...);” and then uses name without checking for NULL in thermal_cooling_device_register(name, ...) and devm_hwmon_device_register_with_groups(&wiphy->dev, name, ...).

3) Trigger Condition:
devm_kasprintf(&wiphy->dev, GFP_KERNEL, ...) fails under memory pressure and returns NULL during mt7996 PHY thermal initialization.

4) Impact Mechanism:
A NULL name pointer is passed into kernel registration functions that expect a valid string, leading to a NULL pointer dereference in those functions or subsequent sysfs/kobject operations, causing a kernel oops and denial of service.

5. Patch Analysis
1) Fix Approach:
Defensive programming: add a NULL check immediately after devm_kasprintf() and abort initialization with -ENOMEM if the allocation fails.

2) Key Code Changes:
Inserted:
“if (!name)
    return -ENOMEM;”
right after:
“name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d", wiphy_name(wiphy), phy->mt76->band_idx);”

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch only adds input validation and early return, leaving synchronization behavior unchanged.

6. Broader Kernel Security Implications
Properly handling allocation failures in driver init paths prevents kernel crashes induced by memory pressure, reducing attack surface for denial-of-service via resource exhaustion. This change reinforces a general pattern to validate devm_* allocations and formatted strings before use, especially for names passed into kobject/sysfs and registration APIs. Auditing similar paths across the mt76 subsystem and other drivers can further harden the kernel against NULL dereference bugs.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.