You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38281

[INFO]
[PATCH_DESCRIPTION]
    wifi: mt76: mt7996: Add NULL check in mt7996_thermal_init
    devm_kasprintf() can return a NULL pointer on failure,but this
    returned value in mt7996_thermal_init() is not checked.
    Add NULL check in mt7996_thermal_init(), to handle kernel NULL
    pointer dereference error.

[PATCH_DIFF]
    @@ -217,6 +217,9 @@ static int mt7996_thermal_init(struct mt7996_phy *phy)
     
     	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
     			      wiphy_name(wiphy), phy->mt76->band_idx);
    +	if (!name)
    +		return -ENOMEM;
    +
     	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);
     
     	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38281

2. Vulnerability Type
NULL pointer dereference due to missing allocation-failure check

3. Root Cause Summary
mt7996_thermal_init() failed to validate the return value of devm_kasprintf() before using it as the device name for thermal_cooling_device_register(). When devm_kasprintf() returned NULL on allocation failure, the subsequent use of this NULL pointer led to a kernel NULL pointer dereference during thermal cooling device registration.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
MediaTek mt76 Wi-Fi driver (mt7996) thermal management initialization

2) Pre-Patch Flaw:
The function assigned:
- name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d", wiphy_name(wiphy), phy->mt76->band_idx);
and did not check if name was NULL before proceeding to register the thermal cooling device, thereby passing a NULL name to thermal_cooling_device_register().

3) Trigger Condition:
devm_kasprintf() fails and returns NULL (e.g., under memory pressure) during mt7996_thermal_init() execution.

4) Impact Mechanism:
Passing a NULL pointer as the device name into thermal_cooling_device_register() triggers a kernel NULL pointer dereference inside the thermal registration path, causing a kernel crash (DoS).

5. Patch Analysis
1) Fix Approach:
Defensive programming: add a NULL check after devm_kasprintf() and abort initialization with -ENOMEM if allocation failed, preventing use of a NULL pointer.

2) Key Code Changes:
- Inserted:
  if (!name)
      return -ENOMEM;
immediately after the devm_kasprintf() call in mt7996_thermal_init().

3) Locking/Concurrency Impact:
None. The change only adds an early error return on allocation failure; no locks or ordering were modified.

6. Broader Kernel Security Implications
Unchecked allocation failures in driver init paths can convert recoverable OOM conditions into kernel crashes. This fix improves robustness against memory pressure and exemplifies a common hardening pattern needed across drivers: validate all devm_* and k*alloc* returns before use. System stability and reliability are enhanced, reducing potential for unprivileged DoS via triggerable device initialization under low-memory conditions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.