You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58066

[INFO]
[PATCH_DESCRIPTION]
 clk: mmp: pxa1908-apbcp: Fix a NULL vs IS_ERR() check
 The devm_kzalloc() function doesn't return error pointers, it returns
 NULL on error.  Update the check to match.
 
 Fixes: a89233dbd4df ("clk: mmp: Add Marvell PXA1908 APBCP driver")

[PATCH_DIFF]
 diff --git a/drivers/clk/mmp/clk-pxa1908-apbcp.c b/drivers/clk/mmp/clk-pxa1908-apbcp.c
 index 08f3845cbb1bec…f638d7e89b472f 100644
 --- a/drivers/clk/mmp/clk-pxa1908-apbcp.c
 +++ b/drivers/clk/mmp/clk-pxa1908-apbcp.c
 @@ -48,8 +48,8 @@ static int pxa1908_apbcp_probe(struct platform_device *pdev)
 struct pxa1908_clk_unit *pxa_unit;

   pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
 - if (IS_ERR(pxa_unit))
 - return PTR_ERR(pxa_unit);
 + if (!pxa_unit)
 + return -ENOMEM;

   pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
   if (IS_ERR(pxa_unit->base))

[FUNCTION_CONTENT]
static int pxa1908_apbcp_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, APBCP_NR_CLKS);

	pxa1908_apb_p_periph_clk_init(pxa_unit);

	return 0;
}

/* ----- separator ----- */

			ARRAY_SIZE(apbcp_mux_clks));
	mmp_register_gate_clks(unit, apbcp_gate_clks, pxa_unit->base,
			ARRAY_SIZE(apbcp_gate_clks));
}

static int pxa1908_apbcp_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, APBCP_NR_CLKS);

	pxa1908_apb_p_periph_clk_init(pxa_unit);

	return 0;
}

/* ----- separator ----- */

			ARRAY_SIZE(apbcp_gate_clks));
}

static int pxa1908_apbcp_probe(struct platform_device *pdev)
{
	struct pxa1908_clk_unit *pxa_unit;

	pxa_unit = devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL);
	if (IS_ERR(pxa_unit))
		return PTR_ERR(pxa_unit);

	pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
	if (IS_ERR(pxa_unit->base))
		return PTR_ERR(pxa_unit->base);

	mmp_clk_init(pdev->dev.of_node, &pxa_unit->unit, APBCP_NR_CLKS);

	pxa1908_apb_p_periph_clk_init(pxa_unit);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58066

2. Vulnerability Type
NULL pointer dereference due to incorrect error handling (API misuse)

3. Root Cause Summary
The probe function pxa1908_apbcp_probe() incorrectly used IS_ERR()/PTR_ERR() to check the result of devm_kzalloc(), which returns NULL on failure, not error pointers. As a result, a NULL allocation was not detected and the code proceeded to dereference pxa_unit, causing a NULL pointer dereference. The patch corrects this by checking for NULL and returning -ENOMEM.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Clock framework (drivers/clk), Marvell MMP/PXA1908 APBCP clock driver

2) Pre-Patch Flaw:
In drivers/clk/mmp/clk-pxa1908-apbcp.c, pxa1908_apbcp_probe() used:
- if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);
after devm_kzalloc(), which should be checked against NULL, not IS_ERR().

3) Trigger Condition:
devm_kzalloc(&pdev->dev, sizeof(*pxa_unit), GFP_KERNEL) returns NULL (e.g., under memory pressure) during device probe.

4) Impact Mechanism:
With pxa_unit == NULL and the erroneous IS_ERR() check passing, the subsequent dereference:
- pxa_unit->base = devm_platform_ioremap_resource(pdev, 0);
dereferences a NULL pointer, leading to a kernel crash (denial of service) during driver probing.

5. Patch Analysis
1) Fix Approach:
Correct the allocation failure check to match the allocator’s contract by testing for NULL and returning a proper error code (-ENOMEM).

2) Key Code Changes:
- Replaced:
  if (IS_ERR(pxa_unit)) return PTR_ERR(pxa_unit);
  with:
  if (!pxa_unit) return -ENOMEM;
This ensures allocation failure is detected before any dereference of pxa_unit.

3) Locking/Concurrency Impact:
None. The change is purely in error handling logic for memory allocation in the probe path; no locking or ordering semantics are involved.

6. Broader Kernel Security Implications
- API contract mismatches (checking IS_ERR() for functions that return NULL) are a recurring class of bugs in drivers and can lead to system instability/DoS. This fix underscores the need for consistent error-checking patterns and static analysis/audits for allocator return handling across drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}