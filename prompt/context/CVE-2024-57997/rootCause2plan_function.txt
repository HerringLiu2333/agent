You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57997

[INFO]
[PATCH_DESCRIPTION]
 wifi: wcn36xx: fix channel survey memory allocation size
 [ Upstream commit 6200d947f050efdba4090dfefd8a01981363d954 ]
 
 KASAN reported a memory allocation issue in wcn->chan_survey
 due to incorrect size calculation.
 This commit uses kcalloc to allocate memory for wcn->chan_survey,
 ensuring proper initialization and preventing the use of uninitialized
 values when there are no frames on the channel.

 Fixes: 29696e0aa413 ("wcn36xx: Track SNR and RSSI for each RX frame")

[PATCH_DIFF]
 diff --git a/drivers/net/wireless/ath/wcn36xx/main.c b/drivers/net/wireless/ath/wcn36xx/main.c
 index 2bd1163177f08f…9bbbc86fd2d93d 100644
 --- a/drivers/net/wireless/ath/wcn36xx/main.c
 +++ b/drivers/net/wireless/ath/wcn36xx/main.c
 @@ -1586,7 +1586,10 @@ static int wcn36xx_probe(struct platform_device *pdev)
 }

   n_channels = wcn_band_2ghz.n_channels + wcn_band_5ghz.n_channels;
 - wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);
 + wcn->chan_survey = devm_kcalloc(wcn->dev,
 + n_channels,
 + sizeof(struct wcn36xx_chan_survey),
 + GFP_KERNEL);
   if (!wcn->chan_survey) {
   ret = -ENOMEM;
   goto out_wq;

[FUNCTION_CONTENT]
static int wcn36xx_probe(struct platform_device *pdev)
{
	struct ieee80211_hw *hw;
	struct wcn36xx *wcn;
	void *wcnss;
	int ret;
	const u8 *addr;
	int n_channels;

	wcn36xx_dbg(WCN36XX_DBG_MAC, "platform probe\n");

	wcnss = dev_get_drvdata(pdev->dev.parent);

	hw = ieee80211_alloc_hw(sizeof(struct wcn36xx), &wcn36xx_ops);
	if (!hw) {
		wcn36xx_err("failed to alloc hw\n");
		ret = -ENOMEM;
		goto out_err;
	}
	platform_set_drvdata(pdev, hw);
	wcn = hw->priv;
	wcn->hw = hw;
	wcn->dev = &pdev->dev;
	wcn->first_boot = true;
	mutex_init(&wcn->conf_mutex);
	mutex_init(&wcn->hal_mutex);
	mutex_init(&wcn->scan_lock);
	__skb_queue_head_init(&wcn->amsdu);

	wcn->hal_buf = devm_kmalloc(wcn->dev, WCN36XX_HAL_BUF_SIZE, GFP_KERNEL);
	if (!wcn->hal_buf) {
		ret = -ENOMEM;
		goto out_wq;
	}

	n_channels = wcn_band_2ghz.n_channels + wcn_band_5ghz.n_channels;
	wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);
	if (!wcn->chan_survey) {
		ret = -ENOMEM;
		goto out_wq;
	}

	ret = dma_set_mask_and_coherent(wcn->dev, DMA_BIT_MASK(32));
	if (ret < 0) {
		wcn36xx_err("failed to set DMA mask: %d\n", ret);
		goto out_wq;
	}

	wcn->nv_file = WLAN_NV_FILE;
	ret = of_property_read_string(wcn->dev->parent->of_node, "firmware-name", &wcn->nv_file);
	if (ret < 0 && ret != -EINVAL) {
		wcn36xx_err("failed to read \"firmware-name\" property: %d\n", ret);
		goto out_wq;
	}

	wcn->smd_channel = qcom_wcnss_open_channel(wcnss, "WLAN_CTRL", wcn36xx_smd_rsp_process, hw);
	if (IS_ERR(wcn->smd_channel)) {
		wcn36xx_err("failed to open WLAN_CTRL channel\n");
		ret = PTR_ERR(wcn->smd_channel);
		goto out_wq;
	}

	addr = of_get_property(pdev->dev.of_node, "local-mac-address", &ret);
	if (addr && ret != ETH_ALEN) {
		wcn36xx_err("invalid local-mac-address\n");
		ret = -EINVAL;
		goto out_destroy_ept;
	} else if (addr) {
		wcn36xx_info("mac address: %pM\n", addr);
		SET_IEEE80211_PERM_ADDR(wcn->hw, addr);
	}

	ret = wcn36xx_platform_get_resources(wcn, pdev);
	if (ret)
		goto out_destroy_ept;

	wcn36xx_init_ieee80211(wcn);
	ret = ieee80211_register_hw(wcn->hw);
	if (ret)
		goto out_unmap;

	return 0;

out_unmap:
	iounmap(wcn->ccu_base);
	iounmap(wcn->dxe_base);
out_destroy_ept:
	rpmsg_destroy_ept(wcn->smd_channel);
out_wq:
	ieee80211_free_hw(hw);
out_err:
	return ret;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57997

2. Vulnerability Type
Heap buffer overflow (under-allocation) with potential uninitialized memory use

3. Root Cause Summary
The driver allocated wcn->chan_survey with devm_kmalloc using only the number of channels (n_channels) as the size, instead of n_channels multiplied by sizeof(struct wcn36xx_chan_survey). This miscalculation under-allocates the array and leaves its contents uninitialized. Subsequent per-channel survey updates (tracking SNR/RSSI per RX frame) write into struct fields, causing out-of-bounds writes beyond the allocated buffer and/or reading uninitialized values when no frames have been observed.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm wcn36xx WiFi driver (drivers/net/wireless/ath/wcn36xx), function wcn36xx_probe

2) Pre-Patch Flaw:
In wcn36xx_probe, the array allocation was: “wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);” which allocates only n_channels bytes. The code intended an array of struct wcn36xx_chan_survey of length n_channels, but failed to multiply by the element size and did not zero-initialize the array.

3) Trigger Condition:
When the driver initializes or updates channel survey data per channel (as introduced by “wcn36xx: Track SNR and RSSI for each RX frame”), any access to wcn->chan_survey[i] writes/reads struct fields, immediately exceeding the allocated size if sizeof(struct wcn36xx_chan_survey) > 1. Additionally, reading survey contents without prior frames leads to use of uninitialized memory.

4) Impact Mechanism:
- Out-of-bounds writes on the heap (slab) corrupt adjacent kernel memory, detected by KASAN. 
- Uninitialized reads can propagate bogus measurements and potentially leak stack/slab contents through telemetry or cause undefined behavior. 
- Memory corruption risks include crashes, data corruption, or further exploitable conditions in the kernel.

5. Patch Analysis
1) Fix Approach:
Replace the incorrect kmalloc with kcalloc to correctly allocate n_channels elements of struct wcn36xx_chan_survey and zero-initialize them, eliminating both under-allocation and uninitialized use.

2) Key Code Changes:
- Pre-patch: “wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);”
- Post-patch: “wcn->chan_survey = devm_kcalloc(wcn->dev, n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL);”
This change fixes size computation (count × element size) and ensures initial zero state.

3) Locking/Concurrency Impact:
None. The change is confined to allocation semantics in probe; it does not alter locking, ordering, or concurrency behavior.

6. Broader Kernel Security Implications
Size miscalculations in array allocations are a common and severe class of bugs in kernel drivers, leading to heap overflows and memory corruption. Using kcalloc for arrays enforces correct size computation and mitigates uninitialized memory issues, improving robustness. This fix highlights the need for systematic audits of allocation patterns in drivers, especially where per-object arrays are indexed by runtime counts (e.g., channels, queues, stations).

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.