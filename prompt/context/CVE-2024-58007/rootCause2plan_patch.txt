You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58007

[INFO]
[PATCH_DESCRIPTION]
 soc: qcom: socinfo: Avoid out of bounds read of serial number
 commit 22cf4fae6660b6e1a583a41cbf84e3046ca9ccd0 upstream.
 
 On MSM8916 devices, the serial number exposed in sysfs is constant and does
 not change across individual devices. It's always:
 
   db410c:/sys/devices/soc0$ cat serial_number
   2644893864
 
 The firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not
 have support for the serial_num field in the socinfo struct. There is an
 existing check to avoid exposing the serial number in that case, but it's
 not correct: When checking the item_size returned by SMEM, we need to make
 sure the *end* of the serial_num is within bounds, instead of comparing
 with the *start* offset. The serial_number currently exposed on MSM8916
 devices is just an out of bounds read of whatever comes after the socinfo
 struct in SMEM.
 
 Fix this by changing offsetof() to offsetofend(), so that the size of the
 field is also taken into account.

 Cc: stable@vger.kernel.org
 Fixes: efb448d0a3fc ("soc: qcom: Add socinfo driver")

[PATCH_DIFF]
 diff --git a/drivers/soc/qcom/socinfo.c b/drivers/soc/qcom/socinfo.c
 index 5401b075840b8e…e5f14202618829 100644
 --- a/drivers/soc/qcom/socinfo.c
 +++ b/drivers/soc/qcom/socinfo.c
 @@ -652,7 +652,7 @@ static int qcom_socinfo_probe(struct platform_device *pdev)
   if (!qs->attr.soc_id || !qs->attr.revision)
   return -ENOMEM;

 - if (offsetof(struct socinfo, serial_num) <= item_size) {
 + if (offsetofend(struct socinfo, serial_num) <= item_size) {
   qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
   "%u",
   le32_to_cpu(info->serial_num));



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58007

2. Vulnerability Type
Out-of-bounds read leading to information disclosure via sysfs

3. Root Cause Summary
The driver’s bounds check only verified that the start offset of the serial_num field was within the SMEM item size, not that the entire field (including its size) was contained. Specifically, it used “offsetof(struct socinfo, serial_num) <= item_size” instead of checking the end of the field. On platforms where the socinfo version does not include serial_num (e.g., SOCINFO_VERSION(0, 8)), this erroneous check allowed reading beyond the socinfo SMEM item, causing an out-of-bounds read and exposing whatever data followed as a fake serial number.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm SoC information driver (drivers/soc/qcom/socinfo.c), function qcom_socinfo_probe

2) Pre-Patch Flaw:
In qcom_socinfo_probe, the code gated exposure of serial_number using “if (offsetof(struct socinfo, serial_num) <= item_size)”, which only ensured the field’s start offset was within bounds. It then read “info->serial_num” and exposed it through sysfs, even on socinfo versions where serial_num is not present, leading to an out-of-bounds read from the mapped SMEM region.

3) Trigger Condition:
Devices with SMEM-provided socinfo structures that lack the serial_num field (e.g., MSM8916 with SOCINFO_VERSION(0, 8)), where item_size is at least the start offset of serial_num but smaller than the end of the field. When qcom_socinfo_probe executes, the incorrect check passes and the code reads info->serial_num despite the field not being valid.

4) Impact Mechanism:
Out-of-bounds read from the SMEM item backing socinfo, returning data from beyond the struct boundary. The read value is formatted and published to userspace via the sysfs “serial_number” attribute, causing information disclosure of adjacent SMEM contents.

5. Patch Analysis
1) Fix Approach:
Strengthened the bounds check to ensure the entire serial_num field lies within the SMEM item, by replacing offsetof() with offsetofend().

2) Key Code Changes:
In qcom_socinfo_probe:
- Changed:
  “if (offsetof(struct socinfo, serial_num) <= item_size) {”
  to:
  “if (offsetofend(struct socinfo, serial_num) <= item_size) {”
This ensures the end of the serial_num field is within item_size before accessing info->serial_num.

3) Locking/Concurrency Impact:
None. The patch only adjusts a bounds check; no locking, RCU, or ordering changes are involved.

6. Broader Kernel Security Implications
This fix prevents unintended leakage of data from shared memory regions to userspace, reinforcing strict structure-version-aware bounds validation. It highlights the importance of validating the full extent of fields sourced from firmware-defined structures to avoid OOB reads. Applying similar end-of-field checks across drivers interfacing with variable-format firmware data reduces the risk of info leaks and memory safety violations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.