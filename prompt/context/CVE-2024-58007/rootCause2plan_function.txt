You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58007

[INFO]
[PATCH_DESCRIPTION]
 soc: qcom: socinfo: Avoid out of bounds read of serial number
 commit 22cf4fae6660b6e1a583a41cbf84e3046ca9ccd0 upstream.
 
 On MSM8916 devices, the serial number exposed in sysfs is constant and does
 not change across individual devices. It's always:
 
   db410c:/sys/devices/soc0$ cat serial_number
   2644893864
 
 The firmware used on MSM8916 exposes SOCINFO_VERSION(0, 8), which does not
 have support for the serial_num field in the socinfo struct. There is an
 existing check to avoid exposing the serial number in that case, but it's
 not correct: When checking the item_size returned by SMEM, we need to make
 sure the *end* of the serial_num is within bounds, instead of comparing
 with the *start* offset. The serial_number currently exposed on MSM8916
 devices is just an out of bounds read of whatever comes after the socinfo
 struct in SMEM.
 
 Fix this by changing offsetof() to offsetofend(), so that the size of the
 field is also taken into account.

 Cc: stable@vger.kernel.org
 Fixes: efb448d0a3fc ("soc: qcom: Add socinfo driver")

[PATCH_DIFF]
 diff --git a/drivers/soc/qcom/socinfo.c b/drivers/soc/qcom/socinfo.c
 index 5401b075840b8e…e5f14202618829 100644
 --- a/drivers/soc/qcom/socinfo.c
 +++ b/drivers/soc/qcom/socinfo.c
 @@ -652,7 +652,7 @@ static int qcom_socinfo_probe(struct platform_device *pdev)
   if (!qs->attr.soc_id || !qs->attr.revision)
   return -ENOMEM;

 - if (offsetof(struct socinfo, serial_num) <= item_size) {
 + if (offsetofend(struct socinfo, serial_num) <= item_size) {
   qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
   "%u",
   le32_to_cpu(info->serial_num));

[FUNCTION_CONTENT]
static int qcom_socinfo_probe(struct platform_device *pdev)
{
	struct qcom_socinfo *qs;
	struct socinfo *info;
	size_t item_size;

	info = qcom_smem_get(QCOM_SMEM_HOST_ANY, SMEM_HW_SW_BUILD_ID,
			      &item_size);
	if (IS_ERR(info)) {
		dev_err(&pdev->dev, "Couldn't find socinfo\n");
		return PTR_ERR(info);
	}

	qs = devm_kzalloc(&pdev->dev, sizeof(*qs), GFP_KERNEL);
	if (!qs)
		return -ENOMEM;

	qs->attr.family = "Snapdragon";
	qs->attr.machine = socinfo_machine(&pdev->dev,
					   le32_to_cpu(info->id));
	qs->attr.soc_id = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%u",
					 le32_to_cpu(info->id));
	qs->attr.revision = devm_kasprintf(&pdev->dev, GFP_KERNEL, "%u.%u",
					   SOCINFO_MAJOR(le32_to_cpu(info->ver)),
					   SOCINFO_MINOR(le32_to_cpu(info->ver)));
	if (!qs->attr.soc_id || !qs->attr.revision)
		return -ENOMEM;

	if (offsetof(struct socinfo, serial_num) <= item_size) {
		qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
							"%u",
							le32_to_cpu(info->serial_num));
		if (!qs->attr.serial_number)
			return -ENOMEM;
	}

	qs->soc_dev = soc_device_register(&qs->attr);
	if (IS_ERR(qs->soc_dev))
		return PTR_ERR(qs->soc_dev);

	socinfo_debugfs_init(qs, info, item_size);

	/* Feed the soc specific unique data into entropy pool */
	add_device_randomness(info, item_size);

	platform_set_drvdata(pdev, qs);

	return 0;
}

/* ----- separator ----- */

					   SOCINFO_MAJOR(le32_to_cpu(info->ver)),
					   SOCINFO_MINOR(le32_to_cpu(info->ver)));
	if (!qs->attr.soc_id || !qs->attr.revision)
		return -ENOMEM;

	if (offsetof(struct socinfo, serial_num) <= item_size) {
		qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
							"%u",
							le32_to_cpu(info->serial_num));
		if (!qs->attr.serial_number)
			return -ENOMEM;
	}

/* ----- separator ----- */

					   SOCINFO_MINOR(le32_to_cpu(info->ver)));
	if (!qs->attr.soc_id || !qs->attr.revision)
		return -ENOMEM;

	if (offsetof(struct socinfo, serial_num) <= item_size) {
		qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
							"%u",
							le32_to_cpu(info->serial_num));
		if (!qs->attr.serial_number)
			return -ENOMEM;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58007

2. Vulnerability Type
Out-of-bounds read due to improper bounds check, resulting in information disclosure via sysfs.

3. Root Cause Summary
The pre-patch logic in qcom_socinfo_probe validated only the start offset of the serial_num field against the SMEM-provided item_size using “if (offsetof(struct socinfo, serial_num) <= item_size)”. This allowed a read starting exactly at the end of the buffer or when the field did not exist in older SOCINFO versions, causing the subsequent 4-byte read to go past item_size. The missing validation of the field’s full extent (end offset) led to reading beyond the available socinfo structure, pulling arbitrary data from SMEM and exposing it as a serial number in sysfs.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Qualcomm SoC information driver (drivers/soc/qcom/socinfo.c).

2) Pre-Patch Flaw:
In qcom_socinfo_probe, the bounds check used offsetof(struct socinfo, serial_num) ≤ item_size, which only ensures the field’s start lies within the buffer and ignores the field’s size. This is incorrect for fixed-size fields (u32 serial_num) and versioned structures where the field may not exist, enabling a read past the end of the structure.

3) Trigger Condition:
Devices using SOCINFO_VERSION(0, 8) (e.g., MSM8916) where the socinfo struct lacks serial_num and item_size is equal to the offset where newer versions place serial_num or smaller than the field’s end. On driver probe, the code attempts to format info->serial_num for the sysfs serial_number attribute.

4) Impact Mechanism:
le32_to_cpu(info->serial_num) reads 4 bytes beyond the socinfo buffer from SMEM; devm_kasprintf then exposes this value via sysfs as “serial_number”, leaking unintended memory content. The observed constant serial number on MSM8916 devices evidences a deterministic OOB read of adjacent data beyond the socinfo struct.

5. Patch Analysis
1) Fix Approach:
Strengthen the bounds check to validate that the entire serial_num field is contained within item_size by using offsetofend() rather than offsetof().

2) Key Code Changes:
In qcom_socinfo_probe:
- Replace “if (offsetof(struct socinfo, serial_num) <= item_size)” with “if (offsetofend(struct socinfo, serial_num) <= item_size)”, ensuring the end of the serial_num field is within bounds before reading.

3) Locking/Concurrency Impact:
None. The change is a pure bounds check correction executed during device probe; no locking or ordering modifications.

6. Broader Kernel Security Implications
Firmware-defined, versioned data structures must be validated using end-of-field checks to prevent boundary-adjacent OOB reads. Exposing data from shared memory or firmware blobs via sysfs without proper bounds validation can leak kernel/firmware memory and lead to deterministic, device-wide information disclosure. This fix highlights the need for rigorous size/offset verification in drivers parsing SMEM or other external layouts to avoid similar vulnerabilities.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.