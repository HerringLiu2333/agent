You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-39778

[INFO]
[PATCH_DESCRIPTION]
    objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()
    The csts_state_names[] array only has six sparse entries, but the
    iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
    potential out-of-bounds stack read.  Fix that.
    
    Fixes the following warning with an UBSAN kernel:
    
      vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section

[PATCH_DIFF]
    @@ -78,7 +78,7 @@ static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
     	bool sep = false;
     	int i;
     
    -	for (i = 0; i < 7; i++) {
    +	for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {
     		int state = BIT(i);
     
     		if (!(ctrl->csts & state))



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds stack read (array index out of range), potential information disclosure/UBSAN-triggered undefined behavior

3. Root Cause Summary
nvmet_ctrl_state_show() iterated a fixed seven times while indexing into csts_state_names[], which only has six entries. The hard-coded loop bound “i < 7” allowed i == 6, causing a read past the end of the stack-allocated array when the code dereferenced csts_state_names[i].

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet) control state reporting via seq_file

2) Pre-Patch Flaw:
A mismatched loop bound and array length: the function used a constant upper bound (7) instead of the actual length of csts_state_names[], leading to an out-of-bounds access when i reached 6.

3) Trigger Condition:
When the loop index reaches 6 and the code attempts to use csts_state_names[i]; in practice, this dereference is gated by “if (!(ctrl->csts & state)) continue”, so the out-of-bounds read occurs if ctrl->csts includes the BIT(6) state and the code prints the corresponding name.

4) Impact Mechanism:
Reading beyond the end of a stack array can disclose adjacent stack data via seq_file output or trigger undefined behavior; an UBSAN kernel warns and objtool reports “unexpected end of section,” indicating improper code paths due to the OOB access.

5. Patch Analysis
1) Fix Approach:
Replace the hard-coded loop bound with ARRAY_SIZE(csts_state_names) to align iteration with the actual array length and prevent out-of-bounds indexing.

2) Key Code Changes:
- Pre-patch: “for (i = 0; i < 7; i++) {”
- Post-patch: “for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {”
No other logic changes; BIT(i) state computation remains the same.

3) Locking/Concurrency Impact:
None. This is a local bounds fix in a read-only display function; no locking, ordering, or concurrency primitives were added or modified.

6. Broader Kernel Security Implications
Array-bound mistakes in status-reporting paths can still leak kernel stack contents or cause subtle UB, especially when exposed via seq_file/sysfs. Using ARRAY_SIZE eliminates magic constants and future-proofs the iteration against array changes, improving robustness and reducing the risk of information disclosure or diagnostic tool warnings.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.