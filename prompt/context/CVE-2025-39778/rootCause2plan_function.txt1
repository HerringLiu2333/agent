You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-39778

[INFO]
[PATCH_DESCRIPTION]
    objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()
    The csts_state_names[] array only has six sparse entries, but the
    iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
    potential out-of-bounds stack read.  Fix that.
    
    Fixes the following warning with an UBSAN kernel:
    
      vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section

[PATCH_DIFF]
    @@ -78,7 +78,7 @@ static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
     	bool sep = false;
     	int i;
     
    -	for (i = 0; i < 7; i++) {
    +	for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {
     		int state = BIT(i);
     
     		if (!(ctrl->csts & state))

[FUNCTION_CONTENT]
static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;
	bool sep = false;
	int i;

	for (i = 0; i < 7; i++) {
		int state = BIT(i);

		if (!(ctrl->csts & state))
			continue;
		if (sep)
			seq_puts(m, "|");
		sep = true;
		if (csts_state_names[state])
			seq_puts(m, csts_state_names[state]);
		else
			seq_printf(m, "%d", state);
	}
	if (sep)
		seq_printf(m, "\n");
	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds read (array index based on bitmask exceeding array bounds)

3. Root Cause Summary
nvmet_ctrl_state_show() iterated a hardcoded 7 states and indexed csts_state_names by BIT(i). The csts_state_names[] array only defined six sparse entries with the highest designated index at BIT(5) (i.e., 32), making the array size 33. When i reached 6 (BIT(6) == 64), the code accessed csts_state_names[64], an out-of-bounds read. The patch replaces the hardcoded loop bound with ARRAY_SIZE(csts_state_names), aligning iteration with the actual array capacity.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet), seq_file show function for controller state

2) Pre-Patch Flaw:
- In nvmet_ctrl_state_show(), the loop used a fixed bound: for (i = 0; i < 7; i++) and indexed csts_state_names[BIT(i)].
- csts_state_names[] has sparse designated initializers up to BIT(5), making the valid index range smaller than 64; thus BIT(6) produced an out-of-bounds index.

3) Trigger Condition:
- When ctrl->csts has bit 6 set (ctrl->csts & BIT(6)), the code reaches csts_state_names[BIT(6)] and reads beyond the array.
- Even without dereferencing a string, the pointer fetch for the NULL check itself is an out-of-bounds read.

4) Impact Mechanism:
- Out-of-bounds read from the csts_state_names pointer array (described as “stack” in the patch note), potentially leading to:
  - Undefined behavior, including kernel warnings (observed UBSAN/objtool warning).
  - Possible read of unintended memory and, if non-NULL, unsafe string dereference which may cause further memory disclosure or crash via seq_file output.

5. Patch Analysis
1) Fix Approach:
- Replace the hardcoded iteration bound with ARRAY_SIZE(csts_state_names) to ensure indices derived from BIT(i) do not exceed the array bounds.

2) Key Code Changes:
- Pre-patch: for (i = 0; i < 7; i++) { int state = BIT(i); ... if (csts_state_names[state]) ... }
- Post-patch: for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) { int state = BIT(i); ... }
- This directly prevents the out-of-bounds access at index 64 by limiting i to produce only valid indices for csts_state_names[].

3) Locking/Concurrency Impact:
- None. The change is a bounds correction in a read-only show path; no locking semantics or ordering were modified.

6. Broader Kernel Security Implications
- Demonstrates the risk of hardcoded loop bounds with sparse, designated-initializer arrays indexed by BIT(i): the highest designated index dictates the true array size, not the number of conceptual “states.”
- Encourages consistent use of ARRAY_SIZE (or static assertions) when iterating arrays and careful alignment between bitmask-derived indices and array dimensions to avoid OOB accesses.
- Similar patterns in other seq_file or debugfs/configfs show functions should be audited for BIT()-indexed arrays with sparse initializers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}