You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-39778

[INFO]
[PATCH_DESCRIPTION]
    objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()
    The csts_state_names[] array only has six sparse entries, but the
    iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
    potential out-of-bounds stack read.  Fix that.
    
    Fixes the following warning with an UBSAN kernel:
    
      vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section

[PATCH_DIFF]
    @@ -78,7 +78,7 @@ static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
     	bool sep = false;
     	int i;
     
    -	for (i = 0; i < 7; i++) {
    +	for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {
     		int state = BIT(i);
     
     		if (!(ctrl->csts & state))



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds stack read (array index out of range), potential information disclosure/UBSAN-triggered undefined behavior

3. Root Cause Summary
nvmet_ctrl_state_show() iterated a fixed seven times while indexing into csts_state_names[], which only has six entries. The hard-coded loop bound “i < 7” allowed i == 6, causing a read past the end of the stack-allocated array when the code dereferenced csts_state_names[i].

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet) control state reporting via seq_file

2) Pre-Patch Flaw:
A mismatched loop bound and array length: the function used a constant upper bound (7) instead of the actual length of csts_state_names[], leading to an out-of-bounds access when i reached 6.

3) Trigger Condition:
When the loop index reaches 6 and the code attempts to use csts_state_names[i]; in practice, this dereference is gated by “if (!(ctrl->csts & state)) continue”, so the out-of-bounds read occurs if ctrl->csts includes the BIT(6) state and the code prints the corresponding name.

4) Impact Mechanism:
Reading beyond the end of a stack array can disclose adjacent stack data via seq_file output or trigger undefined behavior; an UBSAN kernel warns and objtool reports “unexpected end of section,” indicating improper code paths due to the OOB access.

5. Patch Analysis
1) Fix Approach:
Replace the hard-coded loop bound with ARRAY_SIZE(csts_state_names) to align iteration with the actual array length and prevent out-of-bounds indexing.

2) Key Code Changes:
- Pre-patch: “for (i = 0; i < 7; i++) {”
- Post-patch: “for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {”
No other logic changes; BIT(i) state computation remains the same.

3) Locking/Concurrency Impact:
None. This is a local bounds fix in a read-only display function; no locking, ordering, or concurrency primitives were added or modified.

6. Broader Kernel Security Implications
Array-bound mistakes in status-reporting paths can still leak kernel stack contents or cause subtle UB, especially when exposed via seq_file/sysfs. Using ARRAY_SIZE eliminates magic constants and future-proofs the iteration against array changes, improving robustness and reducing the risk of information disclosure or diagnostic tool warnings.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}