You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-39778

[INFO]
[PATCH_DESCRIPTION]
    objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()
    The csts_state_names[] array only has six sparse entries, but the
    iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
    potential out-of-bounds stack read.  Fix that.
    
    Fixes the following warning with an UBSAN kernel:
    
      vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section

[PATCH_DIFF]
    @@ -78,7 +78,7 @@ static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
     	bool sep = false;
     	int i;
     
    -	for (i = 0; i < 7; i++) {
    +	for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {
     		int state = BIT(i);
     
     		if (!(ctrl->csts & state))

[FILE_CONTENT]
// SPDX-License-Identifier: GPL-2.0
/*
 * DebugFS interface for the NVMe target.
 * Copyright (c) 2022-2024 Shadow
 * Copyright (c) 2024 SUSE LLC
 */

#include <linux/debugfs.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include "nvmet.h"
#include "debugfs.h"

static struct dentry *nvmet_debugfs;

#define NVMET_DEBUGFS_ATTR(field) \
	static int field##_open(struct inode *inode, struct file *file) \
	{ return single_open(file, field##_show, inode->i_private); } \
	\
	static const struct file_operations field##_fops = { \
		.open = field##_open, \
		.read = seq_read, \
		.release = single_release, \
	}

#define NVMET_DEBUGFS_RW_ATTR(field) \
	static int field##_open(struct inode *inode, struct file *file) \
	{ return single_open(file, field##_show, inode->i_private); } \
	\
	static const struct file_operations field##_fops = { \
		.open = field##_open, \
		.read = seq_read, \
		.write = field##_write, \
		.release = single_release, \
	}

static int nvmet_ctrl_hostnqn_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;

	seq_puts(m, ctrl->hostnqn);
	return 0;
}
NVMET_DEBUGFS_ATTR(nvmet_ctrl_hostnqn);

static int nvmet_ctrl_kato_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;

	seq_printf(m, "%d\n", ctrl->kato);
	return 0;
}
NVMET_DEBUGFS_ATTR(nvmet_ctrl_kato);

static int nvmet_ctrl_port_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;

	seq_printf(m, "%d\n", le16_to_cpu(ctrl->port->disc_addr.portid));
	return 0;
}
NVMET_DEBUGFS_ATTR(nvmet_ctrl_port);

static const char *const csts_state_names[] = {
	[NVME_CSTS_RDY]		= "ready",
	[NVME_CSTS_CFS]		= "fatal",
	[NVME_CSTS_NSSRO]	= "reset",
	[NVME_CSTS_SHST_OCCUR]	= "shutdown",
	[NVME_CSTS_SHST_CMPLT]	= "completed",
	[NVME_CSTS_PP]		= "paused",
};

static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;
	bool sep = false;
	int i;

	for (i = 0; i < 7; i++) {
		int state = BIT(i);

		if (!(ctrl->csts & state))
			continue;
		if (sep)
			seq_puts(m, "|");
		sep = true;
		if (csts_state_names[state])
			seq_puts(m, csts_state_names[state]);
		else
			seq_printf(m, "%d", state);
	}
	if (sep)
		seq_printf(m, "\n");
	return 0;
}

static ssize_t nvmet_ctrl_state_write(struct file *file, const char __user *buf,
				      size_t count, loff_t *ppos)
{
	struct seq_file *m = file->private_data;
	struct nvmet_ctrl *ctrl = m->private;
	char reset[16];

	if (count >= sizeof(reset))
		return -EINVAL;
	if (copy_from_user(reset, buf, count))
		return -EFAULT;
	if (!memcmp(reset, "fatal", 5))
		nvmet_ctrl_fatal_error(ctrl);
	else
		return -EINVAL;
	return count;
}
NVMET_DEBUGFS_RW_ATTR(nvmet_ctrl_state);

static int nvmet_ctrl_host_traddr_show(struct seq_file *m, void *p)
{
	struct nvmet_ctrl *ctrl = m->private;
	ssize_t size;
	char buf[NVMF_TRADDR_SIZE + 1];

	size = nvmet_ctrl_host_traddr(ctrl, buf, NVMF_TRADDR_SIZE);
	if (size < 0) {
		buf[0] = '\0';
		size = 0;
	}
	buf[size] = '\0';
	seq_printf(m, "%s\n", buf);
	return 0;
}
NVMET_DEBUGFS_ATTR(nvmet_ctrl_host_traddr);

int nvmet_debugfs_ctrl_setup(struct nvmet_ctrl *ctrl)
{
	char name[32];
	struct dentry *parent = ctrl->subsys->debugfs_dir;
	int ret;

	if (!parent)
		return -ENODEV;
	snprintf(name, sizeof(name), "ctrl%d", ctrl->cntlid);
	ctrl->debugfs_dir = debugfs_create_dir(name, parent);
	if (IS_ERR(ctrl->debugfs_dir)) {
		ret = PTR_ERR(ctrl->debugfs_dir);
		ctrl->debugfs_dir = NULL;
		return ret;
	}
	debugfs_create_file("port", S_IRUSR, ctrl->debugfs_dir, ctrl,
			    &nvmet_ctrl_port_fops);
	debugfs_create_file("hostnqn", S_IRUSR, ctrl->debugfs_dir, ctrl,
			    &nvmet_ctrl_hostnqn_fops);
	debugfs_create_file("kato", S_IRUSR, ctrl->debugfs_dir, ctrl,
			    &nvmet_ctrl_kato_fops);
	debugfs_create_file("state", S_IRUSR | S_IWUSR, ctrl->debugfs_dir, ctrl,
			    &nvmet_ctrl_state_fops);
	debugfs_create_file("host_traddr", S_IRUSR, ctrl->debugfs_dir, ctrl,
			    &nvmet_ctrl_host_traddr_fops);
	return 0;
}

void nvmet_debugfs_ctrl_free(struct nvmet_ctrl *ctrl)
{
	debugfs_remove_recursive(ctrl->debugfs_dir);
}

int nvmet_debugfs_subsys_setup(struct nvmet_subsys *subsys)
{
	int ret = 0;

	subsys->debugfs_dir = debugfs_create_dir(subsys->subsysnqn,
						 nvmet_debugfs);
	if (IS_ERR(subsys->debugfs_dir)) {
		ret = PTR_ERR(subsys->debugfs_dir);
		subsys->debugfs_dir = NULL;
	}
	return ret;
}

void nvmet_debugfs_subsys_free(struct nvmet_subsys *subsys)
{
	debugfs_remove_recursive(subsys->debugfs_dir);
}

int __init nvmet_init_debugfs(void)
{
	struct dentry *parent;

	parent = debugfs_create_dir("nvmet", NULL);
	if (IS_ERR(parent)) {
		pr_warn("%s: failed to create debugfs directory\n", "nvmet");
		return PTR_ERR(parent);
	}
	nvmet_debugfs = parent;
	return 0;
}

void nvmet_exit_debugfs(void)
{
	debugfs_remove_recursive(nvmet_debugfs);
}




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39778

2. Vulnerability Type
Out-of-bounds read (stack) due to off-by-one loop bound and sparse array indexing

3. Root Cause Summary
nvmet_ctrl_state_show() iterates seven bits (i < 7) and uses state = BIT(i) to index csts_state_names[state], but csts_state_names[] only defines six sparse entries. This off-by-one loop bound permits an index (BIT(6) == 64) that falls beyond the valid indices covered by the array, causing a potential out-of-bounds stack read when the corresponding bit is set in ctrl->csts. The flaw arises from hard-coding the iteration limit rather than deriving it from the actual array size and its sparse (bitmask) indexing pattern.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
NVMe target (nvmet) debugfs interface

2) Pre-Patch Flaw:
In nvmet_ctrl_state_show(), the loop "for (i = 0; i < 7; i++)" computes state = BIT(i) and indexes csts_state_names[state]; csts_state_names[] has only six sparse entries, so accessing index BIT(6) may go beyond the array’s allocated bounds. The code path then dereferences csts_state_names[state] to decide whether to print the name, leading to an out-of-bounds read.

3) Trigger Condition:
Reading the debugfs file "state" for a controller when ctrl->csts has the 7th bit (BIT(6)) set, causing the loop body to reach the dereference of csts_state_names[BIT(6)]. Even without the bit set, static analysis (objtool/UBSAN) flags the potential OOB due to the incorrect bound and indexing scheme.

4) Impact Mechanism:
Potential out-of-bounds stack read when accessing csts_state_names[BIT(6)] may fetch memory beyond the array, resulting in undefined behavior, possible kernel warnings (UBSAN), or unintended data exposure through seq_puts/seq_printf paths.

5. Patch Analysis
1) Fix Approach:
Replace the hard-coded loop bound with ARRAY_SIZE(csts_state_names), aligning iteration with the actual array size and avoiding indices beyond defined sparse entries.

2) Key Code Changes:
- In nvmet_ctrl_state_show():
  - Changed "for (i = 0; i < 7; i++)" to "for (i = 0; i < ARRAY_SIZE(csts_state_names); i++)".
This ensures the loop never reaches a bitmask index that exceeds the array bounds.

3) Locking/Concurrency Impact:
None. The patch only adjusts loop bounds and indexing; no synchronization, ordering, or RCU changes are involved.

6. Broader Kernel Security Implications
This highlights the risks of hard-coded iteration limits with sparse, bitmask-indexed arrays in kernel code. Using ARRAY_SIZE or otherwise deriving bounds from data structures avoids off-by-one and index-mismatch bugs that can lead to memory safety issues. Even in debugfs, such errors can trigger undefined behavior or leak information; adopting safer iteration patterns reduces attack surface and improves robustness under sanitizers and static analysis tools.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.