You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57978

[INFO]
[PATCH_DESCRIPTION]
 media: imx-jpeg: Fix potential error pointer dereference in detach_pm()
 commit 1378ffec30367233152b7dbf4fa6a25ee98585d1 upstream.
 
 The proble is on the first line:
 
 	if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))
 
 If jpeg->pd_dev[i] is an error pointer, then passing it to
 pm_runtime_suspended() will lead to an Oops.  The other conditions
 check for both error pointers and NULL, but it would be more clear to
 use the IS_ERR_OR_NULL() check for that.

 Fixes: fd0af4cd35da ("media: imx-jpeg: Ensure power suppliers be suspended before detach them")

[PATCH_DIFF]
    diff --git a/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c b/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
    index 26e010f8518464..f2ecd3322d1e3d 100644
    --- a/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
    +++ b/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
    @@ -2097,11 +2097,12 @@ static void mxc_jpeg_detach_pm_domains(struct mxc_jpeg_dev *jpeg)
     	int i;
     
     	for (i = 0; i < jpeg->num_domains; i++) {
    -		if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))
    +		if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]) &&
    +		    !pm_runtime_suspended(jpeg->pd_dev[i]))
     			pm_runtime_force_suspend(jpeg->pd_dev[i]);
    -		if (jpeg->pd_link[i] && !IS_ERR(jpeg->pd_link[i]))
    +		if (!IS_ERR_OR_NULL(jpeg->pd_link[i]))
     			device_link_del(jpeg->pd_link[i]);
    -		if (jpeg->pd_dev[i] && !IS_ERR(jpeg->pd_dev[i]))
    +		if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]))
     			dev_pm_domain_detach(jpeg->pd_dev[i], true);
     		jpeg->pd_dev[i] = NULL;
     		jpeg->pd_link[i] = NULL;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57978

2. Vulnerability Type
Error pointer dereference (ERR_PTR misuse) leading to kernel crash/Oops.

3. Root Cause Summary
The detach path in mxc_jpeg_detach_pm_domains used a NULL-only check before passing jpeg->pd_dev[i] to pm_runtime_suspended(). If jpeg->pd_dev[i] held an ERR_PTR, the condition “jpeg->pd_dev[i]” evaluated true and pm_runtime_suspended() was called with an invalid pointer, causing an Oops. The first branch lacked IS_ERR/IS_ERR_OR_NULL validation, unlike the other branches, resulting in inconsistent and unsafe handling of error pointers.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Linux media subsystem, NXP i.MX JPEG driver (drivers/media/platform/nxp/imx-jpeg), power management domain detach and runtime PM.

2) Pre-Patch Flaw:
In mxc_jpeg_detach_pm_domains(), the code used “if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))” without checking for ERR_PTR values, allowing an error pointer to be passed to pm_runtime_suspended().

3) Trigger Condition:
jpeg->pd_dev[i] is set to an ERR_PTR (not NULL), and mxc_jpeg_detach_pm_domains() is executed, causing the first if-condition to pass and pm_runtime_suspended(jpeg->pd_dev[i]) to be invoked with an error pointer.

4) Impact Mechanism:
pm_runtime_suspended() expects a valid struct device pointer; receiving an ERR_PTR leads to invalid memory access and kernel Oops, resulting in a crash/DoS during PM domain detach.

5. Patch Analysis
1) Fix Approach:
Strengthen pointer validation by converting all checks on jpeg->pd_dev[i] and jpeg->pd_link[i] to IS_ERR_OR_NULL, ensuring runtime PM and device link/domain APIs are only called with valid pointers.

2) Key Code Changes:
- Replaced “if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))” with “if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]) && !pm_runtime_suspended(jpeg->pd_dev[i]))” to guard pm_runtime_suspended() against ERR_PTR.
- Replaced “if (jpeg->pd_link[i] && !IS_ERR(jpeg->pd_link[i]))” with “if (!IS_ERR_OR_NULL(jpeg->pd_link[i]))” before device_link_del().
- Replaced “if (jpeg->pd_dev[i] && !IS_ERR(jpeg->pd_dev[i]))” with “if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]))” before dev_pm_domain_detach().

3) Locking/Concurrency Impact:
No locking or ordering changes; the patch solely improves pointer validation. Runtime PM operations continue as before, but are now gated on valid pointers, eliminating unsafe calls.

6. Broader Kernel Security Implications
Consistent use of IS_ERR_OR_NULL prevents invalid pointer dereferences in PM cleanup paths, improving kernel robustness against error-path-induced crashes. It reinforces a best practice across drivers: arrays or fields that may contain ERR_PTR must be validated before use. By avoiding Oops in teardown, the patch reduces denial-of-service risk and stabilizes power management interactions within the media subsystem.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.