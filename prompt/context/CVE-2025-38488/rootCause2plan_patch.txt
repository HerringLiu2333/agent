You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38488

[INFO]
[PATCH_DESCRIPTION]
    smb: client: fix use-after-free in crypt_message when using async crypto
    The CVE-2024-50047 fix removed asynchronous crypto handling from
    crypt_message(), assuming all crypto operations are synchronous.
    However, when hardware crypto accelerators are used, this can cause
    use-after-free crashes:
    
      crypt_message()
        // Allocate the creq buffer containing the req
        creq = smb2_get_aead_req(..., &req);
    
        // Async encryption returns -EINPROGRESS immediately
        rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
    
        // Free creq while async operation is still in progress
        kvfree_sensitive(creq, ...);
    
    Hardware crypto modules often implement async AEAD operations for
    performance. When crypto_aead_encrypt/decrypt() returns -EINPROGRESS,
    the operation completes asynchronously. Without crypto_wait_req(),
    the function immediately frees the request buffer, leading to crashes
    when the driver later accesses the freed memory.
    
    This results in a use-after-free condition when the hardware crypto
    driver later accesses the freed request structure, leading to kernel
    crashes with NULL pointer dereferences.
    
    The issue occurs because crypto_alloc_aead() with mask=0 doesn't
    guarantee synchronous operation. Even without CRYPTO_ALG_ASYNC in
    the mask, async implementations can be selected.
    
    Fix by restoring the async crypto handling:
    - DECLARE_CRYPTO_WAIT(wait) for completion tracking
    - aead_request_set_callback() for async completion notification
    - crypto_wait_req() to wait for operation completion
    
    This ensures the request buffer isn't freed until the crypto operation
    completes, whether synchronous or asynchronous, while preserving the
    CVE-2024-50047 fix.

[PATCH_DIFF]
     @@ -4316,6 +4316,7 @@ crypt_message(struct TCP_Server_Info *server, int num_rqst,
      	u8 key[SMB3_ENC_DEC_KEY_SIZE];
      	struct aead_request *req;
      	u8 *iv;
     +	DECLARE_CRYPTO_WAIT(wait);
      	unsigned int crypt_len = le32_to_cpu(tr_hdr->OriginalMessageSize);
      	void *creq;
      	size_t sensitive_size;
     @@ -4366,7 +4367,11 @@ crypt_message(struct TCP_Server_Info *server, int num_rqst,
      	aead_request_set_crypt(req, sg, sg, crypt_len, iv);
      	aead_request_set_ad(req, assoc_data_len);
     
     -	rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
     +	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
     +				  crypto_req_done, &wait);
     +
     +	rc = crypto_wait_req(enc ? crypto_aead_encrypt(req)
     +				: crypto_aead_decrypt(req), &wait);
     
      	if (!rc && enc)
      		memcpy(&tr_hdr->Signature, sign, SMB2_SIGNATURE_SIZE);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38488

2. Vulnerability Type
Use-after-free due to missing asynchronous crypto completion handling (lifetime management/race window)

3. Root Cause Summary
crypt_message() assumed AEAD operations are always synchronous and did not set a completion callback or wait for completion. It directly invoked crypto_aead_encrypt/decrypt and then freed the request buffer (creq) even when the operation returned -EINPROGRESS and continued asynchronously. This premature free caused a use-after-free when the hardware crypto driver later accessed the aead_request from the freed buffer. The flaw originated when prior changes for CVE-2024-50047 removed the async handling from crypt_message(), but crypto_alloc_aead() could still select async implementations.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
SMB client (CIFS) encryption/decryption path using the kernel crypto API (SMB3 AEAD) in crypt_message().

2) Pre-Patch Flaw:
crypt_message() did not register an async callback or wait on completion and immediately freed creq after:
“rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);”
With async AEAD, this returns -EINPROGRESS and completes later, but the request storage was already freed.

3) Trigger Condition:
Use of hardware crypto accelerators or any AEAD implementation that performs asynchronous operations, causing crypto_aead_encrypt/decrypt() to return -EINPROGRESS in crypt_message().

4) Impact Mechanism:
The function freed the aead_request backing buffer (kvfree_sensitive(creq, ...)) before the async operation completed. The crypto driver then accessed the freed request memory during its completion, leading to use-after-free, kernel crashes, and reported NULL pointer dereferences.

5. Patch Analysis
1) Fix Approach:
Restore proper asynchronous crypto handling by tracking completion and waiting before freeing resources. The patch declares a completion wait object, sets an async callback on the request, and uses crypto_wait_req() to block until the AEAD operation finishes, covering both synchronous and asynchronous implementations.

2) Key Code Changes:
- Added DECLARE_CRYPTO_WAIT(wait) in crypt_message().
- Added aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait) to register completion handling.
- Replaced the direct call with a waited call: rc = crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait).
These changes ensure the request buffer isn’t freed until the operation completes.

3) Locking/Concurrency Impact:
The patch introduces proper synchronization with the crypto subsystem via the crypto wait API, eliminating the race window between freeing creq and async completion. No new locks are added; instead, completion waiting (crypto_wait_req) ensures correct lifetime management of the request memory for both sync and async paths.

6. Broader Kernel Security Implications
Kernel code using the crypto API must not assume synchronous behavior; implementations may be async even without requesting CRYPTO_ALG_ASYNC explicitly. Mismanaging async completion leads to severe lifetime bugs (use-after-free) involving sensitive buffers (keys and request state), causing crashes or potential data leakage. The fix demonstrates the correct pattern: set callbacks and wait for completion before freeing or reusing request memory. Other kernel paths interfacing with AEAD or similar crypto operations should audit for similar assumptions to prevent regressive UAF vulnerabilities, especially when hardware accelerators are present.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.