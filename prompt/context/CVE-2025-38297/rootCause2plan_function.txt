You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38297

[INFO]
[PATCH_DESCRIPTION]
    PM: EM: Fix potential division-by-zero error in em_compute_costs()
    When the device is of a non-CPU type, table[i].performance won't be
    initialized in the previous em_init_performance(), resulting in division
    by zero when calculating costs in em_compute_costs().
    
    Since the 'cost' algorithm is only used for EAS energy efficiency
    calculations and is currently not utilized by other device drivers, we
    should add the _is_cpu_device(dev) check to prevent this division-by-zero
    issue.

[PATCH_DIFF]
     @@ -233,6 +233,10 @@ static int em_compute_costs(struct device *dev, struct em_perf_state *table,
      	unsigned long prev_cost = ULONG_MAX;
      	int i, ret;
     
     +	/* This is needed only for CPUs and EAS skip other devices */
     +	if (!_is_cpu_device(dev))
     +		return 0;
     +
      	/* Compute the cost of each performance state. */
      	for (i = nr_states - 1; i >= 0; i--) {
      		unsigned long power_res, cost;

[FUNCTION_CONTENT]
static int em_compute_costs(struct device *dev, struct em_perf_state *table,
			    const struct em_data_callback *cb, int nr_states,
			    unsigned long flags)
{
	unsigned long prev_cost = ULONG_MAX;
	int i, ret;

	/* Compute the cost of each performance state. */
	for (i = nr_states - 1; i >= 0; i--) {
		unsigned long power_res, cost;

		if ((flags & EM_PERF_DOMAIN_ARTIFICIAL) && cb->get_cost) {
			ret = cb->get_cost(dev, table[i].frequency, &cost);
			if (ret || !cost || cost > EM_MAX_POWER) {
				dev_err(dev, "EM: invalid cost %lu %d\n",
					cost, ret);
				return -EINVAL;
			}
		} else {
			/* increase resolution of 'cost' precision */
			power_res = table[i].power * 10;
			cost = power_res / table[i].performance;
		}

		table[i].cost = cost;

		if (table[i].cost >= prev_cost) {
			table[i].flags = EM_PERF_STATE_INEFFICIENT;
			dev_dbg(dev, "EM: OPP:%lu is inefficient\n",
				table[i].frequency);
		} else {
			prev_cost = table[i].cost;
		}
	}

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38297

2. Vulnerability Type
Arithmetic error (division-by-zero) causing kernel crash/Denial-of-Service

3. Root Cause Summary
em_compute_costs() unconditionally divides by table[i].performance in the non-artificial cost path. For non-CPU devices, table[i].performance is not initialized by em_init_performance(), so performance can be zero, leading to a division-by-zero when computing “cost = power_res / table[i].performance;”. The pre-patch logic lacked both a device-type gate and a zero/initialization check on performance.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Power Management (PM), Energy Model (EM), used by Energy-Aware Scheduling (EAS)

2) Pre-Patch Flaw:
em_compute_costs() assumes table[i].performance is valid for all devices and performs a division in the non-artificial path without verifying non-CPU device suitability or performance being non-zero/initialized. Specifically, in the else branch it executes “cost = power_res / table[i].performance;” without guarding against zero.

3) Trigger Condition:
Invoking em_compute_costs() for a non-CPU device where cb->get_cost is NULL or EM_PERF_DOMAIN_ARTIFICIAL is not set, causing the function to take the default division path with table[i].performance left uninitialized (zero).

4) Impact Mechanism:
A division-by-zero in kernel space triggers an exception/oops leading to a kernel crash during EM cost computation, resulting in denial-of-service during device initialization or scheduler energy model setup.

5. Patch Analysis
1) Fix Approach:
Introduce an early return for non-CPU devices, ensuring the cost computation logic (used only for CPUs/EAS) is skipped and thus avoiding the division-by-zero scenario.

2) Key Code Changes:
- Added at the start of em_compute_costs():
  “if (!_is_cpu_device(dev)) return 0;”
- No changes to the division logic; the guard prevents reaching the division for non-CPU devices.

3) Locking/Concurrency Impact:
None. The patch only adds an early-exit control-flow guard; no locks or synchronization primitives are introduced or modified.

6. Broader Kernel Security Implications
By restricting EM cost calculations to CPU devices, the patch prevents crashes that could be triggered via non-CPU device registration or probing paths, improving system stability and reducing denial-of-service risk. It underscores the need for device-type gating and input validation before performing arithmetic operations in shared PM/EAS infrastructure.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.