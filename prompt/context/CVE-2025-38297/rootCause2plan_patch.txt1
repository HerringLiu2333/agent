You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38297

[INFO]
[PATCH_DESCRIPTION]
    PM: EM: Fix potential division-by-zero error in em_compute_costs()
    When the device is of a non-CPU type, table[i].performance won't be
    initialized in the previous em_init_performance(), resulting in division
    by zero when calculating costs in em_compute_costs().
    
    Since the 'cost' algorithm is only used for EAS energy efficiency
    calculations and is currently not utilized by other device drivers, we
    should add the _is_cpu_device(dev) check to prevent this division-by-zero
    issue.

[PATCH_DIFF]
     @@ -233,6 +233,10 @@ static int em_compute_costs(struct device *dev, struct em_perf_state *table,
      	unsigned long prev_cost = ULONG_MAX;
      	int i, ret;
     
     +	/* This is needed only for CPUs and EAS skip other devices */
     +	if (!_is_cpu_device(dev))
     +		return 0;
     +
      	/* Compute the cost of each performance state. */
      	for (i = nr_states - 1; i >= 0; i--) {
      		unsigned long power_res, cost;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38297

2. Vulnerability Type
Division-by-zero leading to kernel crash (Denial of Service)

3. Root Cause Summary
em_compute_costs() assumed that em_perf_state::performance was initialized for all devices, but em_init_performance() initializes it only for CPU devices. When invoked for non-CPU devices, table[i].performance remained zero, and the cost calculation divided by this value, causing a division-by-zero fault.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Power Management (PM) – Energy Model (EM), used by Energy Aware Scheduling (EAS)

2) Pre-Patch Flaw:
em_compute_costs() executed the cost computation loop for any device type without verifying that the device is a CPU, thereby using table[i].performance as a divisor even when it was not initialized (zero) for non-CPU devices.

3) Trigger Condition:
Calling em_compute_costs(dev, ...) with dev being a non-CPU device; prior em_init_performance() did not set performance for such devices.

4) Impact Mechanism:
Division-by-zero during cost computation triggers a kernel divide-error exception, leading to an oops/panic and denial of service.

5. Patch Analysis
1) Fix Approach:
Add a device-type guard to skip cost computation unless the device is a CPU, preventing the division-by-zero on uninitialized performance values.

2) Key Code Changes:
- In em_compute_costs():
  - Inserted:
    - Comment: "This is needed only for CPUs and EAS skip other devices"
    - if (!_is_cpu_device(dev)) return 0;
  - This early return precedes the cost computation loop.

3) Locking/Concurrency Impact:
None; the change is a simple control-flow guard with no locking or ordering modifications.

6. Broader Kernel Security Implications
This fix hardens the EM framework against misuse by non-CPU devices, preventing kernel crashes from invalid assumptions about per-state initialization. Ensuring device-type validation in shared PM helpers reduces the risk of similar DoS conditions when generic code is invoked by heterogeneous devices.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}