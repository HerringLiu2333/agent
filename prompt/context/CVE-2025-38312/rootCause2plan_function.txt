You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38312

[INFO]
[PATCH_DESCRIPTION]
    fbdev: core: fbcvt: avoid division by 0 in fb_cvt_hperiod()
    In fb_find_mode_cvt(), iff mode->refresh somehow happens to be 0x80000000,
    cvt.f_refresh will become 0 when multiplying it by 2 due to overflow. It's
    then passed to fb_cvt_hperiod(), where it's used as a divider -- division
    by 0 will result in kernel oops. Add a sanity check for cvt.f_refresh to
    avoid such overflow...
    
    Found by Linux Verification Center (linuxtesting.org) with the Svace static
    analysis tool.

[PATCH_DIFF]
    @@ -312,7 +312,7 @@ int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
     	cvt.f_refresh = cvt.refresh;
     	cvt.interlace = 1;
     
    -	if (!cvt.xres || !cvt.yres || !cvt.refresh) {
    +	if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX) {
     		printk(KERN_INFO "fbcvt: Invalid input parameters\n");
     		return 1;
     	}

[FUNCTION_CONTENT]
int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
{
	struct fb_cvt_data cvt;

	memset(&cvt, 0, sizeof(cvt));

	if (margins)
	    cvt.flags |= FB_CVT_FLAG_MARGINS;

	if (rb)
	    cvt.flags |= FB_CVT_FLAG_REDUCED_BLANK;

	if (mode->vmode & FB_VMODE_INTERLACED)
	    cvt.flags |= FB_CVT_FLAG_INTERLACED;

	cvt.xres = mode->xres;
	cvt.yres = mode->yres;
	cvt.refresh = mode->refresh;
	cvt.f_refresh = cvt.refresh;
	cvt.interlace = 1;

	if (!cvt.xres || !cvt.yres || !cvt.refresh) {
		printk(KERN_INFO "fbcvt: Invalid input parameters\n");
		return 1;
	}

	if (!(cvt.refresh == 50 || cvt.refresh == 60 || cvt.refresh == 70 ||
	      cvt.refresh == 85)) {
		printk(KERN_INFO "fbcvt: Refresh rate not CVT "
		       "standard\n");
		cvt.status = 1;
	}

	cvt.xres &= ~(FB_CVT_CELLSIZE - 1);

	if (cvt.flags & FB_CVT_FLAG_INTERLACED) {
		cvt.interlace = 2;
		cvt.f_refresh *= 2;
	}

	if (cvt.flags & FB_CVT_FLAG_REDUCED_BLANK) {
		if (cvt.refresh != 60) {
			printk(KERN_INFO "fbcvt: 60Hz refresh rate "
			       "advised for reduced blanking\n");
			cvt.status = 1;
		}
	}

	if (cvt.flags & FB_CVT_FLAG_MARGINS) {
		cvt.h_margin = (cvt.xres * 18)/1000;
		cvt.h_margin &= ~(FB_CVT_CELLSIZE - 1);
		cvt.v_margin = ((cvt.yres/cvt.interlace)* 18)/1000;
	}

	cvt.aspect_ratio = fb_cvt_aspect_ratio(&cvt);
	cvt.active_pixels = cvt.xres + 2 * cvt.h_margin;
	cvt.hperiod = fb_cvt_hperiod(&cvt);
	cvt.vsync = fb_cvt_vbi_tab[cvt.aspect_ratio];
	cvt.vtotal = fb_cvt_vtotal(&cvt);
	cvt.hblank = fb_cvt_hblank(&cvt);
	cvt.htotal = cvt.active_pixels + cvt.hblank;
	cvt.hsync = fb_cvt_hsync(&cvt);
	cvt.pixclock = fb_cvt_pixclock(&cvt);
	cvt.hfreq = cvt.pixclock/cvt.htotal;
	cvt.h_back_porch = cvt.hblank/2 + cvt.h_margin;
	cvt.h_front_porch = cvt.hblank - cvt.hsync - cvt.h_back_porch +
		2 * cvt.h_margin;
	cvt.v_front_porch = 3 + cvt.v_margin;
	cvt.v_back_porch = cvt.vtotal - cvt.yres/cvt.interlace -
	    cvt.v_front_porch - cvt.vsync;
	fb_cvt_print_name(&cvt);
	fb_cvt_convert_to_mode(&cvt, mode);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38312

2. Vulnerability Type
Integer overflow leading to divide-by-zero (kernel crash/DoS)

3. Root Cause Summary
fb_find_mode_cvt() failed to validate that the computed refresh factor (cvt.f_refresh) would remain within a safe numeric range before later use as a divisor in fb_cvt_hperiod(). When interlacing is requested, the code doubles cvt.f_refresh (“cvt.f_refresh *= 2”), which can overflow for extreme refresh values (e.g., 0x80000000), silently turning cvt.f_refresh into 0. This zero value is then used as a divider in fb_cvt_hperiod(), causing a division-by-zero and a kernel oops. The pre-patch input validation only checked for zero refresh, not for values that would overflow upon doubling.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fbdev core, CVT timing generation (fbcvt)

2) Pre-Patch Flaw:
fb_find_mode_cvt() performed insufficient validation of mode->refresh/cvt.f_refresh, lacking an upper-bound check to prevent overflow when cvt.f_refresh is multiplied by 2 in the interlaced path. The function only rejected zero refresh (“if (!cvt.xres || !cvt.yres || !cvt.refresh)”) but did not consider overflow-induced zero after arithmetic.

3) Trigger Condition:
- mode->refresh set to 0x80000000 (as described), and
- mode->vmode includes FB_VMODE_INTERLACED, causing “cvt.f_refresh *= 2”.
This results in cvt.f_refresh wrapping to 0 due to integer overflow.

4) Impact Mechanism:
With cvt.f_refresh becoming 0, fb_cvt_hperiod(&cvt) uses it as a divider, leading to a division by zero and kernel oops (crash).

5. Patch Analysis
1) Fix Approach:
Introduce a sanity check on cvt.f_refresh to reject inputs that would overflow the refresh factor, preventing later division by zero in fb_cvt_hperiod().

2) Key Code Changes:
- In fb_find_mode_cvt(), the validation condition was expanded:
  Pre-patch: if (!cvt.xres || !cvt.yres || !cvt.refresh) …
  Post-patch: if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX) …
This early return prevents proceeding with unsafe cvt.f_refresh values that could overflow when doubled.

3) Locking/Concurrency Impact:
None. The change is purely input validation; no locks, ordering, or concurrency primitives were modified.

6. Broader Kernel Security Implications
Strengthening arithmetic bounds checking in display mode computation reduces crash surfaces reachable via malformed or extreme framebuffer mode inputs, improving kernel robustness against DoS. Preventing divide-by-zero in widely used subsystems like fbdev helps maintain system stability, especially where user-controlled parameters may flow into kernel mode setting paths. This fix exemplifies the need for rigorous validation of derived values before arithmetic operations that can overflow or become divisors.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.