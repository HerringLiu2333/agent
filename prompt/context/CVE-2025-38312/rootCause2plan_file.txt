You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FILE_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38312

[INFO]
[PATCH_DESCRIPTION]
    fbdev: core: fbcvt: avoid division by 0 in fb_cvt_hperiod()
    In fb_find_mode_cvt(), iff mode->refresh somehow happens to be 0x80000000,
    cvt.f_refresh will become 0 when multiplying it by 2 due to overflow. It's
    then passed to fb_cvt_hperiod(), where it's used as a divider -- division
    by 0 will result in kernel oops. Add a sanity check for cvt.f_refresh to
    avoid such overflow...
    
    Found by Linux Verification Center (linuxtesting.org) with the Svace static
    analysis tool.

[PATCH_DIFF]
    @@ -312,7 +312,7 @@ int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
     	cvt.f_refresh = cvt.refresh;
     	cvt.interlace = 1;
     
    -	if (!cvt.xres || !cvt.yres || !cvt.refresh) {
    +	if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX) {
     		printk(KERN_INFO "fbcvt: Invalid input parameters\n");
     		return 1;
     	}

[FILE_CONTENT]
/*
 * linux/drivers/video/fbcvt.c - VESA(TM) Coordinated Video Timings
 *
 * Copyright (C) 2005 Antonino Daplas <adaplas@pol.net>
 *
 *      Based from the VESA(TM) Coordinated Video Timing Generator by
 *      Graham Loveridge April 9, 2003 available at
 *      http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive
 * for more details.
 *
 */
#include <linux/fb.h>
#include <linux/slab.h>

#define FB_CVT_CELLSIZE               8
#define FB_CVT_GTF_C                 40
#define FB_CVT_GTF_J                 20
#define FB_CVT_GTF_K                128
#define FB_CVT_GTF_M                600
#define FB_CVT_MIN_VSYNC_BP         550
#define FB_CVT_MIN_VPORCH             3
#define FB_CVT_MIN_BPORCH             6

#define FB_CVT_RB_MIN_VBLANK        460
#define FB_CVT_RB_HBLANK            160
#define FB_CVT_RB_V_FPORCH            3

#define FB_CVT_FLAG_REDUCED_BLANK 1
#define FB_CVT_FLAG_MARGINS       2
#define FB_CVT_FLAG_INTERLACED    4

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

static const unsigned char fb_cvt_vbi_tab[] = {
	4,        /* 4:3      */
	5,        /* 16:9     */
	6,        /* 16:10    */
	7,        /* 5:4      */
	7,        /* 15:9     */
	8,        /* reserved */
	9,        /* reserved */
	10        /* custom   */
};

/* returns hperiod * 1000 */
static u32 fb_cvt_hperiod(struct fb_cvt_data *cvt)
{
	u32 num = 1000000000/cvt->f_refresh;
	u32 den;

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK) {
		num -= FB_CVT_RB_MIN_VBLANK * 1000;
		den = 2 * (cvt->yres/cvt->interlace + 2 * cvt->v_margin);
	} else {
		num -= FB_CVT_MIN_VSYNC_BP * 1000;
		den = 2 * (cvt->yres/cvt->interlace + cvt->v_margin * 2
			   + FB_CVT_MIN_VPORCH + cvt->interlace/2);
	}

	return 2 * (num/den);
}

/* returns ideal duty cycle * 1000 */
static u32 fb_cvt_ideal_duty_cycle(struct fb_cvt_data *cvt)
{
	u32 c_prime = (FB_CVT_GTF_C - FB_CVT_GTF_J) *
		(FB_CVT_GTF_K) + 256 * FB_CVT_GTF_J;
	u32 m_prime = (FB_CVT_GTF_K * FB_CVT_GTF_M);
	u32 h_period_est = cvt->hperiod;

	return (1000 * c_prime  - ((m_prime * h_period_est)/1000))/256;
}

static u32 fb_cvt_hblank(struct fb_cvt_data *cvt)
{
	u32 hblank = 0;

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)
		hblank = FB_CVT_RB_HBLANK;
	else {
		u32 ideal_duty_cycle = fb_cvt_ideal_duty_cycle(cvt);
		u32 active_pixels = cvt->active_pixels;

		if (ideal_duty_cycle < 20000)
			hblank = (active_pixels * 20000)/
				(100000 - 20000);
		else {
			hblank = (active_pixels * ideal_duty_cycle)/
				(100000 - ideal_duty_cycle);
		}
	}

	hblank &= ~((2 * FB_CVT_CELLSIZE) - 1);

	return hblank;
}

static u32 fb_cvt_hsync(struct fb_cvt_data *cvt)
{
	u32 hsync;

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)
		hsync = 32;
	else
		hsync = (FB_CVT_CELLSIZE * cvt->htotal)/100;

	hsync &= ~(FB_CVT_CELLSIZE - 1);
	return hsync;
}

static u32 fb_cvt_vbi_lines(struct fb_cvt_data *cvt)
{
	u32 vbi_lines, min_vbi_lines, act_vbi_lines;

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK) {
		vbi_lines = (1000 * FB_CVT_RB_MIN_VBLANK)/cvt->hperiod + 1;
		min_vbi_lines =  FB_CVT_RB_V_FPORCH + cvt->vsync +
			FB_CVT_MIN_BPORCH;

	} else {
		vbi_lines = (FB_CVT_MIN_VSYNC_BP * 1000)/cvt->hperiod + 1 +
			 FB_CVT_MIN_VPORCH;
		min_vbi_lines = cvt->vsync + FB_CVT_MIN_BPORCH +
			FB_CVT_MIN_VPORCH;
	}

	if (vbi_lines < min_vbi_lines)
		act_vbi_lines = min_vbi_lines;
	else
		act_vbi_lines = vbi_lines;

	return act_vbi_lines;
}

static u32 fb_cvt_vtotal(struct fb_cvt_data *cvt)
{
	u32 vtotal = cvt->yres/cvt->interlace;

	vtotal += 2 * cvt->v_margin + cvt->interlace/2 + fb_cvt_vbi_lines(cvt);
	vtotal |= cvt->interlace/2;

	return vtotal;
}

static u32 fb_cvt_pixclock(struct fb_cvt_data *cvt)
{
	u32 pixclock;

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)
		pixclock = (cvt->f_refresh * cvt->vtotal * cvt->htotal)/1000;
	else
		pixclock = (cvt->htotal * 1000000)/cvt->hperiod;

	pixclock /= 250;
	pixclock *= 250;
	pixclock *= 1000;

	return pixclock;
}

static u32 fb_cvt_aspect_ratio(struct fb_cvt_data *cvt)
{
	u32 xres = cvt->xres;
	u32 yres = cvt->yres;
	u32 aspect = -1;

	if (xres == (yres * 4)/3 && !((yres * 4) % 3))
		aspect = 0;
	else if (xres == (yres * 16)/9 && !((yres * 16) % 9))
		aspect = 1;
	else if (xres == (yres * 16)/10 && !((yres * 16) % 10))
		aspect = 2;
	else if (xres == (yres * 5)/4 && !((yres * 5) % 4))
		aspect = 3;
	else if (xres == (yres * 15)/9 && !((yres * 15) % 9))
		aspect = 4;
	else {
		printk(KERN_INFO "fbcvt: Aspect ratio not CVT "
		       "standard\n");
		aspect = 7;
		cvt->status = 1;
	}

	return aspect;
}

static void fb_cvt_print_name(struct fb_cvt_data *cvt)
{
	u32 pixcount, pixcount_mod;
	int size = 256;
	int off = 0;
	u8 *buf;

	buf = kzalloc(size, GFP_KERNEL);
	if (!buf)
		return;

	pixcount = (cvt->xres * (cvt->yres/cvt->interlace))/1000000;
	pixcount_mod = (cvt->xres * (cvt->yres/cvt->interlace)) % 1000000;
	pixcount_mod /= 1000;

	off += scnprintf(buf + off, size - off, "fbcvt: %dx%d@%d: CVT Name - ",
			    cvt->xres, cvt->yres, cvt->refresh);

	if (cvt->status) {
		off += scnprintf(buf + off, size - off,
				 "Not a CVT standard - %d.%03d Mega Pixel Image\n",
				 pixcount, pixcount_mod);
	} else {
		if (pixcount)
			off += scnprintf(buf + off, size - off, "%d", pixcount);

		off += scnprintf(buf + off, size - off, ".%03dM", pixcount_mod);

		if (cvt->aspect_ratio == 0)
			off += scnprintf(buf + off, size - off, "3");
		else if (cvt->aspect_ratio == 3)
			off += scnprintf(buf + off, size - off, "4");
		else if (cvt->aspect_ratio == 1 || cvt->aspect_ratio == 4)
			off += scnprintf(buf + off, size - off, "9");
		else if (cvt->aspect_ratio == 2)
			off += scnprintf(buf + off, size - off, "A");

		if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)
			off += scnprintf(buf + off, size - off, "-R");
	}

	printk(KERN_INFO "%s\n", buf);
	kfree(buf);
}

static void fb_cvt_convert_to_mode(struct fb_cvt_data *cvt,
				   struct fb_videomode *mode)
{
	mode->refresh = cvt->f_refresh;
	mode->pixclock = KHZ2PICOS(cvt->pixclock/1000);
	mode->left_margin = cvt->h_back_porch;
	mode->right_margin = cvt->h_front_porch;
	mode->hsync_len = cvt->hsync;
	mode->upper_margin = cvt->v_back_porch;
	mode->lower_margin = cvt->v_front_porch;
	mode->vsync_len = cvt->vsync;

	mode->sync &= ~(FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT);

	if (cvt->flags & FB_CVT_FLAG_REDUCED_BLANK)
		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
	else
		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
}

/*
 * fb_find_mode_cvt - calculate mode using VESA(TM) CVT
 * @mode: pointer to fb_videomode; xres, yres, refresh and vmode must be
 *        pre-filled with the desired values
 * @margins: add margin to calculation (1.8% of xres and yres)
 * @rb: compute with reduced blanking (for flatpanels)
 *
 * RETURNS:
 * 0 for success
 * @mode is filled with computed values.  If interlaced, the refresh field
 * will be filled with the field rate (2x the frame rate)
 *
 * DESCRIPTION:
 * Computes video timings using VESA(TM) Coordinated Video Timings
 */
int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
{
	struct fb_cvt_data cvt;

	memset(&cvt, 0, sizeof(cvt));

	if (margins)
	    cvt.flags |= FB_CVT_FLAG_MARGINS;

	if (rb)
	    cvt.flags |= FB_CVT_FLAG_REDUCED_BLANK;

	if (mode->vmode & FB_VMODE_INTERLACED)
	    cvt.flags |= FB_CVT_FLAG_INTERLACED;

	cvt.xres = mode->xres;
	cvt.yres = mode->yres;
	cvt.refresh = mode->refresh;
	cvt.f_refresh = cvt.refresh;
	cvt.interlace = 1;

	if (!cvt.xres || !cvt.yres || !cvt.refresh) {
		printk(KERN_INFO "fbcvt: Invalid input parameters\n");
		return 1;
	}

	if (!(cvt.refresh == 50 || cvt.refresh == 60 || cvt.refresh == 70 ||
	      cvt.refresh == 85)) {
		printk(KERN_INFO "fbcvt: Refresh rate not CVT "
		       "standard\n");
		cvt.status = 1;
	}

	cvt.xres &= ~(FB_CVT_CELLSIZE - 1);

	if (cvt.flags & FB_CVT_FLAG_INTERLACED) {
		cvt.interlace = 2;
		cvt.f_refresh *= 2;
	}

	if (cvt.flags & FB_CVT_FLAG_REDUCED_BLANK) {
		if (cvt.refresh != 60) {
			printk(KERN_INFO "fbcvt: 60Hz refresh rate "
			       "advised for reduced blanking\n");
			cvt.status = 1;
		}
	}

	if (cvt.flags & FB_CVT_FLAG_MARGINS) {
		cvt.h_margin = (cvt.xres * 18)/1000;
		cvt.h_margin &= ~(FB_CVT_CELLSIZE - 1);
		cvt.v_margin = ((cvt.yres/cvt.interlace)* 18)/1000;
	}

	cvt.aspect_ratio = fb_cvt_aspect_ratio(&cvt);
	cvt.active_pixels = cvt.xres + 2 * cvt.h_margin;
	cvt.hperiod = fb_cvt_hperiod(&cvt);
	cvt.vsync = fb_cvt_vbi_tab[cvt.aspect_ratio];
	cvt.vtotal = fb_cvt_vtotal(&cvt);
	cvt.hblank = fb_cvt_hblank(&cvt);
	cvt.htotal = cvt.active_pixels + cvt.hblank;
	cvt.hsync = fb_cvt_hsync(&cvt);
	cvt.pixclock = fb_cvt_pixclock(&cvt);
	cvt.hfreq = cvt.pixclock/cvt.htotal;
	cvt.h_back_porch = cvt.hblank/2 + cvt.h_margin;
	cvt.h_front_porch = cvt.hblank - cvt.hsync - cvt.h_back_porch +
		2 * cvt.h_margin;
	cvt.v_front_porch = 3 + cvt.v_margin;
	cvt.v_back_porch = cvt.vtotal - cvt.yres/cvt.interlace -
	    cvt.v_front_porch - cvt.vsync;
	fb_cvt_print_name(&cvt);
	fb_cvt_convert_to_mode(&cvt, mode);

	return 0;
}




[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38312

2. Vulnerability Type
Integer overflow leading to divide-by-zero (kernel crash/DoS)

3. Root Cause Summary
fb_find_mode_cvt() did not validate that the refresh rate (cvt.f_refresh) stayed within a safe upper bound before it could be doubled for interlaced modes. With cvt.f_refresh stored as u32, doubling a value of 0x80000000 wraps to 0, which is then used as a divisor in fb_cvt_hperiod(). Specifically, fb_cvt_hperiod() computes “u32 num = 1000000000/cvt->f_refresh;” and thus triggers a division-by-zero. The pre-patch validation only checked for zero (cvt.refresh == 0), missing the wrap-to-zero after multiplication overflow.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
fbdev core, CVT timing generator (drivers/video/fbcvt.c), functions fb_find_mode_cvt() and fb_cvt_hperiod().

2) Pre-Patch Flaw:
- Missing upper-bound validation on cvt.f_refresh prior to scaling for interlaced modes in fb_find_mode_cvt().
- No guard against u32 overflow when doubling cvt.f_refresh (cvt.f_refresh *= 2) under FB_VMODE_INTERLACED.
- fb_cvt_hperiod() uses cvt->f_refresh as a divisor without ensuring it cannot become 0 after overflow.

3) Trigger Condition:
- mode->vmode has FB_VMODE_INTERLACED set, and mode->refresh equals 0x80000000.
- In fb_find_mode_cvt(), cvt.f_refresh is set from refresh and then doubled for interlaced, wrapping 0x80000000 to 0 due to u32 overflow.
- fb_cvt_hperiod() is called and divides by cvt->f_refresh (now 0).

4) Impact Mechanism:
- Division-by-zero in fb_cvt_hperiod() at “u32 num = 1000000000/cvt->f_refresh;” causes a kernel oops, leading to denial of service.

5. Patch Analysis
1) Fix Approach:
Input sanitization by bounding the acceptable range of cvt.f_refresh before any arithmetic that could overflow to 0. The check rejects values that could wrap to 0 when doubled, ensuring the divisor in fb_cvt_hperiod() is never zero.

2) Key Code Changes:
- In fb_find_mode_cvt(), the precondition check was extended from:
  “if (!cvt.xres || !cvt.yres || !cvt.refresh)”
  to:
  “if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX)”
- This ensures any initial cvt.f_refresh >= 0x80000000 (including 0x80000000) is treated as invalid, preventing the wrap-to-zero on doubling and the subsequent divide-by-zero.

3) Locking/Concurrency Impact:
None; the change is pure input validation in a computational path with no shared-state concurrency.

6. Broader Kernel Security Implications
- Arithmetic on untrusted or out-of-range inputs must consider overflow effects before values are used as divisors or scaled further; u32 wrap-around can silently convert nonzero inputs into zero.
- Similar timing and refresh computations elsewhere should be reviewed for overflow-before-division patterns; adopting explicit range checks or using wider types (u64) with overflow detection can prevent such faults.
- Early input validation is a low-cost mitigation that prevents kernel oopses and improves robustness against malformed user-provided display modes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.