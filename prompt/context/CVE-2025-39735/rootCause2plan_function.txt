You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-39735

[INFO]
[PATCH_DESCRIPTION]
    jfs: fix slab-out-of-bounds read in ea_get()
    commit fdf480da5837c23b146c4743c18de97202fcab37 upstream.
    
    During the "size_check" label in ea_get(), the code checks if the extended
    attribute list (xattr) size matches ea_size. If not, it logs
    "ea_get: invalid extended attribute" and calls print_hex_dump().
    
    Here, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds
    INT_MAX (2,147,483,647). Then ea_size is clamped:
    
    	int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
    
    Although clamp_t aims to bound ea_size between 0 and 4110417968, the upper
    limit is treated as an int, causing an overflow above 2^31 - 1. This leads
    "size" to wrap around and become negative (-184549328).
    
    The "size" is then passed to print_hex_dump() (called "len" in
    print_hex_dump()), it is passed as type size_t (an unsigned
    type), this is then stored inside a variable called
    "int remaining", which is then assigned to "int linelen" which
    is then passed to hex_dump_to_buffer(). In print_hex_dump()
    the for loop, iterates through 0 to len-1, where len is
    18446744073525002176, calling hex_dump_to_buffer()
    on each iteration:
    
    	for (i = 0; i < len; i += rowsize) {
    		linelen = min(remaining, rowsize);
    		remaining -= rowsize;
    
    		hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
    				   linebuf, sizeof(linebuf), ascii);
    
    		...
    	}
    
    The expected stopping condition (i < len) is effectively broken
    since len is corrupted and very large. This eventually leads to
    the "ptr+i" being passed to hex_dump_to_buffer() to get closer
    to the end of the actual bounds of "ptr", eventually an out of
    bounds access is done in hex_dump_to_buffer() in the following
    for loop:
    
    	for (j = 0; j < len; j++) {
    			if (linebuflen < lx + 2)
    				goto overflow2;
    			ch = ptr[j];
    		...
    	}
    
    To fix this we should validate "EALIST_SIZE(ea_buf->xattr)"
    before it is utilised.

[PATCH_DIFF]
    @@ -559,11 +559,16 @@ static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)
     
           size_check:
     	if (EALIST_SIZE(ea_buf->xattr) != ea_size) {
-		int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
-
-		printk(KERN_ERR "ea_get: invalid extended attribute\n");
-		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_ADDRESS, 16, 1,
-				     ea_buf->xattr, size, 1);
+		if (unlikely(EALIST_SIZE(ea_buf->xattr) > INT_MAX)) {
+			printk(KERN_ERR "ea_get: extended attribute size too large: %u > INT_MAX\n",
+			       EALIST_SIZE(ea_buf->xattr));
+		} else {
+			int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
+
+			printk(KERN_ERR "ea_get: invalid extended attribute\n");
+			print_hex_dump(KERN_ERR, "", DUMP_PREFIX_ADDRESS, 16, 1,
+				       ea_buf->xattr, size, 1);
+		}
     		ea_release(inode, ea_buf);
     		rc = -EIO;
     		goto clean_up;

[FUNCTION_CONTENT]
static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)
{
	struct jfs_inode_info *ji = JFS_IP(inode);
	struct super_block *sb = inode->i_sb;
	int size;
	int ea_size = sizeDXD(&ji->ea);
	int blocks_needed, current_blocks;
	s64 blkno;
	int rc;
	int quota_allocation = 0;

	memset(&ea_buf->new_ea, 0, sizeof(ea_buf->new_ea));

	/* When fsck.jfs clears a bad ea, it doesn't clear the size */
	if (ji->ea.flag == 0)
		ea_size = 0;

	if (ea_size == 0) {
		if (min_size == 0) {
			ea_buf->flag = 0;
			ea_buf->max_size = 0;
			ea_buf->xattr = NULL;
			return 0;
		}
		if ((min_size <= sizeof (ji->i_inline_ea)) &&
		    (ji->mode2 & INLINEEA)) {
			ea_buf->flag = EA_INLINE | EA_NEW;
			ea_buf->max_size = sizeof (ji->i_inline_ea);
			ea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;
			DXDlength(&ea_buf->new_ea, 0);
			DXDaddress(&ea_buf->new_ea, 0);
			ea_buf->new_ea.flag = DXD_INLINE;
			DXDsize(&ea_buf->new_ea, min_size);
			return 0;
		}
		current_blocks = 0;
	} else if (ji->ea.flag & DXD_INLINE) {
		if (min_size <= sizeof (ji->i_inline_ea)) {
			ea_buf->flag = EA_INLINE;
			ea_buf->max_size = sizeof (ji->i_inline_ea);
			ea_buf->xattr = (struct jfs_ea_list *) ji->i_inline_ea;
			goto size_check;
		}
		current_blocks = 0;
	} else {
		if (!(ji->ea.flag & DXD_EXTENT)) {
			jfs_error(sb, "invalid ea.flag\n");
			return -EIO;
		}
		current_blocks = (ea_size + sb->s_blocksize - 1) >>
		    sb->s_blocksize_bits;
	}
	size = max(min_size, ea_size);

	if (size > PSIZE) {
		/*
		 * To keep the rest of the code simple.  Allocate a
		 * contiguous buffer to work with. Make the buffer large
		 * enough to make use of the whole extent.
		 */
		ea_buf->max_size = (size + sb->s_blocksize - 1) &
		    ~(sb->s_blocksize - 1);

		ea_buf->xattr = kmalloc(ea_buf->max_size, GFP_KERNEL);
		if (ea_buf->xattr == NULL)
			return -ENOMEM;

		ea_buf->flag = EA_MALLOC;

		if (ea_size == 0)
			return 0;

		if ((rc = ea_read(inode, ea_buf->xattr))) {
			kfree(ea_buf->xattr);
			ea_buf->xattr = NULL;
			return rc;
		}
		goto size_check;
	}
	blocks_needed = (min_size + sb->s_blocksize - 1) >>
	    sb->s_blocksize_bits;

	if (blocks_needed > current_blocks) {
		/* Allocate new blocks to quota. */
		rc = dquot_alloc_block(inode, blocks_needed);
		if (rc)
			return -EDQUOT;

		quota_allocation = blocks_needed;

		rc = dbAlloc(inode, INOHINT(inode), (s64) blocks_needed,
			     &blkno);
		if (rc)
			goto clean_up;

		DXDlength(&ea_buf->new_ea, blocks_needed);
		DXDaddress(&ea_buf->new_ea, blkno);
		ea_buf->new_ea.flag = DXD_EXTENT;
		DXDsize(&ea_buf->new_ea, min_size);

		ea_buf->flag = EA_EXTENT | EA_NEW;

		ea_buf->mp = get_metapage(inode, blkno,
					  blocks_needed << sb->s_blocksize_bits,
					  1);
		if (ea_buf->mp == NULL) {
			dbFree(inode, blkno, (s64) blocks_needed);
			rc = -EIO;
			goto clean_up;
		}
		ea_buf->xattr = ea_buf->mp->data;
		ea_buf->max_size = (min_size + sb->s_blocksize - 1) &
		    ~(sb->s_blocksize - 1);
		if (ea_size == 0)
			return 0;
		if ((rc = ea_read(inode, ea_buf->xattr))) {
			discard_metapage(ea_buf->mp);
			dbFree(inode, blkno, (s64) blocks_needed);
			goto clean_up;
		}
		goto size_check;
	}
	ea_buf->flag = EA_EXTENT;
	ea_buf->mp = read_metapage(inode, addressDXD(&ji->ea),
				   lengthDXD(&ji->ea) << sb->s_blocksize_bits,
				   1);
	if (ea_buf->mp == NULL) {
		rc = -EIO;
		goto clean_up;
	}
	ea_buf->xattr = ea_buf->mp->data;
	ea_buf->max_size = (ea_size + sb->s_blocksize - 1) &
	    ~(sb->s_blocksize - 1);

      size_check:
	if (EALIST_SIZE(ea_buf->xattr) != ea_size) {
		int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));

		printk(KERN_ERR "ea_get: invalid extended attribute\n");
		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_ADDRESS, 16, 1,
				     ea_buf->xattr, size, 1);
		ea_release(inode, ea_buf);
		rc = -EIO;
		goto clean_up;
	}

	return ea_size;

      clean_up:
	/* Rollback quota allocation */
	if (quota_allocation)
		dquot_free_block(inode, quota_allocation);

	return (rc);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-39735

2. Vulnerability Type
Integer overflow leading to slab out-of-bounds read

3. Root Cause Summary
In ea_get() at the size_check label, the code used clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr)) with an upper bound derived from EALIST_SIZE() that can exceed INT_MAX. The upper bound is effectively treated as int, overflowing and causing the clamped result to become negative. This negative int was then passed to print_hex_dump() as a size_t length, expanding to a very large value and causing hex_dump_to_buffer() to read beyond the allocated slab buffer (slab-out-of-bounds read). The patch adds validation to ensure EALIST_SIZE(ea_buf->xattr) does not exceed INT_MAX before using it for clamping or dumping.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
JFS filesystem, extended attributes handling (ea_get in fs/jfs/xattr.c)

2) Pre-Patch Flaw:
- Missing upper-bound validation for EALIST_SIZE(ea_buf->xattr) relative to INT_MAX.
- Misuse of clamp_t with type int while the upper bound originates from a wider unsigned domain, causing an overflow/truncation.
- Directly using the (possibly negative) clamped value as a length to print_hex_dump(), which expects a size_t.

3) Trigger Condition:
- On-disk extended attribute list where EALIST_SIZE(ea_buf->xattr) is very large (e.g., 4110417968 > INT_MAX) and differs from ea_size, reaching the size_check path in ea_get().

4) Impact Mechanism:
- clamp_t(int, ...) overflows the upper bound, producing a negative size.
- print_hex_dump() receives the negative size as size_t, turning it into a huge value; its loop iterates far beyond the true buffer length.
- hex_dump_to_buffer() then reads ptr[j] out-of-bounds, resulting in a slab-out-of-bounds read.

5. Patch Analysis
1) Fix Approach:
Add explicit validation to reject/log cases where EALIST_SIZE(ea_buf->xattr) > INT_MAX, and skip the clamp and hex dump in that case. Only perform clamp and print_hex_dump() when the xattr length is safely representable as int.

2) Key Code Changes:
- Replaced unconditional clamp and dump with:
  - if (unlikely(EALIST_SIZE(...) > INT_MAX)) { printk("...size too large..."); }
  - else { int size = clamp_t(int, ea_size, 0, EALIST_SIZE(...)); printk("invalid..."); print_hex_dump(..., size, ...); }
- Preserves subsequent error handling (ea_release, rc = -EIO, goto clean_up), but prevents using an overflowing upper bound and passing a negative length to print_hex_dump().

3) Locking/Concurrency Impact:
None. No locking or ordering changes; the fix is purely input validation and control-flow within a single-threaded path.

6. Broader Kernel Security Implications
- Filesystems must validate on-disk metadata sizes before casting or clamping to narrower integer types to avoid integer overflows and downstream OOB accesses.
- Auditing for clamp_t or length handling where upper bounds are derived from u32/size_t but cast to int is advisable across the kernel, especially around logging/hexdump paths.
- Preventing unbounded hexdumps on corrupt metadata also mitigates potential secondary issues like log flooding or reading unintended memory regions.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.