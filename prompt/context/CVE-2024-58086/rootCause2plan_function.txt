You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58086

[INFO]
[PATCH_DESCRIPTION]
 drm/v3d: Stop active perfmon if it is being destroyed
 commit 21f1435b1e6b012a07c42f36b206d2b66fc8f13b upstream.
 
 If the active performance monitor (`v3d->active_perfmon`) is being
 destroyed, stop it first. Currently, the active perfmon is not
 stopped during destruction, leaving the `v3d->active_perfmon` pointer
 stale. This can lead to undefined behavior and instability.

 This patch ensures that the active perfmon is stopped before being
 destroyed, aligning with the behavior introduced in commit
 7d1fd3638ee3 ("drm/v3d: Stop the active perfmon before being destroyed").

 Cc: stable@vger.kernel.org # v5.15+
 Fixes: 26a4dc29b74a ("drm/v3d: Expose performance counters to userspace")

[PATCH_DIFF]
    diff --git a/drivers/gpu/drm/v3d/v3d_perfmon.c b/drivers/gpu/drm/v3d/v3d_perfmon.c
    index ecf06e8e9fbccb..c49abb90954d49 100644
    --- a/drivers/gpu/drm/v3d/v3d_perfmon.c
    +++ b/drivers/gpu/drm/v3d/v3d_perfmon.c
    @@ -384,6 +384,7 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
     {
     	struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
     	struct drm_v3d_perfmon_destroy *req = data;
    +	struct v3d_dev *v3d = v3d_priv->v3d;
     	struct v3d_perfmon *perfmon;
     
     	mutex_lock(&v3d_priv->perfmon.lock);
    @@ -393,6 +394,10 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
     	if (!perfmon)
     		return -EINVAL;
     
    +	/* If the active perfmon is being destroyed, stop it first /
    +	if (perfmon == v3d->active_perfmon)
    +		v3d_perfmon_stop(v3d, perfmon, false);
    +
     	v3d_perfmon_put(perfmon);
     
     	return 0;

[FUNCTION_CONTENT]
int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
			      struct drm_file *file_priv)
{
	struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
	struct drm_v3d_perfmon_destroy *req = data;
	struct v3d_perfmon *perfmon;

	mutex_lock(&v3d_priv->perfmon.lock);
	perfmon = idr_remove(&v3d_priv->perfmon.idr, req->id);
	mutex_unlock(&v3d_priv->perfmon.lock);

	if (!perfmon)
		return -EINVAL;

	v3d_perfmon_put(perfmon);

	return 0;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58086

2. Vulnerability Type
Use-after-free due to stale pointer (lifetime management bug)

3. Root Cause Summary
In v3d_perfmon_destroy_ioctl(), the driver destroyed a perfmon without checking whether it was currently active (v3d->active_perfmon). The function removed the perfmon from the IDR and immediately called v3d_perfmon_put(perfmon), potentially freeing it while v3d->active_perfmon still pointed to the same object. This left v3d->active_perfmon as a dangling pointer, enabling subsequent dereferences of freed memory and undefined behavior. The patch adds a check and stops the active perfmon before releasing it, preventing a stale pointer and ensuring proper teardown.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM V3D (Broadcom V3D GPU) performance monitor handling (drivers/gpu/drm/v3d/v3d_perfmon.c)

2) Pre-Patch Flaw:
v3d_perfmon_destroy_ioctl() unconditionally called v3d_perfmon_put(perfmon) after IDR removal, with no guard to stop and clear v3d->active_perfmon if the perfmon being destroyed was active. This mismatch in lifetime management between per-file perfmon objects and the device-level active pointer caused a dangling pointer.

3) Trigger Condition:
Userspace issues the destroy ioctl for a perfmon that is currently active (perfmon == v3d->active_perfmon). The function removes the perfmon from the IDR, unlocks, and frees it via v3d_perfmon_put() while the device’s active pointer remains set.

4) Impact Mechanism:
The device’s v3d->active_perfmon becomes stale and may be dereferenced by subsequent operations expecting a valid active perfmon, leading to use-after-free, undefined behavior, or system instability. Additionally, hardware performance monitoring may continue without a valid backing object until explicitly stopped elsewhere.

5. Patch Analysis
1) Fix Approach:
Introduce a check to detect when the perfmon being destroyed is the active perfmon and proactively stop it before releasing its reference. This ensures the active pointer is cleared and hardware monitoring is halted prior to freeing.

2) Key Code Changes:
- Added retrieval of the device pointer: struct v3d_dev *v3d = v3d_priv->v3d;
- Inserted conditional stop before put:
  if (perfmon == v3d->active_perfmon)
      v3d_perfmon_stop(v3d, perfmon, false);
- v3d_perfmon_put(perfmon) remains, but now executes after the active perfmon has been stopped.

3) Locking/Concurrency Impact:
No new locks were introduced; the existing mutex around IDR removal (v3d_priv->perfmon.lock) remains unchanged. The ordering is corrected: stop the active perfmon first (which is expected to clear v3d->active_perfmon) and then drop the reference, reducing the race window for dereferencing a freed active perfmon. Specific internal synchronization within v3d_perfmon_stop() is not shown; its locking behavior is unknown/not determinable from the provided context.

6. Broader Kernel Security Implications
This issue underscores the need for coordinated lifetime management between per-file objects and device-global pointers in GPU drivers. Destroy operations must handle active states to prevent dangling references and UAF. Ensuring resources are stopped/disabled before release is critical for preventing kernel memory safety violations and hardware interactions with freed structures.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.