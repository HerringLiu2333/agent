You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58086

[INFO]
[PATCH_DESCRIPTION]
 drm/v3d: Stop active perfmon if it is being destroyed
 commit 21f1435b1e6b012a07c42f36b206d2b66fc8f13b upstream.
 
 If the active performance monitor (`v3d->active_perfmon`) is being
 destroyed, stop it first. Currently, the active perfmon is not
 stopped during destruction, leaving the `v3d->active_perfmon` pointer
 stale. This can lead to undefined behavior and instability.

 This patch ensures that the active perfmon is stopped before being
 destroyed, aligning with the behavior introduced in commit
 7d1fd3638ee3 ("drm/v3d: Stop the active perfmon before being destroyed").

 Cc: stable@vger.kernel.org # v5.15+
 Fixes: 26a4dc29b74a ("drm/v3d: Expose performance counters to userspace")

[PATCH_DIFF]
    diff --git a/drivers/gpu/drm/v3d/v3d_perfmon.c b/drivers/gpu/drm/v3d/v3d_perfmon.c
    index ecf06e8e9fbccb..c49abb90954d49 100644
    --- a/drivers/gpu/drm/v3d/v3d_perfmon.c
    +++ b/drivers/gpu/drm/v3d/v3d_perfmon.c
    @@ -384,6 +384,7 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
     {
     	struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
     	struct drm_v3d_perfmon_destroy *req = data;
    +	struct v3d_dev *v3d = v3d_priv->v3d;
     	struct v3d_perfmon *perfmon;
     
     	mutex_lock(&v3d_priv->perfmon.lock);
    @@ -393,6 +394,10 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
     	if (!perfmon)
     		return -EINVAL;
     
    +	/* If the active perfmon is being destroyed, stop it first /
    +	if (perfmon == v3d->active_perfmon)
    +		v3d_perfmon_stop(v3d, perfmon, false);
    +
     	v3d_perfmon_put(perfmon);
     
     	return 0;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58086

2. Vulnerability Type
Use-after-free / stale pointer due to improper resource teardown

3. Root Cause Summary
In v3d_perfmon_destroy_ioctl, destroying a perfmon did not check whether it was the currently active perfmon (v3d->active_perfmon) and did not stop it before releasing its reference. As a result, v3d->active_perfmon could continue to point to a perfmon object that had been put/freed, leaving a dangling pointer and inconsistent device state. Subsequent code paths that consult or dereference v3d->active_perfmon could then access freed memory or operate on invalid hardware state.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
DRM Broadcom V3D GPU driver (drivers/gpu/drm/v3d), performance monitor handling.

2) Pre-Patch Flaw:
v3d_perfmon_destroy_ioctl performed v3d_perfmon_put(perfmon) without first stopping the perfmon if it was active, and without clearing v3d->active_perfmon. This omission left v3d->active_perfmon pointing to an object whose lifetime had ended.

3) Trigger Condition:
Userspace issues the perfmon destroy IOCTL (v3d_perfmon_destroy_ioctl) targeting the perfmon that is currently active (perfmon == v3d->active_perfmon).

4) Impact Mechanism:
- v3d->active_perfmon becomes a stale/dangling pointer after the destroy path releases the object, enabling use-after-free when later code accesses or dereferences v3d->active_perfmon.
- The hardware perf monitor may continue running after its software object is destroyed, causing undefined behavior and instability.

5. Patch Analysis
1) Fix Approach:
Ensure proper teardown ordering: detect when the perfmon being destroyed is the active one and explicitly stop it before releasing its reference. This guarantees that device state is quiesced and v3d->active_perfmon is cleared in a controlled manner before the object is put/freed.

2) Key Code Changes:
- Added retrieval of v3d device: struct v3d_dev *v3d = v3d_priv->v3d;
- Inserted conditional stop before put:
  if (perfmon == v3d->active_perfmon)
      v3d_perfmon_stop(v3d, perfmon, false);
- Retained the subsequent v3d_perfmon_put(perfmon).
These changes occur inside v3d_perfmon_destroy_ioctl under the existing perfmon.lock.

3) Locking/Concurrency Impact:
The stop operation is now performed while holding v3d_priv->perfmon.lock, closing a race window where active_perfmon could become dangling between destroy and later accesses. The patch does not introduce new locks but enforces correct ordering (stop-before-put) under the existing mutex, improving atomicity of state transition for active_perfmon.

6. Broader Kernel Security Implications
The bug highlights the importance of consistent resource lifecycle management in IOCTL destroy paths, especially for “active” objects referenced globally (like v3d->active_perfmon). Ensuring stop/disable before release prevents stale pointers and UAF conditions that are common in driver subsystems. Similar patterns should be audited across DRM and other drivers: any global/activity pointer must be reset or quiesced prior to object destruction under appropriate locking to avoid memory safety and device state corruption.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}