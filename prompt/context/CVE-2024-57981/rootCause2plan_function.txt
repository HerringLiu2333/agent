You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57981

[INFO]
[PATCH_DESCRIPTION]
 usb: xhci: Fix NULL pointer dereference on certain command aborts
 [ Upstream commit 1e0a19912adb68a4b2b74fd77001c96cd83eb073 ]
 
 If a command is queued to the final usable TRB of a ring segment, the
 enqueue pointer is advanced to the subsequent link TRB and no further.
 If the command is later aborted, when the abort completion is handled
 the dequeue pointer is advanced to the first TRB of the next segment.

 If no further commands are queued, xhci_handle_stopped_cmd_ring() sees
 the ring pointers unequal and assumes that there is a pending command,
 so it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL.
 
 Don't attempt timer setup if cur_cmd is NULL. The subsequent doorbell
 ring likely is unnecessary too, but it's harmless. Leave it alone.

 This is probably Bug 219532, but no confirmation has been received.

 The issue has been independently reproduced and confirmed fixed using
 a USB MCU programmed to NAK the Status stage of SET_ADDRESS forever.
 Everything continued working normally after several prevented crashes.
 
 Link: https://bugzilla.kernel.org/show_bug.cgi?id=219532
 Fixes: c311e391a7ef ("xhci: rework command timeout and cancellation,")

[PATCH_DIFF]
 diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
 index a37b55b2e31f47…08b016864fc088 100644
 --- a/drivers/usb/host/xhci-ring.c
 +++ b/drivers/usb/host/xhci-ring.c
 @@ -332,7 +332,8 @@ static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,
 if ((xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue) &&
 !(xhci->xhc_state & XHCI_STATE_DYING)) {
   xhci->current_cmd = cur_cmd;
 - xhci_mod_cmd_timer(xhci);
 + if (cur_cmd)
 + xhci_mod_cmd_timer(xhci);
 xhci_ring_cmd_db(xhci);
 }
 }

[FUNCTION_CONTENT]
static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,
					 struct xhci_command *cur_cmd)
{
	struct xhci_command *i_cmd;

	/* Turn all aborted commands in list to no-ops, then restart */
	list_for_each_entry(i_cmd, &xhci->cmd_list, cmd_list) {

		if (i_cmd->status != COMP_COMMAND_ABORTED)
			continue;

		i_cmd->status = COMP_COMMAND_RING_STOPPED;

		xhci_dbg(xhci, "Turn aborted command %p to no-op\n",
			 i_cmd->command_trb);

		trb_to_noop(i_cmd->command_trb, TRB_CMD_NOOP);

		/*
		 * caller waiting for completion is called when command
		 *  completion event is received for these no-op commands
		 */
	}

	xhci->cmd_ring_state = CMD_RING_STATE_RUNNING;

	/* ring command ring doorbell to restart the command ring */
	if ((xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue) &&
	    !(xhci->xhc_state & XHCI_STATE_DYING)) {
		xhci->current_cmd = cur_cmd;
		xhci_mod_cmd_timer(xhci);
		xhci_ring_cmd_db(xhci);
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57981

2. Vulnerability Type
NULL pointer dereference (logic/state validation flaw leading to kernel crash/DoS)

3. Root Cause Summary
xhci_handle_stopped_cmd_ring() unconditionally scheduled the command timeout timer (xhci_mod_cmd_timer) when the ring’s dequeue and enqueue pointers were unequal, implicitly assuming a pending command existed. In certain abort scenarios, cur_cmd was NULL but the pointer inequality still occurred due to segment boundary advancement, and xhci_mod_cmd_timer dereferenced xhci->current_cmd (which had just been set to NULL), causing a NULL pointer dereference. The missing validation of cur_cmd before timer setup is the root cause.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
USB xHCI host controller driver (drivers/usb/host/xhci-ring.c)

2) Pre-Patch Flaw:
In xhci_handle_stopped_cmd_ring(), the code set xhci->current_cmd = cur_cmd and then always called xhci_mod_cmd_timer(xhci) whenever (dequeue != enqueue) and !(XHCI_STATE_DYING), without checking whether cur_cmd was NULL.

3) Trigger Condition:
A command is queued to the final usable TRB of a segment, advancing enqueue to the subsequent link TRB; later the command is aborted, advancing dequeue to the first TRB of the next segment. With no further commands queued, the ring pointers remain unequal, but there is no current command (cur_cmd == NULL). This causes the unconditional timer setup to run with a NULL current command.

4) Impact Mechanism:
xhci_mod_cmd_timer() operates on xhci->current_cmd; with xhci->current_cmd == NULL, it dereferences a NULL pointer, leading to a kernel crash/Oops (denial of service). The doorbell ring is harmless and not the crash source.

5. Patch Analysis
1) Fix Approach:
Add a guard to only schedule the command timeout timer if cur_cmd is non-NULL, preventing xhci_mod_cmd_timer from running with a NULL current command.

2) Key Code Changes:
In xhci_handle_stopped_cmd_ring():
- Pre-patch: xhci->current_cmd = cur_cmd; xhci_mod_cmd_timer(xhci);
- Post-patch: xhci->current_cmd = cur_cmd; if (cur_cmd) xhci_mod_cmd_timer(xhci);
The doorbell ring (xhci_ring_cmd_db) remains unchanged.

3) Locking/Concurrency Impact:
No changes to locking, RCU, or ordering. Existing state checks (XHCI_STATE_DYING) are preserved; the fix is a simple null-check guarding timer setup.

6. Broader Kernel Security Implications
The fix removes a crash path in USB command abort handling that could be externally triggered by a malicious or misbehaving device (e.g., persistent NAKs), improving kernel robustness against device-induced DoS. It strengthens error-recovery logic by ensuring timers aren’t scheduled for non-existent commands, reducing instability during command cancellation. No broader security mechanisms are altered; this is a targeted reliability improvement.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.