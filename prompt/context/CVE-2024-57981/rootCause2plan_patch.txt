You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57981

[INFO]
[PATCH_DESCRIPTION]
 usb: xhci: Fix NULL pointer dereference on certain command aborts
 [ Upstream commit 1e0a19912adb68a4b2b74fd77001c96cd83eb073 ]
 
 If a command is queued to the final usable TRB of a ring segment, the
 enqueue pointer is advanced to the subsequent link TRB and no further.
 If the command is later aborted, when the abort completion is handled
 the dequeue pointer is advanced to the first TRB of the next segment.

 If no further commands are queued, xhci_handle_stopped_cmd_ring() sees
 the ring pointers unequal and assumes that there is a pending command,
 so it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL.
 
 Don't attempt timer setup if cur_cmd is NULL. The subsequent doorbell
 ring likely is unnecessary too, but it's harmless. Leave it alone.

 This is probably Bug 219532, but no confirmation has been received.

 The issue has been independently reproduced and confirmed fixed using
 a USB MCU programmed to NAK the Status stage of SET_ADDRESS forever.
 Everything continued working normally after several prevented crashes.
 
 Link: https://bugzilla.kernel.org/show_bug.cgi?id=219532
 Fixes: c311e391a7ef ("xhci: rework command timeout and cancellation,")

[PATCH_DIFF]
 diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
 index a37b55b2e31f47…08b016864fc088 100644
 --- a/drivers/usb/host/xhci-ring.c
 +++ b/drivers/usb/host/xhci-ring.c
 @@ -332,7 +332,8 @@ static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,
 if ((xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue) &&
 !(xhci->xhc_state & XHCI_STATE_DYING)) {
   xhci->current_cmd = cur_cmd;
 - xhci_mod_cmd_timer(xhci);
 + if (cur_cmd)
 + xhci_mod_cmd_timer(xhci);
 xhci_ring_cmd_db(xhci);
 }
 }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57981

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (Denial of Service)

3. Root Cause Summary
In xhci_handle_stopped_cmd_ring(), the code assumed that unequal ring pointers implied a pending command and unconditionally scheduled the command timeout via xhci_mod_cmd_timer(). In abort scenarios where cur_cmd is NULL (no active command despite pointer inequality after a segment transition), xhci_mod_cmd_timer() dereferenced xhci->current_cmd, causing a NULL pointer dereference. The flaw was a missing validation of cur_cmd before setting up the command timer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
USB xHCI host controller driver (command ring handling)

2) Pre-Patch Flaw:
xhci_handle_stopped_cmd_ring() used the condition (dequeue != enqueue) to infer a pending command and executed:
“xhci->current_cmd = cur_cmd; xhci_mod_cmd_timer(xhci);”
without checking cur_cmd for NULL. This incorrect assumption allowed timer setup when there was no valid current command, leading to NULL dereference inside xhci_mod_cmd_timer().

3) Trigger Condition:
- A command is queued to the final usable TRB of a ring segment, advancing enqueue to the subsequent link TRB.
- The command is later aborted; abort completion advances dequeue to the first TRB of the next segment.
- No further commands are queued; xhci_handle_stopped_cmd_ring() sees enqueue != dequeue (and controller not dying), but cur_cmd is NULL, and it still schedules the timer.

4) Impact Mechanism:
xhci_mod_cmd_timer() operates on xhci->current_cmd, which was set to NULL, leading to a NULL pointer dereference and kernel crash. This can be reliably triggered by a USB device that NAKs the Status stage of SET_ADDRESS indefinitely, causing repeated aborts and the flawed timer setup.

5. Patch Analysis
1) Fix Approach:
Add a defensive NULL check to ensure the command timeout timer is only scheduled when cur_cmd is non-NULL, preventing dereference on NULL.

2) Key Code Changes:
In xhci_handle_stopped_cmd_ring():
- Before: “xhci->current_cmd = cur_cmd; xhci_mod_cmd_timer(xhci);”
- After: “xhci->current_cmd = cur_cmd; if (cur_cmd) xhci_mod_cmd_timer(xhci);”
The doorbell ring (xhci_ring_cmd_db(xhci)) remains unaffected.

3) Locking/Concurrency Impact:
No locking changes were made. The change restricts timer activation to valid command states, eliminating the race-like window where abort completion could leave cur_cmd NULL while the timer was still scheduled. Concurrency semantics remain unchanged.

6. Broader Kernel Security Implications
The bug allowed a physically connected USB device to crash the kernel (DoS) by inducing repeated command aborts (e.g., perpetual NAK of SET_ADDRESS), undermining system robustness. Ensuring timer setup is dependent on a valid command improves the resilience of abort and ring stop paths against misbehaving or malicious peripherals. The fix highlights the importance of validating state when deriving action solely from ring pointer positions, especially across segment boundaries and abort handling.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.