You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58057

[INFO]
[PATCH_DESCRIPTION]
 idpf: convert workqueues to unbound
 When a workqueue is created with `WQ_UNBOUND`, its work items are
 served by special worker-pools, whose host workers are not bound to
 any specific CPU. In the default configuration (i.e. when
 `queue_delayed_work` and friends do not specify which CPU to run the
 work item on), `WQ_UNBOUND` allows the work item to be executed on any
 CPU in the same node of the CPU it was enqueued on. While this
 solution potentially sacrifices locality, it avoids contention with
 other processes that might dominate the CPU time of the processor the
 work item was scheduled on.
 
 This is not just a theoretical problem: in a particular scenario
 misconfigured process was hogging most of the time from CPU0, leaving
 less than 0.5% of its CPU time to the kworker. The IDPF workqueues
 that were using the kworker on CPU0 suffered large completion delays
 as a result, causing performance degradation, timeouts and eventual
 system crash.
 
 Tested:

 * I have also run a manual test to gauge the performance
   improvement. The test consists of an antagonist process
   (`./stress --cpu 2`) consuming as much of CPU 0 as possible. This
   process is run under `taskset 01` to bind it to CPU0, and its
   priority is changed with `chrt -pQ 9900 10000 ${pid}` and
   `renice -n -20 ${pid}` after start.

   Then, the IDPF driver is forced to prefer CPU0 by editing all calls
   to `queue_delayed_work`, `mod_delayed_work`, etc... to use CPU 0.
 
   Finally, `ktraces` for the workqueue events are collected.
 
   Without the current patch, the antagonist process can force
   arbitrary delays between `workqueue_queue_work` and
   `workqueue_execute_start`, that in my tests were as high as
   `30ms`. With the current patch applied, the workqueue can be
   migrated to another unloaded CPU in the same node, and, keeping
   everything else equal, the maximum delay I could see was `6us`.
 
 Fixes: 0fe45467a104 ("idpf: add create vport and netdev configuration")

[PATCH_DIFF]
 diff --git a/drivers/net/ethernet/intel/idpf/idpf_main.c b/drivers/net/ethernet/intel/idpf/idpf_main.c
 index f71d3182580b6a…b6c515d14cbf08 100644
 --- a/drivers/net/ethernet/intel/idpf/idpf_main.c
 +++ b/drivers/net/ethernet/intel/idpf/idpf_main.c
 @@ -174,7 +174,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 pci_set_master(pdev);
 pci_set_drvdata(pdev, adapter);

 - adapter->init_wq = alloc_workqueue("%s-%s-init", 0, 0,
 + adapter->init_wq = alloc_workqueue("%s-%s-init",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
 if (!adapter->init_wq) {
 @@ -183,7 +184,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_free;
   }

 - adapter->serv_wq = alloc_workqueue("%s-%s-service", 0, 0,
 + adapter->serv_wq = alloc_workqueue("%s-%s-service",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->serv_wq) {
 @@ -192,7 +194,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_serv_wq_alloc;
   }

 - adapter->mbx_wq = alloc_workqueue("%s-%s-mbx", 0, 0,
 + adapter->mbx_wq = alloc_workqueue("%s-%s-mbx",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->mbx_wq) {
 @@ -201,7 +204,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_mbx_wq_alloc;
   }

 - adapter->stats_wq = alloc_workqueue("%s-%s-stats", 0, 0,
 + adapter->stats_wq = alloc_workqueue("%s-%s-stats",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->stats_wq) {
 @@ -210,7 +214,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_stats_wq_alloc;
   }

 - adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event", 0, 0,
 + adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->vc_event_wq) {



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58057

2. Vulnerability Type
Denial of Service via CPU-bound workqueue starvation (scheduling/affinity misuse)

3. Root Cause Summary
The IDPF driver created multiple workqueues with flags=0 (per-CPU bound) in idpf_probe(), causing work items to execute only on the kworker tied to the CPU they were enqueued on. Under load, a misconfigured or high-priority process could monopolize that CPU’s time, starving the kworker and delaying driver work processing. The absence of WQ_UNBOUND (and WQ_MEM_RECLAIM) prevented migration to another CPU and guaranteed worker availability, leading to prolonged delays, timeouts, and an eventual system crash. The patch corrects this by converting the workqueues to unbound and reclaim-capable, allowing execution on any CPU within the NUMA node and ensuring forward progress.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Intel IDPF network driver (drivers/net/ethernet/intel/idpf), initialization path idpf_probe()

2) Pre-Patch Flaw:
Workqueues init_wq, serv_wq, mbx_wq, stats_wq, and vc_event_wq were created with alloc_workqueue using flags=0 (per-CPU bound), e.g., “alloc_workqueue(..., 0, 0, ...)”. This bound the driver’s asynchronous work to specific CPU kworkers with no ability to migrate when that CPU became overloaded. No use of WQ_UNBOUND or WQ_MEM_RECLAIM was present.

3) Trigger Condition:
When driver work (e.g., via queue_delayed_work/mod_delayed_work) is enqueued to run on a CPU that is heavily loaded or hogged (e.g., a high-priority task pinned to CPU0), the per-CPU kworker receives less than 0.5% CPU time. This causes large delays between workqueue_queue_work and workqueue_execute_start (observed up to ~30 ms).

4) Impact Mechanism:
Starvation of the per-CPU kworker delays execution of critical driver tasks, leading to performance degradation, timeouts in the driver’s workflows, and eventual system crash. In effect, a local process can induce a denial-of-service by monopolizing the CPU servicing the driver’s bound workqueues.

5. Patch Analysis
1) Fix Approach:
Convert all affected workqueues to WQ_UNBOUND | WQ_MEM_RECLAIM so that work can execute on any CPU within the NUMA node, avoiding single-CPU contention, and ensuring worker availability under memory pressure. This removes the dependency on a specific CPU’s kworker and mitigates starvation.

2) Key Code Changes:
In idpf_probe():
- init_wq: alloc_workqueue(..., WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...)
- serv_wq: alloc_workqueue(..., WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...)
- mbx_wq: alloc_workqueue(..., WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...)
- stats_wq: alloc_workqueue(..., WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...)
- vc_event_wq: alloc_workqueue(..., WQ_UNBOUND | WQ_MEM_RECLAIM, 0, ...)
These replace prior “alloc_workqueue(..., 0, 0, ...)” calls.

3) Locking/Concurrency Impact:
No explicit locking changes; the patch alters scheduling semantics by using unbound worker-pools. Work items can migrate across CPUs within the NUMA node, reducing single-CPU contention and improving forward progress. WQ_MEM_RECLAIM provides reserved workers to avoid stalls during memory reclaim. Overall concurrency is improved by decoupling from per-CPU kworker starvation.

6. Broader Kernel Security Implications
Per-CPU bound workqueues in drivers can be a denial-of-service vector: a local process can starve the servicing kworker by monopolizing its CPU. Using WQ_UNBOUND reduces susceptibility to such single-CPU starvation and improves resilience against noisy neighbors and misconfiguration. Adding WQ_MEM_RECLAIM further decreases the risk of stalls under memory pressure, improving reliability of critical driver paths. This patch highlights the need to review workqueue flags in performance-sensitive or critical subsystems to prevent local DoS via scheduler affinity and resource contention.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.