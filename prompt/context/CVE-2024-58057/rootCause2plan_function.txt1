You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58057

[INFO]
[PATCH_DESCRIPTION]
 idpf: convert workqueues to unbound
 When a workqueue is created with `WQ_UNBOUND`, its work items are
 served by special worker-pools, whose host workers are not bound to
 any specific CPU. In the default configuration (i.e. when
 `queue_delayed_work` and friends do not specify which CPU to run the
 work item on), `WQ_UNBOUND` allows the work item to be executed on any
 CPU in the same node of the CPU it was enqueued on. While this
 solution potentially sacrifices locality, it avoids contention with
 other processes that might dominate the CPU time of the processor the
 work item was scheduled on.
 
 This is not just a theoretical problem: in a particular scenario
 misconfigured process was hogging most of the time from CPU0, leaving
 less than 0.5% of its CPU time to the kworker. The IDPF workqueues
 that were using the kworker on CPU0 suffered large completion delays
 as a result, causing performance degradation, timeouts and eventual
 system crash.
 
 Tested:

 * I have also run a manual test to gauge the performance
   improvement. The test consists of an antagonist process
   (`./stress --cpu 2`) consuming as much of CPU 0 as possible. This
   process is run under `taskset 01` to bind it to CPU0, and its
   priority is changed with `chrt -pQ 9900 10000 ${pid}` and
   `renice -n -20 ${pid}` after start.

   Then, the IDPF driver is forced to prefer CPU0 by editing all calls
   to `queue_delayed_work`, `mod_delayed_work`, etc... to use CPU 0.
 
   Finally, `ktraces` for the workqueue events are collected.
 
   Without the current patch, the antagonist process can force
   arbitrary delays between `workqueue_queue_work` and
   `workqueue_execute_start`, that in my tests were as high as
   `30ms`. With the current patch applied, the workqueue can be
   migrated to another unloaded CPU in the same node, and, keeping
   everything else equal, the maximum delay I could see was `6us`.
 
 Fixes: 0fe45467a104 ("idpf: add create vport and netdev configuration")

[PATCH_DIFF]
 diff --git a/drivers/net/ethernet/intel/idpf/idpf_main.c b/drivers/net/ethernet/intel/idpf/idpf_main.c
 index f71d3182580b6a…b6c515d14cbf08 100644
 --- a/drivers/net/ethernet/intel/idpf/idpf_main.c
 +++ b/drivers/net/ethernet/intel/idpf/idpf_main.c
 @@ -174,7 +174,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 pci_set_master(pdev);
 pci_set_drvdata(pdev, adapter);

 - adapter->init_wq = alloc_workqueue("%s-%s-init", 0, 0,
 + adapter->init_wq = alloc_workqueue("%s-%s-init",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
 if (!adapter->init_wq) {
 @@ -183,7 +184,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_free;
   }

 - adapter->serv_wq = alloc_workqueue("%s-%s-service", 0, 0,
 + adapter->serv_wq = alloc_workqueue("%s-%s-service",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->serv_wq) {
 @@ -192,7 +194,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_serv_wq_alloc;
   }

 - adapter->mbx_wq = alloc_workqueue("%s-%s-mbx", 0, 0,
 + adapter->mbx_wq = alloc_workqueue("%s-%s-mbx",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->mbx_wq) {
 @@ -201,7 +204,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_mbx_wq_alloc;
   }

 - adapter->stats_wq = alloc_workqueue("%s-%s-stats", 0, 0,
 + adapter->stats_wq = alloc_workqueue("%s-%s-stats",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->stats_wq) {
 @@ -210,7 +214,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
   goto err_stats_wq_alloc;
   }

 - adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event", 0, 0,
 + adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event",
 + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
   dev_driver_string(dev),
   dev_name(dev));
   if (!adapter->vc_event_wq) {

[FUNCTION_CONTENT]
static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	struct device *dev = &pdev->dev;
	struct idpf_adapter *adapter;
	int err;

	adapter = kzalloc(sizeof(*adapter), GFP_KERNEL);
	if (!adapter)
		return -ENOMEM;

	adapter->req_tx_splitq = true;
	adapter->req_rx_splitq = true;

	switch (ent->device) {
	case IDPF_DEV_ID_PF:
		idpf_dev_ops_init(adapter);
		break;
	case IDPF_DEV_ID_VF:
		idpf_vf_dev_ops_init(adapter);
		adapter->crc_enable = true;
		break;
	default:
		err = -ENODEV;
		dev_err(&pdev->dev, "Unexpected dev ID 0x%x in idpf probe\n",
			ent->device);
		goto err_free;
	}

	adapter->pdev = pdev;
	err = pcim_enable_device(pdev);
	if (err)
		goto err_free;

	err = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));
	if (err) {
		pci_err(pdev, "pcim_iomap_regions failed %pe\n", ERR_PTR(err));

		goto err_free;
	}

	/* set up for high or low dma */
	err = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
	if (err) {
		pci_err(pdev, "DMA configuration failed: %pe\n", ERR_PTR(err));

		goto err_free;
	}

	pci_set_master(pdev);
	pci_set_drvdata(pdev, adapter);

	adapter->init_wq = alloc_workqueue("%s-%s-init", 0, 0,
					   dev_driver_string(dev),
					   dev_name(dev));
	if (!adapter->init_wq) {
		dev_err(dev, "Failed to allocate init workqueue\n");
		err = -ENOMEM;
		goto err_free;
	}

	adapter->serv_wq = alloc_workqueue("%s-%s-service", 0, 0,
					   dev_driver_string(dev),
					   dev_name(dev));
	if (!adapter->serv_wq) {
		dev_err(dev, "Failed to allocate service workqueue\n");
		err = -ENOMEM;
		goto err_serv_wq_alloc;
	}

	adapter->mbx_wq = alloc_workqueue("%s-%s-mbx", 0, 0,
					  dev_driver_string(dev),
					  dev_name(dev));
	if (!adapter->mbx_wq) {
		dev_err(dev, "Failed to allocate mailbox workqueue\n");
		err = -ENOMEM;
		goto err_mbx_wq_alloc;
	}

	adapter->stats_wq = alloc_workqueue("%s-%s-stats", 0, 0,
					    dev_driver_string(dev),
					    dev_name(dev));
	if (!adapter->stats_wq) {
		dev_err(dev, "Failed to allocate workqueue\n");
		err = -ENOMEM;
		goto err_stats_wq_alloc;
	}

	adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event", 0, 0,
					       dev_driver_string(dev),
					       dev_name(dev));
	if (!adapter->vc_event_wq) {
		dev_err(dev, "Failed to allocate virtchnl event workqueue\n");
		err = -ENOMEM;
		goto err_vc_event_wq_alloc;
	}

	/* setup msglvl */
	adapter->msg_enable = netif_msg_init(-1, IDPF_AVAIL_NETIF_M);

	err = idpf_cfg_hw(adapter);
	if (err) {
		dev_err(dev, "Failed to configure HW structure for adapter: %d\n",
			err);
		goto err_cfg_hw;
	}

	mutex_init(&adapter->vport_ctrl_lock);
	mutex_init(&adapter->vector_lock);
	mutex_init(&adapter->queue_lock);
	mutex_init(&adapter->vc_buf_lock);

	INIT_DELAYED_WORK(&adapter->init_task, idpf_init_task);
	INIT_DELAYED_WORK(&adapter->serv_task, idpf_service_task);
	INIT_DELAYED_WORK(&adapter->mbx_task, idpf_mbx_task);
	INIT_DELAYED_WORK(&adapter->stats_task, idpf_statistics_task);
	INIT_DELAYED_WORK(&adapter->vc_event_task, idpf_vc_event_task);

	adapter->dev_ops.reg_ops.reset_reg_init(adapter);
	set_bit(IDPF_HR_DRV_LOAD, adapter->flags);
	queue_delayed_work(adapter->vc_event_wq, &adapter->vc_event_task,
			   msecs_to_jiffies(10 * (pdev->devfn & 0x07)));

	return 0;

err_cfg_hw:
	destroy_workqueue(adapter->vc_event_wq);
err_vc_event_wq_alloc:
	destroy_workqueue(adapter->stats_wq);
err_stats_wq_alloc:
	destroy_workqueue(adapter->mbx_wq);
err_mbx_wq_alloc:
	destroy_workqueue(adapter->serv_wq);
err_serv_wq_alloc:
	destroy_workqueue(adapter->init_wq);
err_free:
	kfree(adapter);
	return err;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58057

2. Vulnerability Type
Denial of Service (DoS) via workqueue starvation caused by CPU-bound worker affinity

3. Root Cause Summary
The IDPF driver created several critical workqueues with default (bound) worker-pool semantics, using alloc_workqueue flags “0, 0” in idpf_probe(). Bound workqueues tie execution to the CPU on which the work was enqueued, making them vulnerable to starvation when that CPU is heavily loaded or pinned by a high-priority task. This led to excessive delays in executing driver work items (service, mailbox, statistics, virtchnl events), causing timeouts, performance degradation, and eventual system crash. The patch corrects this by creating these workqueues as WQ_UNBOUND | WQ_MEM_RECLAIM, allowing migration to other CPUs in the same NUMA node and ensuring forward progress under pressure.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Networking driver (Intel IDPF), drivers/net/ethernet/intel/idpf/idpf_main.c

2) Pre-Patch Flaw:
idpf_probe() initialized adapter->init_wq, serv_wq, mbx_wq, stats_wq, and vc_event_wq with alloc_workqueue(..., 0, 0, ...), producing bound workqueues backed by per-CPU kworkers. These queues handled delayed tasks such as idpf_service_task, idpf_mbx_task, idpf_statistics_task, and idpf_vc_event_task via queue_delayed_work() without specifying a CPU, thereby inheriting the enqueue CPU for execution.

3) Trigger Condition:
A misconfigured or malicious high-priority, CPU-affined userspace process pinned to a specific CPU (e.g., CPU0) hogs CPU time, starving the bound kworker on that CPU. Because the work items are bound to the starved CPU (default configuration), their execution is arbitrarily delayed.

4) Impact Mechanism:
Driver work items accumulate and time out, disrupting control-plane operations (mailbox/virtchnl events), service routines, and stats handling; delays observed up to 30 ms. The cascading timeouts lead to performance degradation and can culminate in a system crash, representing a practical DoS vector against the system’s networking stack and stability.

5. Patch Analysis
1) Fix Approach:
Convert the driver’s workqueues from bound to unbound and enable MEM_RECLAIM. Using WQ_UNBOUND allows work items to execute on any CPU within the same NUMA node, mitigating starvation on a single CPU. WQ_MEM_RECLAIM ensures a rescuer thread for forward progress under resource pressure.

2) Key Code Changes:
In idpf_probe(), all alloc_workqueue() calls are changed from flags “0, 0” to “WQ_UNBOUND | WQ_MEM_RECLAIM, 0” for:
- adapter->init_wq (“%s-%s-init”)
- adapter->serv_wq (“%s-%s-service”)
- adapter->mbx_wq (“%s-%s-mbx”)
- adapter->stats_wq (“%s-%s-stats”)
- adapter->vc_event_wq (“%s-%s-vc_event”)

3) Locking/Concurrency Impact:
No explicit lock changes were made. Scheduling semantics shift from per-CPU bound workers to unbound pools, increasing execution flexibility and reducing susceptibility to single-CPU contention. WQ_MEM_RECLAIM adds a rescuer to guarantee progress, reducing deadlock/timeout risks under reclaim, but does not alter existing mutex usage (e.g., vport_ctrl_lock, vector_lock, queue_lock, vc_buf_lock).

6. Broader Kernel Security Implications
Bound workqueues for critical driver tasks can be exploited for DoS by saturating a specific CPU, especially with high-priority CPU-affined workloads. Adopting WQ_UNBOUND for latency-sensitive paths in drivers improves resilience against localized CPU starvation, while WQ_MEM_RECLAIM helps maintain forward progress under memory pressure. This change strengthens the networking stack’s robustness and reduces the attack surface for scheduler-level starvation causing system instability or crashes.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}