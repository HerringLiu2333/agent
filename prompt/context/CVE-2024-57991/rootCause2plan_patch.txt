You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57991

[INFO]
[PATCH_DESCRIPTION]
 wifi: rtw89: chan: fix soft lockup in rtw89_entity_recalc_mgnt_roles()
 During rtw89_entity_recalc_mgnt_roles(), there is a normalizing process
 which will re-order the list if an entry with target pattern is found.
 And once one is found, should have aborted the list_for_each_entry. But,
 `break` just aborted the inner for-loop. The outer list_for_each_entry
 still continues. Normally, only the first entry will match the target
 pattern, and the re-ordering will change nothing, so there won't be
 soft lockup. However, in some special cases, soft lockup would happen.

 Fix it by `goto fill` to break from the list_for_each_entry.

 The following is a sample of kernel log for this problem.
 
 watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [wpa_supplicant:2055]
 [...]
 RIP: 0010:rtw89_entity_recalc ([...] chan.c:392 chan.c:479) rtw89_core
 [...]
 
 Fixes: 68ec751b2881 ("wifi: rtw89: chan: manage active interfaces")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/realtek/rtw89/chan.c b/drivers/net/wireless/realtek/rtw89/chan.c
    index abc78716596d00..c06d305519df46 100644
    --- a/drivers/net/wireless/realtek/rtw89/chan.c
    +++ b/drivers/net/wireless/realtek/rtw89/chan.c
    @@ -391,11 +391,12 @@ static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
     
     				list_del(&role->mgnt_entry);
     				list_add(&role->mgnt_entry, &mgnt->active_list);
    -				break;
    +				goto fill;
     			}
     		}
     	}
     
    +fill:
     	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
     		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
     			rtw89_warn(rtwdev,



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
Denial of Service (soft lockup) due to improper loop control during list mutation

3. Root Cause Summary
rtw89_entity_recalc_mgnt_roles() mutates mgnt->active_list while iterating it and intended to stop iterating once a target match is found. Pre-patch code used break inside an inner loop, which exited only the inner loop and allowed the outer list_for_each_entry to continue on a modified list. This incorrect loop termination on a mutating list could cause the traversal to fail to make progress in certain cases, leading to a CPU soft lockup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 Wi-Fi driver, channel/management role handling (drivers/net/wireless/realtek/rtw89/chan.c)

2) Pre-Patch Flaw:
- In rtw89_entity_recalc_mgnt_roles(), when a “target pattern” is found, the code reorders the list via list_del/list_add and then uses break, which only exits an inner loop.
- The outer list_for_each_entry continues iterating over mgnt->active_list after it has been reordered, violating safe iteration expectations and enabling a non-progressing traversal.
- Evidence: pre-patch snippet within the function shows “list_del(&role->mgnt_entry); list_add(&role->mgnt_entry, &mgnt->active_list); break;” and the commit message clarifies “break just aborted the inner for-loop. The outer list_for_each_entry still continues.”

3) Trigger Condition:
- “Special cases” where the normalization finds entries matching the target pattern beyond the first, or where reordering while iterating causes the cursor to revisit or loop over the same elements.
- Under these conditions, the continued outer iteration on a mutated list can cause an effective infinite loop, observed as a soft lockup. The log shows soft lockup in rtw89_entity_recalc (chan.c:392, chan.c:479).

4) Impact Mechanism:
- Busy-loop/soft lockup in kernel context (watchdog: BUG: soft lockup) with processes like wpa_supplicant stuck, resulting in denial-of-service of the Wi-Fi stack on the affected CPU.

5. Patch Analysis
1) Fix Approach:
- Ensure termination of the outer list_for_each_entry immediately after performing the reordering by jumping out of the outer loop.
- Replace the inner-loop break with a goto to a label placed after the outer list traversal, preventing further iteration on the modified list.

2) Key Code Changes:
- Changed “break;” to “goto fill;” after list_del/list_add in rtw89_entity_recalc_mgnt_roles().
- Introduced/placed “fill:” label just before the next list_for_each_entry that processes mgnt->active_list.
- This guarantees the function exits the outer traversal as intended once a match-driven reordering occurs.

3) Locking/Concurrency Impact:
- No locking primitives were added or changed.
- The fix addresses control-flow correctness during list mutation; it avoids iterating a list that has just been reordered, removing the non-progress condition without altering concurrency semantics.

6. Broader Kernel Security Implications
- Iterating and mutating kernel linked lists concurrently requires careful control flow. Exiting all relevant loops or using *_safe iteration macros is essential to prevent non-progress conditions and lockups.
- Similar logic/flow bugs in other drivers may lead to kernel hangs or soft lockups; audits should ensure that list mutations during traversal either use safe iteration patterns or terminate traversal immediately after mutation.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.