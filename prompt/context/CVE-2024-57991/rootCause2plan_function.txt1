You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57991

[INFO]
[PATCH_DESCRIPTION]
 wifi: rtw89: chan: fix soft lockup in rtw89_entity_recalc_mgnt_roles()
 During rtw89_entity_recalc_mgnt_roles(), there is a normalizing process
 which will re-order the list if an entry with target pattern is found.
 And once one is found, should have aborted the list_for_each_entry. But,
 `break` just aborted the inner for-loop. The outer list_for_each_entry
 still continues. Normally, only the first entry will match the target
 pattern, and the re-ordering will change nothing, so there won't be
 soft lockup. However, in some special cases, soft lockup would happen.

 Fix it by `goto fill` to break from the list_for_each_entry.

 The following is a sample of kernel log for this problem.
 
 watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [wpa_supplicant:2055]
 [...]
 RIP: 0010:rtw89_entity_recalc ([...] chan.c:392 chan.c:479) rtw89_core
 [...]
 
 Fixes: 68ec751b2881 ("wifi: rtw89: chan: manage active interfaces")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/realtek/rtw89/chan.c b/drivers/net/wireless/realtek/rtw89/chan.c
    index abc78716596d00..c06d305519df46 100644
    --- a/drivers/net/wireless/realtek/rtw89/chan.c
    +++ b/drivers/net/wireless/realtek/rtw89/chan.c
    @@ -391,11 +391,12 @@ static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
     
     				list_del(&role->mgnt_entry);
     				list_add(&role->mgnt_entry, &mgnt->active_list);
    -				break;
    +				goto fill;
     			}
     		}
     	}
     
    +fill:
     	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
     		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
     			rtw89_warn(rtwdev,

[FUNCTION_CONTENT]
static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
{
	struct rtw89_hal *hal = &rtwdev->hal;
	struct rtw89_entity_mgnt *mgnt = &hal->entity_mgnt;
	struct rtw89_vif_link *link;
	struct rtw89_vif *role;
	u8 pos = 0;
	int i, j;

	lockdep_assert_held(&rtwdev->mutex);

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++)
		mgnt->active_roles[i] = NULL;

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++) {
		for (j = 0; j < __RTW89_MLD_MAX_LINK_NUM; j++)
			mgnt->chanctx_tbl[i][j] = RTW89_CHANCTX_IDLE;
	}

	/* To be consistent with legacy behavior, expect the first active role
	 * which uses RTW89_CHANCTX_0 to put at position 0, and make its first
	 * link instance take RTW89_CHANCTX_0. (normalizing)
	 */
	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			if (link->chanctx_idx == RTW89_CHANCTX_0) {
				rtw89_normalize_link_chanctx(rtwdev, link);

				list_del(&role->mgnt_entry);
				list_add(&role->mgnt_entry, &mgnt->active_list);
				break;
			}
		}
	}

	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
			rtw89_warn(rtwdev,
				   "%s: active roles are over max iface num\n",
				   __func__);
			break;
		}

		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			mgnt->chanctx_tbl[pos][i] = link->chanctx_idx;
		}

		mgnt->active_roles[pos++] = role;
	}
}

/* ----- separator ----- */

EXPORT_SYMBOL(__rtw89_mgnt_chan_get);

static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
{
	struct rtw89_hal *hal = &rtwdev->hal;
	struct rtw89_entity_mgnt *mgnt = &hal->entity_mgnt;
	struct rtw89_vif_link *link;
	struct rtw89_vif *role;
	u8 pos = 0;
	int i, j;

	lockdep_assert_held(&rtwdev->mutex);

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++)
		mgnt->active_roles[i] = NULL;

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++) {
		for (j = 0; j < __RTW89_MLD_MAX_LINK_NUM; j++)
			mgnt->chanctx_tbl[i][j] = RTW89_CHANCTX_IDLE;
	}

	/* To be consistent with legacy behavior, expect the first active role
	 * which uses RTW89_CHANCTX_0 to put at position 0, and make its first
	 * link instance take RTW89_CHANCTX_0. (normalizing)
	 */
	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			if (link->chanctx_idx == RTW89_CHANCTX_0) {
				rtw89_normalize_link_chanctx(rtwdev, link);

				list_del(&role->mgnt_entry);
				list_add(&role->mgnt_entry, &mgnt->active_list);
				break;
			}
		}
	}

	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
			rtw89_warn(rtwdev,
				   "%s: active roles are over max iface num\n",
				   __func__);
			break;
		}

		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			mgnt->chanctx_tbl[pos][i] = link->chanctx_idx;
		}

		mgnt->active_roles[pos++] = role;
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
CWE-835: Loop with Unreachable Exit Condition (Infinite Loop) leading to soft lockup (Denial of Service)

3. Root Cause Summary
In rtw89_entity_recalc_mgnt_roles(), the code reorders mgnt->active_list when it finds a role/link with chanctx_idx == RTW89_CHANCTX_0, using list_del() followed by list_add() while iterating with list_for_each_entry(). The pre-patch code only broke out of the inner link loop and continued the outer list_for_each_entry traversal on the mutated list. This unsafe combination (modifying the current list element without using a *_safe iterator and then continuing iteration) can cause the traversal to revisit/misiterate nodes, producing a non-terminating loop and CPU soft lockup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 Wi-Fi driver, channel/entity management (drivers/net/wireless/realtek/rtw89/chan.c)

2) Pre-Patch Flaw:
Inside rtw89_entity_recalc_mgnt_roles(), upon finding a link with RTW89_CHANCTX_0, the code executes:
- list_del(&role->mgnt_entry);
- list_add(&role->mgnt_entry, &mgnt->active_list);
- break;
This break exits only the inner for-loop, not the outer list_for_each_entry over mgnt->active_list, resulting in continued iteration over a mutated list using a non-safe iterator.

3) Trigger Condition:
When a qualifying role/link is found during the first traversal and the list is reordered, especially in cases where the normalization changes list ordering (e.g., more than one candidate or non-head match), the outer list_for_each_entry continues iterating the modified list, causing the iteration to fail to make forward progress.

4) Impact Mechanism:
The outer traversal can repeatedly visit nodes or loop indefinitely due to iterator invalidation after list mutation, leading to a soft lockup (watchdog trigger) with CPU stuck in rtw89_entity_recalc_mgnt_roles(), as observed in kernel logs (e.g., wpa_supplicant invoking the path).

5. Patch Analysis
1) Fix Approach:
Terminate the outer list_for_each_entry immediately after performing the normalization/reordering to avoid iterating the modified list with a non-safe iterator.

2) Key Code Changes:
- Replace the inner “break;” with “goto fill;” to exit the outer list_for_each_entry loop.
- Introduce a “fill:” label placed immediately before the second list_for_each_entry that populates mgnt->active_roles and chanctx_tbl.
This ensures no further iteration occurs on the modified list in the first pass.

3) Locking/Concurrency Impact:
No changes to locking; the function still asserts rtwdev->mutex is held (lockdep_assert_held(&rtwdev->mutex)). The fix addresses control flow/iteration safety rather than a locking deficiency, preventing unsafe iteration after list mutation while under the existing mutex.

6. Broader Kernel Security Implications
The bug allows a reliable denial-of-service via soft lockup in the Wi-Fi management path, potentially triggerable by userspace network configuration tools (e.g., wpa_supplicant). While it does not indicate memory corruption or privilege escalation, it can stall a CPU and disrupt networking and overall system responsiveness. The fix reduces risk by ensuring proper loop termination semantics when reordering kernel lists during iteration.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}