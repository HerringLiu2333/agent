You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57991

[INFO]
[PATCH_DESCRIPTION]
 wifi: rtw89: chan: fix soft lockup in rtw89_entity_recalc_mgnt_roles()
 During rtw89_entity_recalc_mgnt_roles(), there is a normalizing process
 which will re-order the list if an entry with target pattern is found.
 And once one is found, should have aborted the list_for_each_entry. But,
 `break` just aborted the inner for-loop. The outer list_for_each_entry
 still continues. Normally, only the first entry will match the target
 pattern, and the re-ordering will change nothing, so there won't be
 soft lockup. However, in some special cases, soft lockup would happen.

 Fix it by `goto fill` to break from the list_for_each_entry.

 The following is a sample of kernel log for this problem.
 
 watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [wpa_supplicant:2055]
 [...]
 RIP: 0010:rtw89_entity_recalc ([...] chan.c:392 chan.c:479) rtw89_core
 [...]
 
 Fixes: 68ec751b2881 ("wifi: rtw89: chan: manage active interfaces")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/realtek/rtw89/chan.c b/drivers/net/wireless/realtek/rtw89/chan.c
    index abc78716596d00..c06d305519df46 100644
    --- a/drivers/net/wireless/realtek/rtw89/chan.c
    +++ b/drivers/net/wireless/realtek/rtw89/chan.c
    @@ -391,11 +391,12 @@ static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
     
     				list_del(&role->mgnt_entry);
     				list_add(&role->mgnt_entry, &mgnt->active_list);
    -				break;
    +				goto fill;
     			}
     		}
     	}
     
    +fill:
     	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
     		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
     			rtw89_warn(rtwdev,

[FUNCTION_CONTENT]
static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
{
	struct rtw89_hal *hal = &rtwdev->hal;
	struct rtw89_entity_mgnt *mgnt = &hal->entity_mgnt;
	struct rtw89_vif_link *link;
	struct rtw89_vif *role;
	u8 pos = 0;
	int i, j;

	lockdep_assert_held(&rtwdev->mutex);

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++)
		mgnt->active_roles[i] = NULL;

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++) {
		for (j = 0; j < __RTW89_MLD_MAX_LINK_NUM; j++)
			mgnt->chanctx_tbl[i][j] = RTW89_CHANCTX_IDLE;
	}

	/* To be consistent with legacy behavior, expect the first active role
	 * which uses RTW89_CHANCTX_0 to put at position 0, and make its first
	 * link instance take RTW89_CHANCTX_0. (normalizing)
	 */
	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			if (link->chanctx_idx == RTW89_CHANCTX_0) {
				rtw89_normalize_link_chanctx(rtwdev, link);

				list_del(&role->mgnt_entry);
				list_add(&role->mgnt_entry, &mgnt->active_list);
				break;
			}
		}
	}

	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
			rtw89_warn(rtwdev,
				   "%s: active roles are over max iface num\n",
				   __func__);
			break;
		}

		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			mgnt->chanctx_tbl[pos][i] = link->chanctx_idx;
		}

		mgnt->active_roles[pos++] = role;
	}
}

/* ----- separator ----- */

EXPORT_SYMBOL(__rtw89_mgnt_chan_get);

static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
{
	struct rtw89_hal *hal = &rtwdev->hal;
	struct rtw89_entity_mgnt *mgnt = &hal->entity_mgnt;
	struct rtw89_vif_link *link;
	struct rtw89_vif *role;
	u8 pos = 0;
	int i, j;

	lockdep_assert_held(&rtwdev->mutex);

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++)
		mgnt->active_roles[i] = NULL;

	for (i = 0; i < RTW89_MAX_INTERFACE_NUM; i++) {
		for (j = 0; j < __RTW89_MLD_MAX_LINK_NUM; j++)
			mgnt->chanctx_tbl[i][j] = RTW89_CHANCTX_IDLE;
	}

	/* To be consistent with legacy behavior, expect the first active role
	 * which uses RTW89_CHANCTX_0 to put at position 0, and make its first
	 * link instance take RTW89_CHANCTX_0. (normalizing)
	 */
	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			if (link->chanctx_idx == RTW89_CHANCTX_0) {
				rtw89_normalize_link_chanctx(rtwdev, link);

				list_del(&role->mgnt_entry);
				list_add(&role->mgnt_entry, &mgnt->active_list);
				break;
			}
		}
	}

	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
			rtw89_warn(rtwdev,
				   "%s: active roles are over max iface num\n",
				   __func__);
			break;
		}

		for (i = 0; i < role->links_inst_valid_num; i++) {
			link = rtw89_vif_get_link_inst(role, i);
			if (!link || !link->chanctx_assigned)
				continue;

			mgnt->chanctx_tbl[pos][i] = link->chanctx_idx;
		}

		mgnt->active_roles[pos++] = role;
	}
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57991

2. Vulnerability Type
CWE-835: Loop with Unreachable Exit Condition (Infinite Loop) leading to soft lockup (Denial of Service)

3. Root Cause Summary
In rtw89_entity_recalc_mgnt_roles(), the code reorders mgnt->active_list when it finds a role/link with chanctx_idx == RTW89_CHANCTX_0, using list_del() followed by list_add() while iterating with list_for_each_entry(). The pre-patch code only broke out of the inner link loop and continued the outer list_for_each_entry traversal on the mutated list. This unsafe combination (modifying the current list element without using a *_safe iterator and then continuing iteration) can cause the traversal to revisit/misiterate nodes, producing a non-terminating loop and CPU soft lockup.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Realtek rtw89 Wi-Fi driver, channel/entity management (drivers/net/wireless/realtek/rtw89/chan.c)

2) Pre-Patch Flaw:
Inside rtw89_entity_recalc_mgnt_roles(), upon finding a link with RTW89_CHANCTX_0, the code executes:
- list_del(&role->mgnt_entry);
- list_add(&role->mgnt_entry, &mgnt->active_list);
- break;
This break exits only the inner for-loop, not the outer list_for_each_entry over mgnt->active_list, resulting in continued iteration over a mutated list using a non-safe iterator.

3) Trigger Condition:
When a qualifying role/link is found during the first traversal and the list is reordered, especially in cases where the normalization changes list ordering (e.g., more than one candidate or non-head match), the outer list_for_each_entry continues iterating the modified list, causing the iteration to fail to make forward progress.

4) Impact Mechanism:
The outer traversal can repeatedly visit nodes or loop indefinitely due to iterator invalidation after list mutation, leading to a soft lockup (watchdog trigger) with CPU stuck in rtw89_entity_recalc_mgnt_roles(), as observed in kernel logs (e.g., wpa_supplicant invoking the path).

5. Patch Analysis
1) Fix Approach:
Terminate the outer list_for_each_entry immediately after performing the normalization/reordering to avoid iterating the modified list with a non-safe iterator.

2) Key Code Changes:
- Replace the inner “break;” with “goto fill;” to exit the outer list_for_each_entry loop.
- Introduce a “fill:” label placed immediately before the second list_for_each_entry that populates mgnt->active_roles and chanctx_tbl.
This ensures no further iteration occurs on the modified list in the first pass.

3) Locking/Concurrency Impact:
No changes to locking; the function still asserts rtwdev->mutex is held (lockdep_assert_held(&rtwdev->mutex)). The fix addresses control flow/iteration safety rather than a locking deficiency, preventing unsafe iteration after list mutation while under the existing mutex.

6. Broader Kernel Security Implications
The bug allows a reliable denial-of-service via soft lockup in the Wi-Fi management path, potentially triggerable by userspace network configuration tools (e.g., wpa_supplicant). While it does not indicate memory corruption or privilege escalation, it can stall a CPU and disrupt networking and overall system responsiveness. The fix reduces risk by ensuring proper loop termination semantics when reordering kernel lists during iteration.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.