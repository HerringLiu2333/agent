You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38269

[INFO]
[PATCH_DESCRIPTION]
    btrfs: exit after state insertion failure at btrfs_convert_extent_bit()
    If insert_state() state failed it returns an error pointer and we call
    extent_io_tree_panic() which will trigger a BUG() call. However if
    CONFIG_BUG is disabled, which is an uncommon and exotic scenario, then
    we fallthrough and call cache_state() which will dereference the error
    pointer, resulting in an invalid memory access.
    
    So jump to the 'out' label after calling extent_io_tree_panic(), it also
    makes the code more clear besides dealing with the exotic scenario where
    CONFIG_BUG is disabled.

[PATCH_DIFF]
    @@ -1439,6 +1439,7 @@ hit_next:
     		if (IS_ERR(inserted_state)) {
     			ret = PTR_ERR(inserted_state);
     			extent_io_tree_panic(tree, prealloc, "insert", ret);
    +			goto out;
     		}
     		cache_state(inserted_state, cached_state);
     		if (inserted_state == prealloc)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38269

2. Vulnerability Type
Invalid pointer dereference (ERR_PTR) leading to kernel crash/DoS

3. Root Cause Summary
In btrfs_convert_extent_bit(), when insert_state() fails it returns an ERR_PTR. The code calls extent_io_tree_panic(), but if CONFIG_BUG is disabled it continues execution and calls cache_state(inserted_state, cached_state), dereferencing the ERR_PTR. The missing early exit/guard after detecting IS_ERR(inserted_state) is the root cause.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Btrfs extent I/O tree and extent state management (btrfs_convert_extent_bit, insert_state, cache_state)

2) Pre-Patch Flaw:
The error path relied on extent_io_tree_panic() to halt execution (via BUG()), but did not enforce an early return/goto; thus, the code fell through and used the error pointer. Specifically, after IS_ERR(inserted_state), the subsequent cache_state(inserted_state, cached_state) had no validation.

3) Trigger Condition:
insert_state() returns an ERR_PTR and the kernel is built with CONFIG_BUG disabled, so extent_io_tree_panic() does not stop execution.

4) Impact Mechanism:
cache_state() dereferences the ERR_PTR “inserted_state”, causing invalid memory access and a kernel crash/oops (Denial of Service). Depending on how the pointer is used, this can corrupt memory before the crash.

5. Patch Analysis
1) Fix Approach:
Enforce an immediate exit from the error path by jumping to the function’s out label when IS_ERR(inserted_state) is detected, preventing any dereference of the ERR_PTR.

2) Key Code Changes:
Added “goto out;” immediately after extent_io_tree_panic(tree, prealloc, "insert", ret) in the IS_ERR(inserted_state) branch:
- Before: extent_io_tree_panic(...); [fallthrough] cache_state(inserted_state, cached_state)
- After: extent_io_tree_panic(...); goto out; (skips cache_state on ERR_PTR)

3) Locking/Concurrency Impact:
No locking or concurrency changes; this is a control-flow correction on the error path to avoid unsafe pointer use.

6. Broader Kernel Security Implications
Relying on BUG() to enforce control flow is unsafe for configurations where BUG is disabled; error paths must explicitly prevent further execution. Ensuring robust ERR_PTR handling prevents kernel crashes/DoS from error-path fallthroughs. This change underscores the need for consistent defensive programming across all kernel config variants to avoid latent vulnerabilities in “exotic” builds.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.