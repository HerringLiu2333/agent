You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38265

[INFO]
[PATCH_DESCRIPTION]
    serial: jsm: fix NPE during jsm_uart_port_init
    No device was set which caused serial_base_ctrl_add to crash.
    
     BUG: kernel NULL pointer dereference, address: 0000000000000050
     Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI
     CPU: 16 UID: 0 PID: 368 Comm: (udev-worker) Not tainted 6.12.25-amd64 #1  Debian 6.12.25-1
     RIP: 0010:serial_base_ctrl_add+0x96/0x120
     Call Trace:
      <TASK>
      serial_core_register_port+0x1a0/0x580
      ? __setup_irq+0x39c/0x660
      ? __kmalloc_cache_noprof+0x111/0x310
      jsm_uart_port_init+0xe8/0x180 [jsm]
      jsm_probe_one+0x1f4/0x410 [jsm]
      local_pci_probe+0x42/0x90
      pci_device_probe+0x22f/0x270
      really_probe+0xdb/0x340
      ? pm_runtime_barrier+0x54/0x90
      ? __pfx___driver_attach+0x10/0x10
      __driver_probe_device+0x78/0x110
      driver_probe_device+0x1f/0xa0
      __driver_attach+0xba/0x1c0
      bus_for_each_dev+0x8c/0xe0
      bus_add_driver+0x112/0x1f0
      driver_register+0x72/0xd0
      jsm_init_module+0x36/0xff0 [jsm]
      ? __pfx_jsm_init_module+0x10/0x10 [jsm]
      do_one_initcall+0x58/0x310
      do_init_module+0x60/0x230
    
    Tested with Digi Neo PCIe 8 port card.

[PATCH_DIFF]
    @@ -451,6 +451,7 @@ int jsm_uart_port_init(struct jsm_board *brd)
     		if (!brd->channels[i])
     			continue;
     
+		brd->channels[i]->uart_port.dev = &brd->pci_dev->dev;
     		brd->channels[i]->uart_port.irq = brd->irq;
     		brd->channels[i]->uart_port.uartclk = 14745600;
     		brd->channels[i]->uart_port.type = PORT_JSM;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38265

2. Vulnerability Type
Kernel NULL pointer dereference (Denial of Service)

3. Root Cause Summary
The jsm driver failed to initialize uart_port.dev before registering the UART port with the serial core. serial_core_register_port() (via serial_base_ctrl_add) assumes a non-NULL port->dev and dereferences it, leading to a NULL pointer dereference during device probe. The patch sets uart_port.dev to the PCI device’s struct device, eliminating the NULL dereference.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
TTY/Serial core and the jsm PCI serial driver (module “jsm”)

2) Pre-Patch Flaw:
jsm_uart_port_init() populated several uart_port fields (irq, uartclk, type) but omitted setting uart_port.dev for each channel, leaving it NULL prior to registration.

3) Trigger Condition:
During device probe (jsm_probe_one -> jsm_uart_port_init -> serial_core_register_port -> serial_base_ctrl_add), serial_base_ctrl_add dereferenced port->dev when it was NULL, as shown by the call trace and RIP in serial_base_ctrl_add.

4) Impact Mechanism:
Dereferencing a NULL device pointer inside serial_base_ctrl_add caused a kernel NULL pointer dereference (address 0x50), resulting in an oops and system crash/DoS during probe of affected hardware (e.g., Digi Neo PCIe 8-port card).

5. Patch Analysis
1) Fix Approach:
Initialize the uart_port.dev pointer to the parent PCI device prior to registering the port so serial core has a valid struct device to operate on.

2) Key Code Changes:
- In jsm_uart_port_init(), for each valid channel, added:
  brd->channels[i]->uart_port.dev = &brd->pci_dev->dev;
This precedes setting irq, uartclk, and type, ensuring port->dev is non-NULL before registration.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the fix is a straightforward initialization of a required field. No ordering or atomicity adjustments were made or needed.

6. Broader Kernel Security Implications
- Highlights a common class of bugs where driver structures passed to core subsystems must have required fields initialized; failure leads to kernel crashes during probe. 
- Ensuring uart_port.dev is set is a baseline requirement across serial drivers; similar omissions elsewhere could cause DoS on device hotplug or boot. 
- The issue is limited to stability/availability (DoS) with no indication of memory corruption or privilege escalation in the provided materials.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.