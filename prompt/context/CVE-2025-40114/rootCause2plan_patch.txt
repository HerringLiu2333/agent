You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-40114

[INFO]
[PATCH_DESCRIPTION]
    iio: light: Add check for array bounds in veml6075_read_int_time_ms
    The array contains only 5 elements, but the index calculated by
    veml6075_read_int_time_index can range from 0 to 7,
    which could lead to out-of-bounds access. The check prevents this issue.
    
    Coverity Issue
    CID 1574309: (#1 of 1): Out-of-bounds read (OVERRUN)
    overrun-local: Overrunning array veml6075_it_ms of 5 4-byte
    elements at element index 7 (byte offset 31) using
    index int_index (which evaluates to 7)
    
    This is hardening against potentially broken hardware. Good to have
    but not necessary to backport.

[PATCH_DIFF]
     @@ -195,13 +195,17 @@ static int veml6075_read_uv_direct(struct veml6075_data *data, int chan,
      
      static int veml6075_read_int_time_index(struct veml6075_data *data)
      {
     -	int ret, conf;
     +	int ret, conf, int_index;
      
      	ret = regmap_read(data->regmap, VEML6075_CMD_CONF, &conf);
      	if (ret < 0)
      		return ret;
      
     -	return FIELD_GET(VEML6075_CONF_IT, conf);
     +	int_index = FIELD_GET(VEML6075_CONF_IT, conf);
     +	if (int_index >= ARRAY_SIZE(veml6075_it_ms))
     +		return -EINVAL;
     +
     +	return int_index;
      }
      
      static int veml6075_read_int_time_ms(struct veml6075_data *data, int *val)



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-40114

2. Vulnerability Type
Out-of-bounds read (array index bounds violation)

3. Root Cause Summary
The function veml6075_read_int_time_index returned a hardware-derived index (FIELD_GET(VEML6075_CONF_IT, conf)) without validating its range. The corresponding array veml6075_it_ms contains only 5 elements, while the hardware field can produce values in the range 0–7. This lack of bounds checking allowed veml6075_read_int_time_ms to index past the end of veml6075_it_ms, causing an out-of-bounds read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) subsystem, VEML6075 UV light sensor driver

2) Pre-Patch Flaw:
veml6075_read_int_time_index directly returned “FIELD_GET(VEML6075_CONF_IT, conf)” without range validation, and downstream code used that value to index veml6075_it_ms.

3) Trigger Condition:
The device configuration register VEML6075_CMD_CONF contains an integration time field (VEML6075_CONF_IT) that can yield values 5–7 (e.g., due to broken/misalbehaving hardware), exceeding the 0–4 valid index range for veml6075_it_ms.

4) Impact Mechanism:
Using an index ≥ ARRAY_SIZE(veml6075_it_ms) causes an out-of-bounds read from the static array, potentially returning garbage values to userspace via the IIO interface and, in worst cases, reading adjacent kernel memory.

5. Patch Analysis
1) Fix Approach:
Introduce explicit bounds checking of the computed integration time index against ARRAY_SIZE(veml6075_it_ms) and reject invalid values by returning -EINVAL.

2) Key Code Changes:
- Added a local variable int_index to hold the extracted field value.
- Inserted “if (int_index >= ARRAY_SIZE(veml6075_it_ms)) return -EINVAL;”.
- Replaced the direct return of FIELD_GET with returning the validated int_index.

3) Locking/Concurrency Impact:
No locking or concurrency changes; the patch is purely input validation around regmap_read results.

6. Broader Kernel Security Implications
Validating indices derived from device register bitfields prevents memory safety errors when hardware returns unexpected values. This hardening reduces the risk of data corruption or unintended kernel memory disclosure via IIO interfaces. It reinforces a best practice across drivers: never trust hardware-derived indices without bounds checks and use ARRAY_SIZE to guard array accesses.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.