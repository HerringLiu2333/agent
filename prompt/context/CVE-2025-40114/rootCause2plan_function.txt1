You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-40114

[INFO]
[PATCH_DESCRIPTION]
    iio: light: Add check for array bounds in veml6075_read_int_time_ms
    The array contains only 5 elements, but the index calculated by
    veml6075_read_int_time_index can range from 0 to 7,
    which could lead to out-of-bounds access. The check prevents this issue.
    
    Coverity Issue
    CID 1574309: (#1 of 1): Out-of-bounds read (OVERRUN)
    overrun-local: Overrunning array veml6075_it_ms of 5 4-byte
    elements at element index 7 (byte offset 31) using
    index int_index (which evaluates to 7)
    
    This is hardening against potentially broken hardware. Good to have
    but not necessary to backport.

[PATCH_DIFF]
     @@ -195,13 +195,17 @@ static int veml6075_read_uv_direct(struct veml6075_data *data, int chan,
      
      static int veml6075_read_int_time_index(struct veml6075_data *data)
      {
     -	int ret, conf;
     +	int ret, conf, int_index;
      
      	ret = regmap_read(data->regmap, VEML6075_CMD_CONF, &conf);
      	if (ret < 0)
      		return ret;
      
     -	return FIELD_GET(VEML6075_CONF_IT, conf);
     +	int_index = FIELD_GET(VEML6075_CONF_IT, conf);
     +	if (int_index >= ARRAY_SIZE(veml6075_it_ms))
     +		return -EINVAL;
     +
     +	return int_index;
      }
      
      static int veml6075_read_int_time_ms(struct veml6075_data *data, int *val)

[FUNCTION_CONTENT]
static int veml6075_read_int_time_index(struct veml6075_data *data)
{
	int ret, conf;

	ret = regmap_read(data->regmap, VEML6075_CMD_CONF, &conf);
	if (ret < 0)
		return ret;

	return FIELD_GET(VEML6075_CONF_IT, conf);
}

/* ----- separator ----- */

static int veml6075_read_int_time_ms(struct veml6075_data *data, int *val)
{
	int int_index;

	guard(mutex)(&data->lock);
	int_index = veml6075_read_int_time_index(data);
	if (int_index < 0)
		return int_index;

	*val = veml6075_it_ms[int_index];

	return IIO_VAL_INT;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-40114

2. Vulnerability Type
Out-of-bounds read

3. Root Cause Summary
The driver returned a hardware-derived index from veml6075_read_int_time_index without validating it against the size of the local lookup array veml6075_it_ms. veml6075_read_int_time_ms then used this unchecked index to access veml6075_it_ms, resulting in a possible out-of-bounds read when the hardware provided values ≥ 5. This missing bounds validation on the configuration field VEML6075_CONF_IT is the root cause.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Industrial I/O (IIO) subsystem, light sensor driver for VEML6075

2) Pre-Patch Flaw:
- In veml6075_read_int_time_index, the code returned FIELD_GET(VEML6075_CONF_IT, conf) directly, with no check against ARRAY_SIZE(veml6075_it_ms).
- In veml6075_read_int_time_ms, the returned index was used as "*val = veml6075_it_ms[int_index]" without verification, enabling out-of-bounds array access if int_index exceeded 4.

3) Trigger Condition:
- The VEML6075_CMD_CONF register’s VEML6075_CONF_IT field yields a value in the range 5–7 (as noted in the patch description), due to broken or nonconforming hardware behavior.

4) Impact Mechanism:
- The unchecked index causes an out-of-bounds read from the 5-element array veml6075_it_ms in kernel memory, leading to undefined behavior and potential information exposure via the returned value to user space through the IIO read path.

5. Patch Analysis
1) Fix Approach:
Bounds checking was added to validate the integration time index against the size of the lookup array and to return an error on invalid values.

2) Key Code Changes:
- In veml6075_read_int_time_index:
  - Introduced local variable int_index to store FIELD_GET(VEML6075_CONF_IT, conf).
  - Added "if (int_index >= ARRAY_SIZE(veml6075_it_ms)) return -EINVAL;" to reject out-of-range indices.
  - Returned int_index only after successful validation.
- No changes were required in veml6075_read_int_time_ms; it now safely uses the validated index.

3) Locking/Concurrency Impact:
No changes to locking or concurrency. The existing mutex guard in veml6075_read_int_time_ms remains, and the new bounds check only affects the return path of veml6075_read_int_time_index.

6. Broader Kernel Security Implications
Validating hardware-derived indices before using them to access kernel arrays prevents out-of-bounds reads that can leak kernel data or cause instability. This hardening reduces risk from misbehaving devices and improves resilience of the IIO subsystem against faulty hardware inputs. It exemplifies the importance of defensive checks around register-derived parameters to avoid memory-safety issues in drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}