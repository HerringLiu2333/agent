You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38249

[INFO]
[PATCH_DESCRIPTION]
    ALSA: usb-audio: Fix out-of-bounds read in snd_usb_get_audioformat_uac3()
    In snd_usb_get_audioformat_uac3(), the length value returned from
    snd_usb_ctl_msg() is used directly for memory allocation without
    validation. This length is controlled by the USB device.
    
    The allocated buffer is cast to a uac3_cluster_header_descriptor
    and its fields are accessed without verifying that the buffer
    is large enough. If the device returns a smaller than expected
    length, this leads to an out-of-bounds read.
    
    Add a length check to ensure the buffer is large enough for
    uac3_cluster_header_descriptor.

[PATCH_DIFF]
    @@ -987,6 +987,8 @@ snd_usb_get_audioformat_uac3(struct snd_usb_audio *chip,
     	 * and request Cluster Descriptor
     	 *
     	wLength = le16_to_cpu(hc_header.wLength);
    +	if (wLength < sizeof(*cluster))
    +		return NULL;
     	cluster = kzalloc(wLength, GFP_KERNEL);
     	if (!cluster)
     		return ERR_PTR(-ENOMEM);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38249

2. Vulnerability Type
Out-of-bounds read (size/length validation flaw)

3. Root Cause Summary
snd_usb_get_audioformat_uac3() used a device-controlled length (wLength) to allocate a buffer and then accessed it as a uac3_cluster_header_descriptor without ensuring the buffer was large enough. Pre-patch, the code did kzalloc(wLength) immediately after setting wLength = le16_to_cpu(hc_header.wLength), and then parsed fields of the presumed cluster header. If a malicious or buggy USB device returned a smaller-than-required length, subsequent field accesses read beyond the allocated buffer, causing an out-of-bounds read.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ALSA USB audio (sound/usb, UAC3 descriptor parsing)

2) Pre-Patch Flaw:
- Missing minimum-size validation of the device-supplied descriptor length before treating the buffer as a uac3_cluster_header_descriptor.
- The function trusted hc_header.wLength and allocated exactly wLength bytes, then accessed structure fields unconditionally.

3) Trigger Condition:
- A USB audio device (or emulator) returns a UAC3 descriptor with wLength smaller than sizeof(uac3_cluster_header_descriptor) during snd_usb_get_audioformat_uac3() processing.

4) Impact Mechanism:
- The function reads fields past the end of the allocated buffer, resulting in a kernel out-of-bounds read. This can lead to kernel memory access violations and potential crashes; information disclosure potential is unknown based on provided materials.

5. Patch Analysis
1) Fix Approach:
- Defensive size validation: ensure wLength is at least sizeof(*cluster) before allocation and parsing.

2) Key Code Changes:
- In snd_usb_get_audioformat_uac3(), immediately after setting wLength = le16_to_cpu(hc_header.wLength), the patch adds:
  - if (wLength < sizeof(*cluster)) return NULL;
- This prevents allocation of undersized buffers and subsequent OOB reads when parsing the cluster header.

3) Locking/Concurrency Impact:
- None. The change introduces a simple bounds check and early return, with no locking or ordering adjustments.

6. Broader Kernel Security Implications
- Reinforces the need for strict validation of device-controlled lengths in USB descriptor parsing paths to prevent memory safety violations.
- Similar descriptor parsing routines across ALSA USB and other USB class drivers should ensure minimum-size checks prior to casting/field access.
- System-wide, this reduces attack surface from malicious USB devices that can supply malformed descriptors to trigger kernel memory errors.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}