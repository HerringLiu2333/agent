You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38317

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: Fix buffer overflow in debugfs
    If the user tries to write more than 32 bytes then it results in memory
    corruption.  Fortunately, this is debugfs so it's limited to root users.

[PATCH_DIFF]
     @@ -5377,6 +5377,9 @@ static ssize_t ath12k_write_htt_stats_type(struct file *file,
      	const int size = 32;
      	int num_args;
      
     +	if (count > size)
     +		return -EINVAL;
     +
      	char *buf __free(kfree) = kzalloc(size, GFP_KERNEL);
      	if (!buf)
      		return -ENOMEM;

[FUNCTION_CONTENT]
static ssize_t ath12k_write_htt_stats_type(struct file *file,
					   const char __user *user_buf,
					   size_t count, loff_t *ppos)
{
	struct ath12k *ar = file->private_data;
	enum ath12k_dbg_htt_ext_stats_type type;
	unsigned int cfg_param[4] = {0};
	const int size = 32;
	int num_args;

	char *buf __free(kfree) = kzalloc(size, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	if (copy_from_user(buf, user_buf, count))
		return -EFAULT;

	num_args = sscanf(buf, "%u %u %u %u %u\n", &type, &cfg_param[0],
			  &cfg_param[1], &cfg_param[2], &cfg_param[3]);
	if (!num_args || num_args > 5)
		return -EINVAL;

	if (type == ATH12K_DBG_HTT_EXT_STATS_RESET ||
	    type >= ATH12K_DBG_HTT_NUM_EXT_STATS)
		return -EINVAL;

	wiphy_lock(ath12k_ar_to_hw(ar)->wiphy);

	ar->debug.htt_stats.type = type;
	ar->debug.htt_stats.cfg_param[0] = cfg_param[0];
	ar->debug.htt_stats.cfg_param[1] = cfg_param[1];
	ar->debug.htt_stats.cfg_param[2] = cfg_param[2];
	ar->debug.htt_stats.cfg_param[3] = cfg_param[3];

	wiphy_unlock(ath12k_ar_to_hw(ar)->wiphy);

	return count;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38317

2. Vulnerability Type
Heap-based buffer overflow (memory corruption) in a debugfs write handler due to missing input length validation.

3. Root Cause Summary
The function ath12k_write_htt_stats_type allocates a fixed-size 32-byte buffer and then copies user-provided data into it using copy_from_user(buf, user_buf, count) without verifying that count ≤ 32. This missing bounds check allows writes larger than the buffer, causing a heap overflow. The patch adds an explicit size check (if (count > size) return -EINVAL;) before allocating and using the buffer, preventing out-of-bounds writes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
ath12k Wi-Fi driver debugfs interface (function: ath12k_write_htt_stats_type).

2) Pre-Patch Flaw:
A fixed-size buffer (size = 32) is allocated with kzalloc, but the subsequent copy_from_user uses the unvalidated count from userspace, enabling copying more than 32 bytes into the buffer.

3) Trigger Condition:
A debugfs write operation where the user supplies more than 32 bytes to the file handled by ath12k_write_htt_stats_type; debugfs is generally restricted to root, but the kernel still processes the oversized input.

4) Impact Mechanism:
copy_from_user writes beyond the 32-byte allocation, corrupting adjacent kernel heap memory (out-of-bounds write), potentially leading to crashes, data corruption, or undefined behavior within the kernel.

5. Patch Analysis
1) Fix Approach:
Input length validation is added to reject oversized writes; the function now returns -EINVAL if count exceeds the fixed buffer size, ensuring safe copying.

2) Key Code Changes:
- Inserted:
  if (count > size)
      return -EINVAL;
- This check is placed immediately after determining size and before allocating the buffer and performing copy_from_user.

3) Locking/Concurrency Impact:
No locking or concurrency changes were made. Existing wiphy_lock/unlock around debug parameter updates remain unchanged; the fix solely addresses bounds checking before memory copy.

6. Broader Kernel Security Implications
- Even in privileged-only interfaces like debugfs, kernel code must validate user-controlled lengths before copying into fixed-size buffers to prevent memory corruption.
- Reliance on copy_from_user with unbounded count is a common pitfall; introducing explicit size checks or using helpers that clamp lengths helps avoid similar vulnerabilities.
- Such overflows in kernel space can destabilize the system and erode kernel integrity, highlighting the need for rigorous input validation across all user-kernel interfaces.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.