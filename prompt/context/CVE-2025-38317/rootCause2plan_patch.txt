You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38317

[INFO]
[PATCH_DESCRIPTION]
    wifi: ath12k: Fix buffer overflow in debugfs
    If the user tries to write more than 32 bytes then it results in memory
    corruption.  Fortunately, this is debugfs so it's limited to root users.

[PATCH_DIFF]
     @@ -5377,6 +5377,9 @@ static ssize_t ath12k_write_htt_stats_type(struct file *file,
      	const int size = 32;
      	int num_args;
      
     +	if (count > size)
     +		return -EINVAL;
     +
      	char *buf __free(kfree) = kzalloc(size, GFP_KERNEL);
      	if (!buf)
      		return -ENOMEM;



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38317

2. Vulnerability Type
Heap-based buffer overflow in a debugfs write handler

3. Root Cause Summary
The debugfs write handler ath12k_write_htt_stats_type allocated a fixed-size 32-byte heap buffer and accepted an arbitrary user-supplied write length (count) without validating it against the buffer size. When a user wrote more than 32 bytes, subsequent processing wrote past the end of the allocated buffer, causing kernel heap memory corruption. The patch adds a strict upper bound check on count to prevent writes larger than the buffer.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
- Wireless networking (ath12k) debugfs interface

2) Pre-Patch Flaw:
- The function used a fixed buffer “const int size = 32; char *buf = kzalloc(size, GFP_KERNEL);” but lacked any check that the incoming write size (count) did not exceed 32 bytes before writing into buf.

3) Trigger Condition:
- Writing more than 32 bytes to the ath12k debugfs file handled by ath12k_write_htt_stats_type.

4) Impact Mechanism:
- Writing count > 32 bytes led to data being stored past the 32-byte heap allocation, corrupting adjacent kernel heap memory; outcomes include kernel crashes (DoS) or potentially controllable memory corruption.

5. Patch Analysis
1) Fix Approach:
- Input validation: reject writes larger than the fixed buffer by validating count against the 32-byte limit and returning an error.

2) Key Code Changes:
- Added:
  - “if (count > size) return -EINVAL;”
- Existing context shows “const int size = 32; … char *buf = kzalloc(size, GFP_KERNEL);” indicating the buffer is heap-allocated and fixed-size; the new guard aligns write size with buffer capacity.

3) Locking/Concurrency Impact:
- None. The change is a simple parameter validation prior to allocation/use; it does not alter locking, ordering, or concurrency behavior.

6. Broader Kernel Security Implications
- Even though debugfs is typically restricted to privileged users, unbounded writes in kernel interfaces can yield reliable kernel heap corruption primitives, risking local privilege escalation or system instability. This fix reinforces the need for strict length validation for all user-controlled inputs, including in debug paths, to prevent memory safety violations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.