You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57995

[INFO]
[PATCH_DESCRIPTION]
 wifi: ath12k: fix read pointer after free in ath12k_mac_assign_vif_to_vdev()
 [ Upstream commit 5a10971c7645a95f5d5dc23c26fbac4bf61801d0 ]
 
 In ath12k_mac_assign_vif_to_vdev(), if arvif is created on a different
 radio, it gets deleted from that radio through a call to
 ath12k_mac_unassign_link_vif(). This action frees the arvif pointer.
 Subsequently, there is a check involving arvif, which will result in a
 read-after-free scenario.

 Fix this by moving this check after arvif is again assigned via call to
 ath12k_mac_assign_link_vif().
 
 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
 
 Closes: https://scan5.scan.coverity.com/#/project-view/63541/10063?selectedIssue=1636423
 Fixes: b5068bc9180d ("wifi: ath12k: Cache vdev configs before vdev create")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c
    index d493ec812055f8..cf4f4245f6068b 100644
    --- a/drivers/net/wireless/ath/ath12k/mac.c
    +++ b/drivers/net/wireless/ath/ath12k/mac.c
    @@ -7173,9 +7173,6 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     
     	ab = ar->ab;
     
    -	if (arvif->is_created)
    -		goto flush;
    -
     	/* Assign arvif again here since previous radio switch block
     	 * would've unassigned and cleared it.
     	 /
    @@ -7186,6 +7183,9 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     		goto unlock;
     	}
     
    +	if (arvif->is_created)
    +		goto flush;
    +
     	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
     		ath12k_warn(ab, "failed to create vdev, reached max vdev limit %d\n",
     			    TARGET_NUM_VDEVS);

[FUNCTION_CONTENT]
static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
						    struct ath12k_link_vif *arvif,
						    struct ieee80211_chanctx_conf *ctx)
{
	struct ieee80211_vif *vif = ath12k_ahvif_to_vif(arvif->ahvif);
	struct ath12k_hw *ah = hw->priv;
	struct ath12k *ar;
	struct ath12k_base *ab;
	u8 link_id = arvif->link_id;
	int ret;

	lockdep_assert_wiphy(hw->wiphy);

	if (ah->num_radio == 1)
		ar = ah->radio;
	else if (ctx)
		ar = ath12k_get_ar_by_ctx(hw, ctx);
	else
		return NULL;

	if (!ar)
		return NULL;

	if (arvif->ar) {
		/* This is not expected really */
		if (WARN_ON(!arvif->is_created)) {
			arvif->ar = NULL;
			return NULL;
		}

		if (ah->num_radio == 1)
			return arvif->ar;

		/* This can happen as scan vdev gets created during multiple scans
		 * across different radios before a vdev is brought up in
		 * a certain radio.
		 */
		if (ar != arvif->ar) {
			if (WARN_ON(arvif->is_started))
				return NULL;

			ath12k_mac_remove_link_interface(hw, arvif);
			ath12k_mac_unassign_link_vif(arvif);
		}
	}

	ab = ar->ab;

	if (arvif->is_created)
		goto flush;

	/* Assign arvif again here since previous radio switch block
	 * would've unassigned and cleared it.
	 */
	arvif = ath12k_mac_assign_link_vif(ah, vif, link_id);
	if (vif->type == NL80211_IFTYPE_AP &&
	    ar->num_peers > (ar->max_num_peers - 1)) {
		ath12k_warn(ab, "failed to create vdev due to insufficient peer entry resource in firmware\n");
		goto unlock;
	}

	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
		ath12k_warn(ab, "failed to create vdev, reached max vdev limit %d\n",
			    TARGET_NUM_VDEVS);
		goto unlock;
	}

	ret = ath12k_mac_vdev_create(ar, arvif);
	if (ret) {
		ath12k_warn(ab, "failed to create vdev %pM ret %d", vif->addr, ret);
		goto unlock;
	}

flush:
	/* If the vdev is created during channel assign and not during
	 * add_interface(), Apply any parameters for the vdev which were received
	 * after add_interface, corresponding to this vif.
	 */
	ath12k_mac_vif_cache_flush(ar, arvif);
unlock:
	return arvif->ar;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57995

2. Vulnerability Type
Use-after-free (read-after-free) due to stale pointer access after unassignment

3. Root Cause Summary
In ath12k_mac_assign_vif_to_vdev(), when the vif’s link is moved across radios, the function may call ath12k_mac_unassign_link_vif(arvif) which frees and clears the arvif pointer. Immediately afterward, the pre-patch code performs a check on the freed pointer (“if (arvif->is_created) goto flush;”), causing a read-after-free. The subsequent flush path also dereferences the stale arvif in ath12k_mac_vif_cache_flush(), compounding the UAF risk. The patch fixes this by moving the is_created check to after arvif is re-assigned via ath12k_mac_assign_link_vif(), restoring pointer validity before use.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
drivers/net/wireless/ath/ath12k/mac.c (ath12k MAC/vdev assignment logic)

2) Pre-Patch Flaw:
Incorrect ordering/lifetime handling: after possibly freeing arvif via ath12k_mac_unassign_link_vif(arvif), the code immediately reads arvif->is_created before reassigning arvif, leading to use of a freed pointer.

3) Trigger Condition:
Multi-radio configurations when ar != arvif->ar, causing ath12k_mac_remove_link_interface(hw, arvif) followed by ath12k_mac_unassign_link_vif(arvif); then the stale check “if (arvif->is_created) goto flush;” runs before arvif is re-assigned.

4) Impact Mechanism:
Read-after-free of arvif->is_created and subsequent dereferences (e.g., ath12k_mac_vif_cache_flush(ar, arvif)) can cause kernel memory corruption, unpredictable behavior, or crashes due to accessing freed memory.

5. Patch Analysis
1) Fix Approach:
Reorder the logic to ensure arvif is reassigned (via ath12k_mac_assign_link_vif()) before any dereferences or state checks, thereby eliminating reads on a freed pointer.

2) Key Code Changes:
- Removed early check:
  “if (arvif->is_created) goto flush;”
- Added the same check after reassigning arvif:
  after “arvif = ath12k_mac_assign_link_vif(ah, vif, link_id);”
This ensures all subsequent uses of arvif, including is_created checks and cache flush, operate on a valid object.

3) Locking/Concurrency Impact:
No locking changes; lockdep_assert_wiphy(hw->wiphy) remains the only lock validation. The fix addresses pointer lifetime/ordering, not synchronization primitives.

6. Broader Kernel Security Implications
This highlights the importance of strict pointer lifetime management in complex driver flows where objects may be unassigned and reallocated across hardware contexts. Ensuring no stale pointer reads after teardown paths prevents UAFs that can be triggered by normal wireless operations (e.g., scan or channel context changes). Similar reordering and validation should be audited in other ath12k and wireless subsystems to avoid latent UAFs and improve overall kernel robustness.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.