You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-57995

[INFO]
[PATCH_DESCRIPTION]
 wifi: ath12k: fix read pointer after free in ath12k_mac_assign_vif_to_vdev()
 [ Upstream commit 5a10971c7645a95f5d5dc23c26fbac4bf61801d0 ]
 
 In ath12k_mac_assign_vif_to_vdev(), if arvif is created on a different
 radio, it gets deleted from that radio through a call to
 ath12k_mac_unassign_link_vif(). This action frees the arvif pointer.
 Subsequently, there is a check involving arvif, which will result in a
 read-after-free scenario.

 Fix this by moving this check after arvif is again assigned via call to
 ath12k_mac_assign_link_vif().
 
 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
 
 Closes: https://scan5.scan.coverity.com/#/project-view/63541/10063?selectedIssue=1636423
 Fixes: b5068bc9180d ("wifi: ath12k: Cache vdev configs before vdev create")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c
    index d493ec812055f8..cf4f4245f6068b 100644
    --- a/drivers/net/wireless/ath/ath12k/mac.c
    +++ b/drivers/net/wireless/ath/ath12k/mac.c
    @@ -7173,9 +7173,6 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     
     	ab = ar->ab;
     
    -	if (arvif->is_created)
    -		goto flush;
    -
     	/* Assign arvif again here since previous radio switch block
     	 * would've unassigned and cleared it.
     	 /
    @@ -7186,6 +7183,9 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     		goto unlock;
     	}
     
    +	if (arvif->is_created)
    +		goto flush;
    +
     	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
     		ath12k_warn(ab, "failed to create vdev, reached max vdev limit %d\n",
     			    TARGET_NUM_VDEVS);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57995

2. Vulnerability Type
Use-after-free (read-after-free)

3. Root Cause Summary
ath12k_mac_assign_vif_to_vdev() dereferenced arvif->is_created after arvif had been freed by ath12k_mac_unassign_link_vif() during a radio switch path. The check on arvif->is_created was performed before reassigning arvif via ath12k_mac_assign_link_vif(), resulting in a read-after-free on the stale pointer. The flaw is an incorrect ordering/lifetime management of arvif: reading a field without ensuring the pointer was valid after an earlier unassignment/free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Wi-Fi (ath12k driver), drivers/net/wireless/ath/ath12k/mac.c

2) Pre-Patch Flaw:
In ath12k_mac_assign_vif_to_vdev(), the code executed “if (arvif->is_created) goto flush;” before reassigning arvif after a potential unassign/free on a different radio. This allowed dereferencing arvif->is_created when arvif had been freed by ath12k_mac_unassign_link_vif().

3) Trigger Condition:
When a VIF (arvif) had been created on a different radio and the radio switch logic unassigned it via ath12k_mac_unassign_link_vif() (freeing the pointer), the subsequent early check of arvif->is_created occurred before arvif was re-assigned by ath12k_mac_assign_link_vif().

4) Impact Mechanism:
Dereferencing a freed pointer (read-after-free) can lead to kernel crashes (Oops), undefined behavior, or potential memory corruption by reading invalid memory contents associated with the stale arvif pointer.

5. Patch Analysis
1) Fix Approach:
Reorder the logic to defer the arvif->is_created check until after arvif has been re-assigned/validated via ath12k_mac_assign_link_vif(), ensuring the pointer is valid before any dereference.

2) Key Code Changes:
- Removed the early dereference:
  “if (arvif->is_created) goto flush;”
- Added the same check after re-assignment:
  After successful ath12k_mac_assign_link_vif(), perform “if (arvif->is_created) goto flush;”
This change is visible in ath12k_mac_assign_vif_to_vdev() at lines ~7173–7186 of mac.c in the diff hunk.

3) Locking/Concurrency Impact:
No locking changes were introduced; the fix strictly reorders operations to avoid dereferencing a freed pointer. Concurrency aspects are not modified or evident in the provided diff.

6. Broader Kernel Security Implications
Temporal memory safety bugs caused by incorrect lifetime/order of operations are common in complex driver paths, especially with multi-radio handling. Ensuring pointers are revalidated or reassigned before dereferencing is critical to prevent UAFs. Static analysis (e.g., Coverity) can effectively detect such issues; adopting consistent lifetime management patterns (e.g., clear after free, refcounting, or structured reinitialization points) helps mitigate similar vulnerabilities across drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}