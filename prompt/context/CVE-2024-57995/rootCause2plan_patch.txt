You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-57995

[INFO]
[PATCH_DESCRIPTION]
 wifi: ath12k: fix read pointer after free in ath12k_mac_assign_vif_to_vdev()
 [ Upstream commit 5a10971c7645a95f5d5dc23c26fbac4bf61801d0 ]
 
 In ath12k_mac_assign_vif_to_vdev(), if arvif is created on a different
 radio, it gets deleted from that radio through a call to
 ath12k_mac_unassign_link_vif(). This action frees the arvif pointer.
 Subsequently, there is a check involving arvif, which will result in a
 read-after-free scenario.

 Fix this by moving this check after arvif is again assigned via call to
 ath12k_mac_assign_link_vif().
 
 Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1
 
 Closes: https://scan5.scan.coverity.com/#/project-view/63541/10063?selectedIssue=1636423
 Fixes: b5068bc9180d ("wifi: ath12k: Cache vdev configs before vdev create")

[PATCH_DIFF]
    diff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c
    index d493ec812055f8..cf4f4245f6068b 100644
    --- a/drivers/net/wireless/ath/ath12k/mac.c
    +++ b/drivers/net/wireless/ath/ath12k/mac.c
    @@ -7173,9 +7173,6 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     
     	ab = ar->ab;
     
    -	if (arvif->is_created)
    -		goto flush;
    -
     	/* Assign arvif again here since previous radio switch block
     	 * would've unassigned and cleared it.
     	 /
    @@ -7186,6 +7183,9 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
     		goto unlock;
     	}
     
    +	if (arvif->is_created)
    +		goto flush;
    +
     	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
     		ath12k_warn(ab, "failed to create vdev, reached max vdev limit %d\n",
     			    TARGET_NUM_VDEVS);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-57995

2. Vulnerability Type
Use-after-free (read-after-free)

3. Root Cause Summary
ath12k_mac_assign_vif_to_vdev() dereferenced arvif->is_created after arvif had been freed by ath12k_mac_unassign_link_vif() during a radio switch path. The check on arvif->is_created was performed before reassigning arvif via ath12k_mac_assign_link_vif(), resulting in a read-after-free on the stale pointer. The flaw is an incorrect ordering/lifetime management of arvif: reading a field without ensuring the pointer was valid after an earlier unassignment/free.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Wi-Fi (ath12k driver), drivers/net/wireless/ath/ath12k/mac.c

2) Pre-Patch Flaw:
In ath12k_mac_assign_vif_to_vdev(), the code executed “if (arvif->is_created) goto flush;” before reassigning arvif after a potential unassign/free on a different radio. This allowed dereferencing arvif->is_created when arvif had been freed by ath12k_mac_unassign_link_vif().

3) Trigger Condition:
When a VIF (arvif) had been created on a different radio and the radio switch logic unassigned it via ath12k_mac_unassign_link_vif() (freeing the pointer), the subsequent early check of arvif->is_created occurred before arvif was re-assigned by ath12k_mac_assign_link_vif().

4) Impact Mechanism:
Dereferencing a freed pointer (read-after-free) can lead to kernel crashes (Oops), undefined behavior, or potential memory corruption by reading invalid memory contents associated with the stale arvif pointer.

5. Patch Analysis
1) Fix Approach:
Reorder the logic to defer the arvif->is_created check until after arvif has been re-assigned/validated via ath12k_mac_assign_link_vif(), ensuring the pointer is valid before any dereference.

2) Key Code Changes:
- Removed the early dereference:
  “if (arvif->is_created) goto flush;”
- Added the same check after re-assignment:
  After successful ath12k_mac_assign_link_vif(), perform “if (arvif->is_created) goto flush;”
This change is visible in ath12k_mac_assign_vif_to_vdev() at lines ~7173–7186 of mac.c in the diff hunk.

3) Locking/Concurrency Impact:
No locking changes were introduced; the fix strictly reorders operations to avoid dereferencing a freed pointer. Concurrency aspects are not modified or evident in the provided diff.

6. Broader Kernel Security Implications
Temporal memory safety bugs caused by incorrect lifetime/order of operations are common in complex driver paths, especially with multi-radio handling. Ensuring pointers are revalidated or reassigned before dereferencing is critical to prevent UAFs. Static analysis (e.g., Coverity) can effectively detect such issues; adopting consistent lifetime management patterns (e.g., clear after free, refcounting, or structured reinitialization points) helps mitigate similar vulnerabilities across drivers.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.