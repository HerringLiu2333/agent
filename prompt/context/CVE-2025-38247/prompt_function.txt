You are a senior Linux kernel vulnerability analyst.
Task: Identify the minimal root cause code snippet that directly enabled the vulnerability BEFORE the patch.

Rules:
1. Root cause = flawed or missing logic the patch fixes (missing check, wrong locking, unsafe access, race window, integer/length misuse, etc.).
2. Prefer removed (-) lines or original versions of modified lines. If issue is absence of code, show the surrounding code where it should have been.
3. Output ONLY vulnerable original code (before patch). No explanations.
4. Keep snippet minimal (≈3–25 lines). Preserve original indentation.
5. If multiple disjoint regions are required, separate them with a single blank line.
6. Do NOT include added '+' lines unless absolutely necessary for minimal context.
7. If nothing identifiable: output exactly NO_ROOT_CAUSE_FOUND.
8. Return strictly between the tags below.

[META]
CVE_NAME: CVE-2025-38247

[PATCH_DESCRIPTION]
    userns and mnt_idmap leak in open_tree_attr(2)
    Once want_mount_setattr() has returned a positive, it does require
    finish_mount_kattr() to release ->mnt_userns.  Failing do_mount_setattr()
    does not change that.
    
    As the result, we can end up leaking userns and possibly mnt_idmap as
    well.
    
    Fixes: c4a16820d901 ("fs: add open_tree_attr()")

[PATCH_DIFF]
    @@ -5307,16 +5307,12 @@ SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
     			kattr.kflags |= MOUNT_KATTR_RECURSE;
     
     		ret = wants_mount_setattr(uattr, usize, &kattr);
    -		if (ret < 0)
    -			return ret;
    -
    -		if (ret) {
    +		if (ret > 0) {
     			ret = do_mount_setattr(&file->f_path, &kattr);
    -			if (ret)
    -				return ret;
    -
     			finish_mount_kattr(&kattr);
     		}
    +		if (ret)
    +			return ret;
     	}
     
     	fd = get_unused_fd_flags(flags & O_CLOEXEC);

[FUNCTION_CONTENT]

SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
		unsigned, flags, struct mount_attr __user *, uattr,
		size_t, usize)
{
	struct file __free(fput) *file = NULL;
	int fd;

	if (!uattr && usize)
		return -EINVAL;

	file = vfs_open_tree(dfd, filename, flags);
	if (IS_ERR(file))
		return PTR_ERR(file);

	if (uattr) {
		int ret;
		struct mount_kattr kattr = {};

		kattr.kflags = MOUNT_KATTR_IDMAP_REPLACE;
		if (flags & AT_RECURSIVE)
			kattr.kflags |= MOUNT_KATTR_RECURSE;

		ret = wants_mount_setattr(uattr, usize, &kattr);
		if (ret < 0)
			return ret;

		if (ret) {
			ret = do_mount_setattr(&file->f_path, &kattr);
			if (ret)
				return ret;

			finish_mount_kattr(&kattr);
		}
	}

	fd = get_unused_fd_flags(flags & O_CLOEXEC);
	if (fd < 0)
		return fd;

	fd_install(fd, no_free_ptr(file));
	return fd;
}

[OUTPUT FORMAT]
<<<ROOT_CAUSE_CODE_START>>>
<root cause original code here>
<<<ROOT_CAUSE_CODE_END>>>