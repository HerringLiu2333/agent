You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38247

[INFO]
[PATCH_DESCRIPTION]
    userns and mnt_idmap leak in open_tree_attr(2)
    Once want_mount_setattr() has returned a positive, it does require
    finish_mount_kattr() to release ->mnt_userns.  Failing do_mount_setattr()
    does not change that.
    
    As the result, we can end up leaking userns and possibly mnt_idmap as
    well.
    
    Fixes: c4a16820d901 ("fs: add open_tree_attr()")

[PATCH_DIFF]
    @@ -5307,16 +5307,12 @@ SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
     			kattr.kflags |= MOUNT_KATTR_RECURSE;
     
     		ret = wants_mount_setattr(uattr, usize, &kattr);
    -		if (ret < 0)
    -			return ret;
    -
    -		if (ret) {
    +		if (ret > 0) {
     			ret = do_mount_setattr(&file->f_path, &kattr);
    -			if (ret)
    -				return ret;
    -
     			finish_mount_kattr(&kattr);
     		}
    +		if (ret)
    +			return ret;
     	}
     
     	fd = get_unused_fd_flags(flags & O_CLOEXEC);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38247

2. Vulnerability Type
Resource/reference leak (lifetime/refcount bug)

3. Root Cause Summary
open_tree_attr() failed to call finish_mount_kattr() on the error path when do_mount_setattr() failed after wants_mount_setattr() had returned a positive value. wants_mount_setattr() sets up kattr and acquires references (e.g., ->mnt_userns and possibly mnt_idmap) that must be released by finish_mount_kattr() regardless of subsequent failures. The pre-patch code returned early on do_mount_setattr() error (“if (ret) return ret;”) inside the block, skipping the required cleanup, leaking references.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFS mount attribute handling in the open_tree_attr(2) syscall (fs/open_tree_attr path)

2) Pre-Patch Flaw:
- In SYSCALL_DEFINE5(open_tree_attr, ...), after:
  ret = wants_mount_setattr(uattr, usize, &kattr);
  if (ret) { ret = do_mount_setattr(...); if (ret) return ret; finish_mount_kattr(&kattr); }
- If do_mount_setattr() failed, the function returned immediately without invoking finish_mount_kattr(), leaving acquired references (->mnt_userns, possibly mnt_idmap) unreleased.

3) Trigger Condition:
- wants_mount_setattr() returns >0 (indicating attributes to apply and resources acquired), followed by do_mount_setattr() returning an error. Any scenario that makes do_mount_setattr() fail (invalid attributes, permission checks, etc.) after a positive wants_mount_setattr() result triggers the leak.

4) Impact Mechanism:
- Leaked references to mnt_userns and potentially mnt_idmap prevent their reference counts from being decremented, leading to persistent objects and memory/resource consumption. Repeated triggers can cause resource exhaustion (DoS) due to accumulating unreleased references.

5. Patch Analysis
1) Fix Approach:
- Ensure finish_mount_kattr() is always called when wants_mount_setattr() returned >0, regardless of do_mount_setattr()’s success or failure. Reorder returns so cleanup occurs before propagating errors.

2) Key Code Changes:
- Change conditional from “if (ret)” to “if (ret > 0)” to enter the block only when wants_mount_setattr() indicated setup occurred.
- Move finish_mount_kattr(&kattr) to execute unconditionally within that block, after do_mount_setattr(), removing the early return on do_mount_setattr() failure.
- Add a unified “if (ret) return ret;” after the block to propagate any error after cleanup.
  Diff evidence:
  - Pre-patch: inside the block:
    ret = do_mount_setattr(...);
    if (ret) return ret;
    finish_mount_kattr(&kattr);
  - Post-patch:
    if (ret > 0) {
      ret = do_mount_setattr(...);
      finish_mount_kattr(&kattr);
    }
    if (ret) return ret;

3) Locking/Concurrency Impact:
- No locking or ordering semantics changed. The patch strictly fixes resource lifetime management by ensuring reference releases on all paths; no changes to locks, RCU, or atomic operations.

6. Broader Kernel Security Implications
- Highlights the need for robust error-path cleanup in VFS mount attribute flows, especially when preparatory functions acquire references requiring paired “finish/put” calls. Similar patterns elsewhere should be audited to ensure that cleanup is executed even when subsequent operations fail. Preventing such reference leaks mitigates potential denial-of-service vectors via resource exhaustion in user namespace and idmap objects.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}