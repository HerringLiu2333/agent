You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38247

[INFO]
[PATCH_DESCRIPTION]
    userns and mnt_idmap leak in open_tree_attr(2)
    Once want_mount_setattr() has returned a positive, it does require
    finish_mount_kattr() to release ->mnt_userns.  Failing do_mount_setattr()
    does not change that.
    
    As the result, we can end up leaking userns and possibly mnt_idmap as
    well.
    
    Fixes: c4a16820d901 ("fs: add open_tree_attr()")

[PATCH_DIFF]
    @@ -5307,16 +5307,12 @@ SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
     			kattr.kflags |= MOUNT_KATTR_RECURSE;
     
     		ret = wants_mount_setattr(uattr, usize, &kattr);
    -		if (ret < 0)
    -			return ret;
    -
    -		if (ret) {
    +		if (ret > 0) {
     			ret = do_mount_setattr(&file->f_path, &kattr);
    -			if (ret)
    -				return ret;
    -
     			finish_mount_kattr(&kattr);
     		}
    +		if (ret)
    +			return ret;
     	}
     
     	fd = get_unused_fd_flags(flags & O_CLOEXEC);

[FUNCTION_CONTENT]

SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
		unsigned, flags, struct mount_attr __user *, uattr,
		size_t, usize)
{
	struct file __free(fput) *file = NULL;
	int fd;

	if (!uattr && usize)
		return -EINVAL;

	file = vfs_open_tree(dfd, filename, flags);
	if (IS_ERR(file))
		return PTR_ERR(file);

	if (uattr) {
		int ret;
		struct mount_kattr kattr = {};

		kattr.kflags = MOUNT_KATTR_IDMAP_REPLACE;
		if (flags & AT_RECURSIVE)
			kattr.kflags |= MOUNT_KATTR_RECURSE;

		ret = wants_mount_setattr(uattr, usize, &kattr);
		if (ret < 0)
			return ret;

		if (ret) {
			ret = do_mount_setattr(&file->f_path, &kattr);
			if (ret)
				return ret;

			finish_mount_kattr(&kattr);
		}
	}

	fd = get_unused_fd_flags(flags & O_CLOEXEC);
	if (fd < 0)
		return fd;

	fd_install(fd, no_free_ptr(file));
	return fd;
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38247

2. Vulnerability Type
Refcount/resource leak (missing cleanup on error path) leading to potential denial-of-service via leaked user namespace and mount idmap references.

3. Root Cause Summary
In open_tree_attr(), when wants_mount_setattr() returns a positive value, it allocates/acquires resources (e.g., mnt_userns and possibly mnt_idmap) that must be released by finish_mount_kattr(). The pre-patch logic returned early on error from do_mount_setattr() without calling finish_mount_kattr(), leaving those resources leaked. Specifically, inside the “if (ret)” block, the code executed “if (ret) return ret;” before invoking finish_mount_kattr(), so failures bypassed cleanup. This is a lifetime/refcount management bug in the error path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFS mount/namespace handling, open_tree_attr(2) syscall, mount attribute/idmap handling.

2) Pre-Patch Flaw:
The syscall’s error path failed to call finish_mount_kattr() after wants_mount_setattr() had indicated work (ret > 0) and resources were acquired, if do_mount_setattr() returned an error. Cleanup was conditional on success, resulting in leaked mnt_userns and potentially mnt_idmap.

3) Trigger Condition:
- uattr is provided and wants_mount_setattr(uattr, usize, &kattr) returns > 0 (resources prepared).
- do_mount_setattr(&file->f_path, &kattr) returns an error.
- The function returns immediately without calling finish_mount_kattr().

4) Impact Mechanism:
Leaked references to ->mnt_userns and possibly mnt_idmap cause refcount/resource leaks, pinning user namespaces/idmaps and consuming kernel memory. Repeated invocations can accumulate leaked references, potentially leading to resource exhaustion and denial-of-service.

5. Patch Analysis
1) Fix Approach:
Ensure finish_mount_kattr() is called whenever wants_mount_setattr() returned positive, irrespective of do_mount_setattr() success. Move the error return to occur after finish_mount_kattr() and adjust conditionals to distinguish positive from negative returns.

2) Key Code Changes:
- Change check to “if (ret > 0) { ret = do_mount_setattr(...); finish_mount_kattr(&kattr); }”.
- Remove the early “if (ret) return ret;” from inside the block that previously guarded finish_mount_kattr().
- Add a unified “if (ret) return ret;” after the cleanup, ensuring resources are released before returning on both success and failure paths.

3) Locking/Concurrency Impact:
No locking changes; the patch addresses lifetime/refcount correctness by guaranteeing the matching release (finish_mount_kattr) for resources acquired when wants_mount_setattr() is positive. Concurrency semantics remain unchanged.

6. Broader Kernel Security Implications
Correct refcount/lifetime management in mount and user namespace handling is critical to prevent resource pinning and memory leaks. Such leaks can enable unprivileged users to trigger persistent resource consumption, leading to denial-of-service conditions in multi-tenant or containerized environments. The fix strengthens reliability of namespace/idmap management and reduces the risk of system instability due to leaked kernel objects.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.