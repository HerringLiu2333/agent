static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}