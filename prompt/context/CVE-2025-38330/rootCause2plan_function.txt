You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38330

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test (ctl cache)
    KASAN reported out of bounds access - cs_dsp_ctl_cache_init_multiple_offsets().
    The code uses mock_coeff_template.length_bytes (4 bytes) for register value
    allocations. But later, this length is set to 8 bytes which causes
    test code failures.
    
    As fix, just remove the lenght override, keeping the original value 4
    for all operations.

[PATCH_DIFF]
     @@ -776,7 +776,6 @@ static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
     					      "dummyalg", NULL);
     
     	/* Create controls identical except for offset */
     -	def.length_bytes = 8;
     	def.offset_dsp_words = 0;
     	def.shortname = "CtlA";
     	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

[FUNCTION_CONTENT]
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38330

2. Vulnerability Type
Out-of-bounds read due to size/length mismatch

3. Root Cause Summary
Inside the KUnit test function cs_dsp_ctl_cache_init_multiple_offsets, buffers (reg_vals[i] and readback) are allocated using mock_coeff_template.length_bytes (4 bytes), but the test then overrides def.length_bytes to 8 and proceeds to read/write and compare using this larger length. This creates a mismatch between allocated buffer sizes (4) and the number of bytes accessed (8), leading to out-of-bounds reads detected by KASAN. The flawed logic is the length override “def.length_bytes = 8;” without re-allocating buffers or validating sizes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test for control cache initialization)

2) Pre-Patch Flaw:
The test allocates memory based on def.length_bytes from mock_coeff_template (4 bytes) and later changes def.length_bytes to 8, causing accesses to exceed the allocated buffer sizes. There is no validation ensuring that the new length matches previously allocated sizes.

3) Trigger Condition:
Running cs_dsp_ctl_cache_init_multiple_offsets when mock_coeff_template.length_bytes is 4 and the code sets “def.length_bytes = 8;” before calling regmap_raw_write, cs_dsp_coeff_lock_and_read_ctrl, and KUNIT_EXPECT_MEMEQ with def.length_bytes.

4) Impact Mechanism:
- regmap_raw_write(dsp->regmap, ..., reg_vals[x], def.length_bytes) reads 8 bytes from reg_vals[x] allocated for 4 bytes (source OOB read).
- cs_dsp_coeff_lock_and_read_ctrl(..., readback, def.length_bytes) followed by KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[x], def.length_bytes) causes 8-byte comparisons against 4-byte buffers (OOB read by the test comparison).
KASAN reports out-of-bounds memory read during these operations.

5. Patch Analysis
1) Fix Approach:
Ensure consistent length usage by removing the erroneous override so all operations use the original 4-byte length that matches buffer allocations.

2) Key Code Changes:
- Single-line removal within cs_dsp_ctl_cache_init_multiple_offsets:
  “- def.length_bytes = 8;”
This prevents subsequent read/write/comparison operations from using a larger length than the allocated buffers.

3) Locking/Concurrency Impact:
None. The change is confined to test code and does not alter locking, concurrency, or ordering; it only corrects the length used for memory operations.

6. Broader Kernel Security Implications
Maintaining consistency between allocation sizes and I/O lengths is essential to avoid OOB accesses; this patch eliminates false positives and KASAN noise in the test harness, improving test reliability. Although limited to KUnit test code, it underscores a general principle critical to production code paths in firmware/control cache handling: do not change operational lengths without corresponding buffer management or validation.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.