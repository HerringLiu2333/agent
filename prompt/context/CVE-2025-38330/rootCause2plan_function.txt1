You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2025-38330

[INFO]
[PATCH_DESCRIPTION]
    firmware: cs_dsp: Fix OOB memory read access in KUnit test (ctl cache)
    KASAN reported out of bounds access - cs_dsp_ctl_cache_init_multiple_offsets().
    The code uses mock_coeff_template.length_bytes (4 bytes) for register value
    allocations. But later, this length is set to 8 bytes which causes
    test code failures.
    
    As fix, just remove the lenght override, keeping the original value 4
    for all operations.

[PATCH_DIFF]
     @@ -776,7 +776,6 @@ static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
     					      "dummyalg", NULL);
     
     	/* Create controls identical except for offset */
     -	def.length_bytes = 8;
     	def.offset_dsp_words = 0;
     	def.shortname = "CtlA";
     	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

[FUNCTION_CONTENT]
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */


	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/*
 * Firmware with controls in the same algorithm and memory but at
 * different offsets.
 * The control cache should be initialized with content from the
 * correct offset.
 * Only for wmfw format V2 and later. V1 only supports one control per
 * memory per algorithm.
 */
static void cs_dsp_ctl_cache_init_multiple_offsets(struct kunit *test)
{
	struct cs_dsp_test *priv = test->priv;
	struct cs_dsp *dsp = priv->dsp;
	struct cs_dsp_test_local *local = priv->local;
	struct cs_dsp_mock_coeff_def def = mock_coeff_template;
	unsigned int reg, alg_base_words, alg_base_reg;
	struct cs_dsp_coeff_ctl *walkctl, *ctl[3];
	struct firmware *wmfw;
	u32 *reg_vals[3], *readback;
	int i;

	static_assert(ARRAY_SIZE(ctl) ==  ARRAY_SIZE(reg_vals));
	static_assert(ARRAY_SIZE(reg_vals) <= ARRAY_SIZE(cs_dsp_ctl_cache_test_algs));

	for (i = 0; i < ARRAY_SIZE(reg_vals); i++) {
		reg_vals[i] = kunit_kmalloc(test, def.length_bytes, GFP_KERNEL);
		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

	KUNIT_ASSERT_NOT_NULL(test, ctl[0]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[1]);
	KUNIT_ASSERT_NOT_NULL(test, ctl[2]);

	/*
	 * The data should have been populated into the control cache
	 * so should be readable through the control.
	 */
	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[0], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[0], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[1], 0, readback, def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[1], def.length_bytes);

	KUNIT_EXPECT_EQ(test,
			cs_dsp_coeff_lock_and_read_ctrl(ctl[2], 0, readback,
							def.length_bytes),
			0);
	KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[2], def.length_bytes);
}

/* ----- separator ----- */

		KUNIT_ASSERT_NOT_ERR_OR_NULL(test, reg_vals[i]);
		get_random_bytes(reg_vals[i], def.length_bytes);
	}

	readback = kunit_kzalloc(test, def.length_bytes, GFP_KERNEL);
	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}

/* ----- separator ----- */

	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, readback);

	cs_dsp_mock_wmfw_start_alg_info_block(local->wmfw_builder,
					      cs_dsp_ctl_cache_test_algs[0].id,
					      "dummyalg", NULL);

	/* Create controls identical except for offset */
	def.length_bytes = 8;
	def.offset_dsp_words = 0;
	def.shortname = "CtlA";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 5;
	def.shortname = "CtlB";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	def.offset_dsp_words = 8;
	def.shortname = "CtlC";
	cs_dsp_mock_wmfw_add_coeff_desc(local->wmfw_builder, &def);

	cs_dsp_mock_wmfw_end_alg_info_block(local->wmfw_builder);

	/* Create random content in the registers backing each control */
	alg_base_words = _get_alg_mem_base_words(test, 0, def.mem_type);
	alg_base_reg = cs_dsp_mock_base_addr_for_mem(priv, def.mem_type);
	alg_base_reg += alg_base_words * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv);

	reg = alg_base_reg;
	regmap_raw_write(dsp->regmap, reg, reg_vals[0], def.length_bytes);
	reg = alg_base_reg + (5 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[1], def.length_bytes);
	reg = alg_base_reg + (8 * cs_dsp_mock_reg_addr_inc_per_unpacked_word(priv));
	regmap_raw_write(dsp->regmap, reg, reg_vals[2], def.length_bytes);

	/* Download, run, stop and power-down the firmware */
	wmfw = cs_dsp_mock_wmfw_get_firmware(local->wmfw_builder);
	KUNIT_ASSERT_EQ(test, cs_dsp_power_up(dsp, wmfw, "mock_fw", NULL, NULL, "misc"), 0);
	KUNIT_ASSERT_EQ(test, cs_dsp_run(dsp), 0);
	cs_dsp_stop(dsp);
	cs_dsp_power_down(dsp);

	/* There should now be 3 controls */
	KUNIT_ASSERT_EQ(test, list_count_nodes(&dsp->ctl_list), 3);

	/*
	 * There's no requirement for the control list to be in any
	 * particular order, so don't assume the order.
	 */
	for (i = 0; i < ARRAY_SIZE(ctl); i++)
		ctl[i] = NULL;

	list_for_each_entry(walkctl, &dsp->ctl_list, list) {
		if (walkctl->offset == 0)
			ctl[0] = walkctl;
		if (walkctl->offset == 5)
			ctl[1] = walkctl;
		if (walkctl->offset == 8)
			ctl[2] = walkctl;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38330

2. Vulnerability Type
Out-of-bounds read due to size/length mismatch

3. Root Cause Summary
Inside the KUnit test function cs_dsp_ctl_cache_init_multiple_offsets, buffers (reg_vals[i] and readback) are allocated using mock_coeff_template.length_bytes (4 bytes), but the test then overrides def.length_bytes to 8 and proceeds to read/write and compare using this larger length. This creates a mismatch between allocated buffer sizes (4) and the number of bytes accessed (8), leading to out-of-bounds reads detected by KASAN. The flawed logic is the length override “def.length_bytes = 8;” without re-allocating buffers or validating sizes.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
firmware: cs_dsp (KUnit test for control cache initialization)

2) Pre-Patch Flaw:
The test allocates memory based on def.length_bytes from mock_coeff_template (4 bytes) and later changes def.length_bytes to 8, causing accesses to exceed the allocated buffer sizes. There is no validation ensuring that the new length matches previously allocated sizes.

3) Trigger Condition:
Running cs_dsp_ctl_cache_init_multiple_offsets when mock_coeff_template.length_bytes is 4 and the code sets “def.length_bytes = 8;” before calling regmap_raw_write, cs_dsp_coeff_lock_and_read_ctrl, and KUNIT_EXPECT_MEMEQ with def.length_bytes.

4) Impact Mechanism:
- regmap_raw_write(dsp->regmap, ..., reg_vals[x], def.length_bytes) reads 8 bytes from reg_vals[x] allocated for 4 bytes (source OOB read).
- cs_dsp_coeff_lock_and_read_ctrl(..., readback, def.length_bytes) followed by KUNIT_EXPECT_MEMEQ(test, readback, reg_vals[x], def.length_bytes) causes 8-byte comparisons against 4-byte buffers (OOB read by the test comparison).
KASAN reports out-of-bounds memory read during these operations.

5. Patch Analysis
1) Fix Approach:
Ensure consistent length usage by removing the erroneous override so all operations use the original 4-byte length that matches buffer allocations.

2) Key Code Changes:
- Single-line removal within cs_dsp_ctl_cache_init_multiple_offsets:
  “- def.length_bytes = 8;”
This prevents subsequent read/write/comparison operations from using a larger length than the allocated buffers.

3) Locking/Concurrency Impact:
None. The change is confined to test code and does not alter locking, concurrency, or ordering; it only corrects the length used for memory operations.

6. Broader Kernel Security Implications
Maintaining consistency between allocation sizes and I/O lengths is essential to avoid OOB accesses; this patch eliminates false positives and KASAN noise in the test harness, improving test reliability. Although limited to KUnit test code, it underscores a general principle critical to production code paths in firmware/control cache handling: do not change operational lengths without corresponding buffer management or validation.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}