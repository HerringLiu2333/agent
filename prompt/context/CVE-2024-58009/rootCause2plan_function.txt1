You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually).
4. List limitations and assumptions (what is Not determinable from inputs). If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".
5. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
6. Please try to use the simplest way and fewer steps to achieve your goal. But for every step, your response should be as concrete as possible so that I can easily follow your guidance and write a correct checker!

[META]
CVE_NAME: CVE-2024-58009

[INFO]
[PATCH_DESCRIPTION]
 Bluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_alloc
 commit 5f397409f8ee5bc82901eeaf799e1cbc4f8edcf1 upstream.
 
 A NULL sock pointer is passed into l2cap_sock_alloc() when it is called
 from l2cap_sock_new_connection_cb() and the error handling paths should
 also be aware of it.

 Seemingly a more elegant solution would be to swap bt_sock_alloc() and
 l2cap_chan_create() calls since they are not interdependent to that moment
 but then l2cap_chan_create() adds the soon to be deallocated and still
 dummy-initialized channel to the global list accessible by many L2CAP
 paths. The channel would be removed from the list in short period of time
 but be a bit more straight-forward here and just check for NULL instead of
 changing the order of function calls.
 
 Found by Linux Verification Center (linuxtesting.org) with SVACE static
 analysis tool.
 
 Fixes: 7c4f78cdb8e7 ("Bluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()")

[PATCH_DIFF]
 diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
 index 57035e46f71518…4a0e73d3996056 100644
 --- a/net/bluetooth/l2cap_sock.c
 +++ b/net/bluetooth/l2cap_sock.c
 @@ -1876,7 +1876,8 @@ static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
   chan = l2cap_chan_create();
   if (!chan) {
   sk_free(sk);
 - sock->sk = NULL;
 + if (sock)
 + sock->sk = NULL;
   return NULL;
   }

[FUNCTION_CONTENT]
static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
				     int proto, gfp_t prio, int kern)
{
	struct sock *sk;
	struct l2cap_chan *chan;

	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);
	if (!sk)
		return NULL;

	sock_init_data(sock, sk);
	INIT_LIST_HEAD(&bt_sk(sk)->accept_q);

	sk->sk_destruct = l2cap_sock_destruct;
	sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;

	sock_reset_flag(sk, SOCK_ZAPPED);

	sk->sk_protocol = proto;
	sk->sk_state = BT_OPEN;

	chan = l2cap_chan_create();
	if (!chan) {
		sk_free(sk);
		sock->sk = NULL;
		return NULL;
	}

	l2cap_chan_hold(chan);

	l2cap_pi(sk)->chan = chan;

	return sk;
}

/* ----- separator ----- */

	INIT_LIST_HEAD(&bt_sk(sk)->accept_q);

	sk->sk_destruct = l2cap_sock_destruct;
	sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;

	sock_reset_flag(sk, SOCK_ZAPPED);

	sk->sk_protocol = proto;
	sk->sk_state = BT_OPEN;

	chan = l2cap_chan_create();
	if (!chan) {
		sk_free(sk);
		sock->sk = NULL;
		return NULL;
	}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58009

2. Vulnerability Type
NULL pointer dereference leading to kernel crash (Denial of Service)

3. Root Cause Summary
The error path in l2cap_sock_alloc unconditionally dereferenced the socket pointer to clear sock->sk when channel creation failed, even when the function can be invoked with a NULL socket pointer (from l2cap_sock_new_connection_cb). Specifically, after l2cap_chan_create() returned NULL, the code executed “sock->sk = NULL;” without checking if sock was NULL. This missing NULL check caused a NULL pointer dereference in the kernel on the error path.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth L2CAP socket layer (net/bluetooth/l2cap_sock.c)

2) Pre-Patch Flaw:
In l2cap_sock_alloc, the failure branch after l2cap_chan_create() returned NULL always executed “sock->sk = NULL;” without verifying that sock was non-NULL, unlike sock_init_data() which correctly guards use of sock.

3) Trigger Condition:
l2cap_sock_alloc is called with a NULL socket pointer (from l2cap_sock_new_connection_cb), and l2cap_chan_create() fails (e.g., allocation or initialization failure), leading execution into the error path that dereferences sock.

4) Impact Mechanism:
The unconditional dereference of a NULL socket pointer (“sock->sk = NULL;”) results in a kernel NULL pointer dereference, causing an oops/panic and thus a denial of service.

5. Patch Analysis
1) Fix Approach:
Introduce a NULL check before accessing sock in the error path to safely handle calls where sock is NULL.

2) Key Code Changes:
In l2cap_sock_alloc:
- Changed “sock->sk = NULL;” to “if (sock) sock->sk = NULL;” within the branch handling l2cap_chan_create() failure. This ensures error cleanup does not dereference a NULL pointer.

3) Locking/Concurrency Impact:
No locking or ordering changes. The patch deliberately avoids reordering bt_sock_alloc and l2cap_chan_create due to side effects (adding a dummy channel to a global list), focusing solely on safe NULL handling; thus, no concurrency implications are introduced.

6. Broader Kernel Security Implications
Strengthens kernel robustness in Bluetooth L2CAP error handling by preventing a straightforward kernel crash path triggered by NULL socket contexts. Reduces attack surface for denial-of-service conditions that could be induced by resource exhaustion or malformed connection scenarios reaching the channel creation failure path. Improves consistency with existing safe patterns (e.g., sock_init_data’s NULL guard) and enhances overall stability of the Bluetooth stack.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals).
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals}
2) Step 2: {objective — conceptual signals}
...
(narrow to ≤12 steps)

3. Limitations & Assumptions
- {explicit missing info or assumptions}