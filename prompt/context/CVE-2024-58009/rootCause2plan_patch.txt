You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2024-58009

[INFO]
[PATCH_DESCRIPTION]
 Bluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_alloc
 commit 5f397409f8ee5bc82901eeaf799e1cbc4f8edcf1 upstream.
 
 A NULL sock pointer is passed into l2cap_sock_alloc() when it is called
 from l2cap_sock_new_connection_cb() and the error handling paths should
 also be aware of it.

 Seemingly a more elegant solution would be to swap bt_sock_alloc() and
 l2cap_chan_create() calls since they are not interdependent to that moment
 but then l2cap_chan_create() adds the soon to be deallocated and still
 dummy-initialized channel to the global list accessible by many L2CAP
 paths. The channel would be removed from the list in short period of time
 but be a bit more straight-forward here and just check for NULL instead of
 changing the order of function calls.
 
 Found by Linux Verification Center (linuxtesting.org) with SVACE static
 analysis tool.
 
 Fixes: 7c4f78cdb8e7 ("Bluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()")

[PATCH_DIFF]
 diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
 index 57035e46f71518…4a0e73d3996056 100644
 --- a/net/bluetooth/l2cap_sock.c
 +++ b/net/bluetooth/l2cap_sock.c
 @@ -1876,7 +1876,8 @@ static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
   chan = l2cap_chan_create();
   if (!chan) {
   sk_free(sk);
 - sock->sk = NULL;
 + if (sock)
 + sock->sk = NULL;
   return NULL;
   }



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2024-58009

2. Vulnerability Type
NULL pointer dereference due to missing NULL check in error path

3. Root Cause Summary
The error-handling path in l2cap_sock_alloc unconditionally dereferenced the socket pointer and executed “sock->sk = NULL” after l2cap_chan_create failed. In call paths where l2cap_sock_alloc is invoked with sock == NULL (e.g., from l2cap_sock_new_connection_cb), this led to a NULL pointer dereference. The flawed logic was introduced when ensuring no dangling sk pointer on error, but it failed to account for a NULL sock argument in some contexts.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
Bluetooth L2CAP socket handling (net/bluetooth/l2cap_sock.c)

2) Pre-Patch Flaw:
In l2cap_sock_alloc, after “chan = l2cap_chan_create();” if channel creation failed, the code executed:
- “sk_free(sk);”
- “sock->sk = NULL;”
without verifying that sock was non-NULL, assuming a valid struct socket was always provided.

3) Trigger Condition:
When l2cap_sock_alloc is called with sock == NULL (as happens in l2cap_sock_new_connection_cb) and l2cap_chan_create() returns NULL, the error path writes to sock->sk, dereferencing a NULL pointer.

4) Impact Mechanism:
Dereferencing a NULL socket pointer causes a kernel NULL pointer dereference/Oops, leading to a system crash or denial-of-service.

5. Patch Analysis
1) Fix Approach:
Defensive programming: add a NULL check before touching sock->sk in the error path to safely handle invocations with a NULL sock pointer.

2) Key Code Changes:
In l2cap_sock_alloc:
- Replaced “sock->sk = NULL;” with “if (sock) sock->sk = NULL;” under the “if (!chan)” branch.
- No reordering of bt_sock_alloc() and l2cap_chan_create(), explicitly avoiding side effects of adding a dummy channel to global lists.

3) Locking/Concurrency Impact:
None. The patch only adds a conditional check and does not alter locking, ordering, or list manipulation. The description notes why reordering calls (which could affect global list visibility) was avoided.

6. Broader Kernel Security Implications
This change eliminates a straightforward kernel crash in Bluetooth error handling, improving robustness against malformed states or resource failures during connection setup. It underscores the need to validate pointers across shared helper paths that may be used with different calling conventions. By preventing NULL dereferences, the fix reduces potential denial-of-service vectors arising from Bluetooth stack operations.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.