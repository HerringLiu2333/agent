You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38283

[INFO]
[PATCH_DESCRIPTION]
    hisi_acc_vfio_pci: bugfix live migration function without VF device driver
    If the VF device driver is not loaded in the Guest OS and we attempt to
    perform device data migration, the address of the migrated data will
    be NULL.
    The live migration recovery operation on the destination side will
    access a null address value, which will cause access errors.
    
    Therefore, live migration of VMs without added VF device drivers
    does not require device data migration.
    In addition, when the queue address data obtained by the destination
    is empty, device queue recovery processing will not be performed.

[PATCH_DIFF]
    @@ -498,6 +491,20 @@ static int vf_qm_load_data(struct hisi_acc_vf_core_device *hisi_acc_vdev,
     	if (migf->total_length < sizeof(struct acc_vf_data))
     		return -EINVAL;
     
    +	if (!vf_data->eqe_dma || !vf_data->aeqe_dma ||
    +	    !vf_data->sqc_dma || !vf_data->cqc_dma) {
    +		dev_info(dev, "resume dma addr is NULL!\n");
    +		hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
    +		return 0;
    +	}
    +
     	qm->eqe_dma = vf_data->eqe_dma;
     	qm->aeqe_dma = vf_data->aeqe_dma;
     	qm->sqc_dma = vf_data->sqc_dma;
    ...
    @@ -1531,6 +1538,7 @@ static int hisi_acc_vfio_pci_migrn_init_dev(struct vfio_device *core_vdev)
     	hisi_acc_vdev->vf_id = pci_iov_vf_id(pdev) + 1;
     	hisi_acc_vdev->pf_qm = pf_qm;
     	hisi_acc_vdev->vf_dev = pdev;
    +	hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
     	mutex_init(&hisi_acc_vdev->state_mutex);
     	mutex_init(&hisi_acc_vdev->open_mutex);



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38283

2. Vulnerability Type
NULL pointer dereference / unsafe use of migrated DMA addresses due to missing input validation during live migration recovery

3. Root Cause Summary
The live migration recovery path in vf_qm_load_data used migrated queue DMA addresses (eqe_dma, aeqe_dma, sqc_dma, cqc_dma) without validating that they were non-NULL. When the guest VM had no VF device driver loaded, these migrated addresses were NULL, and the destination attempted to recover device queues using these NULL addresses, leading to access errors (NULL dereference/invalid DMA use). Additionally, the VF QM state was not initialized to a “not ready” state, allowing recovery logic to run even when essential data was absent.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFIO PCI vendor driver for HiSilicon accelerator (hisi_acc_vfio_pci), live migration (queue manager data recovery)

2) Pre-Patch Flaw:
- vf_qm_load_data assigned vf_data->eqe_dma/aeqe_dma/sqc_dma/cqc_dma directly to qm->* without checking for NULL (e.g., “qm->eqe_dma = vf_data->eqe_dma;”).
- The device state (vf_qm_state) was not initialized to QM_NOT_READY in hisi_acc_vfio_pci_migrn_init_dev, permitting recovery to proceed with invalid/empty migrated data.

3) Trigger Condition:
Performing VM live migration when the guest OS lacks the VF device driver, resulting in migrated device queue DMA addresses being NULL; destination side invokes queue recovery using these NULL addresses.

4) Impact Mechanism:
Accessing or programming hardware with NULL DMA addresses during recovery causes kernel access errors, likely a NULL pointer dereference or invalid DMA operation, leading to device malfunction or kernel crash/DoS on the destination host.

5. Patch Analysis
1) Fix Approach:
- Add explicit validation of migrated DMA addresses and skip queue recovery when any required address is NULL.
- Initialize vf_qm_state to QM_NOT_READY at device migration init to gate recovery until valid data is present.

2) Key Code Changes:
- In vf_qm_load_data:
  - Inserted check: if (!vf_data->eqe_dma || !vf_data->aeqe_dma || !vf_data->sqc_dma || !vf_data->cqc_dma) { log, set vf_qm_state = QM_NOT_READY, return 0; }.
  - This prevents assigning NULL addresses to qm->* and stops recovery early when data is absent.
- In hisi_acc_vfio_pci_migrn_init_dev:
  - Added initialization: hisi_acc_vdev->vf_qm_state = QM_NOT_READY to reflect a safe initial state prior to data validation.

3) Locking/Concurrency Impact:
Unknown/Not determinable. The patch does not modify locking primitives; it introduces state gating and early return, which reduces the chance of concurrent recovery operations using invalid data but does not change mutex usage.

6. Broader Kernel Security Implications
- Validating all migrated device state before use is critical to prevent kernel crashes during live migration, especially when guest environments differ (e.g., missing drivers).
- Establishing and enforcing device state machines (e.g., NOT_READY until data verified) hardens migration paths against malformed or incomplete inputs.
- Similar migration/recovery paths in other VFIO/vendor drivers should audit for NULL/invalid pointer checks and proper state initialization to avoid UAF/OOB or NULL dereference issues.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.