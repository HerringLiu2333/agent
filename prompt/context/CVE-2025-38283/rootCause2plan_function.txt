You are a senior static-analysis engineer and CodeQL design expert.
Task: Based only on the supplied materials, produce a human-readable detection plan (natural-language) for a CodeQL checker that would detect the same class of vulnerability described. DO NOT produce any query code or pseudocode — the output must be purely natural language steps and rationale.

Rules:
1. Only use evidence contained in the sections labeled [PATCH_DESCRIPTION], [PATCH_DIFF], [FUNCTION_CONTENT], and [ROOTCAUSE_ANALYSIS]. Do not invent facts.
2. The plan must be a step-by-step detection strategy in natural language (numbered steps). No code, no query snippets, no regex, no domain-specific language.
3. Each step must state: objective, signals to look for (AST/semantic patterns expressed conceptually), why it maps to the root cause, and how to reduce false positives.
4. Include a short test/validation strategy (what sample cases to run and expected outcomes).
5. List limitations and assumptions (what is Not determinable from inputs).
6. Keep the plan concise: overall ≤ 12 numbered steps and each step ≤ 2 concise sentences. Use bullets where helpful.
7. If information required to design an accurate checker is missing, state it explicitly under "Limitations & Assumptions".

[META]
CVE_NAME: CVE-2025-38283

[INFO]
[PATCH_DESCRIPTION]
    hisi_acc_vfio_pci: bugfix live migration function without VF device driver
    If the VF device driver is not loaded in the Guest OS and we attempt to
    perform device data migration, the address of the migrated data will
    be NULL.
    The live migration recovery operation on the destination side will
    access a null address value, which will cause access errors.
    
    Therefore, live migration of VMs without added VF device drivers
    does not require device data migration.
    In addition, when the queue address data obtained by the destination
    is empty, device queue recovery processing will not be performed.

[PATCH_DIFF]
    @@ -498,6 +491,20 @@ static int vf_qm_load_data(struct hisi_acc_vf_core_device *hisi_acc_vdev,
     	if (migf->total_length < sizeof(struct acc_vf_data))
     		return -EINVAL;
     
    +	if (!vf_data->eqe_dma || !vf_data->aeqe_dma ||
    +	    !vf_data->sqc_dma || !vf_data->cqc_dma) {
    +		dev_info(dev, "resume dma addr is NULL!\n");
    +		hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
    +		return 0;
    +	}
    +
     	qm->eqe_dma = vf_data->eqe_dma;
     	qm->aeqe_dma = vf_data->aeqe_dma;
     	qm->sqc_dma = vf_data->sqc_dma;
    ...
    @@ -1531,6 +1538,7 @@ static int hisi_acc_vfio_pci_migrn_init_dev(struct vfio_device *core_vdev)
     	hisi_acc_vdev->vf_id = pci_iov_vf_id(pdev) + 1;
     	hisi_acc_vdev->pf_qm = pf_qm;
     	hisi_acc_vdev->vf_dev = pdev;
    +	hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
     	mutex_init(&hisi_acc_vdev->state_mutex);
     	mutex_init(&hisi_acc_vdev->open_mutex);

[FUNCTION_CONTENT]
static int vf_qm_load_data(struct hisi_acc_vf_core_device *hisi_acc_vdev,
			   struct hisi_acc_vf_migration_file *migf)
{
	struct hisi_qm *qm = &hisi_acc_vdev->vf_qm;
	struct device *dev = &qm->pdev->dev;
	struct acc_vf_data *vf_data = &migf->vf_data;
	int ret;

	/* Return if only match data was transferred */
	if (migf->total_length == QM_MATCH_SIZE)
		return 0;

	if (migf->total_length < sizeof(struct acc_vf_data))
		return -EINVAL;

	qm->eqe_dma = vf_data->eqe_dma;
	qm->aeqe_dma = vf_data->aeqe_dma;
	qm->sqc_dma = vf_data->sqc_dma;
	qm->cqc_dma = vf_data->cqc_dma;

	qm->qp_base = vf_data->qp_base;
	qm->qp_num = vf_data->qp_num;

	ret = qm_set_regs(qm, vf_data);
	if (ret) {
		dev_err(dev, "set VF regs failed\n");
		return ret;
	}

	ret = hisi_qm_mb(qm, QM_MB_CMD_SQC_BT, qm->sqc_dma, 0, 0);
	if (ret) {
		dev_err(dev, "set sqc failed\n");
		return ret;
	}

	ret = hisi_qm_mb(qm, QM_MB_CMD_CQC_BT, qm->cqc_dma, 0, 0);
	if (ret) {
		dev_err(dev, "set cqc failed\n");
		return ret;
	}

	qm_dev_cmd_init(qm);
	return 0;
}

/* ----- separator ----- */

static int hisi_acc_vfio_pci_migrn_init_dev(struct vfio_device *core_vdev)
{
	struct hisi_acc_vf_core_device *hisi_acc_vdev = hisi_acc_get_vf_dev(core_vdev);
	struct pci_dev *pdev = to_pci_dev(core_vdev->dev);
	struct hisi_qm *pf_qm = hisi_acc_get_pf_qm(pdev);

	hisi_acc_vdev->vf_id = pci_iov_vf_id(pdev) + 1;
	hisi_acc_vdev->pf_qm = pf_qm;
	hisi_acc_vdev->vf_dev = pdev;
	mutex_init(&hisi_acc_vdev->state_mutex);
	mutex_init(&hisi_acc_vdev->open_mutex);

	core_vdev->migration_flags = VFIO_MIGRATION_STOP_COPY | VFIO_MIGRATION_PRE_COPY;
	core_vdev->mig_ops = &hisi_acc_vfio_pci_migrn_state_ops;

	return vfio_pci_core_init_dev(core_vdev);
}



[ROOTCAUSE_ANALYSIS]
1. CVE Identifier
CVE-2025-38283

2. Vulnerability Type
Improper input validation leading to unsafe device programming (NULL DMA address use) and potential denial of service during VF live migration resume.

3. Root Cause Summary
The destination-side resume path did not validate that migrated DMA base addresses (eqe_dma, aeqe_dma, sqc_dma, cqc_dma) were non-zero before programming the device. In vf_qm_load_data(), these fields were blindly assigned and then used in mailbox commands to configure queue tables (“qm->sqc_dma = vf_data->sqc_dma; … hisi_qm_mb(qm, QM_MB_CMD_SQC_BT, qm->sqc_dma, …)”). Additionally, the VF QM state was not initialized or set to NOT_READY when no valid queue data was present, allowing subsequent recovery logic to proceed on invalid inputs. This allowed attempting to resume with NULL DMA addresses, causing device accesses to address 0 and migration failure/device errors.

4. Kernel Subsystem Analysis
1) Affected Subsystem:
VFIO PCI driver for HiSilicon accelerator (hisi_acc_vfio_pci), live migration resume path.

2) Pre-Patch Flaw:
- vf_qm_load_data() did not check vf_data->{eqe_dma, aeqe_dma, sqc_dma, cqc_dma} for NULL/zero before using them to program hardware via mailbox commands.
- hisi_acc_vfio_pci_migrn_init_dev() did not initialize hisi_acc_vdev->vf_qm_state, and vf_qm_load_data() did not set it to NOT_READY on invalid inputs, enabling queue recovery attempts with invalid state.

3) Trigger Condition:
Attempting live migration of a VF when the guest OS does not have the VF device driver loaded, resulting in migrated acc_vf_data containing zero (NULL) DMA addresses.

4) Impact Mechanism:
The driver issues mailbox commands (QM_MB_CMD_SQC_BT/CQC_BT) with zero DMA addresses, causing the device to access a null address (address 0). This leads to access errors, device malfunction, and migration failure (denial of service for the VF/function).

5. Patch Analysis
1) Fix Approach:
- Input validation: Bail out early if any required DMA address is NULL and mark the VF QM as not ready.
- State initialization: Initialize vf_qm_state to QM_NOT_READY during device migration init to avoid accidental recovery on empty data.

2) Key Code Changes:
- In vf_qm_load_data():
  - Added check: if (!vf_data->eqe_dma || !vf_data->aeqe_dma || !vf_data->sqc_dma || !vf_data->cqc_dma) { dev_info(...); hisi_acc_vdev->vf_qm_state = QM_NOT_READY; return 0; }
  - Prevents executing qm_set_regs() and hisi_qm_mb() with NULL DMA addresses.
- In hisi_acc_vfio_pci_migrn_init_dev():
  - Added hisi_acc_vdev->vf_qm_state = QM_NOT_READY; to ensure a safe initial state for migration handling.

3) Locking/Concurrency Impact:
No locking or concurrency semantics were changed. The fix is purely input validation and state initialization; existing mutexes (state_mutex, open_mutex) remain unchanged.

6. Broader Kernel Security Implications
Validating migration data before programming hardware is critical in VFIO contexts to prevent device DMA to unintended addresses. Without such checks, malformed or incomplete migration data can lead to device errors or DoS on the destination host. Establishing explicit NOT_READY states helps gate recovery logic and reduces the risk of unsafe operations during complex migration sequences.

[REQUEST]
Produce a detection plan for a CodeQL-based static checker that would detect similar pre-patch flaws.
Requirements for the plan:
- High-level detection goal (1–2 lines).
- A numbered list of detection steps (objective, conceptual AST/semantic signals, FP mitigation).
- Types of program elements to target (functions, call sites, allocation sites, condition checks, lock boundaries, function return-value uses, etc.).
- Dataflow/taint patterns to consider (if applicable), described conceptually.
- Minimal test cases to validate the checker (positive/negative examples).
- Estimated effort/priority (low/medium/high) and likely false-positive sources.
- A short "Limitations & Assumptions" block.

OUTPUT FORMAT (produce exactly this structure; no extra text):
1. Plan Summary
{one-line summary}

2. Detection Steps
1) Step 1: {objective — conceptual signals — FP mitigation}
2) Step 2: {objective — conceptual signals — FP mitigation}
...
(narrow to ≤12 steps)

3. Target Elements
- {list of element types to inspect}

4. Dataflow / Taint Considerations
- {conceptual taint/flow rules to track}

5. Validation & Test Cases
- Positive: {brief}
- Negative: {brief}
- Test harness notes: {brief}

6. Estimated Effort & Priority
{low/medium/high}

7. Likely False-Positive Sources & Mitigations
- {list}

8. Limitations & Assumptions
- {explicit missing info or assumptions}

CONSTRAINTS:
- Do not emit any CodeQL, SQL, pseudocode, or query fragments.
- Keep answers evidence-based and reference which provided field supported each major choice (e.g., “based on [PATCH_DIFF] hunk that adds X”).
- Output must be machine-parseable: keep the exact numbered section headings as above.